<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Brion: Redesign of the SpikeReport and Spikes container</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Brion
   &#160;<span id="projectnumber">1.9.0</span>
   </div>
   <div id="projectbrief">The Blue Brain C++ I/O library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__jenkins_02_workspace_oss_8_brion_8documentation_build_type__debug_platform_cscsviz-vm_sources_doc_feature_spike_report.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Redesign of the SpikeReport and Spikes container </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The current design of the SpikeReport has several flaws that need to be addressed:</p><ul>
<li>It doesn't allow partial loading for file based reports.</li>
<li>It exposes too many details of the stream case which can probably be hidden.</li>
<li>The container class is a std::multimap while it could simply be a sorted array because no insertion is needed. This specification proposes a new API to address these defficiencies as well as include new requirements that need to be fulfilled.</li>
</ul>
<h2>Requirements</h2>
<p>The high level requirements for the replacement are listed below. Note that all these requirements do not need to be directly satisfied by <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">brion::SpikeReport</a>, but it must be possible to do so by a higher level class based on it.</p>
<ul>
<li>Provide a container for spikes which is sorted by timestamp, storage efficient, and random accessible at the <sup>n</sup>th position in amortized constant time (provided the data has been already fetched). This is basically a std::vector, but only read access is needed.</li>
<li>Allow partial data loading for file access.</li>
<li>Allow the selection of a subset of the cells present in the data source to be reported. In stream-based reports this information should be made available to the sender to allow filtering at the source. In the ZeroEQ implementation, the same channel needed for communicating the desired target could be used for the handshaking required to ensure that the first spikes are not missed.</li>
<li>As few details as possible that are specific to streams should be exposed. This means that it should be easy to write client code that works the same for both file based and stream based reports without special conditions for stream based reports.</li>
<li>For stream reports the user will be able to:<ul>
<li>Retrieve all the data until the end of the stream in a simple loop without doing any active wait (blocking calls are allowed).</li>
<li>Know if the end of stream has been reached.</li>
<li>Get all the data received so far without locking.</li>
<li>Get information about the latest timestamp reached by the source in the sender side even when there are no spikes at all (currently if the spike report is completely empty it's not possible to make any progress until the producer reaches the end of the report).</li>
</ul>
</li>
<li>When data for a time interval is requested, the time intervals are always closed on the left and open on the right.</li>
</ul>
<h2>General remarks</h2>
<p>It has been agreed that unifying both the file and the stream cases under a stream-like interface (in the sense of std::iostream or POSIX file descriptor IO) seems to be the best abstraction at the lower level. Providing random access and out-of-core support is complicated at the lower level because internal buffering is needed and this can only be implementated efficiently if some assumptions about how client code will use the API are made. The most important characteristic of the current proposal is that read and write operations can only move forward, so each operation starts where the previous one left over. This way there is no need to make any distinction between the file and stream based cases. Random access is partially supported by a seek function that for stream based reports will only support forward skip.</p>
<p>The current proposal defers important design decisions to the higher level API, but the its benefit is that it provides a relatively simply API for the most critical part.</p>
<h2>API</h2>
<p>Thread-safey is only guaranteed for const access.</p>
<h3>Helper types</h3>
<pre class="fragment">struct Spike
{
    Spike( float time_, uint32_t gid_ );
    float time;
    uint32_t gid;
};

typedef std::vector&lt; Spike &gt; Spikes;
</pre><h3>SpikeReport</h3>
<pre class="fragment">SpikeReport : public boost::noncopyable
{
public:
    SpikeReport( const URI&amp; uri, int mode );

    /*
     * Open a report in read mode with a subset selection.
     *
     * @param uri
     * @param subset The set of gids to be reported. This set should be
     *        understood as a filter: any included GID which is not
     *        actually part of the report will be silently ignored.
     */
    SpikeReport( const URI&amp; uri, const GIDSet&amp; subset );

    /**
     * Release all resources.
     * Any threads waiting on futures will return immediately and calling
     * get will throw std::runtime_error.
     */
    ~SpikeReport();

    const URI&amp; getURI();

    /** ? */
    float getStartTime() const;
    float getEndTime() const;

    /**
     * @return the end time of the latest complete read/write operation or
     *         UNDEFINED_TIMESTAMP if no operation has been issued.
     *
     * Read operations are deemed as complete when the returned future is
     * ready.
     *
     * The time inverval to which getCurrentTime refers is open on the
     * right. That means that upon completion of a read or write operation
     * no spike read or written may have a timestamp &gt;= getCurrentTime().
     */
    float getCurrentTime() const;

    /**
     * Read spikes until getCurrentTime becomes &gt; min, the end of the report
     * is reached or the report closed.
     *
     * This function fetches all the available data from the source.
     * If no error occurs and the end is not reached, the min value passed
     * is also guaranteed to be inside the time window of the data returned.
     *
     * Preconditions:
     * - r.getState() is OK or ENDED.
     * - The report was open in read mode.
     * - There is no previous read or seek operation with a pending
     *   future.
     * - min &gt;= getCurrentTime() or UNDEFINED_TIMESTAMP.
     *
     * Postconditions:
     * Let:
     *  - r be the SpikeReport
     *  - f be the returned future by r.read(min)
     *  - and s = r.getCurrentTime() before read is called (s = -inf if
     *    undefined):
     * After f.wait() returns the following are all true:
     *  - r.getCurrentTime() &gt;= s
     *  - If r.getState() == OK, then r.getCurrentTime() &gt; min
     *  - For each spike timestamp t_s in f.get(),
     *    s &lt;= t_s &lt; r.getCurrentTime() (Note this could collapse to an
     *    empty interval if r.getState() != OK)
     *
     * After successful f.wait_for or f.wait_until, the result is the same
     * as above. If they time out, no observable state changes.
     *
     * If the state is FAILED or some other operation is still pending
     * when read is called the result is undefined.
     *
     * @param min The minimum end time until which spikes will be read. If
     *        UNDEFINED_TIMESTAMP, it will be considered as -infinite. This
     *        means that as much data as possible will be fetched without
     *        a minumum.
     * @throw std::logic_error if one of the preconditions is not fulfilled.
     */
    boost::future&lt; Spikes &gt; read( float min );

    /**
     * Read spikes until getCurrentTime() == max, the end of the report is
     * reached or the report closed.
     *
     * This function is very similar to the normal read, but instead of
     * specifying a lower bound of getCurrentTime at return, it specifies
     * a requested strict value. The preconditions and postconditions
     * are the same except for those involving the parameter min which
     * become:
     *
     * Precondition: max &gt; getCurrentTime()
     * Postcondition: If r.getState() == OK, then r.getCurrentTime() == max
     *
     * @throw std::runtime_error if the precondition does not hold.
     * @sa seek()
     */
    boost::future&lt; Spikes &gt; readUntil( float max );

    /**
     * Seek to a given absolute timestamp.
     *
     * If toTimestamp &gt;= getCurrentTime() and the report was opening
     * for reading, data will be skipped forward until the timestamp
     * is made current. In write mode for streams, consumers are notified
     * about the progress.
     *
     * The case toTimestamp &lt; getCurrentTime() is only supported by file
     * based reports.
     *
     * Preconditions:
     * - There is no standing read or readUntil operation.
     *
     * Postconditions:
     * Let:
     *  - r be the SpikeReport
     *  - f be the returned future by r.seek(toTimestamp)
     * Then:
     *  - After f.wait() returns r.getCurrentTime() == toTimestamp.
     *  - The postconditions of read operations imply that in forward skips
     *    this function throws away the data previous to toTimestamp (or
     *    avoids reading it at all if possible).
     *
     * @throw std::runtime_error if a precondition does not hold or the
     *        operation is not supported by the implementation.
     */
    boost::future&lt; void &gt; seek( float toTimestamp );

    enum State { OK = 0, ENDED = 1, FAILED = 2 };
    /** @return The state after the last completed operation. */
    State getState() const;

   /**
     * Write the given spikes to the output.
     *
     * Upon return getCurrenTime() is the greatest of all the spike times
     * plus an epsilon.
     *
     * @param spikes A sorted collection of spikes. For every spike, its
     *        timestamp t must be &gt;= getCurrentTime().
     */
    void write( const Spikes&amp; spikes );
}
</pre><h2>Examples</h2>
<h3>Copying a spike report from one URL to another without any timeout.</h3>
<pre class="fragment">SpikeReport input( "url1", brion::MODE_READ )
SpikeReport output( "url2", brion::MODE_WRITE )

while( input.getState() == OK )
    output.write( input.read().get() ))

if (input .getState() == SpikeReport::FAILED)
   ... // Report error.
// To be strictly correct, the last operation should be output.seek to
// advance until the current timestamp.
</pre><h3>Copying a spike report from one URL to another with a read timeout.</h3>
<pre class="fragment">SpikeReport intput( "url1", brion::MODE_READ )
SpikeReport output( "url2", brion::MODE_WRITE )

while( input.getState() == OK )
{
    auto future = input.read();
    const auto status =
        future.wait_for( boost::chrono::milliseconds( 250 ));
    if( status == boost::future_state::ready )
        output.write( future.get( ));
    else
        ... // Handle timeout

    output.write( spikes );
    if (output.getState() == SpikeReport::FAILED)
       ... // Report error.
}
if (input.getState() == SpikeReport::FAILED)
   ... // Report error.
</pre><h3>Writing data at regular time intervals</h3>
<pre class="fragment">const float time delta = ...;
for( size_t i = 0; ...; ++i )
{
    const start = i * delta;
    const end = (i + 1) * delta;
    const Spikes = produceSpikes( start, end );
    output.write( spikes );
    output.seek( end ).get();
}
</pre><h2>Implementation</h2>
<p>TODO</p>
<h2>Issues</h2>
<h3>1: Do we need a Spikes container?</h3>
<p><em>Resolved: Yes</em></p>
<p>Not at this level. A higher level class can could provide a custom container if that's necessary for performance reasons. At this class, the interface is designed in a way that the implementation does not need to cache anything under normal conditions (no operation times out). This means that the container can be handed over to the consumer and rely on RVO and move semantics to avoid unnecessary copies.</p>
<h3>2: Why Spikes::getCurrentTime() returns a time greater than the largest spike time (in the general case)?</h3>
<p><em>Resolved: Yes</em></p>
<p>To ensure consistency with the specification of the time interval from SpikeReport::read, which is open on the right. The time of the last spike is still easy to recover because it is the last element in the container.</p>
<h3>3: The return value of read should be boost::future&lt; Spikes&amp; &gt; or boost::future&lt; Spikes &gt;?</h3>
<p><em>Resolved: No</em></p>
<p>It is desirable to avoid the reference and according to <a href="http://en.cppreference.com/w/cpp/thread/future/get">this reference</a>, it seems that get() returns a meaningful value only the first time is called when returning by value (because the implementation uses std::move, but I'm not fully sure about this).</p>
<h3>4: Are the getStartTime() and getEndTime() methods needed?</h3>
<p><em>Resolved: No</em></p>
<p>Seems convenient, but it's not clear what value should they return when the data source is a stream and no data (or metadata) has been received yet. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jul 8 2016 06:03:42 for Brion by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
