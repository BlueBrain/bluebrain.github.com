<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Brion: Synapse support in Brain</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Brion
   &#160;<span id="projectnumber">1.9.0</span>
   </div>
   <div id="projectbrief">The Blue Brain C++ I/O library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__jenkins_02_workspace_oss_8_brion_8documentation_build_type__debug_platform_cscsviz-vm_sources_doc_feature_synapses.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Synapse support in Brain </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The low-level data access for synapses provided by Brion needs a complementary API in Brain to support various common higher-level uses cases, like semantic synapse object access or full-circuit synapse density voxelization, to name the two extremes.</p>
<h2>Requirements</h2>
<ul>
<li>Semantic synapse objects that give read-access to all properties</li>
<li>Array access which allows vectorization</li>
<li>Filtering of synapses for pathway use case (projected synapses of two targets)</li>
<li>Lazy-loading to support out-of-core scenarios</li>
<li>User-transparent KVS caching</li>
</ul>
<h2>New dependencies</h2>
<p>None</p>
<h2>API</h2>
<p>```cpp</p>
<p>namespace brain { /*</p><ul>
<li>Synapse GID.</li>
<li></li>
<li>The GID of a synapse is the a tuple of two numbers:</li>
<li>- The GID of the post-synaptic cell.</li>
<li>- The index of the synapse in the array of afferent contacts</li>
<li>of the post-synaptic cell before pruning/filtering.</li>
<li>GIDs are invariant regardless of how the structural touches are</li>
<li>converted into functional synapses during circuit building. */ typedef std::pair&lt; uint32_t, size &gt; SynapseGID;</li>
</ul>
<p>// loading of data during SynapseStream.read(), otherwise load happens on // first touch enum SynapsesPrefetch { SP_NONE = 0, // only loads pre- and post GIDs SP_ATTRIBUTES = 1 &lt;&lt; 0, // topological information (section, segment, // distance) and electrical attributes SP_POSITIONS = 1 &lt;&lt; 1, // pre/post surface/center positions SP_ALL = SP_ATTRIBUTES | SP_POSITIONS } }</p>
<p>class Circuit { // max count for read is gids.size() SynapsesStream getAfferentSynapses( const GIDSet&amp; gids, SynapsesPrefetch prefetch = SP_ALL ) const;</p>
<p>// max count for read is gids.size() SynapsesStream getEfferentSynapses( const GIDSet&amp; gids, SynapsesPrefetch prefetch = SP_ALL ) const;</p>
<p>// max count for read is min(preGIDs.size(), postGIDs.size()) SynapsesStream getProjectedSynapses( const GIDSet&amp; preGIDs, const GIDSet&amp; postGIDs, SynapsesPrefetch prefetch = SP_ALL ) const; };</p>
<p>// read-only, moveable proxy object of data storage in Synapses container class Synapse { uint32_t preGID() const; uint32_t preSectionID() const; uint32_t preSegmentID() const; float preDistance() const; Vector3f preSurfacePosition() const; Vector3f preCenterPosition() const;</p>
<p>uint32_t postGID() const; uint32_t postSectionID() const; uint32_t postSegmentID() const; float postDistance() const; Vector3f postSurfacePosition() const; Vector3f postCenterPosition() const;</p>
<p>SynapseGID gid() const; float conductance() const; float utilization() const; float depression() const; float facilitation() const; float decay() const; int efficacy() const; };</p>
<p>// read-only, moveable, copyable, thread-safe class Synapses { // conversion ctor; read all synapses from selected GIDs into memory Synapses( const SynapsesStream&amp; );</p>
<p>size_t size() const; bool empty() const;</p>
<p>bool operator==( const Synapses&amp; rhs ) const; bool operator!=( const Synapses&amp; rhs ) const;</p>
<p>const_iterator begin() const; const_iterator end() const;</p>
<p>const Synapse&amp; operator[]( size_t ) const;</p>
<p>const size_t* index() const; const uint32_t* preGID() const; const uint32_t* preSectionID() const; const uint32_t* preSegmentID() const; const float* preDistance() const; const float* preSurfacePositionX() const; const float* preSurfacePositionY() const; const float* preSurfacePositionZ() const; const float* preCenterPositionX() const; const float* preCenterPositionY() const; const float* preCenterPositionZ() const;</p>
<p>const uint32_t* postGID() const; const uint32_t* postSectionID() const; const uint32_t* postSegmentID() const; const float* postDistance() const; const float* postSurfacePositionX() const; const float* postSurfacePositionY() const; const float* postSurfacePositionZ() const; const float* postCenterPositionX() const; const float* postCenterPositionY() const; const float* postCenterPositionZ() const;</p>
<p>const size_t* indices() const; const float* conductance() const; const float* utilization() const; const float* depression() const; const float* facilitation() const; const float* decay() const; const int* efficacy() const; };</p>
<p>// sequentially &amp; forwarding iteration through synapses for any number of GIDs // not thread-safe, but reentrant class SynapsesStream { bool eos() const;</p>
<p>// Remaining count reads before eos() // equals to max - current, max determined by get..Synapses() in // <a class="el" href="classbrain_1_1_circuit.html" title="Read access to a circuit database. ">brain::Circuit</a> size_t getRemaining() const;</p>
<p>// - async load of synapses for count cells // - no order guarantee // - resulting Synapses can be empty // - count will be clamped if count &gt; getRemaining() std::future&lt; Synapses &gt; read( size_t count = 1 ) const; };</p>
<p>```</p>
<h2>File format</h2>
<p>Uses existing nrn* files</p>
<h2>Examples</h2>
<h3>Stream synapse positions for pathway density voxelization</h3>
<p>```cpp const <a class="el" href="classbrain_1_1_circuit.html" title="Read access to a circuit database. ">brain::Circuit</a> circuit; const <a class="el" href="classbrain_1_1_synapses_stream.html" title="A class which allows sequential and forward-only iterations through the synapses from the involved GI...">brain::SynapsesStream</a>&amp; stream = circuit.getProjectedSynapses( circuit.getGIDs( "mtypetarget_1" ), circuit.getGIDs( "mtypetarget_2" )); std::future&lt; brain::Synapses &gt; future = stream.read(); while( !stream.eos( )) { const <a class="el" href="classbrain_1_1_synapses.html" title="A container providing read-only access to Synapses retrieved by getXXXSynapses() functions from brain...">brain::Synapses</a> synapses = future.get(); future = stream.read(); // fetch next</p>
<p>const float* <b>restrict</b> posx = synapses.preSurfacePositionX(); const float* <b>restrict</b> posy = synapses.preSurfacePositionY(); const float* <b>restrict</b> posz = synapses.preSurfacePositionZ(); for( size_t i = 0; i &lt; synapses.size(); ++i ) doVoxelization( posx[i], posy[i], posz[i] ); } ```</p>
<h3>Access all afferent synapses of a GIDSet</h3>
<p>```cpp const <a class="el" href="classbrain_1_1_circuit.html" title="Read access to a circuit database. ">brain::Circuit</a> circuit; const <a class="el" href="classbrain_1_1_synapses.html" title="A container providing read-only access to Synapses retrieved by getXXXSynapses() functions from brain...">brain::Synapses</a>&amp; synapses = circuit.getAfferentSynapses( circuit.getGIDs( "Layer1" )); for( const auto&amp; synapse : synapses ) std::cout &lt;&lt; synapse.postGID() &lt;&lt; " " &lt;&lt; synapse.decay() &lt;&lt; std::endl; ```</p>
<h3>Retrograde projection</h3>
<p>```cpp const <a class="el" href="classbrain_1_1_circuit.html" title="Read access to a circuit database. ">brain::Circuit</a> circuit; const <a class="el" href="namespacebrion.html#a0f53c74f86d04c704c228013a096ef72" title="Ordered set of GIDs of neurons. ">brion::GIDSet</a>&amp; preNeurons = circuit.getGIDs( "Layer1" ); const <a class="el" href="namespacebrion.html#a0f53c74f86d04c704c228013a096ef72" title="Ordered set of GIDs of neurons. ">brion::GIDSet</a> postNeuron = { 1 }; const <a class="el" href="classbrain_1_1_synapses.html" title="A container providing read-only access to Synapses retrieved by getXXXSynapses() functions from brain...">brain::Synapses</a>&amp; synapses = circuit.getProjectedSynapses( preNeurons, postNeuron ); BOOST_CHECK( !synapses.empty( )); BOOST_CHECK_EQUAL( synapses.size(), 5 ); ```</p>
<h2>Implementation</h2>
<ul>
<li>Data owned by container in the form of the arrays (transformed from SynapseMatrix), loaded upon construction wrt prefetch, lazy on first touch except for pre- and postGID for connectivity queries and to fulfill the contract for size().</li>
<li>Synapse object stores index to get data from (parenting) container, triggers lazy loading on first touch.</li>
<li>SynapsesStream::read() uses async read of synapse data of the given fraction of GIDs.</li>
<li>OPT: getProjectedSynapses() loads the synapses from the smaller GIDSet and uses the correct side (afferent/efferent) accordingly.</li>
</ul>
<h2>Issues</h2>
<h3>1: Why does the synapses container has to load on construction?</h3>
<p><em>Resolved: Yes</em></p>
<p>For an easier implemenation and a consistent API. Determining the size of the container already requires 'touching' all synapse datasets in the current file storage, hence loading attributes or positions in the same go does not waste more time. Regarding memory concerns, the stream approach helps there to only load synapses for a fraction of gids of interest.</p>
<h3>2: Why there are no set operators like in the BBPSDK synapse container?</h3>
<p><em>Resolved: Yes</em></p>
<p>Synapses::getProjectedSynapses() was the missing part in the SDK to render most of the set operations useless. It is a more optimized way of filtering. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 23 2016 06:03:35 for Brion by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
