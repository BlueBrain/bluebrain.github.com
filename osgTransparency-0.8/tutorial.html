<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OSG Transparency: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OSG Transparency
   &#160;<span id="projectnumber">0.8.1</span>
   </div>
   <div id="projectbrief">OSG library for transparency rendering algorithms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This brief tutorial shows the key steps to set up multi-layer depth peeling with 4 slices per pass.</p>
<p>The first step is to add the render bin to use to the set of render bins known to OSG.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;bbp::osgTransparency::MultiLayerDepthPeelingBin *renderBin =</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  renderBin = new bbp::osgTransparency::MultiLayerDepthPeelingBin();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;osgUtil::RenderBin::addRenderBinPrototype(&quot;alphaBlended&quot;, renderBin);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;renderBin-&gt;setDefaultNumSlices(4);</div></div><!-- fragment --><p>Next, the objects to render must include at least a vertex and fragment shader inside an osg::Program part of their osg::StateSet. These shaders provide functions needed by the render bins to complete the GLSL programs used. The function addExtraShadersForState is used to inform our MultiLayerDepthPeelingBin about which shaders to use for a osg::StateSet. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;osg::Program *program = new osg::Program;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// ... create the extra shaders and add them to the program</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;renderBin-&gt;addExtraShadersForState(stateSet, program);</div></div><!-- fragment --><p> Warning, the program object must not be part of the osg::StateSet to add.</p>
<p>And example of basic vertex shader is: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#version 130</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;out vec3 normal;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// Writes to gl_Position.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;void shadeVertex()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    normal = gl_NormalMatrix * gl_Normal;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// A potentially simplified version of the funcion above to be used</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// in passes that only need to know the final fragment depth.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;void trivialShadeVertex()</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;{</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    shadeVertex();</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div></div><!-- fragment --><p>And for the fragment shader: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#version 130</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;in vec3 normal;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// Returns the final color to apply for a shaded fragment</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;vec4 shadeFragment()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    vec4 color = vec4(1, 0, 0, 0.2);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    vec3 n = normalize(normal);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    const vec3 l = vec3(0.0, 0.0, 1.0);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    float lambertTerm = dot(n, l);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    if (lambertTerm &lt; 0.0)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        lambertTerm = -lambertTerm;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    vec3 shadedColor = color.rgb * lambertTerm;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    return vec4(shadedColor, color.a);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;// Returns the alpha value of the fragment.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// This method is used in some optimizations which are not enabled by</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;// default. It is safe to return 0 as a fallback value.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;float fragmentAlpha()</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;{</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    return color.a;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;// Returns the depth value of the fragment.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;// This functions is provided for shaders which can modify the fragment depth</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;// from the value given in gl_FragCoord.z</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;float fragmentDepth()</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;{</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    return gl_FragCoord.z;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;}</div></div><!-- fragment --><p>Note that there is no main in any of the shaders above (each step of every algorithm provides their own ones). The functions and prototypes in the examples above are the interface that the internal shaders expect for each state set that has been enabled.</p>
<p>Geometry shaders are also supported without any special consideration. The current implementation cannot mix opaque and transparent geometry properly. The main reason is that the z-buffer of the render bins is independent from the z-buffer of the framebuffer. Future releases will address this problem.</p>
<p>Finally, a complete code example can be found <a href="https://bbpteam.epfl.ch/reps/viz/osgTransparency.git/tree/examples/example.cpp">here</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Sep 11 2018 05:26:07 for OSG Transparency by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
