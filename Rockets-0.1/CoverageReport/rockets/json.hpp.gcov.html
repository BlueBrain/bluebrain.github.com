<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Rockets - rockets/json.hpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">rockets</a> - json.hpp<span style="font-size: 80%;"> (source / <a href="json.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Rockets</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">979</td>
            <td class="headerCovTableEntry">1470</td>
            <td class="headerCovTableEntryMed">66.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-05-30 04:16:03</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">270</td>
            <td class="headerCovTableEntry">331</td>
            <td class="headerCovTableEntryHi">81.6 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :     __ _____ _____ _____
<span class="lineNum">       3 </span>            :  __|  |   __|     |   | |  JSON for Modern C++
<span class="lineNum">       4 </span>            : |  |  |__   |  |  | | | |  version 3.1.1
<span class="lineNum">       5 </span>            : |_____|_____|_____|_|___|  https://github.com/nlohmann/json
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : Licensed under the MIT License &lt;http://opensource.org/licenses/MIT&gt;.
<span class="lineNum">       8 </span>            : Copyright (c) 2013-2018 Niels Lohmann &lt;http://nlohmann.me&gt;.
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : Permission is hereby  granted, free of charge, to any  person obtaining a copy
<span class="lineNum">      11 </span>            : of this software and associated  documentation files (the &quot;Software&quot;), to deal
<span class="lineNum">      12 </span>            : in the Software  without restriction, including without  limitation the rights
<span class="lineNum">      13 </span>            : to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
<span class="lineNum">      14 </span>            : copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
<span class="lineNum">      15 </span>            : furnished to do so, subject to the following conditions:
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : The above copyright notice and this permission notice shall be included in all
<span class="lineNum">      18 </span>            : copies or substantial portions of the Software.
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : THE SOFTWARE  IS PROVIDED &quot;AS  IS&quot;, WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
<span class="lineNum">      21 </span>            : IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
<span class="lineNum">      22 </span>            : FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
<span class="lineNum">      23 </span>            : AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
<span class="lineNum">      24 </span>            : LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
<span class="lineNum">      25 </span>            : OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
<span class="lineNum">      26 </span>            : SOFTWARE.
<span class="lineNum">      27 </span>            : */
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #ifndef NLOHMANN_JSON_HPP
<span class="lineNum">      30 </span>            : #define NLOHMANN_JSON_HPP
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #define NLOHMANN_JSON_VERSION_MAJOR 3
<span class="lineNum">      33 </span>            : #define NLOHMANN_JSON_VERSION_MINOR 1
<span class="lineNum">      34 </span>            : #define NLOHMANN_JSON_VERSION_PATCH 1
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &lt;algorithm&gt; // all_of, find, for_each
<span class="lineNum">      37 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">      38 </span>            : #include &lt;ciso646&gt; // and, not, or
<span class="lineNum">      39 </span>            : #include &lt;cstddef&gt; // nullptr_t, ptrdiff_t, size_t
<span class="lineNum">      40 </span>            : #include &lt;functional&gt; // hash, less
<span class="lineNum">      41 </span>            : #include &lt;initializer_list&gt; // initializer_list
<span class="lineNum">      42 </span>            : #include &lt;iosfwd&gt; // istream, ostream
<span class="lineNum">      43 </span>            : #include &lt;iterator&gt; // iterator_traits, random_access_iterator_tag
<span class="lineNum">      44 </span>            : #include &lt;numeric&gt; // accumulate
<span class="lineNum">      45 </span>            : #include &lt;string&gt; // string, stoi, to_string
<span class="lineNum">      46 </span>            : #include &lt;utility&gt; // declval, forward, move, pair, swap
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : // #include &lt;nlohmann/json_fwd.hpp&gt;
<span class="lineNum">      49 </span>            : #ifndef NLOHMANN_JSON_FWD_HPP
<span class="lineNum">      50 </span>            : #define NLOHMANN_JSON_FWD_HPP
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #include &lt;cstdint&gt; // int64_t, uint64_t
<span class="lineNum">      53 </span>            : #include &lt;map&gt; // map
<span class="lineNum">      54 </span>            : #include &lt;memory&gt; // allocator
<span class="lineNum">      55 </span>            : #include &lt;string&gt; // string
<span class="lineNum">      56 </span>            : #include &lt;vector&gt; // vector
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /*!
<span class="lineNum">      59 </span>            : @brief namespace for Niels Lohmann
<span class="lineNum">      60 </span>            : @see https://github.com/nlohmann
<span class="lineNum">      61 </span>            : @since version 1.0.0
<span class="lineNum">      62 </span>            : */
<span class="lineNum">      63 </span>            : namespace rockets_nlohmann
<span class="lineNum">      64 </span>            : {
<span class="lineNum">      65 </span>            : /*!
<span class="lineNum">      66 </span>            : @brief default JSONSerializer template argument
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : This serializer ignores the template arguments and uses ADL
<span class="lineNum">      69 </span>            : ([argument-dependent lookup](http://en.cppreference.com/w/cpp/language/adl))
<span class="lineNum">      70 </span>            : for serialization.
<span class="lineNum">      71 </span>            : */
<span class="lineNum">      72 </span>            : template&lt;typename = void, typename = void&gt;
<span class="lineNum">      73 </span>            : struct adl_serializer;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : template&lt;template&lt;typename U, typename V, typename... Args&gt; class ObjectType =
<span class="lineNum">      76 </span>            :          std::map,
<span class="lineNum">      77 </span>            :          template&lt;typename U, typename... Args&gt; class ArrayType = std::vector,
<span class="lineNum">      78 </span>            :          class StringType = std::string, class BooleanType = bool,
<span class="lineNum">      79 </span>            :          class NumberIntegerType = std::int64_t,
<span class="lineNum">      80 </span>            :          class NumberUnsignedType = std::uint64_t,
<span class="lineNum">      81 </span>            :          class NumberFloatType = double,
<span class="lineNum">      82 </span>            :          template&lt;typename U&gt; class AllocatorType = std::allocator,
<span class="lineNum">      83 </span>            :          template&lt;typename T, typename SFINAE = void&gt; class JSONSerializer =
<span class="lineNum">      84 </span>            :          adl_serializer&gt;
<span class="lineNum">      85 </span>            : class basic_json;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : /*!
<span class="lineNum">      88 </span>            : @brief JSON Pointer
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : A JSON pointer defines a string syntax for identifying a specific value
<span class="lineNum">      91 </span>            : within a JSON document. It can be used with functions `at` and
<span class="lineNum">      92 </span>            : `operator[]`. Furthermore, JSON pointers are the base for JSON patches.
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : @sa [RFC 6901](https://tools.ietf.org/html/rfc6901)
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : @since version 2.0.0
<span class="lineNum">      97 </span>            : */
<span class="lineNum">      98 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">      99 </span>            : class json_pointer;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /*!
<span class="lineNum">     102 </span>            : @brief default JSON class
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : This type is the default specialization of the @ref basic_json class which
<span class="lineNum">     105 </span>            : uses the standard template types.
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : @since version 1.0.0
<span class="lineNum">     108 </span>            : */
<span class="lineNum">     109 </span>            : using json = basic_json&lt;&gt;;
<span class="lineNum">     110 </span>            : }
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : #endif
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : // This file contains all internal macro definitions
<span class="lineNum">     118 </span>            : // You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : // exclude unsupported compilers
<span class="lineNum">     121 </span>            : #if defined(__clang__)
<span class="lineNum">     122 </span>            :     #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) &lt; 30400
<span class="lineNum">     123 </span>            :         #error &quot;unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers&quot;
<span class="lineNum">     124 </span>            :     #endif
<span class="lineNum">     125 </span>            : #elif defined(__GNUC__) &amp;&amp; !(defined(__ICC) || defined(__INTEL_COMPILER))
<span class="lineNum">     126 </span>            :     #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) &lt; 40900
<span class="lineNum">     127 </span>            :         #error &quot;unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers&quot;
<span class="lineNum">     128 </span>            :     #endif
<span class="lineNum">     129 </span>            : #endif
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : // disable float-equal warnings on GCC/clang
<span class="lineNum">     132 </span>            : #if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
<span class="lineNum">     133 </span>            :     #pragma GCC diagnostic push
<span class="lineNum">     134 </span>            :     #pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;
<span class="lineNum">     135 </span>            : #endif
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : // disable documentation warnings on clang
<span class="lineNum">     138 </span>            : #if defined(__clang__)
<span class="lineNum">     139 </span>            :     #pragma GCC diagnostic push
<span class="lineNum">     140 </span>            :     #pragma GCC diagnostic ignored &quot;-Wdocumentation&quot;
<span class="lineNum">     141 </span>            : #endif
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : // allow for portable deprecation warnings
<span class="lineNum">     144 </span>            : #if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
<span class="lineNum">     145 </span>            :     #define JSON_DEPRECATED __attribute__((deprecated))
<span class="lineNum">     146 </span>            : #elif defined(_MSC_VER)
<span class="lineNum">     147 </span>            :     #define JSON_DEPRECATED __declspec(deprecated)
<span class="lineNum">     148 </span>            : #else
<span class="lineNum">     149 </span>            :     #define JSON_DEPRECATED
<span class="lineNum">     150 </span>            : #endif
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            : // allow to disable exceptions
<span class="lineNum">     153 </span>            : #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) &amp;&amp; !defined(JSON_NOEXCEPTION)
<span class="lineNum">     154 </span>            :     #define JSON_THROW(exception) throw exception
<span class="lineNum">     155 </span>            :     #define JSON_TRY try
<span class="lineNum">     156 </span>            :     #define JSON_CATCH(exception) catch(exception)
<span class="lineNum">     157 </span>            : #else
<span class="lineNum">     158 </span>            :     #define JSON_THROW(exception) std::abort()
<span class="lineNum">     159 </span>            :     #define JSON_TRY if(true)
<span class="lineNum">     160 </span>            :     #define JSON_CATCH(exception) if(false)
<span class="lineNum">     161 </span>            : #endif
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : // override exception macros
<span class="lineNum">     164 </span>            : #if defined(JSON_THROW_USER)
<span class="lineNum">     165 </span>            :     #undef JSON_THROW
<span class="lineNum">     166 </span>            :     #define JSON_THROW JSON_THROW_USER
<span class="lineNum">     167 </span>            : #endif
<span class="lineNum">     168 </span>            : #if defined(JSON_TRY_USER)
<span class="lineNum">     169 </span>            :     #undef JSON_TRY
<span class="lineNum">     170 </span>            :     #define JSON_TRY JSON_TRY_USER
<span class="lineNum">     171 </span>            : #endif
<span class="lineNum">     172 </span>            : #if defined(JSON_CATCH_USER)
<span class="lineNum">     173 </span>            :     #undef JSON_CATCH
<span class="lineNum">     174 </span>            :     #define JSON_CATCH JSON_CATCH_USER
<span class="lineNum">     175 </span>            : #endif
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : // manual branch prediction
<span class="lineNum">     178 </span>            : #if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
<span class="lineNum">     179 </span>            :     #define JSON_LIKELY(x)      __builtin_expect(!!(x), 1)
<span class="lineNum">     180 </span>            :     #define JSON_UNLIKELY(x)    __builtin_expect(!!(x), 0)
<span class="lineNum">     181 </span>            : #else
<span class="lineNum">     182 </span>            :     #define JSON_LIKELY(x)      x
<span class="lineNum">     183 </span>            :     #define JSON_UNLIKELY(x)    x
<span class="lineNum">     184 </span>            : #endif
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : // C++ language standard detection
<span class="lineNum">     187 </span>            : #if (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201703L) || (defined(_HAS_CXX17) &amp;&amp; _HAS_CXX17 == 1) // fix for issue #464
<span class="lineNum">     188 </span>            :     #define JSON_HAS_CPP_17
<span class="lineNum">     189 </span>            :     #define JSON_HAS_CPP_14
<span class="lineNum">     190 </span>            : #elif (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201402L) || (defined(_HAS_CXX14) &amp;&amp; _HAS_CXX14 == 1)
<span class="lineNum">     191 </span>            :     #define JSON_HAS_CPP_14
<span class="lineNum">     192 </span>            : #endif
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : // Ugly macros to avoid uglier copy-paste when specializing basic_json. They
<span class="lineNum">     195 </span>            : // may be removed in the future once the class is split.
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : #define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
<span class="lineNum">     198 </span>            :     template&lt;template&lt;typename, typename, typename...&gt; class ObjectType,   \
<span class="lineNum">     199 </span>            :              template&lt;typename, typename...&gt; class ArrayType,              \
<span class="lineNum">     200 </span>            :              class StringType, class BooleanType, class NumberIntegerType, \
<span class="lineNum">     201 </span>            :              class NumberUnsignedType, class NumberFloatType,              \
<span class="lineNum">     202 </span>            :              template&lt;typename&gt; class AllocatorType,                       \
<span class="lineNum">     203 </span>            :              template&lt;typename, typename = void&gt; class JSONSerializer&gt;
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            : #define NLOHMANN_BASIC_JSON_TPL                                            \
<span class="lineNum">     206 </span>            :     basic_json&lt;ObjectType, ArrayType, StringType, BooleanType,             \
<span class="lineNum">     207 </span>            :     NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
<span class="lineNum">     208 </span>            :     AllocatorType, JSONSerializer&gt;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : /*!
<span class="lineNum">     211 </span>            : @brief Helper to determine whether there's a key_type for T.
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : This helper is used to tell associative containers apart from other containers
<span class="lineNum">     214 </span>            : such as sequence containers. For instance, `std::map` passes the test as it
<span class="lineNum">     215 </span>            : contains a `mapped_type`, whereas `std::vector` fails the test.
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : @sa http://stackoverflow.com/a/7728728/266378
<span class="lineNum">     218 </span>            : @since version 1.0.0, overworked in version 2.0.6
<span class="lineNum">     219 </span>            : */
<span class="lineNum">     220 </span>            : #define NLOHMANN_JSON_HAS_HELPER(type)                                        \
<span class="lineNum">     221 </span>            :     template&lt;typename T&gt; struct has_##type {                                  \
<span class="lineNum">     222 </span>            :     private:                                                                  \
<span class="lineNum">     223 </span>            :         template&lt;typename U, typename = typename U::type&gt;                     \
<span class="lineNum">     224 </span>            :         static int detect(U &amp;&amp;);                                              \
<span class="lineNum">     225 </span>            :         static void detect(...);                                              \
<span class="lineNum">     226 </span>            :     public:                                                                   \
<span class="lineNum">     227 </span>            :         static constexpr bool value =                                         \
<span class="lineNum">     228 </span>            :                 std::is_integral&lt;decltype(detect(std::declval&lt;T&gt;()))&gt;::value; \
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : // #include &lt;nlohmann/detail/meta.hpp&gt;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : #include &lt;ciso646&gt; // not
<span class="lineNum">     235 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">     236 </span>            : #include &lt;limits&gt; // numeric_limits
<span class="lineNum">     237 </span>            : #include &lt;type_traits&gt; // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type
<span class="lineNum">     238 </span>            : #include &lt;utility&gt; // declval
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : // #include &lt;nlohmann/json_fwd.hpp&gt;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : namespace rockets_nlohmann
<span class="lineNum">     246 </span>            : {
<span class="lineNum">     247 </span>            : /*!
<span class="lineNum">     248 </span>            : @brief detail namespace with internal helper functions
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : This namespace collects functions that should not be exposed,
<span class="lineNum">     251 </span>            : implementations of some @ref basic_json methods, and meta-programming helpers.
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : @since version 2.1.0
<span class="lineNum">     254 </span>            : */
<span class="lineNum">     255 </span>            : namespace detail
<span class="lineNum">     256 </span>            : {
<span class="lineNum">     257 </span>            : /////////////
<span class="lineNum">     258 </span>            : // helpers //
<span class="lineNum">     259 </span>            : /////////////
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : template&lt;typename&gt; struct is_basic_json : std::false_type {};
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : NLOHMANN_BASIC_JSON_TPL_DECLARATION
<span class="lineNum">     264 </span>            : struct is_basic_json&lt;NLOHMANN_BASIC_JSON_TPL&gt; : std::true_type {};
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : // alias templates to reduce boilerplate
<span class="lineNum">     267 </span>            : template&lt;bool B, typename T = void&gt;
<span class="lineNum">     268 </span>            : using enable_if_t = typename std::enable_if&lt;B, T&gt;::type;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : template&lt;typename T&gt;
<span class="lineNum">     271 </span>            : using uncvref_t = typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : // implementation of C++14 index_sequence and affiliates
<span class="lineNum">     274 </span>            : // source: https://stackoverflow.com/a/32223343
<span class="lineNum">     275 </span>            : template&lt;std::size_t... Ints&gt;
<span class="lineNum">     276 </span>            : struct index_sequence
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span>            :     using type = index_sequence;
<span class="lineNum">     279 </span>            :     using value_type = std::size_t;
<span class="lineNum">     280 </span>            :     static constexpr std::size_t size() noexcept
<span class="lineNum">     281 </span>            :     {
<span class="lineNum">     282 </span>            :         return sizeof...(Ints);
<span class="lineNum">     283 </span>            :     }
<span class="lineNum">     284 </span>            : };
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : template&lt;class Sequence1, class Sequence2&gt;
<span class="lineNum">     287 </span>            : struct merge_and_renumber;
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : template&lt;std::size_t... I1, std::size_t... I2&gt;
<span class="lineNum">     290 </span>            : struct merge_and_renumber&lt;index_sequence&lt;I1...&gt;, index_sequence&lt;I2...&gt;&gt;
<span class="lineNum">     291 </span>            :         : index_sequence &lt; I1..., (sizeof...(I1) + I2)... &gt; {};
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : template&lt;std::size_t N&gt;
<span class="lineNum">     294 </span>            : struct make_index_sequence
<span class="lineNum">     295 </span>            :     : merge_and_renumber &lt; typename make_index_sequence &lt; N / 2 &gt;::type,
<span class="lineNum">     296 </span>            :       typename make_index_sequence &lt; N - N / 2 &gt;::type &gt; {};
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : template&lt;&gt; struct make_index_sequence&lt;0&gt; : index_sequence&lt;&gt; {};
<span class="lineNum">     299 </span>            : template&lt;&gt; struct make_index_sequence&lt;1&gt; : index_sequence&lt;0&gt; {};
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : template&lt;typename... Ts&gt;
<span class="lineNum">     302 </span>            : using index_sequence_for = make_index_sequence&lt;sizeof...(Ts)&gt;;
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : /*
<span class="lineNum">     305 </span>            : Implementation of two C++17 constructs: conjunction, negation. This is needed
<span class="lineNum">     306 </span>            : to avoid evaluating all the traits in a condition
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : For example: not std::is_same&lt;void, T&gt;::value and has_value_type&lt;T&gt;::value
<span class="lineNum">     309 </span>            : will not compile when T = void (on MSVC at least). Whereas
<span class="lineNum">     310 </span>            : conjunction&lt;negation&lt;std::is_same&lt;void, T&gt;&gt;, has_value_type&lt;T&gt;&gt;::value will
<span class="lineNum">     311 </span>            : stop evaluating if negation&lt;...&gt;::value == false
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : Please note that those constructs must be used with caution, since symbols can
<span class="lineNum">     314 </span>            : become very long quickly (which can slow down compilation and cause MSVC
<span class="lineNum">     315 </span>            : internal compiler errors). Only use it when you have to (see example ahead).
<span class="lineNum">     316 </span>            : */
<span class="lineNum">     317 </span>            : template&lt;class...&gt; struct conjunction : std::true_type {};
<span class="lineNum">     318 </span>            : template&lt;class B1&gt; struct conjunction&lt;B1&gt; : B1 {};
<span class="lineNum">     319 </span>            : template&lt;class B1, class... Bn&gt;
<span class="lineNum">     320 </span>            : struct conjunction&lt;B1, Bn...&gt; : std::conditional&lt;bool(B1::value), conjunction&lt;Bn...&gt;, B1&gt;::type {};
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : template&lt;class B&gt; struct negation : std::integral_constant&lt;bool, not B::value&gt; {};
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : // dispatch utility (taken from ranges-v3)
<span class="lineNum">     325 </span>            : template&lt;unsigned N&gt; struct priority_tag : priority_tag &lt; N - 1 &gt; {};
<span class="lineNum">     326 </span>            : template&lt;&gt; struct priority_tag&lt;0&gt; {};
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : ////////////////////////
<span class="lineNum">     329 </span>            : // has_/is_ functions //
<span class="lineNum">     330 </span>            : ////////////////////////
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : // source: https://stackoverflow.com/a/37193089/4116453
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : template &lt;typename T, typename = void&gt;
<span class="lineNum">     335 </span>            : struct is_complete_type : std::false_type {};
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : template &lt;typename T&gt;
<span class="lineNum">     338 </span>            : struct is_complete_type&lt;T, decltype(void(sizeof(T)))&gt; : std::true_type {};
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : NLOHMANN_JSON_HAS_HELPER(mapped_type);
<span class="lineNum">     341 </span>            : NLOHMANN_JSON_HAS_HELPER(key_type);
<span class="lineNum">     342 </span>            : NLOHMANN_JSON_HAS_HELPER(value_type);
<span class="lineNum">     343 </span>            : NLOHMANN_JSON_HAS_HELPER(iterator);
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : template&lt;bool B, class RealType, class CompatibleObjectType&gt;
<span class="lineNum">     346 </span>            : struct is_compatible_object_type_impl : std::false_type {};
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : template&lt;class RealType, class CompatibleObjectType&gt;
<span class="lineNum">     349 </span>            : struct is_compatible_object_type_impl&lt;true, RealType, CompatibleObjectType&gt;
<span class="lineNum">     350 </span>            : {
<span class="lineNum">     351 </span>            :     static constexpr auto value =
<span class="lineNum">     352 </span>            :         std::is_constructible&lt;typename RealType::key_type, typename CompatibleObjectType::key_type&gt;::value and
<span class="lineNum">     353 </span>            :         std::is_constructible&lt;typename RealType::mapped_type, typename CompatibleObjectType::mapped_type&gt;::value;
<span class="lineNum">     354 </span>            : };
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : template&lt;class BasicJsonType, class CompatibleObjectType&gt;
<span class="lineNum">     357 </span>            : struct is_compatible_object_type
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            :     static auto constexpr value = is_compatible_object_type_impl &lt;
<span class="lineNum">     360 </span>            :                                   conjunction&lt;negation&lt;std::is_same&lt;void, CompatibleObjectType&gt;&gt;,
<span class="lineNum">     361 </span>            :                                   has_mapped_type&lt;CompatibleObjectType&gt;,
<span class="lineNum">     362 </span>            :                                   has_key_type&lt;CompatibleObjectType&gt;&gt;::value,
<span class="lineNum">     363 </span>            :                                   typename BasicJsonType::object_t, CompatibleObjectType &gt;::value;
<span class="lineNum">     364 </span>            : };
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">     367 </span>            : struct is_basic_json_nested_type
<span class="lineNum">     368 </span>            : {
<span class="lineNum">     369 </span>            :     static auto constexpr value = std::is_same&lt;T, typename BasicJsonType::iterator&gt;::value or
<span class="lineNum">     370 </span>            :                                   std::is_same&lt;T, typename BasicJsonType::const_iterator&gt;::value or
<span class="lineNum">     371 </span>            :                                   std::is_same&lt;T, typename BasicJsonType::reverse_iterator&gt;::value or
<span class="lineNum">     372 </span>            :                                   std::is_same&lt;T, typename BasicJsonType::const_reverse_iterator&gt;::value;
<span class="lineNum">     373 </span>            : };
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : template&lt;class BasicJsonType, class CompatibleArrayType&gt;
<span class="lineNum">     376 </span>            : struct is_compatible_array_type
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span>            :     static auto constexpr value =
<span class="lineNum">     379 </span>            :         conjunction&lt;negation&lt;std::is_same&lt;void, CompatibleArrayType&gt;&gt;,
<span class="lineNum">     380 </span>            :         negation&lt;is_compatible_object_type&lt;
<span class="lineNum">     381 </span>            :         BasicJsonType, CompatibleArrayType&gt;&gt;,
<span class="lineNum">     382 </span>            :         negation&lt;std::is_constructible&lt;typename BasicJsonType::string_t,
<span class="lineNum">     383 </span>            :         CompatibleArrayType&gt;&gt;,
<span class="lineNum">     384 </span>            :         negation&lt;is_basic_json_nested_type&lt;BasicJsonType, CompatibleArrayType&gt;&gt;,
<span class="lineNum">     385 </span>            :         has_value_type&lt;CompatibleArrayType&gt;,
<span class="lineNum">     386 </span>            :         has_iterator&lt;CompatibleArrayType&gt;&gt;::value;
<span class="lineNum">     387 </span>            : };
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : template&lt;bool, typename, typename&gt;
<span class="lineNum">     390 </span>            : struct is_compatible_integer_type_impl : std::false_type {};
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType&gt;
<span class="lineNum">     393 </span>            : struct is_compatible_integer_type_impl&lt;true, RealIntegerType, CompatibleNumberIntegerType&gt;
<span class="lineNum">     394 </span>            : {
<span class="lineNum">     395 </span>            :     // is there an assert somewhere on overflows?
<span class="lineNum">     396 </span>            :     using RealLimits = std::numeric_limits&lt;RealIntegerType&gt;;
<span class="lineNum">     397 </span>            :     using CompatibleLimits = std::numeric_limits&lt;CompatibleNumberIntegerType&gt;;
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :     static constexpr auto value =
<span class="lineNum">     400 </span>            :         std::is_constructible&lt;RealIntegerType, CompatibleNumberIntegerType&gt;::value and
<span class="lineNum">     401 </span>            :         CompatibleLimits::is_integer and
<span class="lineNum">     402 </span>            :         RealLimits::is_signed == CompatibleLimits::is_signed;
<span class="lineNum">     403 </span>            : };
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : template&lt;typename RealIntegerType, typename CompatibleNumberIntegerType&gt;
<span class="lineNum">     406 </span>            : struct is_compatible_integer_type
<span class="lineNum">     407 </span>            : {
<span class="lineNum">     408 </span>            :     static constexpr auto value =
<span class="lineNum">     409 </span>            :         is_compatible_integer_type_impl &lt;
<span class="lineNum">     410 </span>            :         std::is_integral&lt;CompatibleNumberIntegerType&gt;::value and
<span class="lineNum">     411 </span>            :         not std::is_same&lt;bool, CompatibleNumberIntegerType&gt;::value,
<span class="lineNum">     412 </span>            :         RealIntegerType, CompatibleNumberIntegerType &gt; ::value;
<span class="lineNum">     413 </span>            : };
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : // trait checking if JSONSerializer&lt;T&gt;::from_json(json const&amp;, udt&amp;) exists
<span class="lineNum">     416 </span>            : template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">     417 </span>            : struct has_from_json
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span>            :   private:
<span class="lineNum">     420 </span>            :     // also check the return type of from_json
<span class="lineNum">     421 </span>            :     template&lt;typename U, typename = enable_if_t&lt;std::is_same&lt;void, decltype(uncvref_t&lt;U&gt;::from_json(
<span class="lineNum">     422 </span>            :                  std::declval&lt;BasicJsonType&gt;(), std::declval&lt;T&amp;&gt;()))&gt;::value&gt;&gt;
<span class="lineNum">     423 </span>            :     static int detect(U&amp;&amp;);
<span class="lineNum">     424 </span>            :     static void detect(...);
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :   public:
<span class="lineNum">     427 </span>            :     static constexpr bool value = std::is_integral&lt;decltype(
<span class="lineNum">     428 </span>            :                                       detect(std::declval&lt;typename BasicJsonType::template json_serializer&lt;T, void&gt;&gt;()))&gt;::value;
<span class="lineNum">     429 </span>            : };
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : // This trait checks if JSONSerializer&lt;T&gt;::from_json(json const&amp;) exists
<span class="lineNum">     432 </span>            : // this overload is used for non-default-constructible user-defined-types
<span class="lineNum">     433 </span>            : template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">     434 </span>            : struct has_non_default_from_json
<span class="lineNum">     435 </span>            : {
<span class="lineNum">     436 </span>            :   private:
<span class="lineNum">     437 </span>            :     template &lt;
<span class="lineNum">     438 </span>            :         typename U,
<span class="lineNum">     439 </span>            :         typename = enable_if_t&lt;std::is_same&lt;
<span class="lineNum">     440 </span>            :                                    T, decltype(uncvref_t&lt;U&gt;::from_json(std::declval&lt;BasicJsonType&gt;()))&gt;::value &gt;&gt;
<span class="lineNum">     441 </span>            :     static int detect(U&amp;&amp;);
<span class="lineNum">     442 </span>            :     static void detect(...);
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   public:
<span class="lineNum">     445 </span>            :     static constexpr bool value = std::is_integral&lt;decltype(detect(
<span class="lineNum">     446 </span>            :                                       std::declval&lt;typename BasicJsonType::template json_serializer&lt;T, void&gt;&gt;()))&gt;::value;
<span class="lineNum">     447 </span>            : };
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : // This trait checks if BasicJsonType::json_serializer&lt;T&gt;::to_json exists
<span class="lineNum">     450 </span>            : template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">     451 </span>            : struct has_to_json
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span>            :   private:
<span class="lineNum">     454 </span>            :     template&lt;typename U, typename = decltype(uncvref_t&lt;U&gt;::to_json(
<span class="lineNum">     455 </span>            :                  std::declval&lt;BasicJsonType&amp;&gt;(), std::declval&lt;T&gt;()))&gt;
<span class="lineNum">     456 </span>            :     static int detect(U&amp;&amp;);
<span class="lineNum">     457 </span>            :     static void detect(...);
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :   public:
<span class="lineNum">     460 </span>            :     static constexpr bool value = std::is_integral&lt;decltype(detect(
<span class="lineNum">     461 </span>            :                                       std::declval&lt;typename BasicJsonType::template json_serializer&lt;T, void&gt;&gt;()))&gt;::value;
<span class="lineNum">     462 </span>            : };
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : template &lt;typename BasicJsonType, typename CompatibleCompleteType&gt;
<span class="lineNum">     465 </span>            : struct is_compatible_complete_type
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span>            :     static constexpr bool value =
<span class="lineNum">     468 </span>            :         not std::is_base_of&lt;std::istream, CompatibleCompleteType&gt;::value and
<span class="lineNum">     469 </span>            :         not std::is_same&lt;BasicJsonType, CompatibleCompleteType&gt;::value and
<span class="lineNum">     470 </span>            :         not is_basic_json_nested_type&lt;BasicJsonType, CompatibleCompleteType&gt;::value and
<span class="lineNum">     471 </span>            :         has_to_json&lt;BasicJsonType, CompatibleCompleteType&gt;::value;
<span class="lineNum">     472 </span>            : };
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : template &lt;typename BasicJsonType, typename CompatibleType&gt;
<span class="lineNum">     475 </span>            : struct is_compatible_type
<span class="lineNum">     476 </span>            :     : conjunction&lt;is_complete_type&lt;CompatibleType&gt;,
<span class="lineNum">     477 </span>            :       is_compatible_complete_type&lt;BasicJsonType, CompatibleType&gt;&gt;
<span class="lineNum">     478 </span>            : {
<span class="lineNum">     479 </span>            : };
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : // taken from ranges-v3
<span class="lineNum">     482 </span>            : template&lt;typename T&gt;
<span class="lineNum">     483 </span>            : struct static_const
<span class="lineNum">     484 </span>            : {
<span class="lineNum">     485 </span>            :     static constexpr T value{};
<span class="lineNum">     486 </span>            : };
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : template&lt;typename T&gt;
<span class="lineNum">     489 </span>            : constexpr T static_const&lt;T&gt;::value;
<span class="lineNum">     490 </span>            : }
<span class="lineNum">     491 </span>            : }
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : #include &lt;exception&gt; // exception
<span class="lineNum">     497 </span>            : #include &lt;stdexcept&gt; // runtime_error
<span class="lineNum">     498 </span>            : #include &lt;string&gt; // to_string
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : namespace rockets_nlohmann
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span>            : namespace detail
<span class="lineNum">     503 </span>            : {
<span class="lineNum">     504 </span>            : ////////////////
<span class="lineNum">     505 </span>            : // exceptions //
<span class="lineNum">     506 </span>            : ////////////////
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : /*!
<span class="lineNum">     509 </span>            : @brief general exception of the @ref basic_json class
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : This class is an extension of `std::exception` objects with a member @a id for
<span class="lineNum">     512 </span>            : exception ids. It is used as the base class for all exceptions thrown by the
<span class="lineNum">     513 </span>            : @ref basic_json class. This class can hence be used as &quot;wildcard&quot; to catch
<span class="lineNum">     514 </span>            : exceptions.
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            : Subclasses:
<span class="lineNum">     517 </span>            : - @ref parse_error for exceptions indicating a parse error
<span class="lineNum">     518 </span>            : - @ref invalid_iterator for exceptions indicating errors with iterators
<span class="lineNum">     519 </span>            : - @ref type_error for exceptions indicating executing a member function with
<span class="lineNum">     520 </span>            :                   a wrong type
<span class="lineNum">     521 </span>            : - @ref out_of_range for exceptions indicating access out of the defined range
<span class="lineNum">     522 </span>            : - @ref other_error for exceptions indicating other library errors
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : @internal
<span class="lineNum">     525 </span>            : @note To have nothrow-copy-constructible exceptions, we internally use
<span class="lineNum">     526 </span>            :       `std::runtime_error` which can cope with arbitrary-length error messages.
<span class="lineNum">     527 </span>            :       Intermediate strings are built with static functions and then passed to
<span class="lineNum">     528 </span>            :       the actual constructor.
<span class="lineNum">     529 </span>            : @endinternal
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : @liveexample{The following code shows how arbitrary library exceptions can be
<span class="lineNum">     532 </span>            : caught.,exception}
<span class="lineNum">     533 </span>            : 
<a name="534"><span class="lineNum">     534 </span>            : @since version 3.0.0</a>
<span class="lineNum">     535 </span>            : */
<span class="lineNum">     536 </span><span class="lineCov">          2 : class exception : public std::exception</span>
<span class="lineNum">     537 </span>            : {
<a name="538"><span class="lineNum">     538 </span>            :   public:</a>
<span class="lineNum">     539 </span>            :     /// returns the explanatory string
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     const char* what() const noexcept override</span>
<span class="lineNum">     541 </span>            :     {
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         return m.what();</span>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :     /// the id of the exception
<span class="lineNum">     546 </span>            :     const int id;
<a name="547"><span class="lineNum">     547 </span>            : </a>
<span class="lineNum">     548 </span>            :   protected:
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">          2 :     exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}</span></a>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineCov">          2 :     static std::string name(const std::string&amp; ename, int id_)</span>
<span class="lineNum">     552 </span>            :     {
<span class="lineNum">     553 </span><span class="lineCov">          2 :         return &quot;[json.exception.&quot; + ename + &quot;.&quot; + std::to_string(id_) + &quot;] &quot;;</span>
<span class="lineNum">     554 </span>            :     }
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :   private:
<span class="lineNum">     557 </span>            :     /// an exception object as storage for error messages
<span class="lineNum">     558 </span>            :     std::runtime_error m;
<span class="lineNum">     559 </span>            : };
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : /*!
<span class="lineNum">     562 </span>            : @brief exception indicating a parse error
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : This exception is thrown by the library when a parse error occurs. Parse errors
<span class="lineNum">     565 </span>            : can occur during the deserialization of JSON text, CBOR, MessagePack, as well
<span class="lineNum">     566 </span>            : as when using JSON Patch.
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : Member @a byte holds the byte index of the last read character in the input
<span class="lineNum">     569 </span>            : file.
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : Exceptions have ids 1xx.
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : name / id                      | example message | description
<span class="lineNum">     574 </span>            : ------------------------------ | --------------- | -------------------------
<span class="lineNum">     575 </span>            : json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
<span class="lineNum">     576 </span>            : json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries (&quot;surrogate pairs&quot;). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
<span class="lineNum">     577 </span>            : json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
<span class="lineNum">     578 </span>            : json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
<span class="lineNum">     579 </span>            : json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one &quot;op&quot; member, whose value indicates the operation to perform. Its value must be one of &quot;add&quot;, &quot;remove&quot;, &quot;replace&quot;, &quot;move&quot;, &quot;copy&quot;, or &quot;test&quot;; other values are errors.
<span class="lineNum">     580 </span>            : json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
<span class="lineNum">     581 </span>            : json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
<span class="lineNum">     582 </span>            : json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
<span class="lineNum">     583 </span>            : json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
<span class="lineNum">     584 </span>            : json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
<span class="lineNum">     585 </span>            : json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
<span class="lineNum">     586 </span>            : json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            : @note For an input with n bytes, 1 is the index of the first character and n+1
<span class="lineNum">     589 </span>            :       is the index of the terminating null byte or the end of file. This also
<span class="lineNum">     590 </span>            :       holds true when reading a byte vector (CBOR or MessagePack).
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            : @liveexample{The following code shows how a `parse_error` exception can be
<span class="lineNum">     593 </span>            : caught.,parse_error}
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : @sa @ref exception for the base class of the library exceptions
<span class="lineNum">     596 </span>            : @sa @ref invalid_iterator for exceptions indicating errors with iterators
<span class="lineNum">     597 </span>            : @sa @ref type_error for exceptions indicating executing a member function with
<span class="lineNum">     598 </span>            :                     a wrong type
<span class="lineNum">     599 </span>            : @sa @ref out_of_range for exceptions indicating access out of the defined range
<span class="lineNum">     600 </span>            : @sa @ref other_error for exceptions indicating other library errors
<span class="lineNum">     601 </span>            : 
<a name="602"><span class="lineNum">     602 </span>            : @since version 3.0.0</a>
<span class="lineNum">     603 </span>            : */
<span class="lineNum">     604 </span><span class="lineCov">          2 : class parse_error : public exception</span>
<span class="lineNum">     605 </span>            : {
<span class="lineNum">     606 </span>            :   public:
<span class="lineNum">     607 </span>            :     /*!
<span class="lineNum">     608 </span>            :     @brief create a parse error exception
<span class="lineNum">     609 </span>            :     @param[in] id_       the id of the exception
<span class="lineNum">     610 </span>            :     @param[in] byte_     the byte index where the error occurred (or 0 if the
<span class="lineNum">     611 </span>            :                          position cannot be determined)
<span class="lineNum">     612 </span>            :     @param[in] what_arg  the explanatory string
<a name="613"><span class="lineNum">     613 </span>            :     @return parse_error object</a>
<span class="lineNum">     614 </span>            :     */
<span class="lineNum">     615 </span><span class="lineCov">          2 :     static parse_error create(int id_, std::size_t byte_, const std::string&amp; what_arg)</span>
<span class="lineNum">     616 </span>            :     {
<span class="lineNum">     617 </span><span class="lineCov">          4 :         std::string w = exception::name(&quot;parse_error&quot;, id_) + &quot;parse error&quot; +</span>
<span class="lineNum">     618 </span><span class="lineCov">         10 :                         (byte_ != 0 ? (&quot; at &quot; + std::to_string(byte_)) : &quot;&quot;) +</span>
<span class="lineNum">     619 </span><span class="lineCov">          4 :                         &quot;: &quot; + what_arg;</span>
<span class="lineNum">     620 </span><span class="lineCov">          4 :         return parse_error(id_, byte_, w.c_str());</span>
<span class="lineNum">     621 </span>            :     }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :     /*!
<span class="lineNum">     624 </span>            :     @brief byte index of the parse error
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :     The byte index of the last read character in the input file.
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :     @note For an input with n bytes, 1 is the index of the first character and
<span class="lineNum">     629 </span>            :           n+1 is the index of the terminating null byte or the end of file.
<span class="lineNum">     630 </span>            :           This also holds true when reading a byte vector (CBOR or MessagePack).
<span class="lineNum">     631 </span>            :     */
<span class="lineNum">     632 </span>            :     const std::size_t byte;
<a name="633"><span class="lineNum">     633 </span>            : </a>
<span class="lineNum">     634 </span>            :   private:
<span class="lineNum">     635 </span><span class="lineCov">          2 :     parse_error(int id_, std::size_t byte_, const char* what_arg)</span>
<span class="lineNum">     636 </span><span class="lineCov">          2 :         : exception(id_, what_arg), byte(byte_) {}</span>
<span class="lineNum">     637 </span>            : };
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            : /*!
<span class="lineNum">     640 </span>            : @brief exception indicating errors with iterators
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : This exception is thrown if iterators passed to a library function do not match
<span class="lineNum">     643 </span>            : the expected semantics.
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : Exceptions have ids 2xx.
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : name / id                           | example message | description
<span class="lineNum">     648 </span>            : ----------------------------------- | --------------- | -------------------------
<span class="lineNum">     649 </span>            : json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
<span class="lineNum">     650 </span>            : json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
<span class="lineNum">     651 </span>            : json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
<span class="lineNum">     652 </span>            : json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
<span class="lineNum">     653 </span>            : json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
<span class="lineNum">     654 </span>            : json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
<span class="lineNum">     655 </span>            : json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
<span class="lineNum">     656 </span>            : json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
<span class="lineNum">     657 </span>            : json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
<span class="lineNum">     658 </span>            : json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
<span class="lineNum">     659 </span>            : json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
<span class="lineNum">     660 </span>            : json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
<span class="lineNum">     661 </span>            : json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
<span class="lineNum">     662 </span>            : json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : @liveexample{The following code shows how an `invalid_iterator` exception can be
<span class="lineNum">     665 </span>            : caught.,invalid_iterator}
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : @sa @ref exception for the base class of the library exceptions
<span class="lineNum">     668 </span>            : @sa @ref parse_error for exceptions indicating a parse error
<span class="lineNum">     669 </span>            : @sa @ref type_error for exceptions indicating executing a member function with
<span class="lineNum">     670 </span>            :                     a wrong type
<span class="lineNum">     671 </span>            : @sa @ref out_of_range for exceptions indicating access out of the defined range
<span class="lineNum">     672 </span>            : @sa @ref other_error for exceptions indicating other library errors
<span class="lineNum">     673 </span>            : 
<a name="674"><span class="lineNum">     674 </span>            : @since version 3.0.0</a>
<span class="lineNum">     675 </span>            : */
<span class="lineNum">     676 </span><span class="lineNoCov">          0 : class invalid_iterator : public exception</span>
<a name="677"><span class="lineNum">     677 </span>            : {</a>
<span class="lineNum">     678 </span>            :   public:
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     static invalid_iterator create(int id_, const std::string&amp; what_arg)</span>
<span class="lineNum">     680 </span>            :     {
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         std::string w = exception::name(&quot;invalid_iterator&quot;, id_) + what_arg;</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         return invalid_iterator(id_, w.c_str());</span>
<span class="lineNum">     683 </span>            :     }
<a name="684"><span class="lineNum">     684 </span>            : </a>
<span class="lineNum">     685 </span>            :   private:
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     invalid_iterator(int id_, const char* what_arg)</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :         : exception(id_, what_arg) {}</span>
<span class="lineNum">     688 </span>            : };
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : /*!
<span class="lineNum">     691 </span>            : @brief exception indicating executing a member function with a wrong type
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : This exception is thrown in case of a type error; that is, a library function is
<span class="lineNum">     694 </span>            : executed on a JSON value whose type does not match the expected semantics.
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : Exceptions have ids 3xx.
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : name / id                     | example message | description
<span class="lineNum">     699 </span>            : ----------------------------- | --------------- | -------------------------
<span class="lineNum">     700 </span>            : json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
<span class="lineNum">     701 </span>            : json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
<span class="lineNum">     702 </span>            : json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t&amp;.
<span class="lineNum">     703 </span>            : json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
<span class="lineNum">     704 </span>            : json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
<span class="lineNum">     705 </span>            : json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
<span class="lineNum">     706 </span>            : json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
<span class="lineNum">     707 </span>            : json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
<span class="lineNum">     708 </span>            : json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
<span class="lineNum">     709 </span>            : json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
<span class="lineNum">     710 </span>            : json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
<span class="lineNum">     711 </span>            : json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
<span class="lineNum">     712 </span>            : json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
<span class="lineNum">     713 </span>            : json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
<span class="lineNum">     714 </span>            : json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
<span class="lineNum">     715 </span>            : json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : @liveexample{The following code shows how a `type_error` exception can be
<span class="lineNum">     718 </span>            : caught.,type_error}
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            : @sa @ref exception for the base class of the library exceptions
<span class="lineNum">     721 </span>            : @sa @ref parse_error for exceptions indicating a parse error
<span class="lineNum">     722 </span>            : @sa @ref invalid_iterator for exceptions indicating errors with iterators
<span class="lineNum">     723 </span>            : @sa @ref out_of_range for exceptions indicating access out of the defined range
<span class="lineNum">     724 </span>            : @sa @ref other_error for exceptions indicating other library errors
<span class="lineNum">     725 </span>            : 
<a name="726"><span class="lineNum">     726 </span>            : @since version 3.0.0</a>
<span class="lineNum">     727 </span>            : */
<span class="lineNum">     728 </span><span class="lineNoCov">          0 : class type_error : public exception</span>
<a name="729"><span class="lineNum">     729 </span>            : {</a>
<span class="lineNum">     730 </span>            :   public:
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     static type_error create(int id_, const std::string&amp; what_arg)</span>
<span class="lineNum">     732 </span>            :     {
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         std::string w = exception::name(&quot;type_error&quot;, id_) + what_arg;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         return type_error(id_, w.c_str());</span>
<span class="lineNum">     735 </span>            :     }
<a name="736"><span class="lineNum">     736 </span>            : </a>
<span class="lineNum">     737 </span>            :   private:
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}</span>
<span class="lineNum">     739 </span>            : };
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : /*!
<span class="lineNum">     742 </span>            : @brief exception indicating access out of the defined range
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            : This exception is thrown in case a library function is called on an input
<span class="lineNum">     745 </span>            : parameter that exceeds the expected range, for instance in case of array
<span class="lineNum">     746 </span>            : indices or nonexisting object keys.
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : Exceptions have ids 4xx.
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : name / id                       | example message | description
<span class="lineNum">     751 </span>            : ------------------------------- | --------------- | -------------------------
<span class="lineNum">     752 </span>            : json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
<span class="lineNum">     753 </span>            : json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
<span class="lineNum">     754 </span>            : json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
<span class="lineNum">     755 </span>            : json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
<span class="lineNum">     756 </span>            : json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
<span class="lineNum">     757 </span>            : json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
<span class="lineNum">     758 </span>            : json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON only supports integers numbers up to 9223372036854775807. |
<span class="lineNum">     759 </span>            : json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            : @liveexample{The following code shows how an `out_of_range` exception can be
<span class="lineNum">     762 </span>            : caught.,out_of_range}
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            : @sa @ref exception for the base class of the library exceptions
<span class="lineNum">     765 </span>            : @sa @ref parse_error for exceptions indicating a parse error
<span class="lineNum">     766 </span>            : @sa @ref invalid_iterator for exceptions indicating errors with iterators
<span class="lineNum">     767 </span>            : @sa @ref type_error for exceptions indicating executing a member function with
<span class="lineNum">     768 </span>            :                     a wrong type
<span class="lineNum">     769 </span>            : @sa @ref other_error for exceptions indicating other library errors
<span class="lineNum">     770 </span>            : 
<a name="771"><span class="lineNum">     771 </span>            : @since version 3.0.0</a>
<span class="lineNum">     772 </span>            : */
<span class="lineNum">     773 </span><span class="lineNoCov">          0 : class out_of_range : public exception</span>
<a name="774"><span class="lineNum">     774 </span>            : {</a>
<span class="lineNum">     775 </span>            :   public:
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     static out_of_range create(int id_, const std::string&amp; what_arg)</span>
<span class="lineNum">     777 </span>            :     {
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         std::string w = exception::name(&quot;out_of_range&quot;, id_) + what_arg;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         return out_of_range(id_, w.c_str());</span>
<span class="lineNum">     780 </span>            :     }
<a name="781"><span class="lineNum">     781 </span>            : </a>
<span class="lineNum">     782 </span>            :   private:
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}</span>
<span class="lineNum">     784 </span>            : };
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : /*!
<span class="lineNum">     787 </span>            : @brief exception indicating other library errors
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            : This exception is thrown in case of errors that cannot be classified with the
<span class="lineNum">     790 </span>            : other exception types.
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : Exceptions have ids 5xx.
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            : name / id                      | example message | description
<span class="lineNum">     795 </span>            : ------------------------------ | --------------- | -------------------------
<span class="lineNum">     796 </span>            : json.exception.other_error.501 | unsuccessful: {&quot;op&quot;:&quot;test&quot;,&quot;path&quot;:&quot;/baz&quot;, &quot;value&quot;:&quot;bar&quot;} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : @sa @ref exception for the base class of the library exceptions
<span class="lineNum">     799 </span>            : @sa @ref parse_error for exceptions indicating a parse error
<span class="lineNum">     800 </span>            : @sa @ref invalid_iterator for exceptions indicating errors with iterators
<span class="lineNum">     801 </span>            : @sa @ref type_error for exceptions indicating executing a member function with
<span class="lineNum">     802 </span>            :                     a wrong type
<span class="lineNum">     803 </span>            : @sa @ref out_of_range for exceptions indicating access out of the defined range
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            : @liveexample{The following code shows how an `other_error` exception can be
<span class="lineNum">     806 </span>            : caught.,other_error}
<span class="lineNum">     807 </span>            : 
<a name="808"><span class="lineNum">     808 </span>            : @since version 3.0.0</a>
<span class="lineNum">     809 </span>            : */
<span class="lineNum">     810 </span><span class="lineNoCov">          0 : class other_error : public exception</span>
<a name="811"><span class="lineNum">     811 </span>            : {</a>
<span class="lineNum">     812 </span>            :   public:
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     static other_error create(int id_, const std::string&amp; what_arg)</span>
<span class="lineNum">     814 </span>            :     {
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         std::string w = exception::name(&quot;other_error&quot;, id_) + what_arg;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :         return other_error(id_, w.c_str());</span>
<span class="lineNum">     817 </span>            :     }
<a name="818"><span class="lineNum">     818 </span>            : </a>
<span class="lineNum">     819 </span>            :   private:
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}</span>
<span class="lineNum">     821 </span>            : };
<span class="lineNum">     822 </span>            : }
<span class="lineNum">     823 </span>            : }
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : #include &lt;array&gt; // array
<span class="lineNum">     829 </span>            : #include &lt;ciso646&gt; // and
<span class="lineNum">     830 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">     831 </span>            : #include &lt;cstdint&gt; // uint8_t
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : namespace rockets_nlohmann
<span class="lineNum">     834 </span>            : {
<span class="lineNum">     835 </span>            : namespace detail
<span class="lineNum">     836 </span>            : {
<span class="lineNum">     837 </span>            : ///////////////////////////
<span class="lineNum">     838 </span>            : // JSON type enumeration //
<span class="lineNum">     839 </span>            : ///////////////////////////
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            : /*!
<span class="lineNum">     842 </span>            : @brief the JSON type enumeration
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            : This enumeration collects the different JSON types. It is internally used to
<span class="lineNum">     845 </span>            : distinguish the stored values, and the functions @ref basic_json::is_null(),
<span class="lineNum">     846 </span>            : @ref basic_json::is_object(), @ref basic_json::is_array(),
<span class="lineNum">     847 </span>            : @ref basic_json::is_string(), @ref basic_json::is_boolean(),
<span class="lineNum">     848 </span>            : @ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
<span class="lineNum">     849 </span>            : @ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
<span class="lineNum">     850 </span>            : @ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
<span class="lineNum">     851 </span>            : @ref basic_json::is_structured() rely on it.
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : @note There are three enumeration entries (number_integer, number_unsigned, and
<span class="lineNum">     854 </span>            : number_float), because the library distinguishes these three types for numbers:
<span class="lineNum">     855 </span>            : @ref basic_json::number_unsigned_t is used for unsigned integers,
<span class="lineNum">     856 </span>            : @ref basic_json::number_integer_t is used for signed integers, and
<span class="lineNum">     857 </span>            : @ref basic_json::number_float_t is used for floating-point numbers or to
<span class="lineNum">     858 </span>            : approximate integers which do not fit in the limits of their respective type.
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            : @sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
<span class="lineNum">     861 </span>            : value with the default value for a given type
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : @since version 1.0.0
<span class="lineNum">     864 </span>            : */
<span class="lineNum">     865 </span>            : enum class value_t : std::uint8_t
<span class="lineNum">     866 </span>            : {
<span class="lineNum">     867 </span>            :     null,             ///&lt; null value
<span class="lineNum">     868 </span>            :     object,           ///&lt; object (unordered set of name/value pairs)
<span class="lineNum">     869 </span>            :     array,            ///&lt; array (ordered collection of values)
<span class="lineNum">     870 </span>            :     string,           ///&lt; string value
<span class="lineNum">     871 </span>            :     boolean,          ///&lt; boolean value
<span class="lineNum">     872 </span>            :     number_integer,   ///&lt; number value (signed integer)
<span class="lineNum">     873 </span>            :     number_unsigned,  ///&lt; number value (unsigned integer)
<span class="lineNum">     874 </span>            :     number_float,     ///&lt; number value (floating-point)
<span class="lineNum">     875 </span>            :     discarded         ///&lt; discarded by the the parser callback function
<span class="lineNum">     876 </span>            : };
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : /*!
<span class="lineNum">     879 </span>            : @brief comparison operator for JSON types
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            : Returns an ordering that is similar to Python:
<span class="lineNum">     882 </span>            : - order: null &lt; boolean &lt; number &lt; object &lt; array &lt; string
<span class="lineNum">     883 </span>            : - furthermore, each type is not smaller than itself
<span class="lineNum">     884 </span>            : - discarded values are not comparable
<span class="lineNum">     885 </span>            : 
<a name="886"><span class="lineNum">     886 </span>            : @since version 1.0.0</a>
<span class="lineNum">     887 </span>            : */
<span class="lineNum">     888 </span><span class="lineNoCov">          0 : inline bool operator&lt;(const value_t lhs, const value_t rhs) noexcept</span>
<span class="lineNum">     889 </span>            : {
<span class="lineNum">     890 </span>            :     static constexpr std::array&lt;std::uint8_t, 8&gt; order = {{
<span class="lineNum">     891 </span>            :             0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
<span class="lineNum">     892 </span>            :             1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */
<span class="lineNum">     893 </span>            :         }
<span class="lineNum">     894 </span>            :     };
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     const auto l_index = static_cast&lt;std::size_t&gt;(lhs);</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     const auto r_index = static_cast&lt;std::size_t&gt;(rhs);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     return l_index &lt; order.size() and r_index &lt; order.size() and order[l_index] &lt; order[r_index];</span>
<span class="lineNum">     899 </span>            : }
<span class="lineNum">     900 </span>            : }
<span class="lineNum">     901 </span>            : }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            : // #include &lt;nlohmann/detail/conversions/from_json.hpp&gt;
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : #include &lt;algorithm&gt; // transform
<span class="lineNum">     907 </span>            : #include &lt;array&gt; // array
<span class="lineNum">     908 </span>            : #include &lt;ciso646&gt; // and, not
<span class="lineNum">     909 </span>            : #include &lt;forward_list&gt; // forward_list
<span class="lineNum">     910 </span>            : #include &lt;iterator&gt; // inserter, front_inserter, end
<span class="lineNum">     911 </span>            : #include &lt;string&gt; // string
<span class="lineNum">     912 </span>            : #include &lt;tuple&gt; // tuple, make_tuple
<span class="lineNum">     913 </span>            : #include &lt;type_traits&gt; // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
<span class="lineNum">     914 </span>            : #include &lt;utility&gt; // pair, declval
<span class="lineNum">     915 </span>            : #include &lt;valarray&gt; // valarray
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            : // #include &lt;nlohmann/detail/meta.hpp&gt;
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : namespace rockets_nlohmann
<span class="lineNum">     927 </span>            : {
<span class="lineNum">     928 </span>            : namespace detail
<span class="lineNum">     929 </span>            : {
<span class="lineNum">     930 </span>            : // overloads for basic_json template parameters
<span class="lineNum">     931 </span>            : template&lt;typename BasicJsonType, typename ArithmeticType,
<span class="lineNum">     932 </span>            :          enable_if_t&lt;std::is_arithmetic&lt;ArithmeticType&gt;::value and
<a name="933"><span class="lineNum">     933 </span>            :                      not std::is_same&lt;ArithmeticType, typename BasicJsonType::boolean_t&gt;::value,</a>
<span class="lineNum">     934 </span>            :                      int&gt; = 0&gt;
<span class="lineNum">     935 </span><span class="lineCov">          8 : void get_arithmetic_value(const BasicJsonType&amp; j, ArithmeticType&amp; val)</span>
<span class="lineNum">     936 </span>            : {
<span class="lineNum">     937 </span><span class="lineCov">          8 :     switch (static_cast&lt;value_t&gt;(j))</span>
<span class="lineNum">     938 </span>            :     {
<span class="lineNum">     939 </span>            :         case value_t::number_unsigned:
<span class="lineNum">     940 </span>            :         {
<span class="lineNum">     941 </span><span class="lineCov">          8 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_unsigned_t*&gt;());</span>
<span class="lineNum">     942 </span><span class="lineCov">          8 :             break;</span>
<span class="lineNum">     943 </span>            :         }
<span class="lineNum">     944 </span>            :         case value_t::number_integer:
<span class="lineNum">     945 </span>            :         {
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_integer_t*&gt;());</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     948 </span>            :         }
<span class="lineNum">     949 </span>            :         case value_t::number_float:
<span class="lineNum">     950 </span>            :         {
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_float_t*&gt;());</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     953 </span>            :         }
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :         default:
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :             JSON_THROW(type_error::create(302, &quot;type must be number, but is &quot; + std::string(j.type_name())));</span>
<span class="lineNum">     957 </span>            :     }
<span class="lineNum">     958 </span><span class="lineCov">          8 : }</span>
<a name="959"><span class="lineNum">     959 </span>            : </a>
<span class="lineNum">     960 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">     961 </span><span class="lineNoCov">          0 : void from_json(const BasicJsonType&amp; j, typename BasicJsonType::boolean_t&amp; b)</span>
<span class="lineNum">     962 </span>            : {
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     if (JSON_UNLIKELY(not j.is_boolean()))</span>
<span class="lineNum">     964 </span>            :     {
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         JSON_THROW(type_error::create(302, &quot;type must be boolean, but is &quot; + std::string(j.type_name())));</span>
<span class="lineNum">     966 </span>            :     }
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     b = *j.template get_ptr&lt;const typename BasicJsonType::boolean_t*&gt;();</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 : }</span>
<a name="969"><span class="lineNum">     969 </span>            : </a>
<span class="lineNum">     970 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">     971 </span><span class="lineCov">        115 : void from_json(const BasicJsonType&amp; j, typename BasicJsonType::string_t&amp; s)</span>
<span class="lineNum">     972 </span>            : {
<span class="lineNum">     973 </span><span class="lineCov">        115 :     if (JSON_UNLIKELY(not j.is_string()))</span>
<span class="lineNum">     974 </span>            :     {
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         JSON_THROW(type_error::create(302, &quot;type must be string, but is &quot; + std::string(j.type_name())));</span>
<span class="lineNum">     976 </span>            :     }
<span class="lineNum">     977 </span><span class="lineCov">        115 :     s = *j.template get_ptr&lt;const typename BasicJsonType::string_t*&gt;();</span>
<span class="lineNum">     978 </span><span class="lineCov">        115 : }</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">     981 </span>            : void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_float_t&amp; val)
<span class="lineNum">     982 </span>            : {
<span class="lineNum">     983 </span>            :     get_arithmetic_value(j, val);
<span class="lineNum">     984 </span>            : }
<a name="985"><span class="lineNum">     985 </span>            : </a>
<span class="lineNum">     986 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">     987 </span><span class="lineCov">          8 : void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_unsigned_t&amp; val)</span>
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span><span class="lineCov">          8 :     get_arithmetic_value(j, val);</span>
<span class="lineNum">     990 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">     993 </span>            : void from_json(const BasicJsonType&amp; j, typename BasicJsonType::number_integer_t&amp; val)
<span class="lineNum">     994 </span>            : {
<span class="lineNum">     995 </span>            :     get_arithmetic_value(j, val);
<span class="lineNum">     996 </span>            : }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : template&lt;typename BasicJsonType, typename EnumType,
<span class="lineNum">     999 </span>            :          enable_if_t&lt;std::is_enum&lt;EnumType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1000 </span>            : void from_json(const BasicJsonType&amp; j, EnumType&amp; e)
<span class="lineNum">    1001 </span>            : {
<span class="lineNum">    1002 </span>            :     typename std::underlying_type&lt;EnumType&gt;::type val;
<span class="lineNum">    1003 </span>            :     get_arithmetic_value(j, val);
<span class="lineNum">    1004 </span>            :     e = static_cast&lt;EnumType&gt;(val);
<span class="lineNum">    1005 </span>            : }
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1008 </span>            : void from_json(const BasicJsonType&amp; j, typename BasicJsonType::array_t&amp; arr)
<span class="lineNum">    1009 </span>            : {
<span class="lineNum">    1010 </span>            :     if (JSON_UNLIKELY(not j.is_array()))
<span class="lineNum">    1011 </span>            :     {
<span class="lineNum">    1012 </span>            :         JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name())));
<span class="lineNum">    1013 </span>            :     }
<span class="lineNum">    1014 </span>            :     arr = *j.template get_ptr&lt;const typename BasicJsonType::array_t*&gt;();
<span class="lineNum">    1015 </span>            : }
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : // forward_list doesn't have an insert method
<span class="lineNum">    1018 </span>            : template&lt;typename BasicJsonType, typename T, typename Allocator,
<span class="lineNum">    1019 </span>            :          enable_if_t&lt;std::is_convertible&lt;BasicJsonType, T&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1020 </span>            : void from_json(const BasicJsonType&amp; j, std::forward_list&lt;T, Allocator&gt;&amp; l)
<span class="lineNum">    1021 </span>            : {
<span class="lineNum">    1022 </span>            :     if (JSON_UNLIKELY(not j.is_array()))
<span class="lineNum">    1023 </span>            :     {
<span class="lineNum">    1024 </span>            :         JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name())));
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span>            :     std::transform(j.rbegin(), j.rend(),
<span class="lineNum">    1027 </span>            :                    std::front_inserter(l), [](const BasicJsonType &amp; i)
<span class="lineNum">    1028 </span>            :     {
<span class="lineNum">    1029 </span>            :         return i.template get&lt;T&gt;();
<span class="lineNum">    1030 </span>            :     });
<span class="lineNum">    1031 </span>            : }
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            : // valarray doesn't have an insert method
<span class="lineNum">    1034 </span>            : template&lt;typename BasicJsonType, typename T,
<span class="lineNum">    1035 </span>            :          enable_if_t&lt;std::is_convertible&lt;BasicJsonType, T&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1036 </span>            : void from_json(const BasicJsonType&amp; j, std::valarray&lt;T&gt;&amp; l)
<span class="lineNum">    1037 </span>            : {
<span class="lineNum">    1038 </span>            :     if (JSON_UNLIKELY(not j.is_array()))
<span class="lineNum">    1039 </span>            :     {
<span class="lineNum">    1040 </span>            :         JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; + std::string(j.type_name())));
<span class="lineNum">    1041 </span>            :     }
<span class="lineNum">    1042 </span>            :     l.resize(j.size());
<span class="lineNum">    1043 </span>            :     std::copy(j.m_value.array-&gt;begin(), j.m_value.array-&gt;end(), std::begin(l));
<span class="lineNum">    1044 </span>            : }
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            : template&lt;typename BasicJsonType, typename CompatibleArrayType&gt;
<span class="lineNum">    1047 </span>            : void from_json_array_impl(const BasicJsonType&amp; j, CompatibleArrayType&amp; arr, priority_tag&lt;0&gt; /*unused*/)
<span class="lineNum">    1048 </span>            : {
<span class="lineNum">    1049 </span>            :     using std::end;
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            :     std::transform(j.begin(), j.end(),
<span class="lineNum">    1052 </span>            :                    std::inserter(arr, end(arr)), [](const BasicJsonType &amp; i)
<span class="lineNum">    1053 </span>            :     {
<span class="lineNum">    1054 </span>            :         // get&lt;BasicJsonType&gt;() returns *this, this won't call a from_json
<span class="lineNum">    1055 </span>            :         // method when value_type is BasicJsonType
<span class="lineNum">    1056 </span>            :         return i.template get&lt;typename CompatibleArrayType::value_type&gt;();
<span class="lineNum">    1057 </span>            :     });
<span class="lineNum">    1058 </span>            : }
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            : template&lt;typename BasicJsonType, typename CompatibleArrayType&gt;
<span class="lineNum">    1061 </span>            : auto from_json_array_impl(const BasicJsonType&amp; j, CompatibleArrayType&amp; arr, priority_tag&lt;1&gt; /*unused*/)
<span class="lineNum">    1062 </span>            : -&gt; decltype(
<span class="lineNum">    1063 </span>            :     arr.reserve(std::declval&lt;typename CompatibleArrayType::size_type&gt;()),
<span class="lineNum">    1064 </span>            :     void())
<span class="lineNum">    1065 </span>            : {
<span class="lineNum">    1066 </span>            :     using std::end;
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :     arr.reserve(j.size());
<span class="lineNum">    1069 </span>            :     std::transform(j.begin(), j.end(),
<span class="lineNum">    1070 </span>            :                    std::inserter(arr, end(arr)), [](const BasicJsonType &amp; i)
<span class="lineNum">    1071 </span>            :     {
<span class="lineNum">    1072 </span>            :         // get&lt;BasicJsonType&gt;() returns *this, this won't call a from_json
<span class="lineNum">    1073 </span>            :         // method when value_type is BasicJsonType
<span class="lineNum">    1074 </span>            :         return i.template get&lt;typename CompatibleArrayType::value_type&gt;();
<span class="lineNum">    1075 </span>            :     });
<span class="lineNum">    1076 </span>            : }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : template&lt;typename BasicJsonType, typename T, std::size_t N&gt;
<span class="lineNum">    1079 </span>            : void from_json_array_impl(const BasicJsonType&amp; j, std::array&lt;T, N&gt;&amp; arr, priority_tag&lt;2&gt; /*unused*/)
<span class="lineNum">    1080 </span>            : {
<span class="lineNum">    1081 </span>            :     for (std::size_t i = 0; i &lt; N; ++i)
<span class="lineNum">    1082 </span>            :     {
<span class="lineNum">    1083 </span>            :         arr[i] = j.at(i).template get&lt;T&gt;();
<span class="lineNum">    1084 </span>            :     }
<span class="lineNum">    1085 </span>            : }
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            : template &lt;
<span class="lineNum">    1088 </span>            :     typename BasicJsonType, typename CompatibleArrayType,
<span class="lineNum">    1089 </span>            :     enable_if_t &lt;
<span class="lineNum">    1090 </span>            :         is_compatible_array_type&lt;BasicJsonType, CompatibleArrayType&gt;::value and
<span class="lineNum">    1091 </span>            :         not std::is_same&lt;typename BasicJsonType::array_t,
<span class="lineNum">    1092 </span>            :                          CompatibleArrayType&gt;::value and
<span class="lineNum">    1093 </span>            :         std::is_constructible &lt;
<span class="lineNum">    1094 </span>            :             BasicJsonType, typename CompatibleArrayType::value_type &gt;::value,
<span class="lineNum">    1095 </span>            :         int &gt; = 0 &gt;
<span class="lineNum">    1096 </span>            : void from_json(const BasicJsonType&amp; j, CompatibleArrayType&amp; arr)
<span class="lineNum">    1097 </span>            : {
<span class="lineNum">    1098 </span>            :     if (JSON_UNLIKELY(not j.is_array()))
<span class="lineNum">    1099 </span>            :     {
<span class="lineNum">    1100 </span>            :         JSON_THROW(type_error::create(302, &quot;type must be array, but is &quot; +
<span class="lineNum">    1101 </span>            :                                       std::string(j.type_name())));
<span class="lineNum">    1102 </span>            :     }
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :     from_json_array_impl(j, arr, priority_tag&lt;2&gt; {});
<span class="lineNum">    1105 </span>            : }
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            : template&lt;typename BasicJsonType, typename CompatibleObjectType,
<span class="lineNum">    1108 </span>            :          enable_if_t&lt;is_compatible_object_type&lt;BasicJsonType, CompatibleObjectType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1109 </span>            : void from_json(const BasicJsonType&amp; j, CompatibleObjectType&amp; obj)
<span class="lineNum">    1110 </span>            : {
<span class="lineNum">    1111 </span>            :     if (JSON_UNLIKELY(not j.is_object()))
<span class="lineNum">    1112 </span>            :     {
<span class="lineNum">    1113 </span>            :         JSON_THROW(type_error::create(302, &quot;type must be object, but is &quot; + std::string(j.type_name())));
<span class="lineNum">    1114 </span>            :     }
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            :     auto inner_object = j.template get_ptr&lt;const typename BasicJsonType::object_t*&gt;();
<span class="lineNum">    1117 </span>            :     using value_type = typename CompatibleObjectType::value_type;
<span class="lineNum">    1118 </span>            :     std::transform(
<span class="lineNum">    1119 </span>            :         inner_object-&gt;begin(), inner_object-&gt;end(),
<span class="lineNum">    1120 </span>            :         std::inserter(obj, obj.begin()),
<span class="lineNum">    1121 </span>            :         [](typename BasicJsonType::object_t::value_type const &amp; p)
<span class="lineNum">    1122 </span>            :     {
<span class="lineNum">    1123 </span>            :         return value_type(p.first, p.second.template get&lt;typename CompatibleObjectType::mapped_type&gt;());
<span class="lineNum">    1124 </span>            :     });
<span class="lineNum">    1125 </span>            : }
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            : // overload for arithmetic types, not chosen for basic_json template arguments
<span class="lineNum">    1128 </span>            : // (BooleanType, etc..); note: Is it really necessary to provide explicit
<span class="lineNum">    1129 </span>            : // overloads for boolean_t etc. in case of a custom BooleanType which is not
<span class="lineNum">    1130 </span>            : // an arithmetic type?
<span class="lineNum">    1131 </span>            : template&lt;typename BasicJsonType, typename ArithmeticType,
<span class="lineNum">    1132 </span>            :          enable_if_t &lt;
<span class="lineNum">    1133 </span>            :              std::is_arithmetic&lt;ArithmeticType&gt;::value and
<span class="lineNum">    1134 </span>            :              not std::is_same&lt;ArithmeticType, typename BasicJsonType::number_unsigned_t&gt;::value and
<span class="lineNum">    1135 </span>            :              not std::is_same&lt;ArithmeticType, typename BasicJsonType::number_integer_t&gt;::value and
<span class="lineNum">    1136 </span>            :              not std::is_same&lt;ArithmeticType, typename BasicJsonType::number_float_t&gt;::value and
<a name="1137"><span class="lineNum">    1137 </span>            :              not std::is_same&lt;ArithmeticType, typename BasicJsonType::boolean_t&gt;::value,</a>
<span class="lineNum">    1138 </span>            :              int&gt; = 0&gt;
<span class="lineNum">    1139 </span><span class="lineCov">         46 : void from_json(const BasicJsonType&amp; j, ArithmeticType&amp; val)</span>
<span class="lineNum">    1140 </span>            : {
<span class="lineNum">    1141 </span><span class="lineCov">         46 :     switch (static_cast&lt;value_t&gt;(j))</span>
<span class="lineNum">    1142 </span>            :     {
<span class="lineNum">    1143 </span>            :         case value_t::number_unsigned:
<span class="lineNum">    1144 </span>            :         {
<span class="lineNum">    1145 </span><span class="lineCov">         44 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_unsigned_t*&gt;());</span>
<span class="lineNum">    1146 </span><span class="lineCov">         44 :             break;</span>
<span class="lineNum">    1147 </span>            :         }
<span class="lineNum">    1148 </span>            :         case value_t::number_integer:
<span class="lineNum">    1149 </span>            :         {
<span class="lineNum">    1150 </span><span class="lineCov">          2 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_integer_t*&gt;());</span>
<span class="lineNum">    1151 </span><span class="lineCov">          2 :             break;</span>
<span class="lineNum">    1152 </span>            :         }
<span class="lineNum">    1153 </span>            :         case value_t::number_float:
<span class="lineNum">    1154 </span>            :         {
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::number_float_t*&gt;());</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1157 </span>            :         }
<span class="lineNum">    1158 </span>            :         case value_t::boolean:
<span class="lineNum">    1159 </span>            :         {
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :             val = static_cast&lt;ArithmeticType&gt;(*j.template get_ptr&lt;const typename BasicJsonType::boolean_t*&gt;());</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1162 </span>            :         }
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :         default:
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             JSON_THROW(type_error::create(302, &quot;type must be number, but is &quot; + std::string(j.type_name())));</span>
<span class="lineNum">    1166 </span>            :     }
<span class="lineNum">    1167 </span><span class="lineCov">         46 : }</span>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            : template&lt;typename BasicJsonType, typename A1, typename A2&gt;
<span class="lineNum">    1170 </span>            : void from_json(const BasicJsonType&amp; j, std::pair&lt;A1, A2&gt;&amp; p)
<span class="lineNum">    1171 </span>            : {
<span class="lineNum">    1172 </span>            :     p = {j.at(0).template get&lt;A1&gt;(), j.at(1).template get&lt;A2&gt;()};
<span class="lineNum">    1173 </span>            : }
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span>            : template&lt;typename BasicJsonType, typename Tuple, std::size_t... Idx&gt;
<span class="lineNum">    1176 </span>            : void from_json_tuple_impl(const BasicJsonType&amp; j, Tuple&amp; t, index_sequence&lt;Idx...&gt;)
<span class="lineNum">    1177 </span>            : {
<span class="lineNum">    1178 </span>            :     t = std::make_tuple(j.at(Idx).template get&lt;typename std::tuple_element&lt;Idx, Tuple&gt;::type&gt;()...);
<span class="lineNum">    1179 </span>            : }
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            : template&lt;typename BasicJsonType, typename... Args&gt;
<span class="lineNum">    1182 </span>            : void from_json(const BasicJsonType&amp; j, std::tuple&lt;Args...&gt;&amp; t)
<span class="lineNum">    1183 </span>            : {
<span class="lineNum">    1184 </span>            :     from_json_tuple_impl(j, t, index_sequence_for&lt;Args...&gt; {});
<span class="lineNum">    1185 </span>            : }
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span>            : struct from_json_fn
<span class="lineNum">    1188 </span>            : {
<a name="1189"><span class="lineNum">    1189 </span>            :   private:</a>
<span class="lineNum">    1190 </span>            :     template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">    1191 </span><span class="lineCov">        169 :     auto call(const BasicJsonType&amp; j, T&amp; val, priority_tag&lt;1&gt; /*unused*/) const</span>
<span class="lineNum">    1192 </span>            :     noexcept(noexcept(from_json(j, val)))
<span class="lineNum">    1193 </span>            :     -&gt; decltype(from_json(j, val), void())
<span class="lineNum">    1194 </span>            :     {
<span class="lineNum">    1195 </span><span class="lineCov">        169 :         return from_json(j, val);</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :     template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">    1199 </span>            :     void call(const BasicJsonType&amp; /*unused*/, T&amp; /*unused*/, priority_tag&lt;0&gt; /*unused*/) const noexcept
<span class="lineNum">    1200 </span>            :     {
<span class="lineNum">    1201 </span>            :         static_assert(sizeof(BasicJsonType) == 0,
<span class="lineNum">    1202 </span>            :                       &quot;could not find from_json() method in T's namespace&quot;);
<span class="lineNum">    1203 </span>            : #ifdef _MSC_VER
<span class="lineNum">    1204 </span>            :         // MSVC does not show a stacktrace for the above assert
<span class="lineNum">    1205 </span>            :         using decayed = uncvref_t&lt;T&gt;;
<span class="lineNum">    1206 </span>            :         static_assert(sizeof(typename decayed::force_msvc_stacktrace) == 0,
<span class="lineNum">    1207 </span>            :                       &quot;forcing MSVC stacktrace to show which T we're talking about.&quot;);
<span class="lineNum">    1208 </span>            : #endif
<span class="lineNum">    1209 </span>            :     }
<span class="lineNum">    1210 </span>            : 
<a name="1211"><span class="lineNum">    1211 </span>            :   public:</a>
<span class="lineNum">    1212 </span>            :     template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">    1213 </span><span class="lineCov">        169 :     void operator()(const BasicJsonType&amp; j, T&amp; val) const</span>
<span class="lineNum">    1214 </span>            :     noexcept(noexcept(std::declval&lt;from_json_fn&gt;().call(j, val, priority_tag&lt;1&gt; {})))
<span class="lineNum">    1215 </span>            :     {
<span class="lineNum">    1216 </span><span class="lineCov">        169 :         return call(j, val, priority_tag&lt;1&gt; {});</span>
<span class="lineNum">    1217 </span>            :     }
<span class="lineNum">    1218 </span>            : };
<span class="lineNum">    1219 </span>            : }
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : /// namespace to hold default `from_json` function
<span class="lineNum">    1222 </span>            : /// to see why this is required:
<span class="lineNum">    1223 </span>            : /// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
<span class="lineNum">    1224 </span>            : namespace
<span class="lineNum">    1225 </span>            : {
<span class="lineNum">    1226 </span>            : constexpr const auto&amp; from_json = detail::static_const&lt;detail::from_json_fn&gt;::value;
<span class="lineNum">    1227 </span>            : }
<span class="lineNum">    1228 </span>            : }
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span>            : // #include &lt;nlohmann/detail/conversions/to_json.hpp&gt;
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            : #include &lt;ciso646&gt; // or, and, not
<span class="lineNum">    1234 </span>            : #include &lt;iterator&gt; // begin, end
<span class="lineNum">    1235 </span>            : #include &lt;tuple&gt; // tuple, get
<span class="lineNum">    1236 </span>            : #include &lt;type_traits&gt; // is_same, is_constructible, is_floating_point, is_enum, underlying_type
<span class="lineNum">    1237 </span>            : #include &lt;utility&gt; // move, forward, declval, pair
<span class="lineNum">    1238 </span>            : #include &lt;valarray&gt; // valarray
<span class="lineNum">    1239 </span>            : #include &lt;vector&gt; // vector
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : // #include &lt;nlohmann/detail/meta.hpp&gt;
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            : namespace rockets_nlohmann
<span class="lineNum">    1247 </span>            : {
<span class="lineNum">    1248 </span>            : namespace detail
<span class="lineNum">    1249 </span>            : {
<span class="lineNum">    1250 </span>            : //////////////////
<span class="lineNum">    1251 </span>            : // constructors //
<span class="lineNum">    1252 </span>            : //////////////////
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : template&lt;value_t&gt; struct external_constructor;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            : template&lt;&gt;
<span class="lineNum">    1257 </span>            : struct external_constructor&lt;value_t::boolean&gt;
<span class="lineNum">    1258 </span>            : {
<span class="lineNum">    1259 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1260 </span>            :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::boolean_t b) noexcept
<span class="lineNum">    1261 </span>            :     {
<span class="lineNum">    1262 </span>            :         j.m_type = value_t::boolean;
<span class="lineNum">    1263 </span>            :         j.m_value = b;
<span class="lineNum">    1264 </span>            :         j.assert_invariant();
<span class="lineNum">    1265 </span>            :     }
<span class="lineNum">    1266 </span>            : };
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            : template&lt;&gt;
<span class="lineNum">    1269 </span>            : struct external_constructor&lt;value_t::string&gt;
<a name="1270"><span class="lineNum">    1270 </span>            : {</a>
<span class="lineNum">    1271 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1272 </span><span class="lineCov">         39 :     static void construct(BasicJsonType&amp; j, const typename BasicJsonType::string_t&amp; s)</span>
<span class="lineNum">    1273 </span>            :     {
<span class="lineNum">    1274 </span><span class="lineCov">         39 :         j.m_type = value_t::string;</span>
<span class="lineNum">    1275 </span><span class="lineCov">         39 :         j.m_value = s;</span>
<span class="lineNum">    1276 </span><span class="lineCov">         39 :         j.assert_invariant();</span>
<span class="lineNum">    1277 </span><span class="lineCov">         39 :     }</span>
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<span class="lineNum">    1279 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1280 </span><span class="lineCov">        312 :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::string_t&amp;&amp; s)</span>
<span class="lineNum">    1281 </span>            :     {
<span class="lineNum">    1282 </span><span class="lineCov">        312 :         j.m_type = value_t::string;</span>
<span class="lineNum">    1283 </span><span class="lineCov">        312 :         j.m_value = std::move(s);</span>
<span class="lineNum">    1284 </span><span class="lineCov">        312 :         j.assert_invariant();</span>
<span class="lineNum">    1285 </span><span class="lineCov">        312 :     }</span>
<span class="lineNum">    1286 </span>            : };
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            : template&lt;&gt;
<span class="lineNum">    1289 </span>            : struct external_constructor&lt;value_t::number_float&gt;
<a name="1290"><span class="lineNum">    1290 </span>            : {</a>
<span class="lineNum">    1291 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1292 </span><span class="lineCov">          1 :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_float_t val) noexcept</span>
<span class="lineNum">    1293 </span>            :     {
<span class="lineNum">    1294 </span><span class="lineCov">          1 :         j.m_type = value_t::number_float;</span>
<span class="lineNum">    1295 </span><span class="lineCov">          1 :         j.m_value = val;</span>
<span class="lineNum">    1296 </span><span class="lineCov">          1 :         j.assert_invariant();</span>
<span class="lineNum">    1297 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    1298 </span>            : };
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            : template&lt;&gt;
<span class="lineNum">    1301 </span>            : struct external_constructor&lt;value_t::number_unsigned&gt;
<a name="1302"><span class="lineNum">    1302 </span>            : {</a>
<span class="lineNum">    1303 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1304 </span><span class="lineCov">         11 :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_unsigned_t val) noexcept</span>
<span class="lineNum">    1305 </span>            :     {
<span class="lineNum">    1306 </span><span class="lineCov">         11 :         j.m_type = value_t::number_unsigned;</span>
<span class="lineNum">    1307 </span><span class="lineCov">         11 :         j.m_value = val;</span>
<span class="lineNum">    1308 </span><span class="lineCov">         11 :         j.assert_invariant();</span>
<span class="lineNum">    1309 </span><span class="lineCov">         11 :     }</span>
<span class="lineNum">    1310 </span>            : };
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span>            : template&lt;&gt;
<span class="lineNum">    1313 </span>            : struct external_constructor&lt;value_t::number_integer&gt;
<a name="1314"><span class="lineNum">    1314 </span>            : {</a>
<span class="lineNum">    1315 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1316 </span><span class="lineCov">         23 :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::number_integer_t val) noexcept</span>
<span class="lineNum">    1317 </span>            :     {
<span class="lineNum">    1318 </span><span class="lineCov">         23 :         j.m_type = value_t::number_integer;</span>
<span class="lineNum">    1319 </span><span class="lineCov">         23 :         j.m_value = val;</span>
<span class="lineNum">    1320 </span><span class="lineCov">         23 :         j.assert_invariant();</span>
<span class="lineNum">    1321 </span><span class="lineCov">         23 :     }</span>
<span class="lineNum">    1322 </span>            : };
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            : template&lt;&gt;
<span class="lineNum">    1325 </span>            : struct external_constructor&lt;value_t::array&gt;
<span class="lineNum">    1326 </span>            : {
<span class="lineNum">    1327 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1328 </span>            :     static void construct(BasicJsonType&amp; j, const typename BasicJsonType::array_t&amp; arr)
<span class="lineNum">    1329 </span>            :     {
<span class="lineNum">    1330 </span>            :         j.m_type = value_t::array;
<span class="lineNum">    1331 </span>            :         j.m_value = arr;
<span class="lineNum">    1332 </span>            :         j.assert_invariant();
<span class="lineNum">    1333 </span>            :     }
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1336 </span>            :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::array_t&amp;&amp; arr)
<span class="lineNum">    1337 </span>            :     {
<span class="lineNum">    1338 </span>            :         j.m_type = value_t::array;
<span class="lineNum">    1339 </span>            :         j.m_value = std::move(arr);
<span class="lineNum">    1340 </span>            :         j.assert_invariant();
<span class="lineNum">    1341 </span>            :     }
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            :     template&lt;typename BasicJsonType, typename CompatibleArrayType,
<span class="lineNum">    1344 </span>            :              enable_if_t&lt;not std::is_same&lt;CompatibleArrayType, typename BasicJsonType::array_t&gt;::value,
<span class="lineNum">    1345 </span>            :                          int&gt; = 0&gt;
<span class="lineNum">    1346 </span>            :     static void construct(BasicJsonType&amp; j, const CompatibleArrayType&amp; arr)
<span class="lineNum">    1347 </span>            :     {
<span class="lineNum">    1348 </span>            :         using std::begin;
<span class="lineNum">    1349 </span>            :         using std::end;
<span class="lineNum">    1350 </span>            :         j.m_type = value_t::array;
<span class="lineNum">    1351 </span>            :         j.m_value.array = j.template create&lt;typename BasicJsonType::array_t&gt;(begin(arr), end(arr));
<span class="lineNum">    1352 </span>            :         j.assert_invariant();
<span class="lineNum">    1353 </span>            :     }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1356 </span>            :     static void construct(BasicJsonType&amp; j, const std::vector&lt;bool&gt;&amp; arr)
<span class="lineNum">    1357 </span>            :     {
<span class="lineNum">    1358 </span>            :         j.m_type = value_t::array;
<span class="lineNum">    1359 </span>            :         j.m_value = value_t::array;
<span class="lineNum">    1360 </span>            :         j.m_value.array-&gt;reserve(arr.size());
<span class="lineNum">    1361 </span>            :         for (const bool x : arr)
<span class="lineNum">    1362 </span>            :         {
<span class="lineNum">    1363 </span>            :             j.m_value.array-&gt;push_back(x);
<span class="lineNum">    1364 </span>            :         }
<span class="lineNum">    1365 </span>            :         j.assert_invariant();
<span class="lineNum">    1366 </span>            :     }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :     template&lt;typename BasicJsonType, typename T,
<span class="lineNum">    1369 </span>            :              enable_if_t&lt;std::is_convertible&lt;T, BasicJsonType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1370 </span>            :     static void construct(BasicJsonType&amp; j, const std::valarray&lt;T&gt;&amp; arr)
<span class="lineNum">    1371 </span>            :     {
<span class="lineNum">    1372 </span>            :         j.m_type = value_t::array;
<span class="lineNum">    1373 </span>            :         j.m_value = value_t::array;
<span class="lineNum">    1374 </span>            :         j.m_value.array-&gt;resize(arr.size());
<span class="lineNum">    1375 </span>            :         std::copy(std::begin(arr), std::end(arr), j.m_value.array-&gt;begin());
<span class="lineNum">    1376 </span>            :         j.assert_invariant();
<span class="lineNum">    1377 </span>            :     }
<span class="lineNum">    1378 </span>            : };
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : template&lt;&gt;
<span class="lineNum">    1381 </span>            : struct external_constructor&lt;value_t::object&gt;
<span class="lineNum">    1382 </span>            : {
<span class="lineNum">    1383 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1384 </span>            :     static void construct(BasicJsonType&amp; j, const typename BasicJsonType::object_t&amp; obj)
<span class="lineNum">    1385 </span>            :     {
<span class="lineNum">    1386 </span>            :         j.m_type = value_t::object;
<span class="lineNum">    1387 </span>            :         j.m_value = obj;
<span class="lineNum">    1388 </span>            :         j.assert_invariant();
<span class="lineNum">    1389 </span>            :     }
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1392 </span>            :     static void construct(BasicJsonType&amp; j, typename BasicJsonType::object_t&amp;&amp; obj)
<span class="lineNum">    1393 </span>            :     {
<span class="lineNum">    1394 </span>            :         j.m_type = value_t::object;
<span class="lineNum">    1395 </span>            :         j.m_value = std::move(obj);
<span class="lineNum">    1396 </span>            :         j.assert_invariant();
<span class="lineNum">    1397 </span>            :     }
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span>            :     template&lt;typename BasicJsonType, typename CompatibleObjectType,
<span class="lineNum">    1400 </span>            :              enable_if_t&lt;not std::is_same&lt;CompatibleObjectType, typename BasicJsonType::object_t&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1401 </span>            :     static void construct(BasicJsonType&amp; j, const CompatibleObjectType&amp; obj)
<span class="lineNum">    1402 </span>            :     {
<span class="lineNum">    1403 </span>            :         using std::begin;
<span class="lineNum">    1404 </span>            :         using std::end;
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :         j.m_type = value_t::object;
<span class="lineNum">    1407 </span>            :         j.m_value.object = j.template create&lt;typename BasicJsonType::object_t&gt;(begin(obj), end(obj));
<span class="lineNum">    1408 </span>            :         j.assert_invariant();
<span class="lineNum">    1409 </span>            :     }
<span class="lineNum">    1410 </span>            : };
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span>            : /////////////
<span class="lineNum">    1413 </span>            : // to_json //
<span class="lineNum">    1414 </span>            : /////////////
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span>            : template&lt;typename BasicJsonType, typename T,
<span class="lineNum">    1417 </span>            :          enable_if_t&lt;std::is_same&lt;T, typename BasicJsonType::boolean_t&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1418 </span>            : void to_json(BasicJsonType&amp; j, T b) noexcept
<span class="lineNum">    1419 </span>            : {
<span class="lineNum">    1420 </span>            :     external_constructor&lt;value_t::boolean&gt;::construct(j, b);
<span class="lineNum">    1421 </span>            : }
<span class="lineNum">    1422 </span>            : 
<a name="1423"><span class="lineNum">    1423 </span>            : template&lt;typename BasicJsonType, typename CompatibleString,</a>
<span class="lineNum">    1424 </span>            :          enable_if_t&lt;std::is_constructible&lt;typename BasicJsonType::string_t, CompatibleString&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1425 </span><span class="lineCov">        321 : void to_json(BasicJsonType&amp; j, const CompatibleString&amp; s)</span>
<span class="lineNum">    1426 </span>            : {
<span class="lineNum">    1427 </span><span class="lineCov">        321 :     external_constructor&lt;value_t::string&gt;::construct(j, s);</span>
<span class="lineNum">    1428 </span><span class="lineCov">        321 : }</span>
<a name="1429"><span class="lineNum">    1429 </span>            : </a>
<span class="lineNum">    1430 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1431 </span><span class="lineCov">         30 : void to_json(BasicJsonType&amp; j, typename BasicJsonType::string_t&amp;&amp; s)</span>
<span class="lineNum">    1432 </span>            : {
<span class="lineNum">    1433 </span><span class="lineCov">         30 :     external_constructor&lt;value_t::string&gt;::construct(j, std::move(s));</span>
<span class="lineNum">    1434 </span><span class="lineCov">         30 : }</span>
<span class="lineNum">    1435 </span>            : 
<a name="1436"><span class="lineNum">    1436 </span>            : template&lt;typename BasicJsonType, typename FloatType,</a>
<span class="lineNum">    1437 </span>            :          enable_if_t&lt;std::is_floating_point&lt;FloatType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1438 </span><span class="lineCov">          1 : void to_json(BasicJsonType&amp; j, FloatType val) noexcept</span>
<span class="lineNum">    1439 </span>            : {
<span class="lineNum">    1440 </span><span class="lineCov">          1 :     external_constructor&lt;value_t::number_float&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_float_t&gt;(val));</span>
<span class="lineNum">    1441 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1442 </span>            : 
<a name="1443"><span class="lineNum">    1443 </span>            : template&lt;typename BasicJsonType, typename CompatibleNumberUnsignedType,</a>
<span class="lineNum">    1444 </span>            :          enable_if_t&lt;is_compatible_integer_type&lt;typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1445 </span><span class="lineCov">         11 : void to_json(BasicJsonType&amp; j, CompatibleNumberUnsignedType val) noexcept</span>
<span class="lineNum">    1446 </span>            : {
<span class="lineNum">    1447 </span><span class="lineCov">         11 :     external_constructor&lt;value_t::number_unsigned&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_unsigned_t&gt;(val));</span>
<span class="lineNum">    1448 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">    1449 </span>            : 
<a name="1450"><span class="lineNum">    1450 </span>            : template&lt;typename BasicJsonType, typename CompatibleNumberIntegerType,</a>
<span class="lineNum">    1451 </span>            :          enable_if_t&lt;is_compatible_integer_type&lt;typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1452 </span><span class="lineCov">         22 : void to_json(BasicJsonType&amp; j, CompatibleNumberIntegerType val) noexcept</span>
<span class="lineNum">    1453 </span>            : {
<span class="lineNum">    1454 </span><span class="lineCov">         22 :     external_constructor&lt;value_t::number_integer&gt;::construct(j, static_cast&lt;typename BasicJsonType::number_integer_t&gt;(val));</span>
<span class="lineNum">    1455 </span><span class="lineCov">         22 : }</span>
<span class="lineNum">    1456 </span>            : 
<a name="1457"><span class="lineNum">    1457 </span>            : template&lt;typename BasicJsonType, typename EnumType,</a>
<span class="lineNum">    1458 </span>            :          enable_if_t&lt;std::is_enum&lt;EnumType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1459 </span><span class="lineCov">          1 : void to_json(BasicJsonType&amp; j, EnumType e) noexcept</span>
<span class="lineNum">    1460 </span>            : {
<span class="lineNum">    1461 </span>            :     using underlying_type = typename std::underlying_type&lt;EnumType&gt;::type;
<span class="lineNum">    1462 </span><span class="lineCov">          1 :     external_constructor&lt;value_t::number_integer&gt;::construct(j, static_cast&lt;underlying_type&gt;(e));</span>
<span class="lineNum">    1463 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1466 </span>            : void to_json(BasicJsonType&amp; j, const std::vector&lt;bool&gt;&amp; e)
<span class="lineNum">    1467 </span>            : {
<span class="lineNum">    1468 </span>            :     external_constructor&lt;value_t::array&gt;::construct(j, e);
<span class="lineNum">    1469 </span>            : }
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            : template&lt;typename BasicJsonType, typename CompatibleArrayType,
<span class="lineNum">    1472 </span>            :          enable_if_t&lt;is_compatible_array_type&lt;BasicJsonType, CompatibleArrayType&gt;::value or
<span class="lineNum">    1473 </span>            :                      std::is_same&lt;typename BasicJsonType::array_t, CompatibleArrayType&gt;::value,
<span class="lineNum">    1474 </span>            :                      int&gt; = 0&gt;
<span class="lineNum">    1475 </span>            : void to_json(BasicJsonType&amp; j, const CompatibleArrayType&amp; arr)
<span class="lineNum">    1476 </span>            : {
<span class="lineNum">    1477 </span>            :     external_constructor&lt;value_t::array&gt;::construct(j, arr);
<span class="lineNum">    1478 </span>            : }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            : template&lt;typename BasicJsonType, typename T,
<span class="lineNum">    1481 </span>            :          enable_if_t&lt;std::is_convertible&lt;T, BasicJsonType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1482 </span>            : void to_json(BasicJsonType&amp; j, std::valarray&lt;T&gt; arr)
<span class="lineNum">    1483 </span>            : {
<span class="lineNum">    1484 </span>            :     external_constructor&lt;value_t::array&gt;::construct(j, std::move(arr));
<span class="lineNum">    1485 </span>            : }
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1488 </span>            : void to_json(BasicJsonType&amp; j, typename BasicJsonType::array_t&amp;&amp; arr)
<span class="lineNum">    1489 </span>            : {
<span class="lineNum">    1490 </span>            :     external_constructor&lt;value_t::array&gt;::construct(j, std::move(arr));
<span class="lineNum">    1491 </span>            : }
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            : template&lt;typename BasicJsonType, typename CompatibleObjectType,
<span class="lineNum">    1494 </span>            :          enable_if_t&lt;is_compatible_object_type&lt;BasicJsonType, CompatibleObjectType&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1495 </span>            : void to_json(BasicJsonType&amp; j, const CompatibleObjectType&amp; obj)
<span class="lineNum">    1496 </span>            : {
<span class="lineNum">    1497 </span>            :     external_constructor&lt;value_t::object&gt;::construct(j, obj);
<span class="lineNum">    1498 </span>            : }
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1501 </span>            : void to_json(BasicJsonType&amp; j, typename BasicJsonType::object_t&amp;&amp; obj)
<span class="lineNum">    1502 </span>            : {
<span class="lineNum">    1503 </span>            :     external_constructor&lt;value_t::object&gt;::construct(j, std::move(obj));
<span class="lineNum">    1504 </span>            : }
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span>            : template&lt;typename BasicJsonType, typename T, std::size_t N,
<span class="lineNum">    1507 </span>            :          enable_if_t&lt;not std::is_constructible&lt;typename BasicJsonType::string_t, T (&amp;)[N]&gt;::value, int&gt; = 0&gt;
<span class="lineNum">    1508 </span>            : void to_json(BasicJsonType&amp; j, T (&amp;arr)[N])
<span class="lineNum">    1509 </span>            : {
<span class="lineNum">    1510 </span>            :     external_constructor&lt;value_t::array&gt;::construct(j, arr);
<span class="lineNum">    1511 </span>            : }
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : template&lt;typename BasicJsonType, typename... Args&gt;
<span class="lineNum">    1514 </span>            : void to_json(BasicJsonType&amp; j, const std::pair&lt;Args...&gt;&amp; p)
<span class="lineNum">    1515 </span>            : {
<span class="lineNum">    1516 </span>            :     j = {p.first, p.second};
<span class="lineNum">    1517 </span>            : }
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            : template&lt;typename BasicJsonType, typename Tuple, std::size_t... Idx&gt;
<span class="lineNum">    1520 </span>            : void to_json_tuple_impl(BasicJsonType&amp; j, const Tuple&amp; t, index_sequence&lt;Idx...&gt;)
<span class="lineNum">    1521 </span>            : {
<span class="lineNum">    1522 </span>            :     j = {std::get&lt;Idx&gt;(t)...};
<span class="lineNum">    1523 </span>            : }
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            : template&lt;typename BasicJsonType, typename... Args&gt;
<span class="lineNum">    1526 </span>            : void to_json(BasicJsonType&amp; j, const std::tuple&lt;Args...&gt;&amp; t)
<span class="lineNum">    1527 </span>            : {
<span class="lineNum">    1528 </span>            :     to_json_tuple_impl(j, t, index_sequence_for&lt;Args...&gt; {});
<span class="lineNum">    1529 </span>            : }
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            : struct to_json_fn
<span class="lineNum">    1532 </span>            : {
<a name="1533"><span class="lineNum">    1533 </span>            :   private:</a>
<span class="lineNum">    1534 </span>            :     template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">    1535 </span><span class="lineCov">        386 :     auto call(BasicJsonType&amp; j, T&amp;&amp; val, priority_tag&lt;1&gt; /*unused*/) const noexcept(noexcept(to_json(j, std::forward&lt;T&gt;(val))))</span>
<span class="lineNum">    1536 </span>            :     -&gt; decltype(to_json(j, std::forward&lt;T&gt;(val)), void())
<span class="lineNum">    1537 </span>            :     {
<span class="lineNum">    1538 </span><span class="lineCov">        386 :         return to_json(j, std::forward&lt;T&gt;(val));</span>
<span class="lineNum">    1539 </span>            :     }
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            :     template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">    1542 </span>            :     void call(BasicJsonType&amp; /*unused*/, T&amp;&amp; /*unused*/, priority_tag&lt;0&gt; /*unused*/) const noexcept
<span class="lineNum">    1543 </span>            :     {
<span class="lineNum">    1544 </span>            :         static_assert(sizeof(BasicJsonType) == 0,
<span class="lineNum">    1545 </span>            :                       &quot;could not find to_json() method in T's namespace&quot;);
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : #ifdef _MSC_VER
<span class="lineNum">    1548 </span>            :         // MSVC does not show a stacktrace for the above assert
<span class="lineNum">    1549 </span>            :         using decayed = uncvref_t&lt;T&gt;;
<span class="lineNum">    1550 </span>            :         static_assert(sizeof(typename decayed::force_msvc_stacktrace) == 0,
<span class="lineNum">    1551 </span>            :                       &quot;forcing MSVC stacktrace to show which T we're talking about.&quot;);
<span class="lineNum">    1552 </span>            : #endif
<span class="lineNum">    1553 </span>            :     }
<span class="lineNum">    1554 </span>            : 
<a name="1555"><span class="lineNum">    1555 </span>            :   public:</a>
<span class="lineNum">    1556 </span>            :     template&lt;typename BasicJsonType, typename T&gt;
<span class="lineNum">    1557 </span><span class="lineCov">        386 :     void operator()(BasicJsonType&amp; j, T&amp;&amp; val) const</span>
<span class="lineNum">    1558 </span>            :     noexcept(noexcept(std::declval&lt;to_json_fn&gt;().call(j, std::forward&lt;T&gt;(val), priority_tag&lt;1&gt; {})))
<span class="lineNum">    1559 </span>            :     {
<span class="lineNum">    1560 </span><span class="lineCov">        386 :         return call(j, std::forward&lt;T&gt;(val), priority_tag&lt;1&gt; {});</span>
<span class="lineNum">    1561 </span>            :     }
<span class="lineNum">    1562 </span>            : };
<span class="lineNum">    1563 </span>            : }
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span>            : /// namespace to hold default `to_json` function
<span class="lineNum">    1566 </span>            : namespace
<span class="lineNum">    1567 </span>            : {
<span class="lineNum">    1568 </span>            : constexpr const auto&amp; to_json = detail::static_const&lt;detail::to_json_fn&gt;::value;
<span class="lineNum">    1569 </span>            : }
<span class="lineNum">    1570 </span>            : }
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            : // #include &lt;nlohmann/detail/input/input_adapters.hpp&gt;
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            : #include &lt;algorithm&gt; // min
<span class="lineNum">    1576 </span>            : #include &lt;array&gt; // array
<span class="lineNum">    1577 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">    1578 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">    1579 </span>            : #include &lt;cstring&gt; // strlen
<span class="lineNum">    1580 </span>            : #include &lt;ios&gt; // streamsize, streamoff, streampos
<span class="lineNum">    1581 </span>            : #include &lt;istream&gt; // istream
<span class="lineNum">    1582 </span>            : #include &lt;iterator&gt; // begin, end, iterator_traits, random_access_iterator_tag, distance, next
<span class="lineNum">    1583 </span>            : #include &lt;memory&gt; // shared_ptr, make_shared, addressof
<span class="lineNum">    1584 </span>            : #include &lt;numeric&gt; // accumulate
<span class="lineNum">    1585 </span>            : #include &lt;string&gt; // string, char_traits
<span class="lineNum">    1586 </span>            : #include &lt;type_traits&gt; // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
<span class="lineNum">    1587 </span>            : #include &lt;utility&gt; // pair, declval
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span>            : namespace rockets_nlohmann
<span class="lineNum">    1593 </span>            : {
<span class="lineNum">    1594 </span>            : namespace detail
<span class="lineNum">    1595 </span>            : {
<span class="lineNum">    1596 </span>            : ////////////////////
<span class="lineNum">    1597 </span>            : // input adapters //
<span class="lineNum">    1598 </span>            : ////////////////////
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            : /*!
<span class="lineNum">    1601 </span>            : @brief abstract input adapter interface
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            : Produces a stream of std::char_traits&lt;char&gt;::int_type characters from a
<span class="lineNum">    1604 </span>            : std::istream, a buffer, or some other input type.  Accepts the return of exactly
<span class="lineNum">    1605 </span>            : one non-EOF character for future input.  The int_type characters returned
<span class="lineNum">    1606 </span>            : consist of all valid char values as positive values (typically unsigned char),
<span class="lineNum">    1607 </span>            : plus an EOF value outside that range, specified by the value of the function
<span class="lineNum">    1608 </span>            : std::char_traits&lt;char&gt;::eof().  This value is typically -1, but could be any
<a name="1609"><span class="lineNum">    1609 </span>            : arbitrary value which is not a valid char value.</a>
<span class="lineNum">    1610 </span>            : */
<span class="lineNum">    1611 </span><span class="lineCov">        145 : struct input_adapter_protocol</span>
<span class="lineNum">    1612 </span>            : {
<span class="lineNum">    1613 </span>            :     /// get a character [0,255] or std::char_traits&lt;char&gt;::eof().
<span class="lineNum">    1614 </span>            :     virtual std::char_traits&lt;char&gt;::int_type get_character() = 0;
<a name="1615"><span class="lineNum">    1615 </span>            :     /// restore the last non-eof() character to input</a>
<span class="lineNum">    1616 </span>            :     virtual void unget_character() = 0;
<span class="lineNum">    1617 </span><span class="lineCov">        145 :     virtual ~input_adapter_protocol() = default;</span>
<span class="lineNum">    1618 </span>            : };
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            : /// a type to simplify interfaces
<span class="lineNum">    1621 </span>            : using input_adapter_t = std::shared_ptr&lt;input_adapter_protocol&gt;;
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span>            : /*!
<span class="lineNum">    1624 </span>            : Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
<span class="lineNum">    1625 </span>            : beginning of input. Does not support changing the underlying std::streambuf
<span class="lineNum">    1626 </span>            : in mid-input. Maintains underlying std::istream and std::streambuf to support
<span class="lineNum">    1627 </span>            : subsequent use of standard std::istream operations to process any input
<span class="lineNum">    1628 </span>            : characters following those used in parsing the JSON input.  Clears the
<span class="lineNum">    1629 </span>            : std::istream flags; any input errors (e.g., EOF) will be detected by the first
<span class="lineNum">    1630 </span>            : subsequent call for input from the std::istream.
<span class="lineNum">    1631 </span>            : */
<span class="lineNum">    1632 </span>            : class input_stream_adapter : public input_adapter_protocol
<span class="lineNum">    1633 </span>            : {
<span class="lineNum">    1634 </span>            :   public:
<span class="lineNum">    1635 </span>            :     ~input_stream_adapter() override
<span class="lineNum">    1636 </span>            :     {
<span class="lineNum">    1637 </span>            :         // clear stream flags; we use underlying streambuf I/O, do not
<span class="lineNum">    1638 </span>            :         // maintain ifstream flags
<span class="lineNum">    1639 </span>            :         is.clear();
<span class="lineNum">    1640 </span>            :     }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span>            :     explicit input_stream_adapter(std::istream&amp; i)
<span class="lineNum">    1643 </span>            :         : is(i), sb(*i.rdbuf())
<span class="lineNum">    1644 </span>            :     {
<span class="lineNum">    1645 </span>            :         // skip byte order mark
<span class="lineNum">    1646 </span>            :         std::char_traits&lt;char&gt;::int_type c;
<span class="lineNum">    1647 </span>            :         if ((c = get_character()) == 0xEF)
<span class="lineNum">    1648 </span>            :         {
<span class="lineNum">    1649 </span>            :             if ((c = get_character()) == 0xBB)
<span class="lineNum">    1650 </span>            :             {
<span class="lineNum">    1651 </span>            :                 if ((c = get_character()) == 0xBF)
<span class="lineNum">    1652 </span>            :                 {
<span class="lineNum">    1653 </span>            :                     return; // Ignore BOM
<span class="lineNum">    1654 </span>            :                 }
<span class="lineNum">    1655 </span>            :                 else if (c != std::char_traits&lt;char&gt;::eof())
<span class="lineNum">    1656 </span>            :                 {
<span class="lineNum">    1657 </span>            :                     is.unget();
<span class="lineNum">    1658 </span>            :                 }
<span class="lineNum">    1659 </span>            :                 is.putback('\xBB');
<span class="lineNum">    1660 </span>            :             }
<span class="lineNum">    1661 </span>            :             else if (c != std::char_traits&lt;char&gt;::eof())
<span class="lineNum">    1662 </span>            :             {
<span class="lineNum">    1663 </span>            :                 is.unget();
<span class="lineNum">    1664 </span>            :             }
<span class="lineNum">    1665 </span>            :             is.putback('\xEF');
<span class="lineNum">    1666 </span>            :         }
<span class="lineNum">    1667 </span>            :         else if (c != std::char_traits&lt;char&gt;::eof())
<span class="lineNum">    1668 </span>            :         {
<span class="lineNum">    1669 </span>            :             is.unget(); // no byte order mark; process as usual
<span class="lineNum">    1670 </span>            :         }
<span class="lineNum">    1671 </span>            :     }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :     // delete because of pointer members
<span class="lineNum">    1674 </span>            :     input_stream_adapter(const input_stream_adapter&amp;) = delete;
<span class="lineNum">    1675 </span>            :     input_stream_adapter&amp; operator=(input_stream_adapter&amp;) = delete;
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            :     // std::istream/std::streambuf use std::char_traits&lt;char&gt;::to_int_type, to
<span class="lineNum">    1678 </span>            :     // ensure that std::char_traits&lt;char&gt;::eof() and the character 0xFF do not
<span class="lineNum">    1679 </span>            :     // end up as the same value, eg. 0xFFFFFFFF.
<span class="lineNum">    1680 </span>            :     std::char_traits&lt;char&gt;::int_type get_character() override
<span class="lineNum">    1681 </span>            :     {
<span class="lineNum">    1682 </span>            :         return sb.sbumpc();
<span class="lineNum">    1683 </span>            :     }
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            :     void unget_character() override
<span class="lineNum">    1686 </span>            :     {
<span class="lineNum">    1687 </span>            :         sb.sungetc();  // is.unget() avoided for performance
<span class="lineNum">    1688 </span>            :     }
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            :   private:
<span class="lineNum">    1691 </span>            :     /// the associated input stream
<span class="lineNum">    1692 </span>            :     std::istream&amp; is;
<span class="lineNum">    1693 </span>            :     std::streambuf&amp; sb;
<span class="lineNum">    1694 </span>            : };
<a name="1695"><span class="lineNum">    1695 </span>            : </a>
<span class="lineNum">    1696 </span>            : /// input adapter for buffer input
<span class="lineNum">    1697 </span><span class="lineCov">        145 : class input_buffer_adapter : public input_adapter_protocol</span>
<a name="1698"><span class="lineNum">    1698 </span>            : {</a>
<span class="lineNum">    1699 </span>            :   public:
<span class="lineNum">    1700 </span><span class="lineCov">        145 :     input_buffer_adapter(const char* b, const std::size_t l)</span>
<span class="lineNum">    1701 </span><span class="lineCov">        145 :         : cursor(b), limit(b + l), start(b)</span>
<span class="lineNum">    1702 </span>            :     {
<span class="lineNum">    1703 </span>            :         // skip byte order mark
<span class="lineNum">    1704 </span><span class="lineCov">        145 :         if (l &gt;= 3 and b[0] == '\xEF' and b[1] == '\xBB' and b[2] == '\xBF')</span>
<span class="lineNum">    1705 </span>            :         {
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :             cursor += 3;</span>
<span class="lineNum">    1707 </span>            :         }
<span class="lineNum">    1708 </span><span class="lineCov">        145 :     }</span>
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :     // delete because of pointer members
<span class="lineNum">    1711 </span>            :     input_buffer_adapter(const input_buffer_adapter&amp;) = delete;
<a name="1712"><span class="lineNum">    1712 </span>            :     input_buffer_adapter&amp; operator=(input_buffer_adapter&amp;) = delete;</a>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineCov">       7155 :     std::char_traits&lt;char&gt;::int_type get_character() noexcept override</span>
<span class="lineNum">    1715 </span>            :     {
<span class="lineNum">    1716 </span><span class="lineCov">       7155 :         if (JSON_LIKELY(cursor &lt; limit))</span>
<span class="lineNum">    1717 </span>            :         {
<span class="lineNum">    1718 </span><span class="lineCov">       7005 :             return std::char_traits&lt;char&gt;::to_int_type(*(cursor++));</span>
<span class="lineNum">    1719 </span>            :         }
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span><span class="lineCov">        150 :         return std::char_traits&lt;char&gt;::eof();</span>
<a name="1722"><span class="lineNum">    1722 </span>            :     }</a>
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineCov">        210 :     void unget_character() noexcept override</span>
<span class="lineNum">    1725 </span>            :     {
<span class="lineNum">    1726 </span><span class="lineCov">        210 :         if (JSON_LIKELY(cursor &gt; start))</span>
<span class="lineNum">    1727 </span>            :         {
<span class="lineNum">    1728 </span><span class="lineCov">        210 :             --cursor;</span>
<span class="lineNum">    1729 </span>            :         }
<span class="lineNum">    1730 </span><span class="lineCov">        210 :     }</span>
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :   private:
<span class="lineNum">    1733 </span>            :     /// pointer to the current character
<span class="lineNum">    1734 </span>            :     const char* cursor;
<span class="lineNum">    1735 </span>            :     /// pointer past the last character
<span class="lineNum">    1736 </span>            :     const char* limit;
<span class="lineNum">    1737 </span>            :     /// pointer to the first character
<span class="lineNum">    1738 </span>            :     const char* start;
<a name="1739"><span class="lineNum">    1739 </span>            : };</a>
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span><span class="lineCov">        145 : class input_adapter</span>
<span class="lineNum">    1742 </span>            : {
<span class="lineNum">    1743 </span>            :   public:
<span class="lineNum">    1744 </span>            :     // native support
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :     /// input adapter for input stream
<span class="lineNum">    1747 </span>            :     input_adapter(std::istream&amp; i)
<span class="lineNum">    1748 </span>            :         : ia(std::make_shared&lt;input_stream_adapter&gt;(i)) {}
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            :     /// input adapter for input stream
<span class="lineNum">    1751 </span>            :     input_adapter(std::istream&amp;&amp; i)
<span class="lineNum">    1752 </span>            :         : ia(std::make_shared&lt;input_stream_adapter&gt;(i)) {}
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            :     /// input adapter for buffer
<span class="lineNum">    1755 </span>            :     template&lt;typename CharT,
<span class="lineNum">    1756 </span>            :              typename std::enable_if&lt;
<span class="lineNum">    1757 </span>            :                  std::is_pointer&lt;CharT&gt;::value and
<span class="lineNum">    1758 </span>            :                  std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value and
<span class="lineNum">    1759 </span>            :                  sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
<span class="lineNum">    1760 </span>            :                  int&gt;::type = 0&gt;
<span class="lineNum">    1761 </span>            :     input_adapter(CharT b, std::size_t l)
<span class="lineNum">    1762 </span>            :         : ia(std::make_shared&lt;input_buffer_adapter&gt;(reinterpret_cast&lt;const char*&gt;(b), l)) {}
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span>            :     // derived support
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :     /// input adapter for string literal
<span class="lineNum">    1767 </span>            :     template&lt;typename CharT,
<span class="lineNum">    1768 </span>            :              typename std::enable_if&lt;
<span class="lineNum">    1769 </span>            :                  std::is_pointer&lt;CharT&gt;::value and
<span class="lineNum">    1770 </span>            :                  std::is_integral&lt;typename std::remove_pointer&lt;CharT&gt;::type&gt;::value and
<span class="lineNum">    1771 </span>            :                  sizeof(typename std::remove_pointer&lt;CharT&gt;::type) == 1,
<span class="lineNum">    1772 </span>            :                  int&gt;::type = 0&gt;
<span class="lineNum">    1773 </span>            :     input_adapter(CharT b)
<span class="lineNum">    1774 </span>            :         : input_adapter(reinterpret_cast&lt;const char*&gt;(b),
<span class="lineNum">    1775 </span>            :                         std::strlen(reinterpret_cast&lt;const char*&gt;(b))) {}
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span>            :     /// input adapter for iterator range with contiguous storage
<span class="lineNum">    1778 </span>            :     template&lt;class IteratorType,
<span class="lineNum">    1779 </span>            :              typename std::enable_if&lt;
<a name="1780"><span class="lineNum">    1780 </span>            :                  std::is_same&lt;typename std::iterator_traits&lt;IteratorType&gt;::iterator_category, std::random_access_iterator_tag&gt;::value,</a>
<span class="lineNum">    1781 </span>            :                  int&gt;::type = 0&gt;
<span class="lineNum">    1782 </span><span class="lineCov">        145 :     input_adapter(IteratorType first, IteratorType last)</span>
<span class="lineNum">    1783 </span><span class="lineCov">        145 :     {</span>
<a name="1784"><span class="lineNum">    1784 </span>            :         // assertion to check that the iterator range is indeed contiguous,</a>
<span class="lineNum">    1785 </span>            :         // see http://stackoverflow.com/a/35008842/266378 for more discussion
<span class="lineNum">    1786 </span><span class="lineCov">       6960 :         assert(std::accumulate(</span>
<span class="lineNum">    1787 </span>            :                    first, last, std::pair&lt;bool, int&gt;(true, 0),
<span class="lineNum">    1788 </span>            :                    [&amp;first](std::pair&lt;bool, int&gt; res, decltype(*first) val)
<span class="lineNum">    1789 </span>            :         {
<span class="lineNum">    1790 </span>            :             res.first &amp;= (val == *(std::next(std::addressof(*first), res.second++)));
<span class="lineNum">    1791 </span>            :             return res;
<span class="lineNum">    1792 </span>            :         }).first);
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span>            :         // assertion to check that each element is 1 byte long
<span class="lineNum">    1795 </span>            :         static_assert(
<span class="lineNum">    1796 </span>            :             sizeof(typename std::iterator_traits&lt;IteratorType&gt;::value_type) == 1,
<span class="lineNum">    1797 </span>            :             &quot;each element in the iterator range must have the size of 1 byte&quot;);
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineCov">        145 :         const auto len = static_cast&lt;size_t&gt;(std::distance(first, last));</span>
<span class="lineNum">    1800 </span><span class="lineCov">        145 :         if (JSON_LIKELY(len &gt; 0))</span>
<span class="lineNum">    1801 </span>            :         {
<span class="lineNum">    1802 </span>            :             // there is at least one element: use the address of first
<span class="lineNum">    1803 </span><span class="lineCov">        144 :             ia = std::make_shared&lt;input_buffer_adapter&gt;(reinterpret_cast&lt;const char*&gt;(&amp;(*first)), len);</span>
<span class="lineNum">    1804 </span>            :         }
<span class="lineNum">    1805 </span>            :         else
<span class="lineNum">    1806 </span>            :         {
<span class="lineNum">    1807 </span>            :             // the address of first cannot be used: use nullptr
<span class="lineNum">    1808 </span><span class="lineCov">          1 :             ia = std::make_shared&lt;input_buffer_adapter&gt;(nullptr, len);</span>
<span class="lineNum">    1809 </span>            :         }
<span class="lineNum">    1810 </span><span class="lineCov">        145 :     }</span>
<span class="lineNum">    1811 </span>            : 
<a name="1812"><span class="lineNum">    1812 </span>            :     /// input adapter for array</a>
<span class="lineNum">    1813 </span>            :     template&lt;class T, std::size_t N&gt;
<span class="lineNum">    1814 </span><span class="lineCov">          7 :     input_adapter(T (&amp;array)[N])</span>
<span class="lineNum">    1815 </span><span class="lineCov">          7 :         : input_adapter(std::begin(array), std::end(array)) {}</span>
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span>            :     /// input adapter for contiguous container
<span class="lineNum">    1818 </span>            :     template&lt;class ContiguousContainer, typename
<span class="lineNum">    1819 </span>            :              std::enable_if&lt;not std::is_pointer&lt;ContiguousContainer&gt;::value and
<a name="1820"><span class="lineNum">    1820 </span>            :                             std::is_base_of&lt;std::random_access_iterator_tag, typename std::iterator_traits&lt;decltype(std::begin(std::declval&lt;ContiguousContainer const&gt;()))&gt;::iterator_category&gt;::value,</a>
<span class="lineNum">    1821 </span>            :                             int&gt;::type = 0&gt;
<span class="lineNum">    1822 </span><span class="lineCov">        138 :     input_adapter(const ContiguousContainer&amp; c)</span>
<a name="1823"><span class="lineNum">    1823 </span><span class="lineCov">        138 :         : input_adapter(std::begin(c), std::end(c)) {}</span></a>
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span><span class="lineCov">        145 :     operator input_adapter_t()</span>
<span class="lineNum">    1826 </span>            :     {
<span class="lineNum">    1827 </span><span class="lineCov">        145 :         return ia;</span>
<span class="lineNum">    1828 </span>            :     }
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            :   private:
<span class="lineNum">    1831 </span>            :     /// the actual adapter
<span class="lineNum">    1832 </span>            :     input_adapter_t ia = nullptr;
<span class="lineNum">    1833 </span>            : };
<span class="lineNum">    1834 </span>            : }
<span class="lineNum">    1835 </span>            : }
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            : // #include &lt;nlohmann/detail/input/lexer.hpp&gt;
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            : #include &lt;clocale&gt; // localeconv
<span class="lineNum">    1841 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">    1842 </span>            : #include &lt;cstdlib&gt; // strtof, strtod, strtold, strtoll, strtoull
<span class="lineNum">    1843 </span>            : #include &lt;initializer_list&gt; // initializer_list
<span class="lineNum">    1844 </span>            : #include &lt;iomanip&gt; // setw, setfill
<span class="lineNum">    1845 </span>            : #include &lt;ios&gt; // hex, uppercase
<span class="lineNum">    1846 </span>            : #include &lt;sstream&gt; // stringstream
<span class="lineNum">    1847 </span>            : #include &lt;string&gt; // char_traits, string
<span class="lineNum">    1848 </span>            : #include &lt;vector&gt; // vector
<span class="lineNum">    1849 </span>            : 
<span class="lineNum">    1850 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            : // #include &lt;nlohmann/detail/input/input_adapters.hpp&gt;
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            : namespace rockets_nlohmann
<span class="lineNum">    1856 </span>            : {
<span class="lineNum">    1857 </span>            : namespace detail
<span class="lineNum">    1858 </span>            : {
<span class="lineNum">    1859 </span>            : ///////////
<span class="lineNum">    1860 </span>            : // lexer //
<span class="lineNum">    1861 </span>            : ///////////
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : /*!
<span class="lineNum">    1864 </span>            : @brief lexical analysis
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            : This class organizes the lexical analysis during JSON deserialization.
<a name="1867"><span class="lineNum">    1867 </span>            : */</a>
<span class="lineNum">    1868 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    1869 </span><span class="lineCov">        145 : class lexer</span>
<span class="lineNum">    1870 </span>            : {
<span class="lineNum">    1871 </span>            :     using number_integer_t = typename BasicJsonType::number_integer_t;
<span class="lineNum">    1872 </span>            :     using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
<span class="lineNum">    1873 </span>            :     using number_float_t = typename BasicJsonType::number_float_t;
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span>            :   public:
<span class="lineNum">    1876 </span>            :     /// token types for the parser
<span class="lineNum">    1877 </span>            :     enum class token_type
<span class="lineNum">    1878 </span>            :     {
<span class="lineNum">    1879 </span>            :         uninitialized,    ///&lt; indicating the scanner is uninitialized
<span class="lineNum">    1880 </span>            :         literal_true,     ///&lt; the `true` literal
<span class="lineNum">    1881 </span>            :         literal_false,    ///&lt; the `false` literal
<span class="lineNum">    1882 </span>            :         literal_null,     ///&lt; the `null` literal
<span class="lineNum">    1883 </span>            :         value_string,     ///&lt; a string -- use get_string() for actual value
<span class="lineNum">    1884 </span>            :         value_unsigned,   ///&lt; an unsigned integer -- use get_number_unsigned() for actual value
<span class="lineNum">    1885 </span>            :         value_integer,    ///&lt; a signed integer -- use get_number_integer() for actual value
<span class="lineNum">    1886 </span>            :         value_float,      ///&lt; an floating point number -- use get_number_float() for actual value
<span class="lineNum">    1887 </span>            :         begin_array,      ///&lt; the character for array begin `[`
<span class="lineNum">    1888 </span>            :         begin_object,     ///&lt; the character for object begin `{`
<span class="lineNum">    1889 </span>            :         end_array,        ///&lt; the character for array end `]`
<span class="lineNum">    1890 </span>            :         end_object,       ///&lt; the character for object end `}`
<span class="lineNum">    1891 </span>            :         name_separator,   ///&lt; the name separator `:`
<span class="lineNum">    1892 </span>            :         value_separator,  ///&lt; the value separator `,`
<span class="lineNum">    1893 </span>            :         parse_error,      ///&lt; indicating a parse error
<span class="lineNum">    1894 </span>            :         end_of_input,     ///&lt; indicating the end of the input buffer
<span class="lineNum">    1895 </span>            :         literal_or_value  ///&lt; a literal or the begin of a value (only for diagnostics)
<span class="lineNum">    1896 </span>            :     };
<a name="1897"><span class="lineNum">    1897 </span>            : </a>
<span class="lineNum">    1898 </span>            :     /// return name of values of type token_type (only used for errors)
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :     static const char* token_type_name(const token_type t) noexcept</span>
<span class="lineNum">    1900 </span>            :     {
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :         switch (t)</span>
<span class="lineNum">    1902 </span>            :         {
<span class="lineNum">    1903 </span>            :             case token_type::uninitialized:
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                 return &quot;&lt;uninitialized&gt;&quot;;</span>
<span class="lineNum">    1905 </span>            :             case token_type::literal_true:
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :                 return &quot;true literal&quot;;</span>
<span class="lineNum">    1907 </span>            :             case token_type::literal_false:
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                 return &quot;false literal&quot;;</span>
<span class="lineNum">    1909 </span>            :             case token_type::literal_null:
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :                 return &quot;null literal&quot;;</span>
<span class="lineNum">    1911 </span>            :             case token_type::value_string:
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :                 return &quot;string literal&quot;;</span>
<span class="lineNum">    1913 </span>            :             case lexer::token_type::value_unsigned:
<span class="lineNum">    1914 </span>            :             case lexer::token_type::value_integer:
<span class="lineNum">    1915 </span>            :             case lexer::token_type::value_float:
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :                 return &quot;number literal&quot;;</span>
<span class="lineNum">    1917 </span>            :             case token_type::begin_array:
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :                 return &quot;'['&quot;;</span>
<span class="lineNum">    1919 </span>            :             case token_type::begin_object:
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :                 return &quot;'{'&quot;;</span>
<span class="lineNum">    1921 </span>            :             case token_type::end_array:
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :                 return &quot;']'&quot;;</span>
<span class="lineNum">    1923 </span>            :             case token_type::end_object:
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :                 return &quot;'}'&quot;;</span>
<span class="lineNum">    1925 </span>            :             case token_type::name_separator:
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :                 return &quot;':'&quot;;</span>
<span class="lineNum">    1927 </span>            :             case token_type::value_separator:
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :                 return &quot;','&quot;;</span>
<span class="lineNum">    1929 </span>            :             case token_type::parse_error:
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                 return &quot;&lt;parse error&gt;&quot;;</span>
<span class="lineNum">    1931 </span>            :             case token_type::end_of_input:
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :                 return &quot;end of input&quot;;</span>
<span class="lineNum">    1933 </span>            :             case token_type::literal_or_value:
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                 return &quot;'[', '{', or a literal&quot;;</span>
<span class="lineNum">    1935 </span>            :             default: // catch non-enum values
<span class="lineNum">    1936 </span>            :                 return &quot;unknown token&quot;; // LCOV_EXCL_LINE
<span class="lineNum">    1937 </span>            :         }
<a name="1938"><span class="lineNum">    1938 </span>            :     }</a>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span><span class="lineCov">        145 :     explicit lexer(detail::input_adapter_t adapter)</span>
<span class="lineNum">    1941 </span><span class="lineCov">        290 :         : ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}</span>
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            :     // delete because of pointer members
<span class="lineNum">    1944 </span>            :     lexer(const lexer&amp;) = delete;
<span class="lineNum">    1945 </span>            :     lexer&amp; operator=(lexer&amp;) = delete;
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            :   private:
<span class="lineNum">    1948 </span>            :     /////////////////////
<span class="lineNum">    1949 </span>            :     // locales
<span class="lineNum">    1950 </span>            :     /////////////////////
<a name="1951"><span class="lineNum">    1951 </span>            : </a>
<span class="lineNum">    1952 </span>            :     /// return the locale-dependent decimal point
<span class="lineNum">    1953 </span><span class="lineCov">        145 :     static char get_decimal_point() noexcept</span>
<span class="lineNum">    1954 </span>            :     {
<span class="lineNum">    1955 </span><span class="lineCov">        145 :         const auto loc = localeconv();</span>
<span class="lineNum">    1956 </span><span class="lineCov">        145 :         assert(loc != nullptr);</span>
<span class="lineNum">    1957 </span><span class="lineCov">        145 :         return (loc-&gt;decimal_point == nullptr) ? '.' : *(loc-&gt;decimal_point);</span>
<span class="lineNum">    1958 </span>            :     }
<span class="lineNum">    1959 </span>            : 
<span class="lineNum">    1960 </span>            :     /////////////////////
<span class="lineNum">    1961 </span>            :     // scan functions
<span class="lineNum">    1962 </span>            :     /////////////////////
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            :     /*!
<span class="lineNum">    1965 </span>            :     @brief get codepoint from 4 hex characters following `\u`
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span>            :     For input &quot;\u c1 c2 c3 c4&quot; the codepoint is:
<span class="lineNum">    1968 </span>            :       (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
<span class="lineNum">    1969 </span>            :     = (c1 &lt;&lt; 12) + (c2 &lt;&lt; 8) + (c3 &lt;&lt; 4) + (c4 &lt;&lt; 0)
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span>            :     Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
<span class="lineNum">    1972 </span>            :     must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
<span class="lineNum">    1973 </span>            :     conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
<span class="lineNum">    1974 </span>            :     between the ASCII value of the character and the desired integer value.
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            :     @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
<a name="1977"><span class="lineNum">    1977 </span>            :             non-hex character)</a>
<span class="lineNum">    1978 </span>            :     */
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :     int get_codepoint()</span>
<span class="lineNum">    1980 </span>            :     {
<span class="lineNum">    1981 </span>            :         // this function only makes sense after reading `\u`
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         assert(current == 'u');</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :         int codepoint = 0;</span>
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         const auto factors = { 12, 8, 4, 0 };</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :         for (const auto factor : factors)</span>
<span class="lineNum">    1987 </span>            :         {
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :             get();</span>
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :             if (current &gt;= '0' and current &lt;= '9')</span>
<span class="lineNum">    1991 </span>            :             {
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :                 codepoint += ((current - 0x30) &lt;&lt; factor);</span>
<span class="lineNum">    1993 </span>            :             }
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :             else if (current &gt;= 'A' and current &lt;= 'F')</span>
<span class="lineNum">    1995 </span>            :             {
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :                 codepoint += ((current - 0x37) &lt;&lt; factor);</span>
<span class="lineNum">    1997 </span>            :             }
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :             else if (current &gt;= 'a' and current &lt;= 'f')</span>
<span class="lineNum">    1999 </span>            :             {
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :                 codepoint += ((current - 0x57) &lt;&lt; factor);</span>
<span class="lineNum">    2001 </span>            :             }
<span class="lineNum">    2002 </span>            :             else
<span class="lineNum">    2003 </span>            :             {
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2005 </span>            :             }
<span class="lineNum">    2006 </span>            :         }
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :         assert(0x0000 &lt;= codepoint and codepoint &lt;= 0xFFFF);</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :         return codepoint;</span>
<span class="lineNum">    2010 </span>            :     }
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span>            :     /*!
<span class="lineNum">    2013 </span>            :     @brief check if the next byte(s) are inside a given range
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span>            :     Adds the current byte and, for each passed range, reads a new byte and
<span class="lineNum">    2016 </span>            :     checks if it is inside the range. If a violation was detected, set up an
<span class="lineNum">    2017 </span>            :     error message and return false. Otherwise, return true.
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span>            :     @param[in] ranges  list of integers; interpreted as list of pairs of
<span class="lineNum">    2020 </span>            :                        inclusive lower and upper bound, respectively
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
<span class="lineNum">    2023 </span>            :          1, 2, or 3 pairs. This precondition is enforced by an assertion.
<span class="lineNum">    2024 </span>            : 
<a name="2025"><span class="lineNum">    2025 </span>            :     @return true if and only if no range violation was detected</a>
<span class="lineNum">    2026 </span>            :     */
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :     bool next_byte_in_range(std::initializer_list&lt;int&gt; ranges)</span>
<span class="lineNum">    2028 </span>            :     {
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :         assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :         add(current);</span>
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :         for (auto range = ranges.begin(); range != ranges.end(); ++range)</span>
<span class="lineNum">    2033 </span>            :         {
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :             get();</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :             if (JSON_LIKELY(*range &lt;= current and current &lt;= *(++range)))</span>
<span class="lineNum">    2036 </span>            :             {
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2038 </span>            :             }
<span class="lineNum">    2039 </span>            :             else
<span class="lineNum">    2040 </span>            :             {
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :                 error_message = &quot;invalid string: ill-formed UTF-8 byte&quot;;</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2043 </span>            :             }
<span class="lineNum">    2044 </span>            :         }
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    2047 </span>            :     }
<span class="lineNum">    2048 </span>            : 
<span class="lineNum">    2049 </span>            :     /*!
<span class="lineNum">    2050 </span>            :     @brief scan a string literal
<span class="lineNum">    2051 </span>            : 
<span class="lineNum">    2052 </span>            :     This function scans a string according to Sect. 7 of RFC 7159. While
<span class="lineNum">    2053 </span>            :     scanning, bytes are escaped and copied into buffer token_buffer. Then the
<span class="lineNum">    2054 </span>            :     function returns successfully, token_buffer is *not* null-terminated (as it
<span class="lineNum">    2055 </span>            :     may contain \0 bytes), and token_buffer.size() is the number of bytes in the
<span class="lineNum">    2056 </span>            :     string.
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span>            :     @return token_type::value_string if string could be successfully scanned,
<span class="lineNum">    2059 </span>            :             token_type::parse_error otherwise
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            :     @note In case of errors, variable error_message contains a textual
<a name="2062"><span class="lineNum">    2062 </span>            :           description.</a>
<span class="lineNum">    2063 </span>            :     */
<span class="lineNum">    2064 </span><span class="lineCov">        486 :     token_type scan_string()</span>
<span class="lineNum">    2065 </span>            :     {
<span class="lineNum">    2066 </span>            :         // reset token_buffer (ignore opening quote)
<span class="lineNum">    2067 </span><span class="lineCov">        486 :         reset();</span>
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span>            :         // we entered the function by reading an open quote
<span class="lineNum">    2070 </span><span class="lineCov">        486 :         assert(current == '\&quot;');</span>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineCov">       2591 :         while (true)</span>
<span class="lineNum">    2073 </span>            :         {
<span class="lineNum">    2074 </span>            :             // get next character
<span class="lineNum">    2075 </span><span class="lineCov">       3077 :             switch (get())</span>
<span class="lineNum">    2076 </span>            :             {
<span class="lineNum">    2077 </span>            :                 // end of file while parsing string
<span class="lineNum">    2078 </span>            :                 case std::char_traits&lt;char&gt;::eof():
<span class="lineNum">    2079 </span>            :                 {
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :                     error_message = &quot;invalid string: missing closing quote&quot;;</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                     return token_type::parse_error;</span>
<span class="lineNum">    2082 </span>            :                 }
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            :                 // closing quote
<span class="lineNum">    2085 </span>            :                 case '\&quot;':
<span class="lineNum">    2086 </span>            :                 {
<span class="lineNum">    2087 </span><span class="lineCov">        486 :                     return token_type::value_string;</span>
<span class="lineNum">    2088 </span>            :                 }
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span>            :                 // escapes
<span class="lineNum">    2091 </span>            :                 case '\\':
<span class="lineNum">    2092 </span>            :                 {
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :                     switch (get())</span>
<span class="lineNum">    2094 </span>            :                     {
<span class="lineNum">    2095 </span>            :                         // quotation mark
<span class="lineNum">    2096 </span>            :                         case '\&quot;':
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :                             add('\&quot;');</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2099 </span>            :                         // reverse solidus
<span class="lineNum">    2100 </span>            :                         case '\\':
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :                             add('\\');</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2103 </span>            :                         // solidus
<span class="lineNum">    2104 </span>            :                         case '/':
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :                             add('/');</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2107 </span>            :                         // backspace
<span class="lineNum">    2108 </span>            :                         case 'b':
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :                             add('\b');</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2111 </span>            :                         // form feed
<span class="lineNum">    2112 </span>            :                         case 'f':
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :                             add('\f');</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2115 </span>            :                         // line feed
<span class="lineNum">    2116 </span>            :                         case 'n':
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :                             add('\n');</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2119 </span>            :                         // carriage return
<span class="lineNum">    2120 </span>            :                         case 'r':
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :                             add('\r');</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2123 </span>            :                         // tab
<span class="lineNum">    2124 </span>            :                         case 't':
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :                             add('\t');</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span>            :                         // unicode escapes
<span class="lineNum">    2129 </span>            :                         case 'u':
<span class="lineNum">    2130 </span>            :                         {
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :                             const int codepoint1 = get_codepoint();</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :                             int codepoint = codepoint1; // start with codepoint1</span>
<span class="lineNum">    2133 </span>            : 
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :                             if (JSON_UNLIKELY(codepoint1 == -1))</span>
<span class="lineNum">    2135 </span>            :                             {
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :                                 error_message = &quot;invalid string: '\\u' must be followed by 4 hex digits&quot;;</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :                                 return token_type::parse_error;</span>
<span class="lineNum">    2138 </span>            :                             }
<span class="lineNum">    2139 </span>            : 
<span class="lineNum">    2140 </span>            :                             // check if code point is a high surrogate
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                             if (0xD800 &lt;= codepoint1 and codepoint1 &lt;= 0xDBFF)</span>
<span class="lineNum">    2142 </span>            :                             {
<span class="lineNum">    2143 </span>            :                                 // expect next \uxxxx entry
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :                                 if (JSON_LIKELY(get() == '\\' and get() == 'u'))</span>
<span class="lineNum">    2145 </span>            :                                 {
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :                                     const int codepoint2 = get_codepoint();</span>
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :                                     if (JSON_UNLIKELY(codepoint2 == -1))</span>
<span class="lineNum">    2149 </span>            :                                     {
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                                         error_message = &quot;invalid string: '\\u' must be followed by 4 hex digits&quot;;</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :                                         return token_type::parse_error;</span>
<span class="lineNum">    2152 </span>            :                                     }
<span class="lineNum">    2153 </span>            : 
<span class="lineNum">    2154 </span>            :                                     // check if codepoint2 is a low surrogate
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :                                     if (JSON_LIKELY(0xDC00 &lt;= codepoint2 and codepoint2 &lt;= 0xDFFF))</span>
<span class="lineNum">    2156 </span>            :                                     {
<span class="lineNum">    2157 </span>            :                                         // overwrite codepoint
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :                                         codepoint =</span>
<span class="lineNum">    2159 </span>            :                                             // high surrogate occupies the most significant 22 bits
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :                                             (codepoint1 &lt;&lt; 10)</span>
<span class="lineNum">    2161 </span>            :                                             // low surrogate occupies the least significant 15 bits
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :                                             + codepoint2</span>
<span class="lineNum">    2163 </span>            :                                             // there is still the 0xD800, 0xDC00 and 0x10000 noise
<span class="lineNum">    2164 </span>            :                                             // in the result so we have to subtract with:
<span class="lineNum">    2165 </span>            :                                             // (0xD800 &lt;&lt; 10) + DC00 - 0x10000 = 0x35FDC00
<span class="lineNum">    2166 </span>            :                                             - 0x35FDC00;
<span class="lineNum">    2167 </span>            :                                     }
<span class="lineNum">    2168 </span>            :                                     else
<span class="lineNum">    2169 </span>            :                                     {
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :                                         error_message = &quot;invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF&quot;;</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :                                         return token_type::parse_error;</span>
<span class="lineNum">    2172 </span>            :                                     }
<span class="lineNum">    2173 </span>            :                                 }
<span class="lineNum">    2174 </span>            :                                 else
<span class="lineNum">    2175 </span>            :                                 {
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :                                     error_message = &quot;invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF&quot;;</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                                     return token_type::parse_error;</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :                                 }</span>
<span class="lineNum">    2179 </span>            :                             }
<span class="lineNum">    2180 </span>            :                             else
<span class="lineNum">    2181 </span>            :                             {
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :                                 if (JSON_UNLIKELY(0xDC00 &lt;= codepoint1 and codepoint1 &lt;= 0xDFFF))</span>
<span class="lineNum">    2183 </span>            :                                 {
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                                     error_message = &quot;invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF&quot;;</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :                                     return token_type::parse_error;</span>
<span class="lineNum">    2186 </span>            :                                 }
<span class="lineNum">    2187 </span>            :                             }
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span>            :                             // result of the above calculation yields a proper codepoint
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :                             assert(0x00 &lt;= codepoint and codepoint &lt;= 0x10FFFF);</span>
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span>            :                             // translate codepoint into bytes
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :                             if (codepoint &lt; 0x80)</span>
<span class="lineNum">    2194 </span>            :                             {
<span class="lineNum">    2195 </span>            :                                 // 1-byte characters: 0xxxxxxx (ASCII)
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :                                 add(codepoint);</span>
<span class="lineNum">    2197 </span>            :                             }
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :                             else if (codepoint &lt;= 0x7FF)</span>
<span class="lineNum">    2199 </span>            :                             {
<span class="lineNum">    2200 </span>            :                                 // 2-byte characters: 110xxxxx 10xxxxxx
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :                                 add(0xC0 | (codepoint &gt;&gt; 6));</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :                                 add(0x80 | (codepoint &amp; 0x3F));</span>
<span class="lineNum">    2203 </span>            :                             }
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :                             else if (codepoint &lt;= 0xFFFF)</span>
<span class="lineNum">    2205 </span>            :                             {
<span class="lineNum">    2206 </span>            :                                 // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :                                 add(0xE0 | (codepoint &gt;&gt; 12));</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :                                 add(0x80 | ((codepoint &gt;&gt; 6) &amp; 0x3F));</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :                                 add(0x80 | (codepoint &amp; 0x3F));</span>
<span class="lineNum">    2210 </span>            :                             }
<span class="lineNum">    2211 </span>            :                             else
<span class="lineNum">    2212 </span>            :                             {
<span class="lineNum">    2213 </span>            :                                 // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :                                 add(0xF0 | (codepoint &gt;&gt; 18));</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :                                 add(0x80 | ((codepoint &gt;&gt; 12) &amp; 0x3F));</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :                                 add(0x80 | ((codepoint &gt;&gt; 6) &amp; 0x3F));</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :                                 add(0x80 | (codepoint &amp; 0x3F));</span>
<span class="lineNum">    2218 </span>            :                             }
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    2221 </span>            :                         }
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            :                         // other characters after escape
<span class="lineNum">    2224 </span>            :                         default:
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :                             error_message = &quot;invalid string: forbidden character after backslash&quot;;</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :                             return token_type::parse_error;</span>
<span class="lineNum">    2227 </span>            :                     }
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2230 </span>            :                 }
<span class="lineNum">    2231 </span>            : 
<span class="lineNum">    2232 </span>            :                 // invalid control characters
<span class="lineNum">    2233 </span>            :                 case 0x00:
<span class="lineNum">    2234 </span>            :                 case 0x01:
<span class="lineNum">    2235 </span>            :                 case 0x02:
<span class="lineNum">    2236 </span>            :                 case 0x03:
<span class="lineNum">    2237 </span>            :                 case 0x04:
<span class="lineNum">    2238 </span>            :                 case 0x05:
<span class="lineNum">    2239 </span>            :                 case 0x06:
<span class="lineNum">    2240 </span>            :                 case 0x07:
<span class="lineNum">    2241 </span>            :                 case 0x08:
<span class="lineNum">    2242 </span>            :                 case 0x09:
<span class="lineNum">    2243 </span>            :                 case 0x0A:
<span class="lineNum">    2244 </span>            :                 case 0x0B:
<span class="lineNum">    2245 </span>            :                 case 0x0C:
<span class="lineNum">    2246 </span>            :                 case 0x0D:
<span class="lineNum">    2247 </span>            :                 case 0x0E:
<span class="lineNum">    2248 </span>            :                 case 0x0F:
<span class="lineNum">    2249 </span>            :                 case 0x10:
<span class="lineNum">    2250 </span>            :                 case 0x11:
<span class="lineNum">    2251 </span>            :                 case 0x12:
<span class="lineNum">    2252 </span>            :                 case 0x13:
<span class="lineNum">    2253 </span>            :                 case 0x14:
<span class="lineNum">    2254 </span>            :                 case 0x15:
<span class="lineNum">    2255 </span>            :                 case 0x16:
<span class="lineNum">    2256 </span>            :                 case 0x17:
<span class="lineNum">    2257 </span>            :                 case 0x18:
<span class="lineNum">    2258 </span>            :                 case 0x19:
<span class="lineNum">    2259 </span>            :                 case 0x1A:
<span class="lineNum">    2260 </span>            :                 case 0x1B:
<span class="lineNum">    2261 </span>            :                 case 0x1C:
<span class="lineNum">    2262 </span>            :                 case 0x1D:
<span class="lineNum">    2263 </span>            :                 case 0x1E:
<span class="lineNum">    2264 </span>            :                 case 0x1F:
<span class="lineNum">    2265 </span>            :                 {
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                     error_message = &quot;invalid string: control character must be escaped&quot;;</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                     return token_type::parse_error;</span>
<span class="lineNum">    2268 </span>            :                 }
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            :                 // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
<span class="lineNum">    2271 </span>            :                 case 0x20:
<span class="lineNum">    2272 </span>            :                 case 0x21:
<span class="lineNum">    2273 </span>            :                 case 0x23:
<span class="lineNum">    2274 </span>            :                 case 0x24:
<span class="lineNum">    2275 </span>            :                 case 0x25:
<span class="lineNum">    2276 </span>            :                 case 0x26:
<span class="lineNum">    2277 </span>            :                 case 0x27:
<span class="lineNum">    2278 </span>            :                 case 0x28:
<span class="lineNum">    2279 </span>            :                 case 0x29:
<span class="lineNum">    2280 </span>            :                 case 0x2A:
<span class="lineNum">    2281 </span>            :                 case 0x2B:
<span class="lineNum">    2282 </span>            :                 case 0x2C:
<span class="lineNum">    2283 </span>            :                 case 0x2D:
<span class="lineNum">    2284 </span>            :                 case 0x2E:
<span class="lineNum">    2285 </span>            :                 case 0x2F:
<span class="lineNum">    2286 </span>            :                 case 0x30:
<span class="lineNum">    2287 </span>            :                 case 0x31:
<span class="lineNum">    2288 </span>            :                 case 0x32:
<span class="lineNum">    2289 </span>            :                 case 0x33:
<span class="lineNum">    2290 </span>            :                 case 0x34:
<span class="lineNum">    2291 </span>            :                 case 0x35:
<span class="lineNum">    2292 </span>            :                 case 0x36:
<span class="lineNum">    2293 </span>            :                 case 0x37:
<span class="lineNum">    2294 </span>            :                 case 0x38:
<span class="lineNum">    2295 </span>            :                 case 0x39:
<span class="lineNum">    2296 </span>            :                 case 0x3A:
<span class="lineNum">    2297 </span>            :                 case 0x3B:
<span class="lineNum">    2298 </span>            :                 case 0x3C:
<span class="lineNum">    2299 </span>            :                 case 0x3D:
<span class="lineNum">    2300 </span>            :                 case 0x3E:
<span class="lineNum">    2301 </span>            :                 case 0x3F:
<span class="lineNum">    2302 </span>            :                 case 0x40:
<span class="lineNum">    2303 </span>            :                 case 0x41:
<span class="lineNum">    2304 </span>            :                 case 0x42:
<span class="lineNum">    2305 </span>            :                 case 0x43:
<span class="lineNum">    2306 </span>            :                 case 0x44:
<span class="lineNum">    2307 </span>            :                 case 0x45:
<span class="lineNum">    2308 </span>            :                 case 0x46:
<span class="lineNum">    2309 </span>            :                 case 0x47:
<span class="lineNum">    2310 </span>            :                 case 0x48:
<span class="lineNum">    2311 </span>            :                 case 0x49:
<span class="lineNum">    2312 </span>            :                 case 0x4A:
<span class="lineNum">    2313 </span>            :                 case 0x4B:
<span class="lineNum">    2314 </span>            :                 case 0x4C:
<span class="lineNum">    2315 </span>            :                 case 0x4D:
<span class="lineNum">    2316 </span>            :                 case 0x4E:
<span class="lineNum">    2317 </span>            :                 case 0x4F:
<span class="lineNum">    2318 </span>            :                 case 0x50:
<span class="lineNum">    2319 </span>            :                 case 0x51:
<span class="lineNum">    2320 </span>            :                 case 0x52:
<span class="lineNum">    2321 </span>            :                 case 0x53:
<span class="lineNum">    2322 </span>            :                 case 0x54:
<span class="lineNum">    2323 </span>            :                 case 0x55:
<span class="lineNum">    2324 </span>            :                 case 0x56:
<span class="lineNum">    2325 </span>            :                 case 0x57:
<span class="lineNum">    2326 </span>            :                 case 0x58:
<span class="lineNum">    2327 </span>            :                 case 0x59:
<span class="lineNum">    2328 </span>            :                 case 0x5A:
<span class="lineNum">    2329 </span>            :                 case 0x5B:
<span class="lineNum">    2330 </span>            :                 case 0x5D:
<span class="lineNum">    2331 </span>            :                 case 0x5E:
<span class="lineNum">    2332 </span>            :                 case 0x5F:
<span class="lineNum">    2333 </span>            :                 case 0x60:
<span class="lineNum">    2334 </span>            :                 case 0x61:
<span class="lineNum">    2335 </span>            :                 case 0x62:
<span class="lineNum">    2336 </span>            :                 case 0x63:
<span class="lineNum">    2337 </span>            :                 case 0x64:
<span class="lineNum">    2338 </span>            :                 case 0x65:
<span class="lineNum">    2339 </span>            :                 case 0x66:
<span class="lineNum">    2340 </span>            :                 case 0x67:
<span class="lineNum">    2341 </span>            :                 case 0x68:
<span class="lineNum">    2342 </span>            :                 case 0x69:
<span class="lineNum">    2343 </span>            :                 case 0x6A:
<span class="lineNum">    2344 </span>            :                 case 0x6B:
<span class="lineNum">    2345 </span>            :                 case 0x6C:
<span class="lineNum">    2346 </span>            :                 case 0x6D:
<span class="lineNum">    2347 </span>            :                 case 0x6E:
<span class="lineNum">    2348 </span>            :                 case 0x6F:
<span class="lineNum">    2349 </span>            :                 case 0x70:
<span class="lineNum">    2350 </span>            :                 case 0x71:
<span class="lineNum">    2351 </span>            :                 case 0x72:
<span class="lineNum">    2352 </span>            :                 case 0x73:
<span class="lineNum">    2353 </span>            :                 case 0x74:
<span class="lineNum">    2354 </span>            :                 case 0x75:
<span class="lineNum">    2355 </span>            :                 case 0x76:
<span class="lineNum">    2356 </span>            :                 case 0x77:
<span class="lineNum">    2357 </span>            :                 case 0x78:
<span class="lineNum">    2358 </span>            :                 case 0x79:
<span class="lineNum">    2359 </span>            :                 case 0x7A:
<span class="lineNum">    2360 </span>            :                 case 0x7B:
<span class="lineNum">    2361 </span>            :                 case 0x7C:
<span class="lineNum">    2362 </span>            :                 case 0x7D:
<span class="lineNum">    2363 </span>            :                 case 0x7E:
<span class="lineNum">    2364 </span>            :                 case 0x7F:
<span class="lineNum">    2365 </span>            :                 {
<span class="lineNum">    2366 </span><span class="lineCov">       2591 :                     add(current);</span>
<span class="lineNum">    2367 </span><span class="lineCov">       2591 :                     break;</span>
<span class="lineNum">    2368 </span>            :                 }
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span>            :                 // U+0080..U+07FF: bytes C2..DF 80..BF
<span class="lineNum">    2371 </span>            :                 case 0xC2:
<span class="lineNum">    2372 </span>            :                 case 0xC3:
<span class="lineNum">    2373 </span>            :                 case 0xC4:
<span class="lineNum">    2374 </span>            :                 case 0xC5:
<span class="lineNum">    2375 </span>            :                 case 0xC6:
<span class="lineNum">    2376 </span>            :                 case 0xC7:
<span class="lineNum">    2377 </span>            :                 case 0xC8:
<span class="lineNum">    2378 </span>            :                 case 0xC9:
<span class="lineNum">    2379 </span>            :                 case 0xCA:
<span class="lineNum">    2380 </span>            :                 case 0xCB:
<span class="lineNum">    2381 </span>            :                 case 0xCC:
<span class="lineNum">    2382 </span>            :                 case 0xCD:
<span class="lineNum">    2383 </span>            :                 case 0xCE:
<span class="lineNum">    2384 </span>            :                 case 0xCF:
<span class="lineNum">    2385 </span>            :                 case 0xD0:
<span class="lineNum">    2386 </span>            :                 case 0xD1:
<span class="lineNum">    2387 </span>            :                 case 0xD2:
<span class="lineNum">    2388 </span>            :                 case 0xD3:
<span class="lineNum">    2389 </span>            :                 case 0xD4:
<span class="lineNum">    2390 </span>            :                 case 0xD5:
<span class="lineNum">    2391 </span>            :                 case 0xD6:
<span class="lineNum">    2392 </span>            :                 case 0xD7:
<span class="lineNum">    2393 </span>            :                 case 0xD8:
<span class="lineNum">    2394 </span>            :                 case 0xD9:
<span class="lineNum">    2395 </span>            :                 case 0xDA:
<span class="lineNum">    2396 </span>            :                 case 0xDB:
<span class="lineNum">    2397 </span>            :                 case 0xDC:
<span class="lineNum">    2398 </span>            :                 case 0xDD:
<span class="lineNum">    2399 </span>            :                 case 0xDE:
<span class="lineNum">    2400 </span>            :                 case 0xDF:
<span class="lineNum">    2401 </span>            :                 {
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not next_byte_in_range({0x80, 0xBF})))</span>
<span class="lineNum">    2403 </span>            :                     {
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2405 </span>            :                     }
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2407 </span>            :                 }
<span class="lineNum">    2408 </span>            : 
<span class="lineNum">    2409 </span>            :                 // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
<span class="lineNum">    2410 </span>            :                 case 0xE0:
<span class="lineNum">    2411 </span>            :                 {
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not (next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))</span>
<span class="lineNum">    2413 </span>            :                     {
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2415 </span>            :                     }
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2417 </span>            :                 }
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span>            :                 // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
<span class="lineNum">    2420 </span>            :                 // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
<span class="lineNum">    2421 </span>            :                 case 0xE1:
<span class="lineNum">    2422 </span>            :                 case 0xE2:
<span class="lineNum">    2423 </span>            :                 case 0xE3:
<span class="lineNum">    2424 </span>            :                 case 0xE4:
<span class="lineNum">    2425 </span>            :                 case 0xE5:
<span class="lineNum">    2426 </span>            :                 case 0xE6:
<span class="lineNum">    2427 </span>            :                 case 0xE7:
<span class="lineNum">    2428 </span>            :                 case 0xE8:
<span class="lineNum">    2429 </span>            :                 case 0xE9:
<span class="lineNum">    2430 </span>            :                 case 0xEA:
<span class="lineNum">    2431 </span>            :                 case 0xEB:
<span class="lineNum">    2432 </span>            :                 case 0xEC:
<span class="lineNum">    2433 </span>            :                 case 0xEE:
<span class="lineNum">    2434 </span>            :                 case 0xEF:
<span class="lineNum">    2435 </span>            :                 {
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))</span>
<span class="lineNum">    2437 </span>            :                     {
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2439 </span>            :                     }
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2441 </span>            :                 }
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span>            :                 // U+D000..U+D7FF: bytes ED 80..9F 80..BF
<span class="lineNum">    2444 </span>            :                 case 0xED:
<span class="lineNum">    2445 </span>            :                 {
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))</span>
<span class="lineNum">    2447 </span>            :                     {
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2449 </span>            :                     }
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2451 </span>            :                 }
<span class="lineNum">    2452 </span>            : 
<span class="lineNum">    2453 </span>            :                 // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
<span class="lineNum">    2454 </span>            :                 case 0xF0:
<span class="lineNum">    2455 </span>            :                 {
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not (next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))</span>
<span class="lineNum">    2457 </span>            :                     {
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2459 </span>            :                     }
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2461 </span>            :                 }
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span>            :                 // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
<span class="lineNum">    2464 </span>            :                 case 0xF1:
<span class="lineNum">    2465 </span>            :                 case 0xF2:
<span class="lineNum">    2466 </span>            :                 case 0xF3:
<span class="lineNum">    2467 </span>            :                 {
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))</span>
<span class="lineNum">    2469 </span>            :                     {
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2471 </span>            :                     }
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2473 </span>            :                 }
<span class="lineNum">    2474 </span>            : 
<span class="lineNum">    2475 </span>            :                 // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
<span class="lineNum">    2476 </span>            :                 case 0xF4:
<span class="lineNum">    2477 </span>            :                 {
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :                     if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))</span>
<span class="lineNum">    2479 </span>            :                     {
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :                         return token_type::parse_error;</span>
<span class="lineNum">    2481 </span>            :                     }
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2483 </span>            :                 }
<span class="lineNum">    2484 </span>            : 
<span class="lineNum">    2485 </span>            :                 // remaining bytes (80..C1 and F5..FF) are ill-formed
<span class="lineNum">    2486 </span>            :                 default:
<span class="lineNum">    2487 </span>            :                 {
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :                     error_message = &quot;invalid string: ill-formed UTF-8 byte&quot;;</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :                     return token_type::parse_error;</span>
<span class="lineNum">    2490 </span>            :                 }
<span class="lineNum">    2491 </span>            :             }
<span class="lineNum">    2492 </span>            :         }
<span class="lineNum">    2493 </span>            :     }
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span>            :     static void strtof(float&amp; f, const char* str, char** endptr) noexcept
<span class="lineNum">    2496 </span>            :     {
<span class="lineNum">    2497 </span>            :         f = std::strtof(str, endptr);
<a name="2498"><span class="lineNum">    2498 </span>            :     }</a>
<span class="lineNum">    2499 </span>            : 
<span class="lineNum">    2500 </span><span class="lineCov">          1 :     static void strtof(double&amp; f, const char* str, char** endptr) noexcept</span>
<span class="lineNum">    2501 </span>            :     {
<span class="lineNum">    2502 </span><span class="lineCov">          1 :         f = std::strtod(str, endptr);</span>
<span class="lineNum">    2503 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span>            :     static void strtof(long double&amp; f, const char* str, char** endptr) noexcept
<span class="lineNum">    2506 </span>            :     {
<span class="lineNum">    2507 </span>            :         f = std::strtold(str, endptr);
<span class="lineNum">    2508 </span>            :     }
<span class="lineNum">    2509 </span>            : 
<span class="lineNum">    2510 </span>            :     /*!
<span class="lineNum">    2511 </span>            :     @brief scan a number literal
<span class="lineNum">    2512 </span>            : 
<span class="lineNum">    2513 </span>            :     This function scans a string according to Sect. 6 of RFC 7159.
<span class="lineNum">    2514 </span>            : 
<span class="lineNum">    2515 </span>            :     The function is realized with a deterministic finite state machine derived
<span class="lineNum">    2516 </span>            :     from the grammar described in RFC 7159. Starting in state &quot;init&quot;, the
<span class="lineNum">    2517 </span>            :     input is read and used to determined the next state. Only state &quot;done&quot;
<span class="lineNum">    2518 </span>            :     accepts the number. State &quot;error&quot; is a trap state to model errors. In the
<span class="lineNum">    2519 </span>            :     table below, &quot;anything&quot; means any character but the ones listed before.
<span class="lineNum">    2520 </span>            : 
<span class="lineNum">    2521 </span>            :     state    | 0        | 1-9      | e E      | +       | -       | .        | anything
<span class="lineNum">    2522 </span>            :     ---------|----------|----------|----------|---------|---------|----------|-----------
<span class="lineNum">    2523 </span>            :     init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
<span class="lineNum">    2524 </span>            :     minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
<span class="lineNum">    2525 </span>            :     zero     | done     | done     | exponent | done    | done    | decimal1 | done
<span class="lineNum">    2526 </span>            :     any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
<span class="lineNum">    2527 </span>            :     decimal1 | decimal2 | [error]  | [error]  | [error] | [error] | [error]  | [error]
<span class="lineNum">    2528 </span>            :     decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
<span class="lineNum">    2529 </span>            :     exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
<span class="lineNum">    2530 </span>            :     sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
<span class="lineNum">    2531 </span>            :     any2     | any2     | any2     | done     | done    | done    | done     | done
<span class="lineNum">    2532 </span>            : 
<span class="lineNum">    2533 </span>            :     The state machine is realized with one label per state (prefixed with
<span class="lineNum">    2534 </span>            :     &quot;scan_number_&quot;) and `goto` statements between them. The state machine
<span class="lineNum">    2535 </span>            :     contains cycles, but any cycle can be left when EOF is read. Therefore,
<span class="lineNum">    2536 </span>            :     the function is guaranteed to terminate.
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span>            :     During scanning, the read bytes are stored in token_buffer. This string is
<span class="lineNum">    2539 </span>            :     then converted to a signed integer, an unsigned integer, or a
<span class="lineNum">    2540 </span>            :     floating-point number.
<span class="lineNum">    2541 </span>            : 
<span class="lineNum">    2542 </span>            :     @return token_type::value_unsigned, token_type::value_integer, or
<span class="lineNum">    2543 </span>            :             token_type::value_float if number could be successfully scanned,
<span class="lineNum">    2544 </span>            :             token_type::parse_error otherwise
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span>            :     @note The scanner is independent of the current locale. Internally, the
<span class="lineNum">    2547 </span>            :           locale's decimal point is used instead of `.` to work with the
<a name="2548"><span class="lineNum">    2548 </span>            :           locale-dependent converters.</a>
<span class="lineNum">    2549 </span>            :     */
<span class="lineNum">    2550 </span><span class="lineCov">        225 :     token_type scan_number()</span>
<span class="lineNum">    2551 </span>            :     {
<span class="lineNum">    2552 </span>            :         // reset token_buffer to store the number's bytes
<span class="lineNum">    2553 </span><span class="lineCov">        225 :         reset();</span>
<span class="lineNum">    2554 </span>            : 
<span class="lineNum">    2555 </span>            :         // the type of the parsed number; initially set to unsigned; will be
<span class="lineNum">    2556 </span>            :         // changed if minus sign, decimal point or exponent is read
<span class="lineNum">    2557 </span><span class="lineCov">        225 :         token_type number_type = token_type::value_unsigned;</span>
<span class="lineNum">    2558 </span>            : 
<span class="lineNum">    2559 </span>            :         // state (init): we just found out we need to scan a number
<span class="lineNum">    2560 </span><span class="lineCov">        225 :         switch (current)</span>
<span class="lineNum">    2561 </span>            :         {
<span class="lineNum">    2562 </span>            :             case '-':
<span class="lineNum">    2563 </span>            :             {
<span class="lineNum">    2564 </span><span class="lineCov">          4 :                 add(current);</span>
<span class="lineNum">    2565 </span><span class="lineCov">          4 :                 goto scan_number_minus;</span>
<span class="lineNum">    2566 </span>            :             }
<span class="lineNum">    2567 </span>            : 
<span class="lineNum">    2568 </span>            :             case '0':
<span class="lineNum">    2569 </span>            :             {
<span class="lineNum">    2570 </span><span class="lineCov">         18 :                 add(current);</span>
<span class="lineNum">    2571 </span><span class="lineCov">         18 :                 goto scan_number_zero;</span>
<span class="lineNum">    2572 </span>            :             }
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span>            :             case '1':
<span class="lineNum">    2575 </span>            :             case '2':
<span class="lineNum">    2576 </span>            :             case '3':
<span class="lineNum">    2577 </span>            :             case '4':
<span class="lineNum">    2578 </span>            :             case '5':
<span class="lineNum">    2579 </span>            :             case '6':
<span class="lineNum">    2580 </span>            :             case '7':
<span class="lineNum">    2581 </span>            :             case '8':
<span class="lineNum">    2582 </span>            :             case '9':
<span class="lineNum">    2583 </span>            :             {
<span class="lineNum">    2584 </span><span class="lineCov">        203 :                 add(current);</span>
<span class="lineNum">    2585 </span><span class="lineCov">        203 :                 goto scan_number_any1;</span>
<span class="lineNum">    2586 </span>            :             }
<span class="lineNum">    2587 </span>            : 
<span class="lineNum">    2588 </span>            :             default:
<span class="lineNum">    2589 </span>            :             {
<span class="lineNum">    2590 </span>            :                 // all other characters are rejected outside scan_number()
<span class="lineNum">    2591 </span>            :                 assert(false); // LCOV_EXCL_LINE
<span class="lineNum">    2592 </span>            :             }
<span class="lineNum">    2593 </span>            :         }
<span class="lineNum">    2594 </span>            : 
<span class="lineNum">    2595 </span>            : scan_number_minus:
<span class="lineNum">    2596 </span>            :         // state: we just parsed a leading minus sign
<span class="lineNum">    2597 </span><span class="lineCov">          4 :         number_type = token_type::value_integer;</span>
<span class="lineNum">    2598 </span><span class="lineCov">          4 :         switch (get())</span>
<span class="lineNum">    2599 </span>            :         {
<span class="lineNum">    2600 </span>            :             case '0':
<span class="lineNum">    2601 </span>            :             {
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :                 goto scan_number_zero;</span>
<span class="lineNum">    2604 </span>            :             }
<span class="lineNum">    2605 </span>            : 
<span class="lineNum">    2606 </span>            :             case '1':
<span class="lineNum">    2607 </span>            :             case '2':
<span class="lineNum">    2608 </span>            :             case '3':
<span class="lineNum">    2609 </span>            :             case '4':
<span class="lineNum">    2610 </span>            :             case '5':
<span class="lineNum">    2611 </span>            :             case '6':
<span class="lineNum">    2612 </span>            :             case '7':
<span class="lineNum">    2613 </span>            :             case '8':
<span class="lineNum">    2614 </span>            :             case '9':
<span class="lineNum">    2615 </span>            :             {
<span class="lineNum">    2616 </span><span class="lineCov">          4 :                 add(current);</span>
<span class="lineNum">    2617 </span><span class="lineCov">          4 :                 goto scan_number_any1;</span>
<span class="lineNum">    2618 </span>            :             }
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span>            :             default:
<span class="lineNum">    2621 </span>            :             {
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :                 error_message = &quot;invalid number; expected digit after '-'&quot;;</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 :                 return token_type::parse_error;</span>
<span class="lineNum">    2624 </span>            :             }
<span class="lineNum">    2625 </span>            :         }
<span class="lineNum">    2626 </span>            : 
<span class="lineNum">    2627 </span>            : scan_number_zero:
<span class="lineNum">    2628 </span>            :         // state: we just parse a zero (maybe with a leading minus sign)
<span class="lineNum">    2629 </span><span class="lineCov">         18 :         switch (get())</span>
<span class="lineNum">    2630 </span>            :         {
<span class="lineNum">    2631 </span>            :             case '.':
<span class="lineNum">    2632 </span>            :             {
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :                 add(decimal_point_char);</span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :                 goto scan_number_decimal1;</span>
<span class="lineNum">    2635 </span>            :             }
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span>            :             case 'e':
<span class="lineNum">    2638 </span>            :             case 'E':
<span class="lineNum">    2639 </span>            :             {
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :                 goto scan_number_exponent;</span>
<span class="lineNum">    2642 </span>            :             }
<span class="lineNum">    2643 </span>            : 
<span class="lineNum">    2644 </span>            :             default:
<span class="lineNum">    2645 </span><span class="lineCov">         18 :                 goto scan_number_done;</span>
<span class="lineNum">    2646 </span>            :         }
<span class="lineNum">    2647 </span>            : 
<span class="lineNum">    2648 </span>            : scan_number_any1:
<span class="lineNum">    2649 </span>            :         // state: we just parsed a number 0-9 (maybe with a leading minus sign)
<span class="lineNum">    2650 </span><span class="lineCov">        368 :         switch (get())</span>
<span class="lineNum">    2651 </span>            :         {
<span class="lineNum">    2652 </span>            :             case '0':
<span class="lineNum">    2653 </span>            :             case '1':
<span class="lineNum">    2654 </span>            :             case '2':
<span class="lineNum">    2655 </span>            :             case '3':
<span class="lineNum">    2656 </span>            :             case '4':
<span class="lineNum">    2657 </span>            :             case '5':
<span class="lineNum">    2658 </span>            :             case '6':
<span class="lineNum">    2659 </span>            :             case '7':
<span class="lineNum">    2660 </span>            :             case '8':
<span class="lineNum">    2661 </span>            :             case '9':
<span class="lineNum">    2662 </span>            :             {
<span class="lineNum">    2663 </span><span class="lineCov">        161 :                 add(current);</span>
<span class="lineNum">    2664 </span><span class="lineCov">        161 :                 goto scan_number_any1;</span>
<span class="lineNum">    2665 </span>            :             }
<span class="lineNum">    2666 </span>            : 
<span class="lineNum">    2667 </span>            :             case '.':
<span class="lineNum">    2668 </span>            :             {
<span class="lineNum">    2669 </span><span class="lineCov">          1 :                 add(decimal_point_char);</span>
<span class="lineNum">    2670 </span><span class="lineCov">          1 :                 goto scan_number_decimal1;</span>
<span class="lineNum">    2671 </span>            :             }
<span class="lineNum">    2672 </span>            : 
<span class="lineNum">    2673 </span>            :             case 'e':
<span class="lineNum">    2674 </span>            :             case 'E':
<span class="lineNum">    2675 </span>            :             {
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :                 goto scan_number_exponent;</span>
<span class="lineNum">    2678 </span>            :             }
<span class="lineNum">    2679 </span>            : 
<span class="lineNum">    2680 </span>            :             default:
<span class="lineNum">    2681 </span><span class="lineCov">        206 :                 goto scan_number_done;</span>
<span class="lineNum">    2682 </span>            :         }
<span class="lineNum">    2683 </span>            : 
<span class="lineNum">    2684 </span>            : scan_number_decimal1:
<span class="lineNum">    2685 </span>            :         // state: we just parsed a decimal point
<span class="lineNum">    2686 </span><span class="lineCov">          1 :         number_type = token_type::value_float;</span>
<span class="lineNum">    2687 </span><span class="lineCov">          1 :         switch (get())</span>
<span class="lineNum">    2688 </span>            :         {
<span class="lineNum">    2689 </span>            :             case '0':
<span class="lineNum">    2690 </span>            :             case '1':
<span class="lineNum">    2691 </span>            :             case '2':
<span class="lineNum">    2692 </span>            :             case '3':
<span class="lineNum">    2693 </span>            :             case '4':
<span class="lineNum">    2694 </span>            :             case '5':
<span class="lineNum">    2695 </span>            :             case '6':
<span class="lineNum">    2696 </span>            :             case '7':
<span class="lineNum">    2697 </span>            :             case '8':
<span class="lineNum">    2698 </span>            :             case '9':
<span class="lineNum">    2699 </span>            :             {
<span class="lineNum">    2700 </span><span class="lineCov">          1 :                 add(current);</span>
<span class="lineNum">    2701 </span><span class="lineCov">          1 :                 goto scan_number_decimal2;</span>
<span class="lineNum">    2702 </span>            :             }
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span>            :             default:
<span class="lineNum">    2705 </span>            :             {
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :                 error_message = &quot;invalid number; expected digit after '.'&quot;;</span>
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :                 return token_type::parse_error;</span>
<span class="lineNum">    2708 </span>            :             }
<span class="lineNum">    2709 </span>            :         }
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            : scan_number_decimal2:
<span class="lineNum">    2712 </span>            :         // we just parsed at least one number after a decimal point
<span class="lineNum">    2713 </span><span class="lineCov">          1 :         switch (get())</span>
<span class="lineNum">    2714 </span>            :         {
<span class="lineNum">    2715 </span>            :             case '0':
<span class="lineNum">    2716 </span>            :             case '1':
<span class="lineNum">    2717 </span>            :             case '2':
<span class="lineNum">    2718 </span>            :             case '3':
<span class="lineNum">    2719 </span>            :             case '4':
<span class="lineNum">    2720 </span>            :             case '5':
<span class="lineNum">    2721 </span>            :             case '6':
<span class="lineNum">    2722 </span>            :             case '7':
<span class="lineNum">    2723 </span>            :             case '8':
<span class="lineNum">    2724 </span>            :             case '9':
<span class="lineNum">    2725 </span>            :             {
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :                 goto scan_number_decimal2;</span>
<span class="lineNum">    2728 </span>            :             }
<span class="lineNum">    2729 </span>            : 
<span class="lineNum">    2730 </span>            :             case 'e':
<span class="lineNum">    2731 </span>            :             case 'E':
<span class="lineNum">    2732 </span>            :             {
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :                 goto scan_number_exponent;</span>
<span class="lineNum">    2735 </span>            :             }
<span class="lineNum">    2736 </span>            : 
<span class="lineNum">    2737 </span>            :             default:
<span class="lineNum">    2738 </span><span class="lineCov">          1 :                 goto scan_number_done;</span>
<span class="lineNum">    2739 </span>            :         }
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span>            : scan_number_exponent:
<span class="lineNum">    2742 </span>            :         // we just parsed an exponent
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :         number_type = token_type::value_float;</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :         switch (get())</span>
<span class="lineNum">    2745 </span>            :         {
<span class="lineNum">    2746 </span>            :             case '+':
<span class="lineNum">    2747 </span>            :             case '-':
<span class="lineNum">    2748 </span>            :             {
<span class="lineNum">    2749 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :                 goto scan_number_sign;</span>
<span class="lineNum">    2751 </span>            :             }
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span>            :             case '0':
<span class="lineNum">    2754 </span>            :             case '1':
<span class="lineNum">    2755 </span>            :             case '2':
<span class="lineNum">    2756 </span>            :             case '3':
<span class="lineNum">    2757 </span>            :             case '4':
<span class="lineNum">    2758 </span>            :             case '5':
<span class="lineNum">    2759 </span>            :             case '6':
<span class="lineNum">    2760 </span>            :             case '7':
<span class="lineNum">    2761 </span>            :             case '8':
<span class="lineNum">    2762 </span>            :             case '9':
<span class="lineNum">    2763 </span>            :             {
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :                 goto scan_number_any2;</span>
<span class="lineNum">    2766 </span>            :             }
<span class="lineNum">    2767 </span>            : 
<span class="lineNum">    2768 </span>            :             default:
<span class="lineNum">    2769 </span>            :             {
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :                 error_message =</span>
<span class="lineNum">    2771 </span>            :                     &quot;invalid number; expected '+', '-', or digit after exponent&quot;;
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :                 return token_type::parse_error;</span>
<span class="lineNum">    2773 </span>            :             }
<span class="lineNum">    2774 </span>            :         }
<span class="lineNum">    2775 </span>            : 
<span class="lineNum">    2776 </span>            : scan_number_sign:
<span class="lineNum">    2777 </span>            :         // we just parsed an exponent sign
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :         switch (get())</span>
<span class="lineNum">    2779 </span>            :         {
<span class="lineNum">    2780 </span>            :             case '0':
<span class="lineNum">    2781 </span>            :             case '1':
<span class="lineNum">    2782 </span>            :             case '2':
<span class="lineNum">    2783 </span>            :             case '3':
<span class="lineNum">    2784 </span>            :             case '4':
<span class="lineNum">    2785 </span>            :             case '5':
<span class="lineNum">    2786 </span>            :             case '6':
<span class="lineNum">    2787 </span>            :             case '7':
<span class="lineNum">    2788 </span>            :             case '8':
<span class="lineNum">    2789 </span>            :             case '9':
<span class="lineNum">    2790 </span>            :             {
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :                 goto scan_number_any2;</span>
<span class="lineNum">    2793 </span>            :             }
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span>            :             default:
<span class="lineNum">    2796 </span>            :             {
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :                 error_message = &quot;invalid number; expected digit after exponent sign&quot;;</span>
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :                 return token_type::parse_error;</span>
<span class="lineNum">    2799 </span>            :             }
<span class="lineNum">    2800 </span>            :         }
<span class="lineNum">    2801 </span>            : 
<span class="lineNum">    2802 </span>            : scan_number_any2:
<span class="lineNum">    2803 </span>            :         // we just parsed a number after the exponent or exponent sign
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :         switch (get())</span>
<span class="lineNum">    2805 </span>            :         {
<span class="lineNum">    2806 </span>            :             case '0':
<span class="lineNum">    2807 </span>            :             case '1':
<span class="lineNum">    2808 </span>            :             case '2':
<span class="lineNum">    2809 </span>            :             case '3':
<span class="lineNum">    2810 </span>            :             case '4':
<span class="lineNum">    2811 </span>            :             case '5':
<span class="lineNum">    2812 </span>            :             case '6':
<span class="lineNum">    2813 </span>            :             case '7':
<span class="lineNum">    2814 </span>            :             case '8':
<span class="lineNum">    2815 </span>            :             case '9':
<span class="lineNum">    2816 </span>            :             {
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :                 add(current);</span>
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 :                 goto scan_number_any2;</span>
<span class="lineNum">    2819 </span>            :             }
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span>            :             default:
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :                 goto scan_number_done;</span>
<span class="lineNum">    2823 </span>            :         }
<span class="lineNum">    2824 </span>            : 
<span class="lineNum">    2825 </span>            : scan_number_done:
<span class="lineNum">    2826 </span>            :         // unget the character after the number (we only read it to know that
<span class="lineNum">    2827 </span>            :         // we are done scanning a number)
<span class="lineNum">    2828 </span><span class="lineCov">        225 :         unget();</span>
<span class="lineNum">    2829 </span>            : 
<span class="lineNum">    2830 </span><span class="lineCov">        225 :         char* endptr = nullptr;</span>
<span class="lineNum">    2831 </span><span class="lineCov">        225 :         errno = 0;</span>
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span>            :         // try to parse integers first and fall back to floats
<span class="lineNum">    2834 </span><span class="lineCov">        225 :         if (number_type == token_type::value_unsigned)</span>
<span class="lineNum">    2835 </span>            :         {
<span class="lineNum">    2836 </span><span class="lineCov">        220 :             const auto x = std::strtoull(token_buffer.data(), &amp;endptr, 10);</span>
<span class="lineNum">    2837 </span>            : 
<span class="lineNum">    2838 </span>            :             // we checked the number format before
<span class="lineNum">    2839 </span><span class="lineCov">        220 :             assert(endptr == token_buffer.data() + token_buffer.size());</span>
<span class="lineNum">    2840 </span>            : 
<span class="lineNum">    2841 </span><span class="lineCov">        220 :             if (errno == 0)</span>
<span class="lineNum">    2842 </span>            :             {
<span class="lineNum">    2843 </span><span class="lineCov">        220 :                 value_unsigned = static_cast&lt;number_unsigned_t&gt;(x);</span>
<span class="lineNum">    2844 </span><span class="lineCov">        220 :                 if (value_unsigned == x)</span>
<span class="lineNum">    2845 </span>            :                 {
<span class="lineNum">    2846 </span><span class="lineCov">        220 :                     return token_type::value_unsigned;</span>
<span class="lineNum">    2847 </span>            :                 }
<span class="lineNum">    2848 </span>            :             }
<span class="lineNum">    2849 </span>            :         }
<span class="lineNum">    2850 </span><span class="lineCov">          5 :         else if (number_type == token_type::value_integer)</span>
<span class="lineNum">    2851 </span>            :         {
<span class="lineNum">    2852 </span><span class="lineCov">          4 :             const auto x = std::strtoll(token_buffer.data(), &amp;endptr, 10);</span>
<span class="lineNum">    2853 </span>            : 
<span class="lineNum">    2854 </span>            :             // we checked the number format before
<span class="lineNum">    2855 </span><span class="lineCov">          4 :             assert(endptr == token_buffer.data() + token_buffer.size());</span>
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span><span class="lineCov">          4 :             if (errno == 0)</span>
<span class="lineNum">    2858 </span>            :             {
<span class="lineNum">    2859 </span><span class="lineCov">          4 :                 value_integer = static_cast&lt;number_integer_t&gt;(x);</span>
<span class="lineNum">    2860 </span><span class="lineCov">          4 :                 if (value_integer == x)</span>
<span class="lineNum">    2861 </span>            :                 {
<span class="lineNum">    2862 </span><span class="lineCov">          4 :                     return token_type::value_integer;</span>
<span class="lineNum">    2863 </span>            :                 }
<span class="lineNum">    2864 </span>            :             }
<span class="lineNum">    2865 </span>            :         }
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span>            :         // this code is reached if we parse a floating-point number or if an
<span class="lineNum">    2868 </span>            :         // integer conversion above failed
<span class="lineNum">    2869 </span><span class="lineCov">          1 :         strtof(value_float, token_buffer.data(), &amp;endptr);</span>
<span class="lineNum">    2870 </span>            : 
<span class="lineNum">    2871 </span>            :         // we checked the number format before
<span class="lineNum">    2872 </span><span class="lineCov">          1 :         assert(endptr == token_buffer.data() + token_buffer.size());</span>
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span><span class="lineCov">          1 :         return token_type::value_float;</span>
<span class="lineNum">    2875 </span>            :     }
<span class="lineNum">    2876 </span>            : 
<span class="lineNum">    2877 </span>            :     /*!
<span class="lineNum">    2878 </span>            :     @param[in] literal_text  the literal text to expect
<span class="lineNum">    2879 </span>            :     @param[in] length        the length of the passed literal text
<a name="2880"><span class="lineNum">    2880 </span>            :     @param[in] return_type   the token type to return on success</a>
<span class="lineNum">    2881 </span>            :     */
<span class="lineNum">    2882 </span><span class="lineCov">         13 :     token_type scan_literal(const char* literal_text, const std::size_t length,</span>
<span class="lineNum">    2883 </span>            :                             token_type return_type)
<span class="lineNum">    2884 </span>            :     {
<span class="lineNum">    2885 </span><span class="lineCov">         13 :         assert(current == literal_text[0]);</span>
<span class="lineNum">    2886 </span><span class="lineCov">         53 :         for (std::size_t i = 1; i &lt; length; ++i)</span>
<span class="lineNum">    2887 </span>            :         {
<span class="lineNum">    2888 </span><span class="lineCov">         40 :             if (JSON_UNLIKELY(get() != literal_text[i]))</span>
<span class="lineNum">    2889 </span>            :             {
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :                 error_message = &quot;invalid literal&quot;;</span>
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :                 return token_type::parse_error;</span>
<span class="lineNum">    2892 </span>            :             }
<span class="lineNum">    2893 </span>            :         }
<span class="lineNum">    2894 </span><span class="lineCov">         13 :         return return_type;</span>
<span class="lineNum">    2895 </span>            :     }
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span>            :     /////////////////////
<span class="lineNum">    2898 </span>            :     // input management
<span class="lineNum">    2899 </span>            :     /////////////////////
<a name="2900"><span class="lineNum">    2900 </span>            : </a>
<span class="lineNum">    2901 </span>            :     /// reset token_buffer; current character is beginning of token
<span class="lineNum">    2902 </span><span class="lineCov">        711 :     void reset() noexcept</span>
<span class="lineNum">    2903 </span>            :     {
<span class="lineNum">    2904 </span><span class="lineCov">        711 :         token_buffer.clear();</span>
<span class="lineNum">    2905 </span><span class="lineCov">        711 :         token_string.clear();</span>
<span class="lineNum">    2906 </span><span class="lineCov">        711 :         token_string.push_back(std::char_traits&lt;char&gt;::to_char_type(current));</span>
<span class="lineNum">    2907 </span><span class="lineCov">        711 :     }</span>
<span class="lineNum">    2908 </span>            : 
<span class="lineNum">    2909 </span>            :     /*
<span class="lineNum">    2910 </span>            :     @brief get next character from the input
<span class="lineNum">    2911 </span>            : 
<span class="lineNum">    2912 </span>            :     This function provides the interface to the used input adapter. It does
<span class="lineNum">    2913 </span>            :     not throw in case the input reached EOF, but returns a
<span class="lineNum">    2914 </span>            :     `std::char_traits&lt;char&gt;::eof()` in that case.  Stores the scanned characters
<span class="lineNum">    2915 </span>            :     for use in error messages.
<span class="lineNum">    2916 </span>            : 
<a name="2917"><span class="lineNum">    2917 </span>            :     @return character read from the input</a>
<span class="lineNum">    2918 </span>            :     */
<span class="lineNum">    2919 </span><span class="lineCov">       7155 :     std::char_traits&lt;char&gt;::int_type get()</span>
<span class="lineNum">    2920 </span>            :     {
<span class="lineNum">    2921 </span><span class="lineCov">       7155 :         ++chars_read;</span>
<span class="lineNum">    2922 </span><span class="lineCov">       7155 :         current = ia-&gt;get_character();</span>
<span class="lineNum">    2923 </span><span class="lineCov">       7155 :         if (JSON_LIKELY(current != std::char_traits&lt;char&gt;::eof()))</span>
<span class="lineNum">    2924 </span>            :         {
<span class="lineNum">    2925 </span><span class="lineCov">       7005 :             token_string.push_back(std::char_traits&lt;char&gt;::to_char_type(current));</span>
<span class="lineNum">    2926 </span>            :         }
<span class="lineNum">    2927 </span><span class="lineCov">       7155 :         return current;</span>
<span class="lineNum">    2928 </span>            :     }
<a name="2929"><span class="lineNum">    2929 </span>            : </a>
<span class="lineNum">    2930 </span>            :     /// unget current character (return it again on next get)
<span class="lineNum">    2931 </span><span class="lineCov">        225 :     void unget()</span>
<span class="lineNum">    2932 </span>            :     {
<span class="lineNum">    2933 </span><span class="lineCov">        225 :         --chars_read;</span>
<span class="lineNum">    2934 </span><span class="lineCov">        225 :         if (JSON_LIKELY(current != std::char_traits&lt;char&gt;::eof()))</span>
<span class="lineNum">    2935 </span>            :         {
<span class="lineNum">    2936 </span><span class="lineCov">        210 :             ia-&gt;unget_character();</span>
<span class="lineNum">    2937 </span><span class="lineCov">        210 :             assert(token_string.size() != 0);</span>
<span class="lineNum">    2938 </span><span class="lineCov">        210 :             token_string.pop_back();</span>
<span class="lineNum">    2939 </span>            :         }
<span class="lineNum">    2940 </span><span class="lineCov">        225 :     }</span>
<a name="2941"><span class="lineNum">    2941 </span>            : </a>
<span class="lineNum">    2942 </span>            :     /// add a character to token_buffer
<span class="lineNum">    2943 </span><span class="lineCov">       2983 :     void add(int c)</span>
<span class="lineNum">    2944 </span>            :     {
<span class="lineNum">    2945 </span><span class="lineCov">       2983 :         token_buffer.push_back(std::char_traits&lt;char&gt;::to_char_type(c));</span>
<span class="lineNum">    2946 </span><span class="lineCov">       2983 :     }</span>
<span class="lineNum">    2947 </span>            : 
<span class="lineNum">    2948 </span>            :   public:
<span class="lineNum">    2949 </span>            :     /////////////////////
<span class="lineNum">    2950 </span>            :     // value getters
<span class="lineNum">    2951 </span>            :     /////////////////////
<a name="2952"><span class="lineNum">    2952 </span>            : </a>
<span class="lineNum">    2953 </span>            :     /// return integer value
<span class="lineNum">    2954 </span><span class="lineCov">          4 :     constexpr number_integer_t get_number_integer() const noexcept</span>
<span class="lineNum">    2955 </span>            :     {
<span class="lineNum">    2956 </span><span class="lineCov">          4 :         return value_integer;</span>
<span class="lineNum">    2957 </span>            :     }
<a name="2958"><span class="lineNum">    2958 </span>            : </a>
<span class="lineNum">    2959 </span>            :     /// return unsigned integer value
<span class="lineNum">    2960 </span><span class="lineCov">        219 :     constexpr number_unsigned_t get_number_unsigned() const noexcept</span>
<span class="lineNum">    2961 </span>            :     {
<span class="lineNum">    2962 </span><span class="lineCov">        219 :         return value_unsigned;</span>
<span class="lineNum">    2963 </span>            :     }
<a name="2964"><span class="lineNum">    2964 </span>            : </a>
<span class="lineNum">    2965 </span>            :     /// return floating-point value
<span class="lineNum">    2966 </span><span class="lineCov">          1 :     constexpr number_float_t get_number_float() const noexcept</span>
<span class="lineNum">    2967 </span>            :     {
<span class="lineNum">    2968 </span><span class="lineCov">          1 :         return value_float;</span>
<span class="lineNum">    2969 </span>            :     }
<a name="2970"><span class="lineNum">    2970 </span>            : </a>
<span class="lineNum">    2971 </span>            :     /// return current string value (implicitly resets the token; useful only once)
<span class="lineNum">    2972 </span><span class="lineCov">        486 :     std::string move_string()</span>
<span class="lineNum">    2973 </span>            :     {
<span class="lineNum">    2974 </span><span class="lineCov">        486 :         return std::move(token_buffer);</span>
<span class="lineNum">    2975 </span>            :     }
<span class="lineNum">    2976 </span>            : 
<span class="lineNum">    2977 </span>            :     /////////////////////
<span class="lineNum">    2978 </span>            :     // diagnostics
<span class="lineNum">    2979 </span>            :     /////////////////////
<a name="2980"><span class="lineNum">    2980 </span>            : </a>
<span class="lineNum">    2981 </span>            :     /// return position of last read token
<span class="lineNum">    2982 </span><span class="lineCov">          2 :     constexpr std::size_t get_position() const noexcept</span>
<span class="lineNum">    2983 </span>            :     {
<span class="lineNum">    2984 </span><span class="lineCov">          2 :         return chars_read;</span>
<span class="lineNum">    2985 </span>            :     }
<span class="lineNum">    2986 </span>            : 
<span class="lineNum">    2987 </span>            :     /// return the last read token (for errors only).  Will never contain EOF
<a name="2988"><span class="lineNum">    2988 </span>            :     /// (an arbitrary value that is not a valid char value, often -1), because</a>
<span class="lineNum">    2989 </span>            :     /// 255 may legitimately occur.  May contain NUL, which should be escaped.
<span class="lineNum">    2990 </span><span class="lineCov">          2 :     std::string get_token_string() const</span>
<span class="lineNum">    2991 </span>            :     {
<span class="lineNum">    2992 </span>            :         // escape control characters
<span class="lineNum">    2993 </span><span class="lineCov">          2 :         std::string result;</span>
<span class="lineNum">    2994 </span><span class="lineCov">          4 :         for (const auto c : token_string)</span>
<span class="lineNum">    2995 </span>            :         {
<span class="lineNum">    2996 </span><span class="lineCov">          2 :             if ('\x00' &lt;= c and c &lt;= '\x1F')</span>
<span class="lineNum">    2997 </span>            :             {
<span class="lineNum">    2998 </span>            :                 // escape control characters
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :                 std::stringstream ss;</span>
<span class="lineNum">    3000 </span><span class="lineNoCov">          0 :                 ss &lt;&lt; &quot;&lt;U+&quot; &lt;&lt; std::setw(4) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0')</span>
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :                    &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; &quot;&gt;&quot;;</span>
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :                 result += ss.str();</span>
<span class="lineNum">    3003 </span>            :             }
<span class="lineNum">    3004 </span>            :             else
<span class="lineNum">    3005 </span>            :             {
<span class="lineNum">    3006 </span>            :                 // add character as is
<span class="lineNum">    3007 </span><span class="lineCov">          2 :                 result.push_back(c);</span>
<span class="lineNum">    3008 </span>            :             }
<span class="lineNum">    3009 </span>            :         }
<span class="lineNum">    3010 </span>            : 
<span class="lineNum">    3011 </span><span class="lineCov">          2 :         return result;</span>
<span class="lineNum">    3012 </span>            :     }
<a name="3013"><span class="lineNum">    3013 </span>            : </a>
<span class="lineNum">    3014 </span>            :     /// return syntax error message
<span class="lineNum">    3015 </span><span class="lineCov">          2 :     constexpr const char* get_error_message() const noexcept</span>
<span class="lineNum">    3016 </span>            :     {
<span class="lineNum">    3017 </span><span class="lineCov">          2 :         return error_message;</span>
<span class="lineNum">    3018 </span>            :     }
<span class="lineNum">    3019 </span>            : 
<span class="lineNum">    3020 </span>            :     /////////////////////
<span class="lineNum">    3021 </span>            :     // actual scanner
<a name="3022"><span class="lineNum">    3022 </span>            :     /////////////////////</a>
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span><span class="lineCov">       3646 :     token_type scan()</span>
<span class="lineNum">    3025 </span>            :     {
<span class="lineNum">    3026 </span>            :         // read next character and ignore whitespace
<span class="lineNum">    3027 </span><span class="lineCov">       1799 :         do</span>
<span class="lineNum">    3028 </span>            :         {
<span class="lineNum">    3029 </span><span class="lineCov">       3646 :             get();</span>
<span class="lineNum">    3030 </span>            :         }
<span class="lineNum">    3031 </span><span class="lineCov">       3646 :         while (current == ' ' or current == '\t' or current == '\n' or current == '\r');</span>
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineCov">       1847 :         switch (current)</span>
<span class="lineNum">    3034 </span>            :         {
<span class="lineNum">    3035 </span>            :             // structural characters
<span class="lineNum">    3036 </span>            :             case '[':
<span class="lineNum">    3037 </span><span class="lineCov">         70 :                 return token_type::begin_array;</span>
<span class="lineNum">    3038 </span>            :             case ']':
<span class="lineNum">    3039 </span><span class="lineCov">         69 :                 return token_type::end_array;</span>
<span class="lineNum">    3040 </span>            :             case '{':
<span class="lineNum">    3041 </span><span class="lineCov">        127 :                 return token_type::begin_object;</span>
<span class="lineNum">    3042 </span>            :             case '}':
<span class="lineNum">    3043 </span><span class="lineCov">        127 :                 return token_type::end_object;</span>
<span class="lineNum">    3044 </span>            :             case ':':
<span class="lineNum">    3045 </span><span class="lineCov">        320 :                 return token_type::name_separator;</span>
<span class="lineNum">    3046 </span>            :             case ',':
<span class="lineNum">    3047 </span><span class="lineCov">        264 :                 return token_type::value_separator;</span>
<span class="lineNum">    3048 </span>            : 
<span class="lineNum">    3049 </span>            :             // literals
<span class="lineNum">    3050 </span>            :             case 't':
<span class="lineNum">    3051 </span><span class="lineCov">         12 :                 return scan_literal(&quot;true&quot;, 4, token_type::literal_true);</span>
<span class="lineNum">    3052 </span>            :             case 'f':
<span class="lineNum">    3053 </span><span class="lineCov">          1 :                 return scan_literal(&quot;false&quot;, 5, token_type::literal_false);</span>
<span class="lineNum">    3054 </span>            :             case 'n':
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :                 return scan_literal(&quot;null&quot;, 4, token_type::literal_null);</span>
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span>            :             // string
<span class="lineNum">    3058 </span>            :             case '\&quot;':
<span class="lineNum">    3059 </span><span class="lineCov">        486 :                 return scan_string();</span>
<span class="lineNum">    3060 </span>            : 
<span class="lineNum">    3061 </span>            :             // number
<span class="lineNum">    3062 </span>            :             case '-':
<span class="lineNum">    3063 </span>            :             case '0':
<span class="lineNum">    3064 </span>            :             case '1':
<span class="lineNum">    3065 </span>            :             case '2':
<span class="lineNum">    3066 </span>            :             case '3':
<span class="lineNum">    3067 </span>            :             case '4':
<span class="lineNum">    3068 </span>            :             case '5':
<span class="lineNum">    3069 </span>            :             case '6':
<span class="lineNum">    3070 </span>            :             case '7':
<span class="lineNum">    3071 </span>            :             case '8':
<span class="lineNum">    3072 </span>            :             case '9':
<span class="lineNum">    3073 </span><span class="lineCov">        225 :                 return scan_number();</span>
<span class="lineNum">    3074 </span>            : 
<span class="lineNum">    3075 </span>            :             // end of input (the null byte is needed when parsing from
<span class="lineNum">    3076 </span>            :             // string literals)
<span class="lineNum">    3077 </span>            :             case '\0':
<span class="lineNum">    3078 </span>            :             case std::char_traits&lt;char&gt;::eof():
<span class="lineNum">    3079 </span><span class="lineCov">        142 :                 return token_type::end_of_input;</span>
<span class="lineNum">    3080 </span>            : 
<span class="lineNum">    3081 </span>            :             // error
<span class="lineNum">    3082 </span>            :             default:
<span class="lineNum">    3083 </span><span class="lineCov">          4 :                 error_message = &quot;invalid literal&quot;;</span>
<span class="lineNum">    3084 </span><span class="lineCov">          4 :                 return token_type::parse_error;</span>
<span class="lineNum">    3085 </span>            :         }
<span class="lineNum">    3086 </span>            :     }
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span>            :   private:
<span class="lineNum">    3089 </span>            :     /// input adapter
<span class="lineNum">    3090 </span>            :     detail::input_adapter_t ia = nullptr;
<span class="lineNum">    3091 </span>            : 
<span class="lineNum">    3092 </span>            :     /// the current character
<span class="lineNum">    3093 </span><span class="lineCov">        145 :     std::char_traits&lt;char&gt;::int_type current = std::char_traits&lt;char&gt;::eof();</span>
<span class="lineNum">    3094 </span>            : 
<span class="lineNum">    3095 </span>            :     /// the number of characters read
<span class="lineNum">    3096 </span>            :     std::size_t chars_read = 0;
<span class="lineNum">    3097 </span>            : 
<span class="lineNum">    3098 </span>            :     /// raw input token string (for error messages)
<span class="lineNum">    3099 </span>            :     std::vector&lt;char&gt; token_string {};
<span class="lineNum">    3100 </span>            : 
<span class="lineNum">    3101 </span>            :     /// buffer for variable-length tokens (numbers, strings)
<span class="lineNum">    3102 </span>            :     std::string token_buffer {};
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span>            :     /// a description of occurred lexer errors
<span class="lineNum">    3105 </span>            :     const char* error_message = &quot;&quot;;
<span class="lineNum">    3106 </span>            : 
<span class="lineNum">    3107 </span>            :     // number values
<span class="lineNum">    3108 </span>            :     number_integer_t value_integer = 0;
<span class="lineNum">    3109 </span>            :     number_unsigned_t value_unsigned = 0;
<span class="lineNum">    3110 </span>            :     number_float_t value_float = 0;
<span class="lineNum">    3111 </span>            : 
<span class="lineNum">    3112 </span>            :     /// the decimal point
<span class="lineNum">    3113 </span>            :     const char decimal_point_char = '.';
<span class="lineNum">    3114 </span>            : };
<span class="lineNum">    3115 </span>            : }
<span class="lineNum">    3116 </span>            : }
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span>            : // #include &lt;nlohmann/detail/input/parser.hpp&gt;
<span class="lineNum">    3119 </span>            : 
<span class="lineNum">    3120 </span>            : 
<span class="lineNum">    3121 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">    3122 </span>            : #include &lt;cmath&gt; // isfinite
<span class="lineNum">    3123 </span>            : #include &lt;cstdint&gt; // uint8_t
<span class="lineNum">    3124 </span>            : #include &lt;functional&gt; // function
<span class="lineNum">    3125 </span>            : #include &lt;string&gt; // string
<span class="lineNum">    3126 </span>            : #include &lt;utility&gt; // move
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">    3129 </span>            : 
<span class="lineNum">    3130 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    3131 </span>            : 
<span class="lineNum">    3132 </span>            : // #include &lt;nlohmann/detail/input/input_adapters.hpp&gt;
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span>            : // #include &lt;nlohmann/detail/input/lexer.hpp&gt;
<span class="lineNum">    3135 </span>            : 
<span class="lineNum">    3136 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span>            : 
<span class="lineNum">    3139 </span>            : namespace rockets_nlohmann
<span class="lineNum">    3140 </span>            : {
<span class="lineNum">    3141 </span>            : namespace detail
<span class="lineNum">    3142 </span>            : {
<span class="lineNum">    3143 </span>            : ////////////
<span class="lineNum">    3144 </span>            : // parser //
<span class="lineNum">    3145 </span>            : ////////////
<span class="lineNum">    3146 </span>            : 
<span class="lineNum">    3147 </span>            : /*!
<span class="lineNum">    3148 </span>            : @brief syntax analysis
<span class="lineNum">    3149 </span>            : 
<span class="lineNum">    3150 </span>            : This class implements a recursive decent parser.
<a name="3151"><span class="lineNum">    3151 </span>            : */</a>
<span class="lineNum">    3152 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    3153 </span><span class="lineCov">        145 : class parser</span>
<span class="lineNum">    3154 </span>            : {
<span class="lineNum">    3155 </span>            :     using number_integer_t = typename BasicJsonType::number_integer_t;
<span class="lineNum">    3156 </span>            :     using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
<span class="lineNum">    3157 </span>            :     using number_float_t = typename BasicJsonType::number_float_t;
<span class="lineNum">    3158 </span>            :     using lexer_t = lexer&lt;BasicJsonType&gt;;
<span class="lineNum">    3159 </span>            :     using token_type = typename lexer_t::token_type;
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span>            :   public:
<span class="lineNum">    3162 </span>            :     enum class parse_event_t : uint8_t
<span class="lineNum">    3163 </span>            :     {
<span class="lineNum">    3164 </span>            :         /// the parser read `{` and started to process a JSON object
<span class="lineNum">    3165 </span>            :         object_start,
<span class="lineNum">    3166 </span>            :         /// the parser read `}` and finished processing a JSON object
<span class="lineNum">    3167 </span>            :         object_end,
<span class="lineNum">    3168 </span>            :         /// the parser read `[` and started to process a JSON array
<span class="lineNum">    3169 </span>            :         array_start,
<span class="lineNum">    3170 </span>            :         /// the parser read `]` and finished processing a JSON array
<span class="lineNum">    3171 </span>            :         array_end,
<span class="lineNum">    3172 </span>            :         /// the parser read a key of a value in an object
<span class="lineNum">    3173 </span>            :         key,
<span class="lineNum">    3174 </span>            :         /// the parser finished reading a JSON value
<span class="lineNum">    3175 </span>            :         value
<span class="lineNum">    3176 </span>            :     };
<span class="lineNum">    3177 </span>            : 
<span class="lineNum">    3178 </span>            :     using parser_callback_t =
<span class="lineNum">    3179 </span>            :         std::function&lt;bool(int depth, parse_event_t event, BasicJsonType&amp; parsed)&gt;;
<a name="3180"><span class="lineNum">    3180 </span>            : </a>
<span class="lineNum">    3181 </span>            :     /// a parser reading from an input adapter
<span class="lineNum">    3182 </span><span class="lineCov">        145 :     explicit parser(detail::input_adapter_t adapter,</span>
<span class="lineNum">    3183 </span>            :                     const parser_callback_t cb = nullptr,
<span class="lineNum">    3184 </span>            :                     const bool allow_exceptions_ = true)
<span class="lineNum">    3185 </span><span class="lineCov">        145 :         : callback(cb), m_lexer(adapter), allow_exceptions(allow_exceptions_)</span>
<span class="lineNum">    3186 </span><span class="lineCov">        145 :     {}</span>
<span class="lineNum">    3187 </span>            : 
<span class="lineNum">    3188 </span>            :     /*!
<span class="lineNum">    3189 </span>            :     @brief public parser interface
<span class="lineNum">    3190 </span>            : 
<span class="lineNum">    3191 </span>            :     @param[in] strict      whether to expect the last token to be EOF
<span class="lineNum">    3192 </span>            :     @param[in,out] result  parsed JSON value
<span class="lineNum">    3193 </span>            : 
<span class="lineNum">    3194 </span>            :     @throw parse_error.101 in case of an unexpected token
<span class="lineNum">    3195 </span>            :     @throw parse_error.102 if to_unicode fails or surrogate error
<a name="3196"><span class="lineNum">    3196 </span>            :     @throw parse_error.103 if to_unicode fails</a>
<span class="lineNum">    3197 </span>            :     */
<span class="lineNum">    3198 </span><span class="lineCov">        145 :     void parse(const bool strict, BasicJsonType&amp; result)</span>
<span class="lineNum">    3199 </span>            :     {
<span class="lineNum">    3200 </span>            :         // read first token
<span class="lineNum">    3201 </span><span class="lineCov">        145 :         get_token();</span>
<span class="lineNum">    3202 </span>            : 
<span class="lineNum">    3203 </span><span class="lineCov">        145 :         parse_internal(true, result);</span>
<span class="lineNum">    3204 </span><span class="lineCov">        143 :         result.assert_invariant();</span>
<span class="lineNum">    3205 </span>            : 
<span class="lineNum">    3206 </span>            :         // in strict mode, input must be completely read
<span class="lineNum">    3207 </span><span class="lineCov">        143 :         if (strict)</span>
<span class="lineNum">    3208 </span>            :         {
<span class="lineNum">    3209 </span><span class="lineCov">        143 :             get_token();</span>
<span class="lineNum">    3210 </span><span class="lineCov">        143 :             expect(token_type::end_of_input);</span>
<span class="lineNum">    3211 </span>            :         }
<span class="lineNum">    3212 </span>            : 
<span class="lineNum">    3213 </span>            :         // in case of an error, return discarded value
<span class="lineNum">    3214 </span><span class="lineCov">        143 :         if (errored)</span>
<span class="lineNum">    3215 </span>            :         {
<span class="lineNum">    3216 </span><span class="lineCov">          3 :             result = value_t::discarded;</span>
<span class="lineNum">    3217 </span><span class="lineCov">          3 :             return;</span>
<span class="lineNum">    3218 </span>            :         }
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span>            :         // set top-level value to null if it was discarded by the callback
<span class="lineNum">    3221 </span>            :         // function
<span class="lineNum">    3222 </span><span class="lineCov">        140 :         if (result.is_discarded())</span>
<span class="lineNum">    3223 </span>            :         {
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :             result = nullptr;</span>
<span class="lineNum">    3225 </span>            :         }
<span class="lineNum">    3226 </span>            :     }
<span class="lineNum">    3227 </span>            : 
<span class="lineNum">    3228 </span>            :     /*!
<span class="lineNum">    3229 </span>            :     @brief public accept interface
<span class="lineNum">    3230 </span>            : 
<span class="lineNum">    3231 </span>            :     @param[in] strict  whether to expect the last token to be EOF
<span class="lineNum">    3232 </span>            :     @return whether the input is a proper JSON text
<span class="lineNum">    3233 </span>            :     */
<span class="lineNum">    3234 </span>            :     bool accept(const bool strict = true)
<span class="lineNum">    3235 </span>            :     {
<span class="lineNum">    3236 </span>            :         // read first token
<span class="lineNum">    3237 </span>            :         get_token();
<span class="lineNum">    3238 </span>            : 
<span class="lineNum">    3239 </span>            :         if (not accept_internal())
<span class="lineNum">    3240 </span>            :         {
<span class="lineNum">    3241 </span>            :             return false;
<span class="lineNum">    3242 </span>            :         }
<span class="lineNum">    3243 </span>            : 
<span class="lineNum">    3244 </span>            :         // strict =&gt; last token must be EOF
<span class="lineNum">    3245 </span>            :         return not strict or (get_token() == token_type::end_of_input);
<span class="lineNum">    3246 </span>            :     }
<span class="lineNum">    3247 </span>            : 
<span class="lineNum">    3248 </span>            :   private:
<span class="lineNum">    3249 </span>            :     /*!
<span class="lineNum">    3250 </span>            :     @brief the actual parser
<span class="lineNum">    3251 </span>            :     @throw parse_error.101 in case of an unexpected token
<span class="lineNum">    3252 </span>            :     @throw parse_error.102 if to_unicode fails or surrogate error
<a name="3253"><span class="lineNum">    3253 </span>            :     @throw parse_error.103 if to_unicode fails</a>
<span class="lineNum">    3254 </span>            :     */
<span class="lineNum">    3255 </span><span class="lineCov">        605 :     void parse_internal(bool keep, BasicJsonType&amp; result)</span>
<span class="lineNum">    3256 </span>            :     {
<span class="lineNum">    3257 </span>            :         // never parse after a parse error was detected
<span class="lineNum">    3258 </span><span class="lineCov">        605 :         assert(not errored);</span>
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span>            :         // start with a discarded value
<span class="lineNum">    3261 </span><span class="lineCov">        605 :         if (not result.is_discarded())</span>
<span class="lineNum">    3262 </span>            :         {
<span class="lineNum">    3263 </span><span class="lineCov">        145 :             result.m_value.destroy(result.m_type);</span>
<span class="lineNum">    3264 </span><span class="lineCov">        145 :             result.m_type = value_t::discarded;</span>
<span class="lineNum">    3265 </span>            :         }
<span class="lineNum">    3266 </span>            : 
<span class="lineNum">    3267 </span><span class="lineCov">        605 :         switch (last_token)</span>
<span class="lineNum">    3268 </span>            :         {
<span class="lineNum">    3269 </span>            :             case token_type::begin_object:
<span class="lineNum">    3270 </span>            :             {
<span class="lineNum">    3271 </span><span class="lineCov">        127 :                 if (keep)</span>
<span class="lineNum">    3272 </span>            :                 {
<span class="lineNum">    3273 </span><span class="lineCov">        127 :                     if (callback)</span>
<span class="lineNum">    3274 </span>            :                     {
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :                         keep = callback(depth++, parse_event_t::object_start, result);</span>
<span class="lineNum">    3276 </span>            :                     }
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span><span class="lineCov">        127 :                     if (not callback or keep)</span>
<span class="lineNum">    3279 </span>            :                     {
<span class="lineNum">    3280 </span>            :                         // explicitly set result to object to cope with {}
<span class="lineNum">    3281 </span><span class="lineCov">        127 :                         result.m_type = value_t::object;</span>
<span class="lineNum">    3282 </span><span class="lineCov">        127 :                         result.m_value = value_t::object;</span>
<span class="lineNum">    3283 </span>            :                     }
<span class="lineNum">    3284 </span>            :                 }
<span class="lineNum">    3285 </span>            : 
<span class="lineNum">    3286 </span>            :                 // read next token
<span class="lineNum">    3287 </span><span class="lineCov">        127 :                 get_token();</span>
<span class="lineNum">    3288 </span>            : 
<span class="lineNum">    3289 </span>            :                 // closing } -&gt; we are done
<span class="lineNum">    3290 </span><span class="lineCov">        127 :                 if (last_token == token_type::end_object)</span>
<span class="lineNum">    3291 </span>            :                 {
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :                     if (keep and callback and not callback(--depth, parse_event_t::object_end, result))</span>
<span class="lineNum">    3293 </span>            :                     {
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :                         result.m_value.destroy(result.m_type);</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :                         result.m_type = value_t::discarded;</span>
<span class="lineNum">    3296 </span>            :                     }
<span class="lineNum">    3297 </span><span class="lineCov">        127 :                     break;</span>
<span class="lineNum">    3298 </span>            :                 }
<span class="lineNum">    3299 </span>            : 
<span class="lineNum">    3300 </span>            :                 // parse values
<span class="lineNum">    3301 </span><span class="lineCov">        127 :                 std::string key;</span>
<span class="lineNum">    3302 </span><span class="lineCov">        127 :                 BasicJsonType value;</span>
<span class="lineNum">    3303 </span><span class="lineCov">        192 :                 while (true)</span>
<span class="lineNum">    3304 </span>            :                 {
<span class="lineNum">    3305 </span>            :                     // store key
<span class="lineNum">    3306 </span><span class="lineCov">        319 :                     if (not expect(token_type::value_string))</span>
<span class="lineNum">    3307 </span>            :                     {
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    3309 </span>            :                     }
<span class="lineNum">    3310 </span><span class="lineCov">        319 :                     key = m_lexer.move_string();</span>
<span class="lineNum">    3311 </span>            : 
<span class="lineNum">    3312 </span><span class="lineCov">        319 :                     bool keep_tag = false;</span>
<span class="lineNum">    3313 </span><span class="lineCov">        319 :                     if (keep)</span>
<span class="lineNum">    3314 </span>            :                     {
<span class="lineNum">    3315 </span><span class="lineCov">        319 :                         if (callback)</span>
<span class="lineNum">    3316 </span>            :                         {
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :                             BasicJsonType k(key);</span>
<span class="lineNum">    3318 </span><span class="lineNoCov">          0 :                             keep_tag = callback(depth, parse_event_t::key, k);</span>
<span class="lineNum">    3319 </span>            :                         }
<span class="lineNum">    3320 </span>            :                         else
<span class="lineNum">    3321 </span>            :                         {
<span class="lineNum">    3322 </span><span class="lineCov">        319 :                             keep_tag = true;</span>
<span class="lineNum">    3323 </span>            :                         }
<span class="lineNum">    3324 </span>            :                     }
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span>            :                     // parse separator (:)
<span class="lineNum">    3327 </span><span class="lineCov">        319 :                     get_token();</span>
<span class="lineNum">    3328 </span><span class="lineCov">        319 :                     if (not expect(token_type::name_separator))</span>
<span class="lineNum">    3329 </span>            :                     {
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    3331 </span>            :                     }
<span class="lineNum">    3332 </span>            : 
<span class="lineNum">    3333 </span>            :                     // parse and add value
<span class="lineNum">    3334 </span><span class="lineCov">        319 :                     get_token();</span>
<span class="lineNum">    3335 </span><span class="lineCov">        319 :                     value.m_value.destroy(value.m_type);</span>
<span class="lineNum">    3336 </span><span class="lineCov">        319 :                     value.m_type = value_t::discarded;</span>
<span class="lineNum">    3337 </span><span class="lineCov">        319 :                     parse_internal(keep, value);</span>
<span class="lineNum">    3338 </span>            : 
<span class="lineNum">    3339 </span><span class="lineCov">        319 :                     if (JSON_UNLIKELY(errored))</span>
<span class="lineNum">    3340 </span>            :                     {
<span class="lineNum">    3341 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    3342 </span>            :                     }
<span class="lineNum">    3343 </span>            : 
<span class="lineNum">    3344 </span><span class="lineCov">        319 :                     if (keep and keep_tag and not value.is_discarded())</span>
<span class="lineNum">    3345 </span>            :                     {
<span class="lineNum">    3346 </span><span class="lineCov">        319 :                         result.m_value.object-&gt;emplace(std::move(key), std::move(value));</span>
<span class="lineNum">    3347 </span>            :                     }
<span class="lineNum">    3348 </span>            : 
<span class="lineNum">    3349 </span>            :                     // comma -&gt; next value
<span class="lineNum">    3350 </span><span class="lineCov">        319 :                     get_token();</span>
<span class="lineNum">    3351 </span><span class="lineCov">        319 :                     if (last_token == token_type::value_separator)</span>
<span class="lineNum">    3352 </span>            :                     {
<span class="lineNum">    3353 </span><span class="lineCov">        192 :                         get_token();</span>
<span class="lineNum">    3354 </span><span class="lineCov">        192 :                         continue;</span>
<span class="lineNum">    3355 </span>            :                     }
<span class="lineNum">    3356 </span>            : 
<span class="lineNum">    3357 </span>            :                     // closing }
<span class="lineNum">    3358 </span><span class="lineCov">        127 :                     if (not expect(token_type::end_object))</span>
<span class="lineNum">    3359 </span>            :                     {
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    3361 </span>            :                     }
<span class="lineNum">    3362 </span><span class="lineCov">        127 :                     break;</span>
<span class="lineNum">    3363 </span>            :                 }
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span><span class="lineCov">        127 :                 if (keep and callback and not callback(--depth, parse_event_t::object_end, result))</span>
<span class="lineNum">    3366 </span>            :                 {
<span class="lineNum">    3367 </span><span class="lineNoCov">          0 :                     result.m_value.destroy(result.m_type);</span>
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :                     result.m_type = value_t::discarded;</span>
<span class="lineNum">    3369 </span>            :                 }
<span class="lineNum">    3370 </span><span class="lineCov">        127 :                 break;</span>
<span class="lineNum">    3371 </span>            :             }
<span class="lineNum">    3372 </span>            : 
<span class="lineNum">    3373 </span>            :             case token_type::begin_array:
<span class="lineNum">    3374 </span>            :             {
<span class="lineNum">    3375 </span><span class="lineCov">         70 :                 if (keep)</span>
<span class="lineNum">    3376 </span>            :                 {
<span class="lineNum">    3377 </span><span class="lineCov">         70 :                     if (callback)</span>
<span class="lineNum">    3378 </span>            :                     {
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :                         keep = callback(depth++, parse_event_t::array_start, result);</span>
<span class="lineNum">    3380 </span>            :                     }
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span><span class="lineCov">         70 :                     if (not callback or keep)</span>
<span class="lineNum">    3383 </span>            :                     {
<span class="lineNum">    3384 </span>            :                         // explicitly set result to array to cope with []
<span class="lineNum">    3385 </span><span class="lineCov">         70 :                         result.m_type = value_t::array;</span>
<span class="lineNum">    3386 </span><span class="lineCov">         70 :                         result.m_value = value_t::array;</span>
<span class="lineNum">    3387 </span>            :                     }
<span class="lineNum">    3388 </span>            :                 }
<span class="lineNum">    3389 </span>            : 
<span class="lineNum">    3390 </span>            :                 // read next token
<span class="lineNum">    3391 </span><span class="lineCov">         70 :                 get_token();</span>
<span class="lineNum">    3392 </span>            : 
<span class="lineNum">    3393 </span>            :                 // closing ] -&gt; we are done
<span class="lineNum">    3394 </span><span class="lineCov">         70 :                 if (last_token == token_type::end_array)</span>
<span class="lineNum">    3395 </span>            :                 {
<span class="lineNum">    3396 </span><span class="lineCov">          1 :                     if (callback and not callback(--depth, parse_event_t::array_end, result))</span>
<span class="lineNum">    3397 </span>            :                     {
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :                         result.m_value.destroy(result.m_type);</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :                         result.m_type = value_t::discarded;</span>
<span class="lineNum">    3400 </span>            :                     }
<span class="lineNum">    3401 </span><span class="lineCov">         70 :                     break;</span>
<span class="lineNum">    3402 </span>            :                 }
<span class="lineNum">    3403 </span>            : 
<span class="lineNum">    3404 </span>            :                 // parse values
<span class="lineNum">    3405 </span><span class="lineCov">         69 :                 BasicJsonType value;</span>
<span class="lineNum">    3406 </span>            :                 while (true)
<span class="lineNum">    3407 </span>            :                 {
<span class="lineNum">    3408 </span>            :                     // parse value
<span class="lineNum">    3409 </span><span class="lineCov">        213 :                     value.m_value.destroy(value.m_type);</span>
<span class="lineNum">    3410 </span><span class="lineCov">        141 :                     value.m_type = value_t::discarded;</span>
<span class="lineNum">    3411 </span><span class="lineCov">        141 :                     parse_internal(keep, value);</span>
<span class="lineNum">    3412 </span>            : 
<span class="lineNum">    3413 </span><span class="lineCov">        141 :                     if (JSON_UNLIKELY(errored))</span>
<span class="lineNum">    3414 </span>            :                     {
<span class="lineNum">    3415 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    3416 </span>            :                     }
<span class="lineNum">    3417 </span>            : 
<span class="lineNum">    3418 </span><span class="lineCov">        141 :                     if (keep and not value.is_discarded())</span>
<span class="lineNum">    3419 </span>            :                     {
<span class="lineNum">    3420 </span><span class="lineCov">        141 :                         result.m_value.array-&gt;push_back(std::move(value));</span>
<span class="lineNum">    3421 </span>            :                     }
<span class="lineNum">    3422 </span>            : 
<span class="lineNum">    3423 </span>            :                     // comma -&gt; next value
<span class="lineNum">    3424 </span><span class="lineCov">        141 :                     get_token();</span>
<span class="lineNum">    3425 </span><span class="lineCov">        141 :                     if (last_token == token_type::value_separator)</span>
<span class="lineNum">    3426 </span>            :                     {
<span class="lineNum">    3427 </span><span class="lineCov">         72 :                         get_token();</span>
<span class="lineNum">    3428 </span><span class="lineCov">         72 :                         continue;</span>
<span class="lineNum">    3429 </span>            :                     }
<span class="lineNum">    3430 </span>            : 
<span class="lineNum">    3431 </span>            :                     // closing ]
<span class="lineNum">    3432 </span><span class="lineCov">         69 :                     if (not expect(token_type::end_array))</span>
<span class="lineNum">    3433 </span>            :                     {
<span class="lineNum">    3434 </span><span class="lineCov">          1 :                         return;</span>
<span class="lineNum">    3435 </span>            :                     }
<span class="lineNum">    3436 </span><span class="lineCov">         68 :                     break;</span>
<span class="lineNum">    3437 </span>            :                 }
<span class="lineNum">    3438 </span>            : 
<span class="lineNum">    3439 </span><span class="lineCov">         68 :                 if (keep and callback and not callback(--depth, parse_event_t::array_end, result))</span>
<span class="lineNum">    3440 </span>            :                 {
<span class="lineNum">    3441 </span><span class="lineNoCov">          0 :                     result.m_value.destroy(result.m_type);</span>
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :                     result.m_type = value_t::discarded;</span>
<span class="lineNum">    3443 </span>            :                 }
<span class="lineNum">    3444 </span><span class="lineCov">         68 :                 break;</span>
<span class="lineNum">    3445 </span>            :             }
<span class="lineNum">    3446 </span>            : 
<span class="lineNum">    3447 </span>            :             case token_type::literal_null:
<span class="lineNum">    3448 </span>            :             {
<span class="lineNum">    3449 </span><span class="lineNoCov">          0 :                 result.m_type = value_t::null;</span>
<span class="lineNum">    3450 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3451 </span>            :             }
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span>            :             case token_type::value_string:
<span class="lineNum">    3454 </span>            :             {
<span class="lineNum">    3455 </span><span class="lineCov">        167 :                 result.m_type = value_t::string;</span>
<span class="lineNum">    3456 </span><span class="lineCov">        167 :                 result.m_value = m_lexer.move_string();</span>
<span class="lineNum">    3457 </span><span class="lineCov">        167 :                 break;</span>
<span class="lineNum">    3458 </span>            :             }
<span class="lineNum">    3459 </span>            : 
<span class="lineNum">    3460 </span>            :             case token_type::literal_true:
<span class="lineNum">    3461 </span>            :             {
<span class="lineNum">    3462 </span><span class="lineCov">         12 :                 result.m_type = value_t::boolean;</span>
<span class="lineNum">    3463 </span><span class="lineCov">         12 :                 result.m_value = true;</span>
<span class="lineNum">    3464 </span><span class="lineCov">         12 :                 break;</span>
<span class="lineNum">    3465 </span>            :             }
<span class="lineNum">    3466 </span>            : 
<span class="lineNum">    3467 </span>            :             case token_type::literal_false:
<span class="lineNum">    3468 </span>            :             {
<span class="lineNum">    3469 </span><span class="lineCov">          1 :                 result.m_type = value_t::boolean;</span>
<span class="lineNum">    3470 </span><span class="lineCov">          1 :                 result.m_value = false;</span>
<span class="lineNum">    3471 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3472 </span>            :             }
<span class="lineNum">    3473 </span>            : 
<span class="lineNum">    3474 </span>            :             case token_type::value_unsigned:
<span class="lineNum">    3475 </span>            :             {
<span class="lineNum">    3476 </span><span class="lineCov">        219 :                 result.m_type = value_t::number_unsigned;</span>
<span class="lineNum">    3477 </span><span class="lineCov">        219 :                 result.m_value = m_lexer.get_number_unsigned();</span>
<span class="lineNum">    3478 </span><span class="lineCov">        219 :                 break;</span>
<span class="lineNum">    3479 </span>            :             }
<span class="lineNum">    3480 </span>            : 
<span class="lineNum">    3481 </span>            :             case token_type::value_integer:
<span class="lineNum">    3482 </span>            :             {
<span class="lineNum">    3483 </span><span class="lineCov">          4 :                 result.m_type = value_t::number_integer;</span>
<span class="lineNum">    3484 </span><span class="lineCov">          4 :                 result.m_value = m_lexer.get_number_integer();</span>
<span class="lineNum">    3485 </span><span class="lineCov">          4 :                 break;</span>
<span class="lineNum">    3486 </span>            :             }
<span class="lineNum">    3487 </span>            : 
<span class="lineNum">    3488 </span>            :             case token_type::value_float:
<span class="lineNum">    3489 </span>            :             {
<span class="lineNum">    3490 </span><span class="lineCov">          1 :                 result.m_type = value_t::number_float;</span>
<span class="lineNum">    3491 </span><span class="lineCov">          1 :                 result.m_value = m_lexer.get_number_float();</span>
<span class="lineNum">    3492 </span>            : 
<span class="lineNum">    3493 </span>            :                 // throw in case of infinity or NAN
<span class="lineNum">    3494 </span><span class="lineCov">          1 :                 if (JSON_UNLIKELY(not std::isfinite(result.m_value.number_float)))</span>
<span class="lineNum">    3495 </span>            :                 {
<span class="lineNum">    3496 </span><span class="lineNoCov">          0 :                     if (allow_exceptions)</span>
<span class="lineNum">    3497 </span>            :                     {
<span class="lineNum">    3498 </span><span class="lineNoCov">          0 :                         JSON_THROW(out_of_range::create(406, &quot;number overflow parsing '&quot; +</span>
<span class="lineNum">    3499 </span>            :                                                         m_lexer.get_token_string() + &quot;'&quot;));
<span class="lineNum">    3500 </span>            :                     }
<span class="lineNum">    3501 </span><span class="lineNoCov">          0 :                     expect(token_type::uninitialized);</span>
<span class="lineNum">    3502 </span>            :                 }
<span class="lineNum">    3503 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3504 </span>            :             }
<span class="lineNum">    3505 </span>            : 
<span class="lineNum">    3506 </span>            :             case token_type::parse_error:
<span class="lineNum">    3507 </span>            :             {
<span class="lineNum">    3508 </span>            :                 // using &quot;uninitialized&quot; to avoid &quot;expected&quot; message
<span class="lineNum">    3509 </span><span class="lineCov">          3 :                 if (not expect(token_type::uninitialized))</span>
<span class="lineNum">    3510 </span>            :                 {
<span class="lineNum">    3511 </span><span class="lineCov">          1 :                     return;</span>
<span class="lineNum">    3512 </span>            :                 }
<span class="lineNum">    3513 </span>            :                 break; // LCOV_EXCL_LINE
<span class="lineNum">    3514 </span>            :             }
<span class="lineNum">    3515 </span>            : 
<span class="lineNum">    3516 </span>            :             default:
<span class="lineNum">    3517 </span>            :             {
<span class="lineNum">    3518 </span>            :                 // the last token was unexpected; we expected a value
<span class="lineNum">    3519 </span><span class="lineCov">          1 :                 if (not expect(token_type::literal_or_value))</span>
<span class="lineNum">    3520 </span>            :                 {
<span class="lineNum">    3521 </span><span class="lineCov">          1 :                     return;</span>
<span class="lineNum">    3522 </span>            :                 }
<span class="lineNum">    3523 </span>            :                 break; // LCOV_EXCL_LINE
<span class="lineNum">    3524 </span>            :             }
<span class="lineNum">    3525 </span>            :         }
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span><span class="lineCov">        600 :         if (keep and callback and not callback(depth, parse_event_t::value, result))</span>
<span class="lineNum">    3528 </span>            :         {
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 :             result.m_type = value_t::discarded;</span>
<span class="lineNum">    3530 </span>            :         }
<span class="lineNum">    3531 </span>            :     }
<span class="lineNum">    3532 </span>            : 
<span class="lineNum">    3533 </span>            :     /*!
<span class="lineNum">    3534 </span>            :     @brief the actual acceptor
<span class="lineNum">    3535 </span>            : 
<span class="lineNum">    3536 </span>            :     @invariant 1. The last token is not yet processed. Therefore, the caller
<span class="lineNum">    3537 </span>            :                   of this function must make sure a token has been read.
<span class="lineNum">    3538 </span>            :                2. When this function returns, the last token is processed.
<span class="lineNum">    3539 </span>            :                   That is, the last read character was already considered.
<span class="lineNum">    3540 </span>            : 
<span class="lineNum">    3541 </span>            :     This invariant makes sure that no token needs to be &quot;unput&quot;.
<span class="lineNum">    3542 </span>            :     */
<span class="lineNum">    3543 </span>            :     bool accept_internal()
<span class="lineNum">    3544 </span>            :     {
<span class="lineNum">    3545 </span>            :         switch (last_token)
<span class="lineNum">    3546 </span>            :         {
<span class="lineNum">    3547 </span>            :             case token_type::begin_object:
<span class="lineNum">    3548 </span>            :             {
<span class="lineNum">    3549 </span>            :                 // read next token
<span class="lineNum">    3550 </span>            :                 get_token();
<span class="lineNum">    3551 </span>            : 
<span class="lineNum">    3552 </span>            :                 // closing } -&gt; we are done
<span class="lineNum">    3553 </span>            :                 if (last_token == token_type::end_object)
<span class="lineNum">    3554 </span>            :                 {
<span class="lineNum">    3555 </span>            :                     return true;
<span class="lineNum">    3556 </span>            :                 }
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span>            :                 // parse values
<span class="lineNum">    3559 </span>            :                 while (true)
<span class="lineNum">    3560 </span>            :                 {
<span class="lineNum">    3561 </span>            :                     // parse key
<span class="lineNum">    3562 </span>            :                     if (last_token != token_type::value_string)
<span class="lineNum">    3563 </span>            :                     {
<span class="lineNum">    3564 </span>            :                         return false;
<span class="lineNum">    3565 </span>            :                     }
<span class="lineNum">    3566 </span>            : 
<span class="lineNum">    3567 </span>            :                     // parse separator (:)
<span class="lineNum">    3568 </span>            :                     get_token();
<span class="lineNum">    3569 </span>            :                     if (last_token != token_type::name_separator)
<span class="lineNum">    3570 </span>            :                     {
<span class="lineNum">    3571 </span>            :                         return false;
<span class="lineNum">    3572 </span>            :                     }
<span class="lineNum">    3573 </span>            : 
<span class="lineNum">    3574 </span>            :                     // parse value
<span class="lineNum">    3575 </span>            :                     get_token();
<span class="lineNum">    3576 </span>            :                     if (not accept_internal())
<span class="lineNum">    3577 </span>            :                     {
<span class="lineNum">    3578 </span>            :                         return false;
<span class="lineNum">    3579 </span>            :                     }
<span class="lineNum">    3580 </span>            : 
<span class="lineNum">    3581 </span>            :                     // comma -&gt; next value
<span class="lineNum">    3582 </span>            :                     get_token();
<span class="lineNum">    3583 </span>            :                     if (last_token == token_type::value_separator)
<span class="lineNum">    3584 </span>            :                     {
<span class="lineNum">    3585 </span>            :                         get_token();
<span class="lineNum">    3586 </span>            :                         continue;
<span class="lineNum">    3587 </span>            :                     }
<span class="lineNum">    3588 </span>            : 
<span class="lineNum">    3589 </span>            :                     // closing }
<span class="lineNum">    3590 </span>            :                     return (last_token == token_type::end_object);
<span class="lineNum">    3591 </span>            :                 }
<span class="lineNum">    3592 </span>            :             }
<span class="lineNum">    3593 </span>            : 
<span class="lineNum">    3594 </span>            :             case token_type::begin_array:
<span class="lineNum">    3595 </span>            :             {
<span class="lineNum">    3596 </span>            :                 // read next token
<span class="lineNum">    3597 </span>            :                 get_token();
<span class="lineNum">    3598 </span>            : 
<span class="lineNum">    3599 </span>            :                 // closing ] -&gt; we are done
<span class="lineNum">    3600 </span>            :                 if (last_token == token_type::end_array)
<span class="lineNum">    3601 </span>            :                 {
<span class="lineNum">    3602 </span>            :                     return true;
<span class="lineNum">    3603 </span>            :                 }
<span class="lineNum">    3604 </span>            : 
<span class="lineNum">    3605 </span>            :                 // parse values
<span class="lineNum">    3606 </span>            :                 while (true)
<span class="lineNum">    3607 </span>            :                 {
<span class="lineNum">    3608 </span>            :                     // parse value
<span class="lineNum">    3609 </span>            :                     if (not accept_internal())
<span class="lineNum">    3610 </span>            :                     {
<span class="lineNum">    3611 </span>            :                         return false;
<span class="lineNum">    3612 </span>            :                     }
<span class="lineNum">    3613 </span>            : 
<span class="lineNum">    3614 </span>            :                     // comma -&gt; next value
<span class="lineNum">    3615 </span>            :                     get_token();
<span class="lineNum">    3616 </span>            :                     if (last_token == token_type::value_separator)
<span class="lineNum">    3617 </span>            :                     {
<span class="lineNum">    3618 </span>            :                         get_token();
<span class="lineNum">    3619 </span>            :                         continue;
<span class="lineNum">    3620 </span>            :                     }
<span class="lineNum">    3621 </span>            : 
<span class="lineNum">    3622 </span>            :                     // closing ]
<span class="lineNum">    3623 </span>            :                     return (last_token == token_type::end_array);
<span class="lineNum">    3624 </span>            :                 }
<span class="lineNum">    3625 </span>            :             }
<span class="lineNum">    3626 </span>            : 
<span class="lineNum">    3627 </span>            :             case token_type::value_float:
<span class="lineNum">    3628 </span>            :             {
<span class="lineNum">    3629 </span>            :                 // reject infinity or NAN
<span class="lineNum">    3630 </span>            :                 return std::isfinite(m_lexer.get_number_float());
<span class="lineNum">    3631 </span>            :             }
<span class="lineNum">    3632 </span>            : 
<span class="lineNum">    3633 </span>            :             case token_type::literal_false:
<span class="lineNum">    3634 </span>            :             case token_type::literal_null:
<span class="lineNum">    3635 </span>            :             case token_type::literal_true:
<span class="lineNum">    3636 </span>            :             case token_type::value_integer:
<span class="lineNum">    3637 </span>            :             case token_type::value_string:
<span class="lineNum">    3638 </span>            :             case token_type::value_unsigned:
<span class="lineNum">    3639 </span>            :                 return true;
<span class="lineNum">    3640 </span>            : 
<span class="lineNum">    3641 </span>            :             default: // the last token was unexpected
<span class="lineNum">    3642 </span>            :                 return false;
<span class="lineNum">    3643 </span>            :         }
<span class="lineNum">    3644 </span>            :     }
<a name="3645"><span class="lineNum">    3645 </span>            : </a>
<span class="lineNum">    3646 </span>            :     /// get next token from lexer
<span class="lineNum">    3647 </span><span class="lineCov">       1847 :     token_type get_token()</span>
<span class="lineNum">    3648 </span>            :     {
<span class="lineNum">    3649 </span><span class="lineCov">       1847 :         return (last_token = m_lexer.scan());</span>
<span class="lineNum">    3650 </span>            :     }
<span class="lineNum">    3651 </span>            : 
<span class="lineNum">    3652 </span>            :     /*!
<a name="3653"><span class="lineNum">    3653 </span>            :     @throw parse_error.101 if expected token did not occur</a>
<span class="lineNum">    3654 </span>            :     */
<span class="lineNum">    3655 </span><span class="lineCov">        981 :     bool expect(token_type t)</span>
<span class="lineNum">    3656 </span>            :     {
<span class="lineNum">    3657 </span><span class="lineCov">        981 :         if (JSON_UNLIKELY(t != last_token))</span>
<span class="lineNum">    3658 </span>            :         {
<span class="lineNum">    3659 </span><span class="lineCov">          7 :             errored = true;</span>
<span class="lineNum">    3660 </span><span class="lineCov">          7 :             expected = t;</span>
<span class="lineNum">    3661 </span><span class="lineCov">          7 :             if (allow_exceptions)</span>
<span class="lineNum">    3662 </span>            :             {
<span class="lineNum">    3663 </span><span class="lineCov">          2 :                 throw_exception();</span>
<span class="lineNum">    3664 </span>            :             }
<span class="lineNum">    3665 </span>            :             else
<span class="lineNum">    3666 </span>            :             {
<span class="lineNum">    3667 </span><span class="lineCov">          5 :                 return false;</span>
<span class="lineNum">    3668 </span>            :             }
<span class="lineNum">    3669 </span>            :         }
<span class="lineNum">    3670 </span>            : 
<span class="lineNum">    3671 </span><span class="lineCov">        974 :         return true;</span>
<a name="3672"><span class="lineNum">    3672 </span>            :     }</a>
<span class="lineNum">    3673 </span>            : 
<span class="lineNum">    3674 </span><span class="lineCov">          2 :     [[noreturn]] void throw_exception() const</span>
<span class="lineNum">    3675 </span>            :     {
<span class="lineNum">    3676 </span><span class="lineCov">          4 :         std::string error_msg = &quot;syntax error - &quot;;</span>
<span class="lineNum">    3677 </span><span class="lineCov">          2 :         if (last_token == token_type::parse_error)</span>
<span class="lineNum">    3678 </span>            :         {
<span class="lineNum">    3679 </span><span class="lineCov">          2 :             error_msg += std::string(m_lexer.get_error_message()) + &quot;; last read: '&quot; +</span>
<span class="lineNum">    3680 </span>            :                          m_lexer.get_token_string() + &quot;'&quot;;
<span class="lineNum">    3681 </span>            :         }
<span class="lineNum">    3682 </span>            :         else
<span class="lineNum">    3683 </span>            :         {
<span class="lineNum">    3684 </span><span class="lineNoCov">          0 :             error_msg += &quot;unexpected &quot; + std::string(lexer_t::token_type_name(last_token));</span>
<span class="lineNum">    3685 </span>            :         }
<span class="lineNum">    3686 </span>            : 
<span class="lineNum">    3687 </span><span class="lineCov">          2 :         if (expected != token_type::uninitialized)</span>
<span class="lineNum">    3688 </span>            :         {
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :             error_msg += &quot;; expected &quot; + std::string(lexer_t::token_type_name(expected));</span>
<span class="lineNum">    3690 </span>            :         }
<span class="lineNum">    3691 </span>            : 
<span class="lineNum">    3692 </span><span class="lineCov">          2 :         JSON_THROW(parse_error::create(101, m_lexer.get_position(), error_msg));</span>
<span class="lineNum">    3693 </span>            :     }
<span class="lineNum">    3694 </span>            : 
<span class="lineNum">    3695 </span>            :   private:
<span class="lineNum">    3696 </span>            :     /// current level of recursion
<span class="lineNum">    3697 </span>            :     int depth = 0;
<span class="lineNum">    3698 </span>            :     /// callback function
<span class="lineNum">    3699 </span>            :     const parser_callback_t callback = nullptr;
<span class="lineNum">    3700 </span>            :     /// the type of the last read token
<span class="lineNum">    3701 </span>            :     token_type last_token = token_type::uninitialized;
<span class="lineNum">    3702 </span>            :     /// the lexer
<span class="lineNum">    3703 </span>            :     lexer_t m_lexer;
<span class="lineNum">    3704 </span>            :     /// whether a syntax error occurred
<span class="lineNum">    3705 </span>            :     bool errored = false;
<span class="lineNum">    3706 </span>            :     /// possible reason for the syntax error
<span class="lineNum">    3707 </span>            :     token_type expected = token_type::uninitialized;
<span class="lineNum">    3708 </span>            :     /// whether to throw exceptions in case of errors
<span class="lineNum">    3709 </span>            :     const bool allow_exceptions = true;
<span class="lineNum">    3710 </span>            : };
<span class="lineNum">    3711 </span>            : }
<span class="lineNum">    3712 </span>            : }
<span class="lineNum">    3713 </span>            : 
<span class="lineNum">    3714 </span>            : // #include &lt;nlohmann/detail/iterators/primitive_iterator.hpp&gt;
<span class="lineNum">    3715 </span>            : 
<span class="lineNum">    3716 </span>            : 
<span class="lineNum">    3717 </span>            : #include &lt;cstddef&gt; // ptrdiff_t
<span class="lineNum">    3718 </span>            : #include &lt;limits&gt;  // numeric_limits
<span class="lineNum">    3719 </span>            : 
<span class="lineNum">    3720 </span>            : namespace rockets_nlohmann
<span class="lineNum">    3721 </span>            : {
<span class="lineNum">    3722 </span>            : namespace detail
<span class="lineNum">    3723 </span>            : {
<span class="lineNum">    3724 </span>            : /*
<span class="lineNum">    3725 </span>            : @brief an iterator for primitive JSON types
<span class="lineNum">    3726 </span>            : 
<span class="lineNum">    3727 </span>            : This class models an iterator for primitive JSON types (boolean, number,
<span class="lineNum">    3728 </span>            : string). It's only purpose is to allow the iterator/const_iterator classes
<span class="lineNum">    3729 </span>            : to &quot;iterate&quot; over primitive values. Internally, the iterator is modeled by
<span class="lineNum">    3730 </span>            : a `difference_type` variable. Value begin_value (`0`) models the begin,
<a name="3731"><span class="lineNum">    3731 </span>            : end_value (`1`) models past the end.</a>
<span class="lineNum">    3732 </span>            : */
<span class="lineNum">    3733 </span><span class="lineCov">        212 : class primitive_iterator_t</span>
<span class="lineNum">    3734 </span>            : {
<span class="lineNum">    3735 </span>            :   private:
<span class="lineNum">    3736 </span>            :     using difference_type = std::ptrdiff_t;
<span class="lineNum">    3737 </span>            :     static constexpr difference_type begin_value = 0;
<span class="lineNum">    3738 </span>            :     static constexpr difference_type end_value = begin_value + 1;
<span class="lineNum">    3739 </span>            : 
<span class="lineNum">    3740 </span>            :     /// iterator as signed integer type
<span class="lineNum">    3741 </span><span class="lineCov">        106 :     difference_type m_it = (std::numeric_limits&lt;std::ptrdiff_t&gt;::min)();</span>
<span class="lineNum">    3742 </span>            : 
<span class="lineNum">    3743 </span>            :   public:
<span class="lineNum">    3744 </span>            :     constexpr difference_type get_value() const noexcept
<span class="lineNum">    3745 </span>            :     {
<span class="lineNum">    3746 </span>            :         return m_it;
<span class="lineNum">    3747 </span>            :     }
<a name="3748"><span class="lineNum">    3748 </span>            : </a>
<span class="lineNum">    3749 </span>            :     /// set iterator to a defined beginning
<span class="lineNum">    3750 </span><span class="lineNoCov">          0 :     void set_begin() noexcept</span>
<span class="lineNum">    3751 </span>            :     {
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :         m_it = begin_value;</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :     }</span>
<a name="3754"><span class="lineNum">    3754 </span>            : </a>
<span class="lineNum">    3755 </span>            :     /// set iterator to a defined past the end
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :     void set_end() noexcept</span>
<span class="lineNum">    3757 </span>            :     {
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :         m_it = end_value;</span>
<span class="lineNum">    3759 </span><span class="lineNoCov">          0 :     }</span>
<a name="3760"><span class="lineNum">    3760 </span>            : </a>
<span class="lineNum">    3761 </span>            :     /// return whether the iterator can be dereferenced
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 :     constexpr bool is_begin() const noexcept</span>
<span class="lineNum">    3763 </span>            :     {
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :         return m_it == begin_value;</span>
<span class="lineNum">    3765 </span>            :     }
<span class="lineNum">    3766 </span>            : 
<span class="lineNum">    3767 </span>            :     /// return whether the iterator is at end
<span class="lineNum">    3768 </span>            :     constexpr bool is_end() const noexcept
<span class="lineNum">    3769 </span>            :     {
<span class="lineNum">    3770 </span>            :         return m_it == end_value;
<a name="3771"><span class="lineNum">    3771 </span>            :     }</a>
<span class="lineNum">    3772 </span>            : 
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 :     friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept</span>
<span class="lineNum">    3774 </span>            :     {
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :         return lhs.m_it == rhs.m_it;</span>
<span class="lineNum">    3776 </span>            :     }
<span class="lineNum">    3777 </span>            : 
<span class="lineNum">    3778 </span>            :     friend constexpr bool operator&lt;(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
<span class="lineNum">    3779 </span>            :     {
<span class="lineNum">    3780 </span>            :         return lhs.m_it &lt; rhs.m_it;
<span class="lineNum">    3781 </span>            :     }
<span class="lineNum">    3782 </span>            : 
<span class="lineNum">    3783 </span>            :     primitive_iterator_t operator+(difference_type n) noexcept
<span class="lineNum">    3784 </span>            :     {
<span class="lineNum">    3785 </span>            :         auto result = *this;
<span class="lineNum">    3786 </span>            :         result += n;
<span class="lineNum">    3787 </span>            :         return result;
<span class="lineNum">    3788 </span>            :     }
<span class="lineNum">    3789 </span>            : 
<span class="lineNum">    3790 </span>            :     friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
<span class="lineNum">    3791 </span>            :     {
<span class="lineNum">    3792 </span>            :         return lhs.m_it - rhs.m_it;
<a name="3793"><span class="lineNum">    3793 </span>            :     }</a>
<span class="lineNum">    3794 </span>            : 
<span class="lineNum">    3795 </span><span class="lineNoCov">          0 :     primitive_iterator_t&amp; operator++() noexcept</span>
<span class="lineNum">    3796 </span>            :     {
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :         ++m_it;</span>
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :         return *this;</span>
<span class="lineNum">    3799 </span>            :     }
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span>            :     primitive_iterator_t const operator++(int) noexcept
<span class="lineNum">    3802 </span>            :     {
<span class="lineNum">    3803 </span>            :         auto result = *this;
<span class="lineNum">    3804 </span>            :         m_it++;
<span class="lineNum">    3805 </span>            :         return result;
<span class="lineNum">    3806 </span>            :     }
<span class="lineNum">    3807 </span>            : 
<span class="lineNum">    3808 </span>            :     primitive_iterator_t&amp; operator--() noexcept
<span class="lineNum">    3809 </span>            :     {
<span class="lineNum">    3810 </span>            :         --m_it;
<span class="lineNum">    3811 </span>            :         return *this;
<span class="lineNum">    3812 </span>            :     }
<span class="lineNum">    3813 </span>            : 
<span class="lineNum">    3814 </span>            :     primitive_iterator_t const operator--(int) noexcept
<span class="lineNum">    3815 </span>            :     {
<span class="lineNum">    3816 </span>            :         auto result = *this;
<span class="lineNum">    3817 </span>            :         m_it--;
<span class="lineNum">    3818 </span>            :         return result;
<span class="lineNum">    3819 </span>            :     }
<span class="lineNum">    3820 </span>            : 
<span class="lineNum">    3821 </span>            :     primitive_iterator_t&amp; operator+=(difference_type n) noexcept
<span class="lineNum">    3822 </span>            :     {
<span class="lineNum">    3823 </span>            :         m_it += n;
<span class="lineNum">    3824 </span>            :         return *this;
<span class="lineNum">    3825 </span>            :     }
<span class="lineNum">    3826 </span>            : 
<span class="lineNum">    3827 </span>            :     primitive_iterator_t&amp; operator-=(difference_type n) noexcept
<span class="lineNum">    3828 </span>            :     {
<span class="lineNum">    3829 </span>            :         m_it -= n;
<span class="lineNum">    3830 </span>            :         return *this;
<span class="lineNum">    3831 </span>            :     }
<span class="lineNum">    3832 </span>            : };
<span class="lineNum">    3833 </span>            : }
<span class="lineNum">    3834 </span>            : }
<span class="lineNum">    3835 </span>            : 
<span class="lineNum">    3836 </span>            : // #include &lt;nlohmann/detail/iterators/internal_iterator.hpp&gt;
<span class="lineNum">    3837 </span>            : 
<span class="lineNum">    3838 </span>            : 
<span class="lineNum">    3839 </span>            : // #include &lt;nlohmann/detail/iterators/primitive_iterator.hpp&gt;
<span class="lineNum">    3840 </span>            : 
<span class="lineNum">    3841 </span>            : 
<span class="lineNum">    3842 </span>            : namespace rockets_nlohmann
<span class="lineNum">    3843 </span>            : {
<span class="lineNum">    3844 </span>            : namespace detail
<span class="lineNum">    3845 </span>            : {
<span class="lineNum">    3846 </span>            : /*!
<span class="lineNum">    3847 </span>            : @brief an iterator value
<span class="lineNum">    3848 </span>            : 
<span class="lineNum">    3849 </span>            : @note This structure could easily be a union, but MSVC currently does not allow
<a name="3850"><span class="lineNum">    3850 </span>            : unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.</a>
<span class="lineNum">    3851 </span>            : */
<span class="lineNum">    3852 </span><span class="lineCov">        106 : template&lt;typename BasicJsonType&gt; struct internal_iterator</span>
<span class="lineNum">    3853 </span>            : {
<span class="lineNum">    3854 </span>            :     /// iterator for JSON objects
<span class="lineNum">    3855 </span>            :     typename BasicJsonType::object_t::iterator object_iterator {};
<span class="lineNum">    3856 </span>            :     /// iterator for JSON arrays
<span class="lineNum">    3857 </span>            :     typename BasicJsonType::array_t::iterator array_iterator {};
<span class="lineNum">    3858 </span>            :     /// generic iterator for all other types
<span class="lineNum">    3859 </span>            :     primitive_iterator_t primitive_iterator {};
<span class="lineNum">    3860 </span>            : };
<span class="lineNum">    3861 </span>            : }
<span class="lineNum">    3862 </span>            : }
<span class="lineNum">    3863 </span>            : 
<span class="lineNum">    3864 </span>            : // #include &lt;nlohmann/detail/iterators/iter_impl.hpp&gt;
<span class="lineNum">    3865 </span>            : 
<span class="lineNum">    3866 </span>            : 
<span class="lineNum">    3867 </span>            : #include &lt;ciso646&gt; // not
<span class="lineNum">    3868 </span>            : #include &lt;iterator&gt; // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
<span class="lineNum">    3869 </span>            : #include &lt;type_traits&gt; // conditional, is_const, remove_const
<span class="lineNum">    3870 </span>            : 
<span class="lineNum">    3871 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">    3872 </span>            : 
<span class="lineNum">    3873 </span>            : // #include &lt;nlohmann/detail/iterators/internal_iterator.hpp&gt;
<span class="lineNum">    3874 </span>            : 
<span class="lineNum">    3875 </span>            : // #include &lt;nlohmann/detail/iterators/primitive_iterator.hpp&gt;
<span class="lineNum">    3876 </span>            : 
<span class="lineNum">    3877 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    3878 </span>            : 
<span class="lineNum">    3879 </span>            : // #include &lt;nlohmann/detail/meta.hpp&gt;
<span class="lineNum">    3880 </span>            : 
<span class="lineNum">    3881 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    3882 </span>            : 
<span class="lineNum">    3883 </span>            : 
<span class="lineNum">    3884 </span>            : namespace rockets_nlohmann
<span class="lineNum">    3885 </span>            : {
<span class="lineNum">    3886 </span>            : namespace detail
<span class="lineNum">    3887 </span>            : {
<span class="lineNum">    3888 </span>            : // forward declare, to be able to friend it later on
<span class="lineNum">    3889 </span>            : template&lt;typename IteratorType&gt; class iteration_proxy;
<span class="lineNum">    3890 </span>            : 
<span class="lineNum">    3891 </span>            : /*!
<span class="lineNum">    3892 </span>            : @brief a template for a bidirectional iterator for the @ref basic_json class
<span class="lineNum">    3893 </span>            : 
<span class="lineNum">    3894 </span>            : This class implements a both iterators (iterator and const_iterator) for the
<span class="lineNum">    3895 </span>            : @ref basic_json class.
<span class="lineNum">    3896 </span>            : 
<span class="lineNum">    3897 </span>            : @note An iterator is called *initialized* when a pointer to a JSON value has
<span class="lineNum">    3898 </span>            :       been set (e.g., by a constructor or a copy assignment). If the iterator is
<span class="lineNum">    3899 </span>            :       default-constructed, it is *uninitialized* and most methods are undefined.
<span class="lineNum">    3900 </span>            :       **The library uses assertions to detect calls on uninitialized iterators.**
<span class="lineNum">    3901 </span>            : 
<span class="lineNum">    3902 </span>            : @requirement The class satisfies the following concept requirements:
<span class="lineNum">    3903 </span>            : -
<span class="lineNum">    3904 </span>            : [BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):
<span class="lineNum">    3905 </span>            :   The iterator that can be moved can be moved in both directions (i.e.
<span class="lineNum">    3906 </span>            :   incremented and decremented).
<span class="lineNum">    3907 </span>            : 
<span class="lineNum">    3908 </span>            : @since version 1.0.0, simplified in version 2.0.9, change to bidirectional
<span class="lineNum">    3909 </span>            :        iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
<span class="lineNum">    3910 </span>            : */
<span class="lineNum">    3911 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    3912 </span>            : class iter_impl
<span class="lineNum">    3913 </span>            : {
<span class="lineNum">    3914 </span>            :     /// allow basic_json to access private members
<span class="lineNum">    3915 </span>            :     friend iter_impl&lt;typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value, typename std::remove_const&lt;BasicJsonType&gt;::type, const BasicJsonType&gt;::type&gt;;
<span class="lineNum">    3916 </span>            :     friend BasicJsonType;
<span class="lineNum">    3917 </span>            :     friend iteration_proxy&lt;iter_impl&gt;;
<span class="lineNum">    3918 </span>            : 
<span class="lineNum">    3919 </span>            :     using object_t = typename BasicJsonType::object_t;
<span class="lineNum">    3920 </span>            :     using array_t = typename BasicJsonType::array_t;
<span class="lineNum">    3921 </span>            :     // make sure BasicJsonType is basic_json or const basic_json
<span class="lineNum">    3922 </span>            :     static_assert(is_basic_json&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;::value,
<span class="lineNum">    3923 </span>            :                   &quot;iter_impl only accepts (const) basic_json&quot;);
<span class="lineNum">    3924 </span>            : 
<span class="lineNum">    3925 </span>            :   public:
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span>            :     /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
<span class="lineNum">    3928 </span>            :     /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
<span class="lineNum">    3929 </span>            :     /// A user-defined iterator should provide publicly accessible typedefs named
<span class="lineNum">    3930 </span>            :     /// iterator_category, value_type, difference_type, pointer, and reference.
<span class="lineNum">    3931 </span>            :     /// Note that value_type is required to be non-const, even for constant iterators.
<span class="lineNum">    3932 </span>            :     using iterator_category = std::bidirectional_iterator_tag;
<span class="lineNum">    3933 </span>            : 
<span class="lineNum">    3934 </span>            :     /// the type of the values when the iterator is dereferenced
<span class="lineNum">    3935 </span>            :     using value_type = typename BasicJsonType::value_type;
<span class="lineNum">    3936 </span>            :     /// a type to represent differences between iterators
<span class="lineNum">    3937 </span>            :     using difference_type = typename BasicJsonType::difference_type;
<span class="lineNum">    3938 </span>            :     /// defines a pointer to the type iterated over (value_type)
<span class="lineNum">    3939 </span>            :     using pointer = typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value,
<span class="lineNum">    3940 </span>            :           typename BasicJsonType::const_pointer,
<span class="lineNum">    3941 </span>            :           typename BasicJsonType::pointer&gt;::type;
<span class="lineNum">    3942 </span>            :     /// defines a reference to the type iterated over (value_type)
<span class="lineNum">    3943 </span>            :     using reference =
<span class="lineNum">    3944 </span>            :         typename std::conditional&lt;std::is_const&lt;BasicJsonType&gt;::value,
<span class="lineNum">    3945 </span>            :         typename BasicJsonType::const_reference,
<span class="lineNum">    3946 </span>            :         typename BasicJsonType::reference&gt;::type;
<span class="lineNum">    3947 </span>            : 
<span class="lineNum">    3948 </span>            :     /// default constructor
<span class="lineNum">    3949 </span>            :     iter_impl() = default;
<span class="lineNum">    3950 </span>            : 
<span class="lineNum">    3951 </span>            :     /*!
<span class="lineNum">    3952 </span>            :     @brief constructor for a given JSON instance
<span class="lineNum">    3953 </span>            :     @param[in] object  pointer to a JSON object for this iterator
<span class="lineNum">    3954 </span>            :     @pre object != nullptr
<a name="3955"><span class="lineNum">    3955 </span>            :     @post The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    3956 </span>            :     */
<span class="lineNum">    3957 </span><span class="lineCov">        106 :     explicit iter_impl(pointer object) noexcept : m_object(object)</span>
<span class="lineNum">    3958 </span>            :     {
<span class="lineNum">    3959 </span><span class="lineCov">        106 :         assert(m_object != nullptr);</span>
<span class="lineNum">    3960 </span>            : 
<span class="lineNum">    3961 </span><span class="lineCov">        106 :         switch (m_object-&gt;m_type)</span>
<span class="lineNum">    3962 </span>            :         {
<span class="lineNum">    3963 </span>            :             case value_t::object:
<span class="lineNum">    3964 </span>            :             {
<span class="lineNum">    3965 </span><span class="lineCov">         96 :                 m_it.object_iterator = typename object_t::iterator();</span>
<span class="lineNum">    3966 </span><span class="lineCov">         96 :                 break;</span>
<span class="lineNum">    3967 </span>            :             }
<span class="lineNum">    3968 </span>            : 
<span class="lineNum">    3969 </span>            :             case value_t::array:
<span class="lineNum">    3970 </span>            :             {
<span class="lineNum">    3971 </span><span class="lineCov">         10 :                 m_it.array_iterator = typename array_t::iterator();</span>
<span class="lineNum">    3972 </span><span class="lineCov">         10 :                 break;</span>
<span class="lineNum">    3973 </span>            :             }
<span class="lineNum">    3974 </span>            : 
<span class="lineNum">    3975 </span>            :             default:
<span class="lineNum">    3976 </span>            :             {
<span class="lineNum">    3977 </span><span class="lineNoCov">          0 :                 m_it.primitive_iterator = primitive_iterator_t();</span>
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3979 </span>            :             }
<span class="lineNum">    3980 </span>            :         }
<span class="lineNum">    3981 </span><span class="lineCov">        106 :     }</span>
<span class="lineNum">    3982 </span>            : 
<span class="lineNum">    3983 </span>            :     /*!
<span class="lineNum">    3984 </span>            :     @note The conventional copy constructor and copy assignment are implicitly
<span class="lineNum">    3985 </span>            :           defined. Combined with the following converting constructor and
<span class="lineNum">    3986 </span>            :           assignment, they support: (1) copy from iterator to iterator, (2)
<span class="lineNum">    3987 </span>            :           copy from const iterator to const iterator, and (3) conversion from
<span class="lineNum">    3988 </span>            :           iterator to const iterator. However conversion from const iterator
<span class="lineNum">    3989 </span>            :           to iterator is not defined.
<span class="lineNum">    3990 </span>            :     */
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span>            :     /*!
<span class="lineNum">    3993 </span>            :     @brief converting constructor
<span class="lineNum">    3994 </span>            :     @param[in] other  non-const iterator to copy from
<span class="lineNum">    3995 </span>            :     @note It is not checked whether @a other is initialized.
<span class="lineNum">    3996 </span>            :     */
<span class="lineNum">    3997 </span>            :     iter_impl(const iter_impl&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;&amp; other) noexcept
<span class="lineNum">    3998 </span>            :         : m_object(other.m_object), m_it(other.m_it) {}
<span class="lineNum">    3999 </span>            : 
<span class="lineNum">    4000 </span>            :     /*!
<span class="lineNum">    4001 </span>            :     @brief converting assignment
<span class="lineNum">    4002 </span>            :     @param[in,out] other  non-const iterator to copy from
<span class="lineNum">    4003 </span>            :     @return const/non-const iterator
<span class="lineNum">    4004 </span>            :     @note It is not checked whether @a other is initialized.
<span class="lineNum">    4005 </span>            :     */
<span class="lineNum">    4006 </span>            :     iter_impl&amp; operator=(const iter_impl&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt;&amp; other) noexcept
<span class="lineNum">    4007 </span>            :     {
<span class="lineNum">    4008 </span>            :         m_object = other.m_object;
<span class="lineNum">    4009 </span>            :         m_it = other.m_it;
<span class="lineNum">    4010 </span>            :         return *this;
<span class="lineNum">    4011 </span>            :     }
<span class="lineNum">    4012 </span>            : 
<span class="lineNum">    4013 </span>            :   private:
<span class="lineNum">    4014 </span>            :     /*!
<span class="lineNum">    4015 </span>            :     @brief set the iterator to the first value
<a name="4016"><span class="lineNum">    4016 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    4017 </span>            :     */
<span class="lineNum">    4018 </span><span class="lineCov">          5 :     void set_begin() noexcept</span>
<span class="lineNum">    4019 </span>            :     {
<span class="lineNum">    4020 </span><span class="lineCov">          5 :         assert(m_object != nullptr);</span>
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span><span class="lineCov">          5 :         switch (m_object-&gt;m_type)</span>
<span class="lineNum">    4023 </span>            :         {
<span class="lineNum">    4024 </span>            :             case value_t::object:
<span class="lineNum">    4025 </span>            :             {
<span class="lineNum">    4026 </span><span class="lineNoCov">          0 :                 m_it.object_iterator = m_object-&gt;m_value.object-&gt;begin();</span>
<span class="lineNum">    4027 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4028 </span>            :             }
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span>            :             case value_t::array:
<span class="lineNum">    4031 </span>            :             {
<span class="lineNum">    4032 </span><span class="lineCov">          5 :                 m_it.array_iterator = m_object-&gt;m_value.array-&gt;begin();</span>
<span class="lineNum">    4033 </span><span class="lineCov">          5 :                 break;</span>
<span class="lineNum">    4034 </span>            :             }
<span class="lineNum">    4035 </span>            : 
<span class="lineNum">    4036 </span>            :             case value_t::null:
<span class="lineNum">    4037 </span>            :             {
<span class="lineNum">    4038 </span>            :                 // set to end so begin()==end() is true: null is empty
<span class="lineNum">    4039 </span><span class="lineNoCov">          0 :                 m_it.primitive_iterator.set_end();</span>
<span class="lineNum">    4040 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4041 </span>            :             }
<span class="lineNum">    4042 </span>            : 
<span class="lineNum">    4043 </span>            :             default:
<span class="lineNum">    4044 </span>            :             {
<span class="lineNum">    4045 </span><span class="lineNoCov">          0 :                 m_it.primitive_iterator.set_begin();</span>
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4047 </span>            :             }
<span class="lineNum">    4048 </span>            :         }
<span class="lineNum">    4049 </span><span class="lineCov">          5 :     }</span>
<span class="lineNum">    4050 </span>            : 
<span class="lineNum">    4051 </span>            :     /*!
<span class="lineNum">    4052 </span>            :     @brief set the iterator past the last value
<a name="4053"><span class="lineNum">    4053 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    4054 </span>            :     */
<span class="lineNum">    4055 </span><span class="lineCov">        101 :     void set_end() noexcept</span>
<span class="lineNum">    4056 </span>            :     {
<span class="lineNum">    4057 </span><span class="lineCov">        101 :         assert(m_object != nullptr);</span>
<span class="lineNum">    4058 </span>            : 
<span class="lineNum">    4059 </span><span class="lineCov">        101 :         switch (m_object-&gt;m_type)</span>
<span class="lineNum">    4060 </span>            :         {
<span class="lineNum">    4061 </span>            :             case value_t::object:
<span class="lineNum">    4062 </span>            :             {
<span class="lineNum">    4063 </span><span class="lineCov">         96 :                 m_it.object_iterator = m_object-&gt;m_value.object-&gt;end();</span>
<span class="lineNum">    4064 </span><span class="lineCov">         96 :                 break;</span>
<span class="lineNum">    4065 </span>            :             }
<span class="lineNum">    4066 </span>            : 
<span class="lineNum">    4067 </span>            :             case value_t::array:
<span class="lineNum">    4068 </span>            :             {
<span class="lineNum">    4069 </span><span class="lineCov">          5 :                 m_it.array_iterator = m_object-&gt;m_value.array-&gt;end();</span>
<span class="lineNum">    4070 </span><span class="lineCov">          5 :                 break;</span>
<span class="lineNum">    4071 </span>            :             }
<span class="lineNum">    4072 </span>            : 
<span class="lineNum">    4073 </span>            :             default:
<span class="lineNum">    4074 </span>            :             {
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :                 m_it.primitive_iterator.set_end();</span>
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4077 </span>            :             }
<span class="lineNum">    4078 </span>            :         }
<span class="lineNum">    4079 </span><span class="lineCov">        101 :     }</span>
<span class="lineNum">    4080 </span>            : 
<span class="lineNum">    4081 </span>            :   public:
<span class="lineNum">    4082 </span>            :     /*!
<span class="lineNum">    4083 </span>            :     @brief return a reference to the value pointed to by the iterator
<a name="4084"><span class="lineNum">    4084 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    4085 </span>            :     */
<span class="lineNum">    4086 </span><span class="lineCov">         12 :     reference operator*() const</span>
<span class="lineNum">    4087 </span>            :     {
<span class="lineNum">    4088 </span><span class="lineCov">         12 :         assert(m_object != nullptr);</span>
<span class="lineNum">    4089 </span>            : 
<span class="lineNum">    4090 </span><span class="lineCov">         12 :         switch (m_object-&gt;m_type)</span>
<span class="lineNum">    4091 </span>            :         {
<span class="lineNum">    4092 </span>            :             case value_t::object:
<span class="lineNum">    4093 </span>            :             {
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :                 assert(m_it.object_iterator != m_object-&gt;m_value.object-&gt;end());</span>
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 :                 return m_it.object_iterator-&gt;second;</span>
<span class="lineNum">    4096 </span>            :             }
<span class="lineNum">    4097 </span>            : 
<span class="lineNum">    4098 </span>            :             case value_t::array:
<span class="lineNum">    4099 </span>            :             {
<span class="lineNum">    4100 </span><span class="lineCov">         12 :                 assert(m_it.array_iterator != m_object-&gt;m_value.array-&gt;end());</span>
<span class="lineNum">    4101 </span><span class="lineCov">         12 :                 return *m_it.array_iterator;</span>
<span class="lineNum">    4102 </span>            :             }
<span class="lineNum">    4103 </span>            : 
<span class="lineNum">    4104 </span>            :             case value_t::null:
<span class="lineNum">    4105 </span><span class="lineNoCov">          0 :                 JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;));</span>
<span class="lineNum">    4106 </span>            : 
<span class="lineNum">    4107 </span>            :             default:
<span class="lineNum">    4108 </span>            :             {
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :                 if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))</span>
<span class="lineNum">    4110 </span>            :                 {
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :                     return *m_object;</span>
<span class="lineNum">    4112 </span>            :                 }
<span class="lineNum">    4113 </span>            : 
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :                 JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;));</span>
<span class="lineNum">    4115 </span>            :             }
<span class="lineNum">    4116 </span>            :         }
<span class="lineNum">    4117 </span>            :     }
<span class="lineNum">    4118 </span>            : 
<span class="lineNum">    4119 </span>            :     /*!
<span class="lineNum">    4120 </span>            :     @brief dereference the iterator
<span class="lineNum">    4121 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4122 </span>            :     */
<span class="lineNum">    4123 </span>            :     pointer operator-&gt;() const
<span class="lineNum">    4124 </span>            :     {
<span class="lineNum">    4125 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span>            :         switch (m_object-&gt;m_type)
<span class="lineNum">    4128 </span>            :         {
<span class="lineNum">    4129 </span>            :             case value_t::object:
<span class="lineNum">    4130 </span>            :             {
<span class="lineNum">    4131 </span>            :                 assert(m_it.object_iterator != m_object-&gt;m_value.object-&gt;end());
<span class="lineNum">    4132 </span>            :                 return &amp;(m_it.object_iterator-&gt;second);
<span class="lineNum">    4133 </span>            :             }
<span class="lineNum">    4134 </span>            : 
<span class="lineNum">    4135 </span>            :             case value_t::array:
<span class="lineNum">    4136 </span>            :             {
<span class="lineNum">    4137 </span>            :                 assert(m_it.array_iterator != m_object-&gt;m_value.array-&gt;end());
<span class="lineNum">    4138 </span>            :                 return &amp;*m_it.array_iterator;
<span class="lineNum">    4139 </span>            :             }
<span class="lineNum">    4140 </span>            : 
<span class="lineNum">    4141 </span>            :             default:
<span class="lineNum">    4142 </span>            :             {
<span class="lineNum">    4143 </span>            :                 if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
<span class="lineNum">    4144 </span>            :                 {
<span class="lineNum">    4145 </span>            :                     return m_object;
<span class="lineNum">    4146 </span>            :                 }
<span class="lineNum">    4147 </span>            : 
<span class="lineNum">    4148 </span>            :                 JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;));
<span class="lineNum">    4149 </span>            :             }
<span class="lineNum">    4150 </span>            :         }
<span class="lineNum">    4151 </span>            :     }
<span class="lineNum">    4152 </span>            : 
<span class="lineNum">    4153 </span>            :     /*!
<span class="lineNum">    4154 </span>            :     @brief post-increment (it++)
<span class="lineNum">    4155 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4156 </span>            :     */
<span class="lineNum">    4157 </span>            :     iter_impl const operator++(int)
<span class="lineNum">    4158 </span>            :     {
<span class="lineNum">    4159 </span>            :         auto result = *this;
<span class="lineNum">    4160 </span>            :         ++(*this);
<span class="lineNum">    4161 </span>            :         return result;
<span class="lineNum">    4162 </span>            :     }
<span class="lineNum">    4163 </span>            : 
<span class="lineNum">    4164 </span>            :     /*!
<span class="lineNum">    4165 </span>            :     @brief pre-increment (++it)
<a name="4166"><span class="lineNum">    4166 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    4167 </span>            :     */
<span class="lineNum">    4168 </span><span class="lineCov">         12 :     iter_impl&amp; operator++()</span>
<span class="lineNum">    4169 </span>            :     {
<span class="lineNum">    4170 </span><span class="lineCov">         12 :         assert(m_object != nullptr);</span>
<span class="lineNum">    4171 </span>            : 
<span class="lineNum">    4172 </span><span class="lineCov">         12 :         switch (m_object-&gt;m_type)</span>
<span class="lineNum">    4173 </span>            :         {
<span class="lineNum">    4174 </span>            :             case value_t::object:
<span class="lineNum">    4175 </span>            :             {
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :                 std::advance(m_it.object_iterator, 1);</span>
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4178 </span>            :             }
<span class="lineNum">    4179 </span>            : 
<span class="lineNum">    4180 </span>            :             case value_t::array:
<span class="lineNum">    4181 </span>            :             {
<span class="lineNum">    4182 </span><span class="lineCov">         12 :                 std::advance(m_it.array_iterator, 1);</span>
<span class="lineNum">    4183 </span><span class="lineCov">         12 :                 break;</span>
<span class="lineNum">    4184 </span>            :             }
<span class="lineNum">    4185 </span>            : 
<span class="lineNum">    4186 </span>            :             default:
<span class="lineNum">    4187 </span>            :             {
<span class="lineNum">    4188 </span><span class="lineNoCov">          0 :                 ++m_it.primitive_iterator;</span>
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4190 </span>            :             }
<span class="lineNum">    4191 </span>            :         }
<span class="lineNum">    4192 </span>            : 
<span class="lineNum">    4193 </span><span class="lineCov">         12 :         return *this;</span>
<span class="lineNum">    4194 </span>            :     }
<span class="lineNum">    4195 </span>            : 
<span class="lineNum">    4196 </span>            :     /*!
<span class="lineNum">    4197 </span>            :     @brief post-decrement (it--)
<span class="lineNum">    4198 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4199 </span>            :     */
<span class="lineNum">    4200 </span>            :     iter_impl const operator--(int)
<span class="lineNum">    4201 </span>            :     {
<span class="lineNum">    4202 </span>            :         auto result = *this;
<span class="lineNum">    4203 </span>            :         --(*this);
<span class="lineNum">    4204 </span>            :         return result;
<span class="lineNum">    4205 </span>            :     }
<span class="lineNum">    4206 </span>            : 
<span class="lineNum">    4207 </span>            :     /*!
<span class="lineNum">    4208 </span>            :     @brief pre-decrement (--it)
<span class="lineNum">    4209 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4210 </span>            :     */
<span class="lineNum">    4211 </span>            :     iter_impl&amp; operator--()
<span class="lineNum">    4212 </span>            :     {
<span class="lineNum">    4213 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4214 </span>            : 
<span class="lineNum">    4215 </span>            :         switch (m_object-&gt;m_type)
<span class="lineNum">    4216 </span>            :         {
<span class="lineNum">    4217 </span>            :             case value_t::object:
<span class="lineNum">    4218 </span>            :             {
<span class="lineNum">    4219 </span>            :                 std::advance(m_it.object_iterator, -1);
<span class="lineNum">    4220 </span>            :                 break;
<span class="lineNum">    4221 </span>            :             }
<span class="lineNum">    4222 </span>            : 
<span class="lineNum">    4223 </span>            :             case value_t::array:
<span class="lineNum">    4224 </span>            :             {
<span class="lineNum">    4225 </span>            :                 std::advance(m_it.array_iterator, -1);
<span class="lineNum">    4226 </span>            :                 break;
<span class="lineNum">    4227 </span>            :             }
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span>            :             default:
<span class="lineNum">    4230 </span>            :             {
<span class="lineNum">    4231 </span>            :                 --m_it.primitive_iterator;
<span class="lineNum">    4232 </span>            :                 break;
<span class="lineNum">    4233 </span>            :             }
<span class="lineNum">    4234 </span>            :         }
<span class="lineNum">    4235 </span>            : 
<span class="lineNum">    4236 </span>            :         return *this;
<span class="lineNum">    4237 </span>            :     }
<span class="lineNum">    4238 </span>            : 
<span class="lineNum">    4239 </span>            :     /*!
<span class="lineNum">    4240 </span>            :     @brief  comparison: equal
<a name="4241"><span class="lineNum">    4241 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    4242 </span>            :     */
<span class="lineNum">    4243 </span><span class="lineCov">         65 :     bool operator==(const iter_impl&amp; other) const</span>
<span class="lineNum">    4244 </span>            :     {
<span class="lineNum">    4245 </span>            :         // if objects are not the same, the comparison is undefined
<span class="lineNum">    4246 </span><span class="lineCov">         65 :         if (JSON_UNLIKELY(m_object != other.m_object))</span>
<span class="lineNum">    4247 </span>            :         {
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :             JSON_THROW(invalid_iterator::create(212, &quot;cannot compare iterators of different containers&quot;));</span>
<span class="lineNum">    4249 </span>            :         }
<span class="lineNum">    4250 </span>            : 
<span class="lineNum">    4251 </span><span class="lineCov">         65 :         assert(m_object != nullptr);</span>
<span class="lineNum">    4252 </span>            : 
<span class="lineNum">    4253 </span><span class="lineCov">         65 :         switch (m_object-&gt;m_type)</span>
<span class="lineNum">    4254 </span>            :         {
<span class="lineNum">    4255 </span>            :             case value_t::object:
<span class="lineNum">    4256 </span><span class="lineCov">         48 :                 return (m_it.object_iterator == other.m_it.object_iterator);</span>
<span class="lineNum">    4257 </span>            : 
<span class="lineNum">    4258 </span>            :             case value_t::array:
<span class="lineNum">    4259 </span><span class="lineCov">         17 :                 return (m_it.array_iterator == other.m_it.array_iterator);</span>
<span class="lineNum">    4260 </span>            : 
<span class="lineNum">    4261 </span>            :             default:
<span class="lineNum">    4262 </span><span class="lineNoCov">          0 :                 return (m_it.primitive_iterator == other.m_it.primitive_iterator);</span>
<span class="lineNum">    4263 </span>            :         }
<span class="lineNum">    4264 </span>            :     }
<span class="lineNum">    4265 </span>            : 
<span class="lineNum">    4266 </span>            :     /*!
<span class="lineNum">    4267 </span>            :     @brief  comparison: not equal
<a name="4268"><span class="lineNum">    4268 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.</a>
<span class="lineNum">    4269 </span>            :     */
<span class="lineNum">    4270 </span><span class="lineCov">         17 :     bool operator!=(const iter_impl&amp; other) const</span>
<span class="lineNum">    4271 </span>            :     {
<span class="lineNum">    4272 </span><span class="lineCov">         17 :         return not operator==(other);</span>
<span class="lineNum">    4273 </span>            :     }
<span class="lineNum">    4274 </span>            : 
<span class="lineNum">    4275 </span>            :     /*!
<span class="lineNum">    4276 </span>            :     @brief  comparison: smaller
<span class="lineNum">    4277 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4278 </span>            :     */
<span class="lineNum">    4279 </span>            :     bool operator&lt;(const iter_impl&amp; other) const
<span class="lineNum">    4280 </span>            :     {
<span class="lineNum">    4281 </span>            :         // if objects are not the same, the comparison is undefined
<span class="lineNum">    4282 </span>            :         if (JSON_UNLIKELY(m_object != other.m_object))
<span class="lineNum">    4283 </span>            :         {
<span class="lineNum">    4284 </span>            :             JSON_THROW(invalid_iterator::create(212, &quot;cannot compare iterators of different containers&quot;));
<span class="lineNum">    4285 </span>            :         }
<span class="lineNum">    4286 </span>            : 
<span class="lineNum">    4287 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4288 </span>            : 
<span class="lineNum">    4289 </span>            :         switch (m_object-&gt;m_type)
<span class="lineNum">    4290 </span>            :         {
<span class="lineNum">    4291 </span>            :             case value_t::object:
<span class="lineNum">    4292 </span>            :                 JSON_THROW(invalid_iterator::create(213, &quot;cannot compare order of object iterators&quot;));
<span class="lineNum">    4293 </span>            : 
<span class="lineNum">    4294 </span>            :             case value_t::array:
<span class="lineNum">    4295 </span>            :                 return (m_it.array_iterator &lt; other.m_it.array_iterator);
<span class="lineNum">    4296 </span>            : 
<span class="lineNum">    4297 </span>            :             default:
<span class="lineNum">    4298 </span>            :                 return (m_it.primitive_iterator &lt; other.m_it.primitive_iterator);
<span class="lineNum">    4299 </span>            :         }
<span class="lineNum">    4300 </span>            :     }
<span class="lineNum">    4301 </span>            : 
<span class="lineNum">    4302 </span>            :     /*!
<span class="lineNum">    4303 </span>            :     @brief  comparison: less than or equal
<span class="lineNum">    4304 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4305 </span>            :     */
<span class="lineNum">    4306 </span>            :     bool operator&lt;=(const iter_impl&amp; other) const
<span class="lineNum">    4307 </span>            :     {
<span class="lineNum">    4308 </span>            :         return not other.operator &lt; (*this);
<span class="lineNum">    4309 </span>            :     }
<span class="lineNum">    4310 </span>            : 
<span class="lineNum">    4311 </span>            :     /*!
<span class="lineNum">    4312 </span>            :     @brief  comparison: greater than
<span class="lineNum">    4313 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4314 </span>            :     */
<span class="lineNum">    4315 </span>            :     bool operator&gt;(const iter_impl&amp; other) const
<span class="lineNum">    4316 </span>            :     {
<span class="lineNum">    4317 </span>            :         return not operator&lt;=(other);
<span class="lineNum">    4318 </span>            :     }
<span class="lineNum">    4319 </span>            : 
<span class="lineNum">    4320 </span>            :     /*!
<span class="lineNum">    4321 </span>            :     @brief  comparison: greater than or equal
<span class="lineNum">    4322 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4323 </span>            :     */
<span class="lineNum">    4324 </span>            :     bool operator&gt;=(const iter_impl&amp; other) const
<span class="lineNum">    4325 </span>            :     {
<span class="lineNum">    4326 </span>            :         return not operator&lt;(other);
<span class="lineNum">    4327 </span>            :     }
<span class="lineNum">    4328 </span>            : 
<span class="lineNum">    4329 </span>            :     /*!
<span class="lineNum">    4330 </span>            :     @brief  add to iterator
<span class="lineNum">    4331 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4332 </span>            :     */
<span class="lineNum">    4333 </span>            :     iter_impl&amp; operator+=(difference_type i)
<span class="lineNum">    4334 </span>            :     {
<span class="lineNum">    4335 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4336 </span>            : 
<span class="lineNum">    4337 </span>            :         switch (m_object-&gt;m_type)
<span class="lineNum">    4338 </span>            :         {
<span class="lineNum">    4339 </span>            :             case value_t::object:
<span class="lineNum">    4340 </span>            :                 JSON_THROW(invalid_iterator::create(209, &quot;cannot use offsets with object iterators&quot;));
<span class="lineNum">    4341 </span>            : 
<span class="lineNum">    4342 </span>            :             case value_t::array:
<span class="lineNum">    4343 </span>            :             {
<span class="lineNum">    4344 </span>            :                 std::advance(m_it.array_iterator, i);
<span class="lineNum">    4345 </span>            :                 break;
<span class="lineNum">    4346 </span>            :             }
<span class="lineNum">    4347 </span>            : 
<span class="lineNum">    4348 </span>            :             default:
<span class="lineNum">    4349 </span>            :             {
<span class="lineNum">    4350 </span>            :                 m_it.primitive_iterator += i;
<span class="lineNum">    4351 </span>            :                 break;
<span class="lineNum">    4352 </span>            :             }
<span class="lineNum">    4353 </span>            :         }
<span class="lineNum">    4354 </span>            : 
<span class="lineNum">    4355 </span>            :         return *this;
<span class="lineNum">    4356 </span>            :     }
<span class="lineNum">    4357 </span>            : 
<span class="lineNum">    4358 </span>            :     /*!
<span class="lineNum">    4359 </span>            :     @brief  subtract from iterator
<span class="lineNum">    4360 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4361 </span>            :     */
<span class="lineNum">    4362 </span>            :     iter_impl&amp; operator-=(difference_type i)
<span class="lineNum">    4363 </span>            :     {
<span class="lineNum">    4364 </span>            :         return operator+=(-i);
<span class="lineNum">    4365 </span>            :     }
<span class="lineNum">    4366 </span>            : 
<span class="lineNum">    4367 </span>            :     /*!
<span class="lineNum">    4368 </span>            :     @brief  add to iterator
<span class="lineNum">    4369 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4370 </span>            :     */
<span class="lineNum">    4371 </span>            :     iter_impl operator+(difference_type i) const
<span class="lineNum">    4372 </span>            :     {
<span class="lineNum">    4373 </span>            :         auto result = *this;
<span class="lineNum">    4374 </span>            :         result += i;
<span class="lineNum">    4375 </span>            :         return result;
<span class="lineNum">    4376 </span>            :     }
<span class="lineNum">    4377 </span>            : 
<span class="lineNum">    4378 </span>            :     /*!
<span class="lineNum">    4379 </span>            :     @brief  addition of distance and iterator
<span class="lineNum">    4380 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4381 </span>            :     */
<span class="lineNum">    4382 </span>            :     friend iter_impl operator+(difference_type i, const iter_impl&amp; it)
<span class="lineNum">    4383 </span>            :     {
<span class="lineNum">    4384 </span>            :         auto result = it;
<span class="lineNum">    4385 </span>            :         result += i;
<span class="lineNum">    4386 </span>            :         return result;
<span class="lineNum">    4387 </span>            :     }
<span class="lineNum">    4388 </span>            : 
<span class="lineNum">    4389 </span>            :     /*!
<span class="lineNum">    4390 </span>            :     @brief  subtract from iterator
<span class="lineNum">    4391 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4392 </span>            :     */
<span class="lineNum">    4393 </span>            :     iter_impl operator-(difference_type i) const
<span class="lineNum">    4394 </span>            :     {
<span class="lineNum">    4395 </span>            :         auto result = *this;
<span class="lineNum">    4396 </span>            :         result -= i;
<span class="lineNum">    4397 </span>            :         return result;
<span class="lineNum">    4398 </span>            :     }
<span class="lineNum">    4399 </span>            : 
<span class="lineNum">    4400 </span>            :     /*!
<span class="lineNum">    4401 </span>            :     @brief  return difference
<span class="lineNum">    4402 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4403 </span>            :     */
<span class="lineNum">    4404 </span>            :     difference_type operator-(const iter_impl&amp; other) const
<span class="lineNum">    4405 </span>            :     {
<span class="lineNum">    4406 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4407 </span>            : 
<span class="lineNum">    4408 </span>            :         switch (m_object-&gt;m_type)
<span class="lineNum">    4409 </span>            :         {
<span class="lineNum">    4410 </span>            :             case value_t::object:
<span class="lineNum">    4411 </span>            :                 JSON_THROW(invalid_iterator::create(209, &quot;cannot use offsets with object iterators&quot;));
<span class="lineNum">    4412 </span>            : 
<span class="lineNum">    4413 </span>            :             case value_t::array:
<span class="lineNum">    4414 </span>            :                 return m_it.array_iterator - other.m_it.array_iterator;
<span class="lineNum">    4415 </span>            : 
<span class="lineNum">    4416 </span>            :             default:
<span class="lineNum">    4417 </span>            :                 return m_it.primitive_iterator - other.m_it.primitive_iterator;
<span class="lineNum">    4418 </span>            :         }
<span class="lineNum">    4419 </span>            :     }
<span class="lineNum">    4420 </span>            : 
<span class="lineNum">    4421 </span>            :     /*!
<span class="lineNum">    4422 </span>            :     @brief  access to successor
<span class="lineNum">    4423 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4424 </span>            :     */
<span class="lineNum">    4425 </span>            :     reference operator[](difference_type n) const
<span class="lineNum">    4426 </span>            :     {
<span class="lineNum">    4427 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4428 </span>            : 
<span class="lineNum">    4429 </span>            :         switch (m_object-&gt;m_type)
<span class="lineNum">    4430 </span>            :         {
<span class="lineNum">    4431 </span>            :             case value_t::object:
<span class="lineNum">    4432 </span>            :                 JSON_THROW(invalid_iterator::create(208, &quot;cannot use operator[] for object iterators&quot;));
<span class="lineNum">    4433 </span>            : 
<span class="lineNum">    4434 </span>            :             case value_t::array:
<span class="lineNum">    4435 </span>            :                 return *std::next(m_it.array_iterator, n);
<span class="lineNum">    4436 </span>            : 
<span class="lineNum">    4437 </span>            :             case value_t::null:
<span class="lineNum">    4438 </span>            :                 JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;));
<span class="lineNum">    4439 </span>            : 
<span class="lineNum">    4440 </span>            :             default:
<span class="lineNum">    4441 </span>            :             {
<span class="lineNum">    4442 </span>            :                 if (JSON_LIKELY(m_it.primitive_iterator.get_value() == -n))
<span class="lineNum">    4443 </span>            :                 {
<span class="lineNum">    4444 </span>            :                     return *m_object;
<span class="lineNum">    4445 </span>            :                 }
<span class="lineNum">    4446 </span>            : 
<span class="lineNum">    4447 </span>            :                 JSON_THROW(invalid_iterator::create(214, &quot;cannot get value&quot;));
<span class="lineNum">    4448 </span>            :             }
<span class="lineNum">    4449 </span>            :         }
<span class="lineNum">    4450 </span>            :     }
<span class="lineNum">    4451 </span>            : 
<span class="lineNum">    4452 </span>            :     /*!
<span class="lineNum">    4453 </span>            :     @brief  return the key of an object iterator
<span class="lineNum">    4454 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4455 </span>            :     */
<span class="lineNum">    4456 </span>            :     typename object_t::key_type key() const
<span class="lineNum">    4457 </span>            :     {
<span class="lineNum">    4458 </span>            :         assert(m_object != nullptr);
<span class="lineNum">    4459 </span>            : 
<span class="lineNum">    4460 </span>            :         if (JSON_LIKELY(m_object-&gt;is_object()))
<span class="lineNum">    4461 </span>            :         {
<span class="lineNum">    4462 </span>            :             return m_it.object_iterator-&gt;first;
<span class="lineNum">    4463 </span>            :         }
<span class="lineNum">    4464 </span>            : 
<span class="lineNum">    4465 </span>            :         JSON_THROW(invalid_iterator::create(207, &quot;cannot use key() for non-object iterators&quot;));
<span class="lineNum">    4466 </span>            :     }
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span>            :     /*!
<span class="lineNum">    4469 </span>            :     @brief  return the value of an iterator
<span class="lineNum">    4470 </span>            :     @pre The iterator is initialized; i.e. `m_object != nullptr`.
<span class="lineNum">    4471 </span>            :     */
<span class="lineNum">    4472 </span>            :     reference value() const
<span class="lineNum">    4473 </span>            :     {
<span class="lineNum">    4474 </span>            :         return operator*();
<span class="lineNum">    4475 </span>            :     }
<span class="lineNum">    4476 </span>            : 
<span class="lineNum">    4477 </span>            :   private:
<span class="lineNum">    4478 </span>            :     /// associated JSON instance
<span class="lineNum">    4479 </span>            :     pointer m_object = nullptr;
<span class="lineNum">    4480 </span>            :     /// the actual iterator of the associated instance
<span class="lineNum">    4481 </span>            :     internal_iterator&lt;typename std::remove_const&lt;BasicJsonType&gt;::type&gt; m_it;
<span class="lineNum">    4482 </span>            : };
<span class="lineNum">    4483 </span>            : }
<span class="lineNum">    4484 </span>            : }
<span class="lineNum">    4485 </span>            : 
<span class="lineNum">    4486 </span>            : // #include &lt;nlohmann/detail/iterators/iteration_proxy.hpp&gt;
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span>            : 
<span class="lineNum">    4489 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">    4490 </span>            : #include &lt;string&gt; // string, to_string
<span class="lineNum">    4491 </span>            : 
<span class="lineNum">    4492 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    4493 </span>            : 
<span class="lineNum">    4494 </span>            : 
<span class="lineNum">    4495 </span>            : namespace rockets_nlohmann
<span class="lineNum">    4496 </span>            : {
<span class="lineNum">    4497 </span>            : namespace detail
<span class="lineNum">    4498 </span>            : {
<span class="lineNum">    4499 </span>            : /// proxy class for the items() function
<span class="lineNum">    4500 </span>            : template&lt;typename IteratorType&gt; class iteration_proxy
<span class="lineNum">    4501 </span>            : {
<span class="lineNum">    4502 </span>            :   private:
<span class="lineNum">    4503 </span>            :     /// helper class for iteration
<span class="lineNum">    4504 </span>            :     class iteration_proxy_internal
<span class="lineNum">    4505 </span>            :     {
<span class="lineNum">    4506 </span>            :       private:
<span class="lineNum">    4507 </span>            :         /// the iterator
<span class="lineNum">    4508 </span>            :         IteratorType anchor;
<span class="lineNum">    4509 </span>            :         /// an index for arrays (used to create key names)
<span class="lineNum">    4510 </span>            :         std::size_t array_index = 0;
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span>            :       public:
<span class="lineNum">    4513 </span>            :         explicit iteration_proxy_internal(IteratorType it) noexcept : anchor(it) {}
<span class="lineNum">    4514 </span>            : 
<span class="lineNum">    4515 </span>            :         /// dereference operator (needed for range-based for)
<span class="lineNum">    4516 </span>            :         iteration_proxy_internal&amp; operator*()
<span class="lineNum">    4517 </span>            :         {
<span class="lineNum">    4518 </span>            :             return *this;
<span class="lineNum">    4519 </span>            :         }
<span class="lineNum">    4520 </span>            : 
<span class="lineNum">    4521 </span>            :         /// increment operator (needed for range-based for)
<span class="lineNum">    4522 </span>            :         iteration_proxy_internal&amp; operator++()
<span class="lineNum">    4523 </span>            :         {
<span class="lineNum">    4524 </span>            :             ++anchor;
<span class="lineNum">    4525 </span>            :             ++array_index;
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span>            :             return *this;
<span class="lineNum">    4528 </span>            :         }
<span class="lineNum">    4529 </span>            : 
<span class="lineNum">    4530 </span>            :         /// inequality operator (needed for range-based for)
<span class="lineNum">    4531 </span>            :         bool operator!=(const iteration_proxy_internal&amp; o) const noexcept
<span class="lineNum">    4532 </span>            :         {
<span class="lineNum">    4533 </span>            :             return anchor != o.anchor;
<span class="lineNum">    4534 </span>            :         }
<span class="lineNum">    4535 </span>            : 
<span class="lineNum">    4536 </span>            :         /// return key of the iterator
<span class="lineNum">    4537 </span>            :         std::string key() const
<span class="lineNum">    4538 </span>            :         {
<span class="lineNum">    4539 </span>            :             assert(anchor.m_object != nullptr);
<span class="lineNum">    4540 </span>            : 
<span class="lineNum">    4541 </span>            :             switch (anchor.m_object-&gt;type())
<span class="lineNum">    4542 </span>            :             {
<span class="lineNum">    4543 </span>            :                 // use integer array index as key
<span class="lineNum">    4544 </span>            :                 case value_t::array:
<span class="lineNum">    4545 </span>            :                     return std::to_string(array_index);
<span class="lineNum">    4546 </span>            : 
<span class="lineNum">    4547 </span>            :                 // use key from the object
<span class="lineNum">    4548 </span>            :                 case value_t::object:
<span class="lineNum">    4549 </span>            :                     return anchor.key();
<span class="lineNum">    4550 </span>            : 
<span class="lineNum">    4551 </span>            :                 // use an empty key for all primitive types
<span class="lineNum">    4552 </span>            :                 default:
<span class="lineNum">    4553 </span>            :                     return &quot;&quot;;
<span class="lineNum">    4554 </span>            :             }
<span class="lineNum">    4555 </span>            :         }
<span class="lineNum">    4556 </span>            : 
<span class="lineNum">    4557 </span>            :         /// return value of the iterator
<span class="lineNum">    4558 </span>            :         typename IteratorType::reference value() const
<span class="lineNum">    4559 </span>            :         {
<span class="lineNum">    4560 </span>            :             return anchor.value();
<span class="lineNum">    4561 </span>            :         }
<span class="lineNum">    4562 </span>            :     };
<span class="lineNum">    4563 </span>            : 
<span class="lineNum">    4564 </span>            :     /// the container to iterate
<span class="lineNum">    4565 </span>            :     typename IteratorType::reference container;
<span class="lineNum">    4566 </span>            : 
<span class="lineNum">    4567 </span>            :   public:
<span class="lineNum">    4568 </span>            :     /// construct iteration proxy from a container
<span class="lineNum">    4569 </span>            :     explicit iteration_proxy(typename IteratorType::reference cont) noexcept
<span class="lineNum">    4570 </span>            :         : container(cont) {}
<span class="lineNum">    4571 </span>            : 
<span class="lineNum">    4572 </span>            :     /// return iterator begin (needed for range-based for)
<span class="lineNum">    4573 </span>            :     iteration_proxy_internal begin() noexcept
<span class="lineNum">    4574 </span>            :     {
<span class="lineNum">    4575 </span>            :         return iteration_proxy_internal(container.begin());
<span class="lineNum">    4576 </span>            :     }
<span class="lineNum">    4577 </span>            : 
<span class="lineNum">    4578 </span>            :     /// return iterator end (needed for range-based for)
<span class="lineNum">    4579 </span>            :     iteration_proxy_internal end() noexcept
<span class="lineNum">    4580 </span>            :     {
<span class="lineNum">    4581 </span>            :         return iteration_proxy_internal(container.end());
<span class="lineNum">    4582 </span>            :     }
<span class="lineNum">    4583 </span>            : };
<span class="lineNum">    4584 </span>            : }
<span class="lineNum">    4585 </span>            : }
<span class="lineNum">    4586 </span>            : 
<span class="lineNum">    4587 </span>            : // #include &lt;nlohmann/detail/iterators/json_reverse_iterator.hpp&gt;
<span class="lineNum">    4588 </span>            : 
<span class="lineNum">    4589 </span>            : 
<span class="lineNum">    4590 </span>            : #include &lt;cstddef&gt; // ptrdiff_t
<span class="lineNum">    4591 </span>            : #include &lt;iterator&gt; // reverse_iterator
<span class="lineNum">    4592 </span>            : #include &lt;utility&gt; // declval
<span class="lineNum">    4593 </span>            : 
<span class="lineNum">    4594 </span>            : namespace rockets_nlohmann
<span class="lineNum">    4595 </span>            : {
<span class="lineNum">    4596 </span>            : namespace detail
<span class="lineNum">    4597 </span>            : {
<span class="lineNum">    4598 </span>            : //////////////////////
<span class="lineNum">    4599 </span>            : // reverse_iterator //
<span class="lineNum">    4600 </span>            : //////////////////////
<span class="lineNum">    4601 </span>            : 
<span class="lineNum">    4602 </span>            : /*!
<span class="lineNum">    4603 </span>            : @brief a template for a reverse iterator class
<span class="lineNum">    4604 </span>            : 
<span class="lineNum">    4605 </span>            : @tparam Base the base iterator type to reverse. Valid types are @ref
<span class="lineNum">    4606 </span>            : iterator (to create @ref reverse_iterator) and @ref const_iterator (to
<span class="lineNum">    4607 </span>            : create @ref const_reverse_iterator).
<span class="lineNum">    4608 </span>            : 
<span class="lineNum">    4609 </span>            : @requirement The class satisfies the following concept requirements:
<span class="lineNum">    4610 </span>            : -
<span class="lineNum">    4611 </span>            : [BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):
<span class="lineNum">    4612 </span>            :   The iterator that can be moved can be moved in both directions (i.e.
<span class="lineNum">    4613 </span>            :   incremented and decremented).
<span class="lineNum">    4614 </span>            : - [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):
<span class="lineNum">    4615 </span>            :   It is possible to write to the pointed-to element (only if @a Base is
<span class="lineNum">    4616 </span>            :   @ref iterator).
<span class="lineNum">    4617 </span>            : 
<span class="lineNum">    4618 </span>            : @since version 1.0.0
<span class="lineNum">    4619 </span>            : */
<span class="lineNum">    4620 </span>            : template&lt;typename Base&gt;
<span class="lineNum">    4621 </span>            : class json_reverse_iterator : public std::reverse_iterator&lt;Base&gt;
<span class="lineNum">    4622 </span>            : {
<span class="lineNum">    4623 </span>            :   public:
<span class="lineNum">    4624 </span>            :     using difference_type = std::ptrdiff_t;
<span class="lineNum">    4625 </span>            :     /// shortcut to the reverse iterator adapter
<span class="lineNum">    4626 </span>            :     using base_iterator = std::reverse_iterator&lt;Base&gt;;
<span class="lineNum">    4627 </span>            :     /// the reference type for the pointed-to element
<span class="lineNum">    4628 </span>            :     using reference = typename Base::reference;
<span class="lineNum">    4629 </span>            : 
<span class="lineNum">    4630 </span>            :     /// create reverse iterator from iterator
<span class="lineNum">    4631 </span>            :     json_reverse_iterator(const typename base_iterator::iterator_type&amp; it) noexcept
<span class="lineNum">    4632 </span>            :         : base_iterator(it) {}
<span class="lineNum">    4633 </span>            : 
<span class="lineNum">    4634 </span>            :     /// create reverse iterator from base class
<span class="lineNum">    4635 </span>            :     json_reverse_iterator(const base_iterator&amp; it) noexcept : base_iterator(it) {}
<span class="lineNum">    4636 </span>            : 
<span class="lineNum">    4637 </span>            :     /// post-increment (it++)
<span class="lineNum">    4638 </span>            :     json_reverse_iterator const operator++(int)
<span class="lineNum">    4639 </span>            :     {
<span class="lineNum">    4640 </span>            :         return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator++(1));
<span class="lineNum">    4641 </span>            :     }
<span class="lineNum">    4642 </span>            : 
<span class="lineNum">    4643 </span>            :     /// pre-increment (++it)
<span class="lineNum">    4644 </span>            :     json_reverse_iterator&amp; operator++()
<span class="lineNum">    4645 </span>            :     {
<span class="lineNum">    4646 </span>            :         return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator++());
<span class="lineNum">    4647 </span>            :     }
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span>            :     /// post-decrement (it--)
<span class="lineNum">    4650 </span>            :     json_reverse_iterator const operator--(int)
<span class="lineNum">    4651 </span>            :     {
<span class="lineNum">    4652 </span>            :         return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator--(1));
<span class="lineNum">    4653 </span>            :     }
<span class="lineNum">    4654 </span>            : 
<span class="lineNum">    4655 </span>            :     /// pre-decrement (--it)
<span class="lineNum">    4656 </span>            :     json_reverse_iterator&amp; operator--()
<span class="lineNum">    4657 </span>            :     {
<span class="lineNum">    4658 </span>            :         return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator--());
<span class="lineNum">    4659 </span>            :     }
<span class="lineNum">    4660 </span>            : 
<span class="lineNum">    4661 </span>            :     /// add to iterator
<span class="lineNum">    4662 </span>            :     json_reverse_iterator&amp; operator+=(difference_type i)
<span class="lineNum">    4663 </span>            :     {
<span class="lineNum">    4664 </span>            :         return static_cast&lt;json_reverse_iterator&amp;&gt;(base_iterator::operator+=(i));
<span class="lineNum">    4665 </span>            :     }
<span class="lineNum">    4666 </span>            : 
<span class="lineNum">    4667 </span>            :     /// add to iterator
<span class="lineNum">    4668 </span>            :     json_reverse_iterator operator+(difference_type i) const
<span class="lineNum">    4669 </span>            :     {
<span class="lineNum">    4670 </span>            :         return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator+(i));
<span class="lineNum">    4671 </span>            :     }
<span class="lineNum">    4672 </span>            : 
<span class="lineNum">    4673 </span>            :     /// subtract from iterator
<span class="lineNum">    4674 </span>            :     json_reverse_iterator operator-(difference_type i) const
<span class="lineNum">    4675 </span>            :     {
<span class="lineNum">    4676 </span>            :         return static_cast&lt;json_reverse_iterator&gt;(base_iterator::operator-(i));
<span class="lineNum">    4677 </span>            :     }
<span class="lineNum">    4678 </span>            : 
<span class="lineNum">    4679 </span>            :     /// return difference
<span class="lineNum">    4680 </span>            :     difference_type operator-(const json_reverse_iterator&amp; other) const
<span class="lineNum">    4681 </span>            :     {
<span class="lineNum">    4682 </span>            :         return base_iterator(*this) - base_iterator(other);
<span class="lineNum">    4683 </span>            :     }
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span>            :     /// access to successor
<span class="lineNum">    4686 </span>            :     reference operator[](difference_type n) const
<span class="lineNum">    4687 </span>            :     {
<span class="lineNum">    4688 </span>            :         return *(this-&gt;operator+(n));
<span class="lineNum">    4689 </span>            :     }
<span class="lineNum">    4690 </span>            : 
<span class="lineNum">    4691 </span>            :     /// return the key of an object iterator
<span class="lineNum">    4692 </span>            :     auto key() const -&gt; decltype(std::declval&lt;Base&gt;().key())
<span class="lineNum">    4693 </span>            :     {
<span class="lineNum">    4694 </span>            :         auto it = --this-&gt;base();
<span class="lineNum">    4695 </span>            :         return it.key();
<span class="lineNum">    4696 </span>            :     }
<span class="lineNum">    4697 </span>            : 
<span class="lineNum">    4698 </span>            :     /// return the value of an iterator
<span class="lineNum">    4699 </span>            :     reference value() const
<span class="lineNum">    4700 </span>            :     {
<span class="lineNum">    4701 </span>            :         auto it = --this-&gt;base();
<span class="lineNum">    4702 </span>            :         return it.operator * ();
<span class="lineNum">    4703 </span>            :     }
<span class="lineNum">    4704 </span>            : };
<span class="lineNum">    4705 </span>            : }
<span class="lineNum">    4706 </span>            : }
<span class="lineNum">    4707 </span>            : 
<span class="lineNum">    4708 </span>            : // #include &lt;nlohmann/detail/output/output_adapters.hpp&gt;
<span class="lineNum">    4709 </span>            : 
<span class="lineNum">    4710 </span>            : 
<span class="lineNum">    4711 </span>            : #include &lt;algorithm&gt; // copy
<span class="lineNum">    4712 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">    4713 </span>            : #include &lt;ios&gt; // streamsize
<span class="lineNum">    4714 </span>            : #include &lt;iterator&gt; // back_inserter
<span class="lineNum">    4715 </span>            : #include &lt;memory&gt; // shared_ptr, make_shared
<span class="lineNum">    4716 </span>            : #include &lt;ostream&gt; // basic_ostream
<span class="lineNum">    4717 </span>            : #include &lt;string&gt; // basic_string
<span class="lineNum">    4718 </span>            : #include &lt;vector&gt; // vector
<span class="lineNum">    4719 </span>            : 
<span class="lineNum">    4720 </span>            : namespace rockets_nlohmann
<span class="lineNum">    4721 </span>            : {
<span class="lineNum">    4722 </span>            : namespace detail
<a name="4723"><span class="lineNum">    4723 </span>            : {</a>
<span class="lineNum">    4724 </span>            : /// abstract output adapter interface
<span class="lineNum">    4725 </span><span class="lineCov">        123 : template&lt;typename CharType&gt; struct output_adapter_protocol</span>
<span class="lineNum">    4726 </span>            : {
<a name="4727"><span class="lineNum">    4727 </span>            :     virtual void write_character(CharType c) = 0;</a>
<span class="lineNum">    4728 </span>            :     virtual void write_characters(const CharType* s, std::size_t length) = 0;
<span class="lineNum">    4729 </span><span class="lineCov">        123 :     virtual ~output_adapter_protocol() = default;</span>
<span class="lineNum">    4730 </span>            : };
<span class="lineNum">    4731 </span>            : 
<span class="lineNum">    4732 </span>            : /// a type to simplify interfaces
<span class="lineNum">    4733 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">    4734 </span>            : using output_adapter_t = std::shared_ptr&lt;output_adapter_protocol&lt;CharType&gt;&gt;;
<span class="lineNum">    4735 </span>            : 
<span class="lineNum">    4736 </span>            : /// output adapter for byte vectors
<span class="lineNum">    4737 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">    4738 </span>            : class output_vector_adapter : public output_adapter_protocol&lt;CharType&gt;
<span class="lineNum">    4739 </span>            : {
<span class="lineNum">    4740 </span>            :   public:
<span class="lineNum">    4741 </span>            :     explicit output_vector_adapter(std::vector&lt;CharType&gt;&amp; vec) : v(vec) {}
<span class="lineNum">    4742 </span>            : 
<span class="lineNum">    4743 </span>            :     void write_character(CharType c) override
<span class="lineNum">    4744 </span>            :     {
<span class="lineNum">    4745 </span>            :         v.push_back(c);
<span class="lineNum">    4746 </span>            :     }
<span class="lineNum">    4747 </span>            : 
<span class="lineNum">    4748 </span>            :     void write_characters(const CharType* s, std::size_t length) override
<span class="lineNum">    4749 </span>            :     {
<span class="lineNum">    4750 </span>            :         std::copy(s, s + length, std::back_inserter(v));
<span class="lineNum">    4751 </span>            :     }
<span class="lineNum">    4752 </span>            : 
<span class="lineNum">    4753 </span>            :   private:
<span class="lineNum">    4754 </span>            :     std::vector&lt;CharType&gt;&amp; v;
<span class="lineNum">    4755 </span>            : };
<span class="lineNum">    4756 </span>            : 
<span class="lineNum">    4757 </span>            : /// output adapter for output streams
<span class="lineNum">    4758 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">    4759 </span>            : class output_stream_adapter : public output_adapter_protocol&lt;CharType&gt;
<span class="lineNum">    4760 </span>            : {
<span class="lineNum">    4761 </span>            :   public:
<span class="lineNum">    4762 </span>            :     explicit output_stream_adapter(std::basic_ostream&lt;CharType&gt;&amp; s) : stream(s) {}
<span class="lineNum">    4763 </span>            : 
<span class="lineNum">    4764 </span>            :     void write_character(CharType c) override
<span class="lineNum">    4765 </span>            :     {
<span class="lineNum">    4766 </span>            :         stream.put(c);
<span class="lineNum">    4767 </span>            :     }
<span class="lineNum">    4768 </span>            : 
<span class="lineNum">    4769 </span>            :     void write_characters(const CharType* s, std::size_t length) override
<span class="lineNum">    4770 </span>            :     {
<span class="lineNum">    4771 </span>            :         stream.write(s, static_cast&lt;std::streamsize&gt;(length));
<span class="lineNum">    4772 </span>            :     }
<span class="lineNum">    4773 </span>            : 
<span class="lineNum">    4774 </span>            :   private:
<span class="lineNum">    4775 </span>            :     std::basic_ostream&lt;CharType&gt;&amp; stream;
<span class="lineNum">    4776 </span>            : };
<span class="lineNum">    4777 </span>            : 
<a name="4778"><span class="lineNum">    4778 </span>            : /// output adapter for basic_string</a>
<span class="lineNum">    4779 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">    4780 </span><span class="lineCov">        123 : class output_string_adapter : public output_adapter_protocol&lt;CharType&gt;</span>
<a name="4781"><span class="lineNum">    4781 </span>            : {</a>
<span class="lineNum">    4782 </span>            :   public:
<a name="4783"><span class="lineNum">    4783 </span><span class="lineCov">        123 :     explicit output_string_adapter(std::basic_string&lt;CharType&gt;&amp; s) : str(s) {}</span></a>
<span class="lineNum">    4784 </span>            : 
<span class="lineNum">    4785 </span><span class="lineCov">       1013 :     void write_character(CharType c) override</span>
<span class="lineNum">    4786 </span>            :     {
<span class="lineNum">    4787 </span><span class="lineCov">       1013 :         str.push_back(c);</span>
<a name="4788"><span class="lineNum">    4788 </span><span class="lineCov">       1013 :     }</span></a>
<span class="lineNum">    4789 </span>            : 
<span class="lineNum">    4790 </span><span class="lineCov">       1931 :     void write_characters(const CharType* s, std::size_t length) override</span>
<span class="lineNum">    4791 </span>            :     {
<span class="lineNum">    4792 </span><span class="lineCov">       1931 :         str.append(s, length);</span>
<span class="lineNum">    4793 </span><span class="lineCov">       1931 :     }</span>
<span class="lineNum">    4794 </span>            : 
<span class="lineNum">    4795 </span>            :   private:
<span class="lineNum">    4796 </span>            :     std::basic_string&lt;CharType&gt;&amp; str;
<span class="lineNum">    4797 </span>            : };
<a name="4798"><span class="lineNum">    4798 </span>            : </a>
<span class="lineNum">    4799 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">    4800 </span><span class="lineCov">        123 : class output_adapter</span>
<span class="lineNum">    4801 </span>            : {
<span class="lineNum">    4802 </span>            :   public:
<span class="lineNum">    4803 </span>            :     output_adapter(std::vector&lt;CharType&gt;&amp; vec)
<span class="lineNum">    4804 </span>            :         : oa(std::make_shared&lt;output_vector_adapter&lt;CharType&gt;&gt;(vec)) {}
<span class="lineNum">    4805 </span>            : 
<span class="lineNum">    4806 </span>            :     output_adapter(std::basic_ostream&lt;CharType&gt;&amp; s)
<a name="4807"><span class="lineNum">    4807 </span>            :         : oa(std::make_shared&lt;output_stream_adapter&lt;CharType&gt;&gt;(s)) {}</a>
<span class="lineNum">    4808 </span>            : 
<span class="lineNum">    4809 </span><span class="lineCov">        123 :     output_adapter(std::basic_string&lt;CharType&gt;&amp; s)</span>
<a name="4810"><span class="lineNum">    4810 </span><span class="lineCov">        123 :         : oa(std::make_shared&lt;output_string_adapter&lt;CharType&gt;&gt;(s)) {}</span></a>
<span class="lineNum">    4811 </span>            : 
<span class="lineNum">    4812 </span><span class="lineCov">        123 :     operator output_adapter_t&lt;CharType&gt;()</span>
<span class="lineNum">    4813 </span>            :     {
<span class="lineNum">    4814 </span><span class="lineCov">        123 :         return oa;</span>
<span class="lineNum">    4815 </span>            :     }
<span class="lineNum">    4816 </span>            : 
<span class="lineNum">    4817 </span>            :   private:
<span class="lineNum">    4818 </span>            :     output_adapter_t&lt;CharType&gt; oa = nullptr;
<span class="lineNum">    4819 </span>            : };
<span class="lineNum">    4820 </span>            : }
<span class="lineNum">    4821 </span>            : }
<span class="lineNum">    4822 </span>            : 
<span class="lineNum">    4823 </span>            : // #include &lt;nlohmann/detail/input/binary_reader.hpp&gt;
<span class="lineNum">    4824 </span>            : 
<span class="lineNum">    4825 </span>            : 
<span class="lineNum">    4826 </span>            : #include &lt;algorithm&gt; // generate_n
<span class="lineNum">    4827 </span>            : #include &lt;array&gt; // array
<span class="lineNum">    4828 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">    4829 </span>            : #include &lt;cmath&gt; // ldexp
<span class="lineNum">    4830 </span>            : #include &lt;cstddef&gt; // size_t
<span class="lineNum">    4831 </span>            : #include &lt;cstdint&gt; // uint8_t, uint16_t, uint32_t, uint64_t
<span class="lineNum">    4832 </span>            : #include &lt;cstring&gt; // memcpy
<span class="lineNum">    4833 </span>            : #include &lt;iomanip&gt; // setw, setfill
<span class="lineNum">    4834 </span>            : #include &lt;ios&gt; // hex
<span class="lineNum">    4835 </span>            : #include &lt;iterator&gt; // back_inserter
<span class="lineNum">    4836 </span>            : #include &lt;limits&gt; // numeric_limits
<span class="lineNum">    4837 </span>            : #include &lt;sstream&gt; // stringstream
<span class="lineNum">    4838 </span>            : #include &lt;string&gt; // char_traits, string
<span class="lineNum">    4839 </span>            : #include &lt;utility&gt; // make_pair, move
<span class="lineNum">    4840 </span>            : 
<span class="lineNum">    4841 </span>            : // #include &lt;nlohmann/detail/input/input_adapters.hpp&gt;
<span class="lineNum">    4842 </span>            : 
<span class="lineNum">    4843 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">    4844 </span>            : 
<span class="lineNum">    4845 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    4846 </span>            : 
<span class="lineNum">    4847 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    4848 </span>            : 
<span class="lineNum">    4849 </span>            : 
<span class="lineNum">    4850 </span>            : namespace rockets_nlohmann
<span class="lineNum">    4851 </span>            : {
<span class="lineNum">    4852 </span>            : namespace detail
<span class="lineNum">    4853 </span>            : {
<span class="lineNum">    4854 </span>            : ///////////////////
<span class="lineNum">    4855 </span>            : // binary reader //
<span class="lineNum">    4856 </span>            : ///////////////////
<span class="lineNum">    4857 </span>            : 
<span class="lineNum">    4858 </span>            : /*!
<span class="lineNum">    4859 </span>            : @brief deserialization of CBOR and MessagePack values
<span class="lineNum">    4860 </span>            : */
<span class="lineNum">    4861 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    4862 </span>            : class binary_reader
<span class="lineNum">    4863 </span>            : {
<span class="lineNum">    4864 </span>            :     using number_integer_t = typename BasicJsonType::number_integer_t;
<span class="lineNum">    4865 </span>            :     using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
<span class="lineNum">    4866 </span>            :     using string_t = typename BasicJsonType::string_t;
<span class="lineNum">    4867 </span>            : 
<span class="lineNum">    4868 </span>            :   public:
<span class="lineNum">    4869 </span>            :     /*!
<span class="lineNum">    4870 </span>            :     @brief create a binary reader
<span class="lineNum">    4871 </span>            : 
<span class="lineNum">    4872 </span>            :     @param[in] adapter  input adapter to read from
<span class="lineNum">    4873 </span>            :     */
<span class="lineNum">    4874 </span>            :     explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
<span class="lineNum">    4875 </span>            :     {
<span class="lineNum">    4876 </span>            :         assert(ia);
<span class="lineNum">    4877 </span>            :     }
<span class="lineNum">    4878 </span>            : 
<span class="lineNum">    4879 </span>            :     /*!
<span class="lineNum">    4880 </span>            :     @brief create a JSON value from CBOR input
<span class="lineNum">    4881 </span>            : 
<span class="lineNum">    4882 </span>            :     @param[in] strict  whether to expect the input to be consumed completed
<span class="lineNum">    4883 </span>            :     @return JSON value created from CBOR input
<span class="lineNum">    4884 </span>            : 
<span class="lineNum">    4885 </span>            :     @throw parse_error.110 if input ended unexpectedly or the end of file was
<span class="lineNum">    4886 </span>            :                            not reached when @a strict was set to true
<span class="lineNum">    4887 </span>            :     @throw parse_error.112 if unsupported byte was read
<span class="lineNum">    4888 </span>            :     */
<span class="lineNum">    4889 </span>            :     BasicJsonType parse_cbor(const bool strict)
<span class="lineNum">    4890 </span>            :     {
<span class="lineNum">    4891 </span>            :         const auto res = parse_cbor_internal();
<span class="lineNum">    4892 </span>            :         if (strict)
<span class="lineNum">    4893 </span>            :         {
<span class="lineNum">    4894 </span>            :             get();
<span class="lineNum">    4895 </span>            :             expect_eof();
<span class="lineNum">    4896 </span>            :         }
<span class="lineNum">    4897 </span>            :         return res;
<span class="lineNum">    4898 </span>            :     }
<span class="lineNum">    4899 </span>            : 
<span class="lineNum">    4900 </span>            :     /*!
<span class="lineNum">    4901 </span>            :     @brief create a JSON value from MessagePack input
<span class="lineNum">    4902 </span>            : 
<span class="lineNum">    4903 </span>            :     @param[in] strict  whether to expect the input to be consumed completed
<span class="lineNum">    4904 </span>            :     @return JSON value created from MessagePack input
<span class="lineNum">    4905 </span>            : 
<span class="lineNum">    4906 </span>            :     @throw parse_error.110 if input ended unexpectedly or the end of file was
<span class="lineNum">    4907 </span>            :                            not reached when @a strict was set to true
<span class="lineNum">    4908 </span>            :     @throw parse_error.112 if unsupported byte was read
<span class="lineNum">    4909 </span>            :     */
<span class="lineNum">    4910 </span>            :     BasicJsonType parse_msgpack(const bool strict)
<span class="lineNum">    4911 </span>            :     {
<span class="lineNum">    4912 </span>            :         const auto res = parse_msgpack_internal();
<span class="lineNum">    4913 </span>            :         if (strict)
<span class="lineNum">    4914 </span>            :         {
<span class="lineNum">    4915 </span>            :             get();
<span class="lineNum">    4916 </span>            :             expect_eof();
<span class="lineNum">    4917 </span>            :         }
<span class="lineNum">    4918 </span>            :         return res;
<span class="lineNum">    4919 </span>            :     }
<span class="lineNum">    4920 </span>            : 
<span class="lineNum">    4921 </span>            :     /*!
<span class="lineNum">    4922 </span>            :     @brief create a JSON value from UBJSON input
<span class="lineNum">    4923 </span>            : 
<span class="lineNum">    4924 </span>            :     @param[in] strict  whether to expect the input to be consumed completed
<span class="lineNum">    4925 </span>            :     @return JSON value created from UBJSON input
<span class="lineNum">    4926 </span>            : 
<span class="lineNum">    4927 </span>            :     @throw parse_error.110 if input ended unexpectedly or the end of file was
<span class="lineNum">    4928 </span>            :                            not reached when @a strict was set to true
<span class="lineNum">    4929 </span>            :     @throw parse_error.112 if unsupported byte was read
<span class="lineNum">    4930 </span>            :     */
<span class="lineNum">    4931 </span>            :     BasicJsonType parse_ubjson(const bool strict)
<span class="lineNum">    4932 </span>            :     {
<span class="lineNum">    4933 </span>            :         const auto res = parse_ubjson_internal();
<span class="lineNum">    4934 </span>            :         if (strict)
<span class="lineNum">    4935 </span>            :         {
<span class="lineNum">    4936 </span>            :             get_ignore_noop();
<span class="lineNum">    4937 </span>            :             expect_eof();
<span class="lineNum">    4938 </span>            :         }
<span class="lineNum">    4939 </span>            :         return res;
<span class="lineNum">    4940 </span>            :     }
<span class="lineNum">    4941 </span>            : 
<span class="lineNum">    4942 </span>            :     /*!
<span class="lineNum">    4943 </span>            :     @brief determine system byte order
<span class="lineNum">    4944 </span>            : 
<span class="lineNum">    4945 </span>            :     @return true if and only if system's byte order is little endian
<span class="lineNum">    4946 </span>            : 
<span class="lineNum">    4947 </span>            :     @note from http://stackoverflow.com/a/1001328/266378
<span class="lineNum">    4948 </span>            :     */
<span class="lineNum">    4949 </span>            :     static constexpr bool little_endianess(int num = 1) noexcept
<span class="lineNum">    4950 </span>            :     {
<span class="lineNum">    4951 </span>            :         return (*reinterpret_cast&lt;char*&gt;(&amp;num) == 1);
<span class="lineNum">    4952 </span>            :     }
<span class="lineNum">    4953 </span>            : 
<span class="lineNum">    4954 </span>            :   private:
<span class="lineNum">    4955 </span>            :     /*!
<span class="lineNum">    4956 </span>            :     @param[in] get_char  whether a new character should be retrieved from the
<span class="lineNum">    4957 </span>            :                          input (true, default) or whether the last read
<span class="lineNum">    4958 </span>            :                          character should be considered instead
<span class="lineNum">    4959 </span>            :     */
<span class="lineNum">    4960 </span>            :     BasicJsonType parse_cbor_internal(const bool get_char = true)
<span class="lineNum">    4961 </span>            :     {
<span class="lineNum">    4962 </span>            :         switch (get_char ? get() : current)
<span class="lineNum">    4963 </span>            :         {
<span class="lineNum">    4964 </span>            :             // EOF
<span class="lineNum">    4965 </span>            :             case std::char_traits&lt;char&gt;::eof():
<span class="lineNum">    4966 </span>            :                 JSON_THROW(parse_error::create(110, chars_read, &quot;unexpected end of input&quot;));
<span class="lineNum">    4967 </span>            : 
<span class="lineNum">    4968 </span>            :             // Integer 0x00..0x17 (0..23)
<span class="lineNum">    4969 </span>            :             case 0x00:
<span class="lineNum">    4970 </span>            :             case 0x01:
<span class="lineNum">    4971 </span>            :             case 0x02:
<span class="lineNum">    4972 </span>            :             case 0x03:
<span class="lineNum">    4973 </span>            :             case 0x04:
<span class="lineNum">    4974 </span>            :             case 0x05:
<span class="lineNum">    4975 </span>            :             case 0x06:
<span class="lineNum">    4976 </span>            :             case 0x07:
<span class="lineNum">    4977 </span>            :             case 0x08:
<span class="lineNum">    4978 </span>            :             case 0x09:
<span class="lineNum">    4979 </span>            :             case 0x0A:
<span class="lineNum">    4980 </span>            :             case 0x0B:
<span class="lineNum">    4981 </span>            :             case 0x0C:
<span class="lineNum">    4982 </span>            :             case 0x0D:
<span class="lineNum">    4983 </span>            :             case 0x0E:
<span class="lineNum">    4984 </span>            :             case 0x0F:
<span class="lineNum">    4985 </span>            :             case 0x10:
<span class="lineNum">    4986 </span>            :             case 0x11:
<span class="lineNum">    4987 </span>            :             case 0x12:
<span class="lineNum">    4988 </span>            :             case 0x13:
<span class="lineNum">    4989 </span>            :             case 0x14:
<span class="lineNum">    4990 </span>            :             case 0x15:
<span class="lineNum">    4991 </span>            :             case 0x16:
<span class="lineNum">    4992 </span>            :             case 0x17:
<span class="lineNum">    4993 </span>            :                 return static_cast&lt;number_unsigned_t&gt;(current);
<span class="lineNum">    4994 </span>            : 
<span class="lineNum">    4995 </span>            :             case 0x18: // Unsigned integer (one-byte uint8_t follows)
<span class="lineNum">    4996 </span>            :                 return get_number&lt;uint8_t&gt;();
<span class="lineNum">    4997 </span>            : 
<span class="lineNum">    4998 </span>            :             case 0x19: // Unsigned integer (two-byte uint16_t follows)
<span class="lineNum">    4999 </span>            :                 return get_number&lt;uint16_t&gt;();
<span class="lineNum">    5000 </span>            : 
<span class="lineNum">    5001 </span>            :             case 0x1A: // Unsigned integer (four-byte uint32_t follows)
<span class="lineNum">    5002 </span>            :                 return get_number&lt;uint32_t&gt;();
<span class="lineNum">    5003 </span>            : 
<span class="lineNum">    5004 </span>            :             case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
<span class="lineNum">    5005 </span>            :                 return get_number&lt;uint64_t&gt;();
<span class="lineNum">    5006 </span>            : 
<span class="lineNum">    5007 </span>            :             // Negative integer -1-0x00..-1-0x17 (-1..-24)
<span class="lineNum">    5008 </span>            :             case 0x20:
<span class="lineNum">    5009 </span>            :             case 0x21:
<span class="lineNum">    5010 </span>            :             case 0x22:
<span class="lineNum">    5011 </span>            :             case 0x23:
<span class="lineNum">    5012 </span>            :             case 0x24:
<span class="lineNum">    5013 </span>            :             case 0x25:
<span class="lineNum">    5014 </span>            :             case 0x26:
<span class="lineNum">    5015 </span>            :             case 0x27:
<span class="lineNum">    5016 </span>            :             case 0x28:
<span class="lineNum">    5017 </span>            :             case 0x29:
<span class="lineNum">    5018 </span>            :             case 0x2A:
<span class="lineNum">    5019 </span>            :             case 0x2B:
<span class="lineNum">    5020 </span>            :             case 0x2C:
<span class="lineNum">    5021 </span>            :             case 0x2D:
<span class="lineNum">    5022 </span>            :             case 0x2E:
<span class="lineNum">    5023 </span>            :             case 0x2F:
<span class="lineNum">    5024 </span>            :             case 0x30:
<span class="lineNum">    5025 </span>            :             case 0x31:
<span class="lineNum">    5026 </span>            :             case 0x32:
<span class="lineNum">    5027 </span>            :             case 0x33:
<span class="lineNum">    5028 </span>            :             case 0x34:
<span class="lineNum">    5029 </span>            :             case 0x35:
<span class="lineNum">    5030 </span>            :             case 0x36:
<span class="lineNum">    5031 </span>            :             case 0x37:
<span class="lineNum">    5032 </span>            :                 return static_cast&lt;int8_t&gt;(0x20 - 1 - current);
<span class="lineNum">    5033 </span>            : 
<span class="lineNum">    5034 </span>            :             case 0x38: // Negative integer (one-byte uint8_t follows)
<span class="lineNum">    5035 </span>            :             {
<span class="lineNum">    5036 </span>            :                 return static_cast&lt;number_integer_t&gt;(-1) - get_number&lt;uint8_t&gt;();
<span class="lineNum">    5037 </span>            :             }
<span class="lineNum">    5038 </span>            : 
<span class="lineNum">    5039 </span>            :             case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
<span class="lineNum">    5040 </span>            :             {
<span class="lineNum">    5041 </span>            :                 return static_cast&lt;number_integer_t&gt;(-1) - get_number&lt;uint16_t&gt;();
<span class="lineNum">    5042 </span>            :             }
<span class="lineNum">    5043 </span>            : 
<span class="lineNum">    5044 </span>            :             case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
<span class="lineNum">    5045 </span>            :             {
<span class="lineNum">    5046 </span>            :                 return static_cast&lt;number_integer_t&gt;(-1) - get_number&lt;uint32_t&gt;();
<span class="lineNum">    5047 </span>            :             }
<span class="lineNum">    5048 </span>            : 
<span class="lineNum">    5049 </span>            :             case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
<span class="lineNum">    5050 </span>            :             {
<span class="lineNum">    5051 </span>            :                 return static_cast&lt;number_integer_t&gt;(-1) -
<span class="lineNum">    5052 </span>            :                        static_cast&lt;number_integer_t&gt;(get_number&lt;uint64_t&gt;());
<span class="lineNum">    5053 </span>            :             }
<span class="lineNum">    5054 </span>            : 
<span class="lineNum">    5055 </span>            :             // UTF-8 string (0x00..0x17 bytes follow)
<span class="lineNum">    5056 </span>            :             case 0x60:
<span class="lineNum">    5057 </span>            :             case 0x61:
<span class="lineNum">    5058 </span>            :             case 0x62:
<span class="lineNum">    5059 </span>            :             case 0x63:
<span class="lineNum">    5060 </span>            :             case 0x64:
<span class="lineNum">    5061 </span>            :             case 0x65:
<span class="lineNum">    5062 </span>            :             case 0x66:
<span class="lineNum">    5063 </span>            :             case 0x67:
<span class="lineNum">    5064 </span>            :             case 0x68:
<span class="lineNum">    5065 </span>            :             case 0x69:
<span class="lineNum">    5066 </span>            :             case 0x6A:
<span class="lineNum">    5067 </span>            :             case 0x6B:
<span class="lineNum">    5068 </span>            :             case 0x6C:
<span class="lineNum">    5069 </span>            :             case 0x6D:
<span class="lineNum">    5070 </span>            :             case 0x6E:
<span class="lineNum">    5071 </span>            :             case 0x6F:
<span class="lineNum">    5072 </span>            :             case 0x70:
<span class="lineNum">    5073 </span>            :             case 0x71:
<span class="lineNum">    5074 </span>            :             case 0x72:
<span class="lineNum">    5075 </span>            :             case 0x73:
<span class="lineNum">    5076 </span>            :             case 0x74:
<span class="lineNum">    5077 </span>            :             case 0x75:
<span class="lineNum">    5078 </span>            :             case 0x76:
<span class="lineNum">    5079 </span>            :             case 0x77:
<span class="lineNum">    5080 </span>            :             case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
<span class="lineNum">    5081 </span>            :             case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
<span class="lineNum">    5082 </span>            :             case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
<span class="lineNum">    5083 </span>            :             case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
<span class="lineNum">    5084 </span>            :             case 0x7F: // UTF-8 string (indefinite length)
<span class="lineNum">    5085 </span>            :             {
<span class="lineNum">    5086 </span>            :                 return get_cbor_string();
<span class="lineNum">    5087 </span>            :             }
<span class="lineNum">    5088 </span>            : 
<span class="lineNum">    5089 </span>            :             // array (0x00..0x17 data items follow)
<span class="lineNum">    5090 </span>            :             case 0x80:
<span class="lineNum">    5091 </span>            :             case 0x81:
<span class="lineNum">    5092 </span>            :             case 0x82:
<span class="lineNum">    5093 </span>            :             case 0x83:
<span class="lineNum">    5094 </span>            :             case 0x84:
<span class="lineNum">    5095 </span>            :             case 0x85:
<span class="lineNum">    5096 </span>            :             case 0x86:
<span class="lineNum">    5097 </span>            :             case 0x87:
<span class="lineNum">    5098 </span>            :             case 0x88:
<span class="lineNum">    5099 </span>            :             case 0x89:
<span class="lineNum">    5100 </span>            :             case 0x8A:
<span class="lineNum">    5101 </span>            :             case 0x8B:
<span class="lineNum">    5102 </span>            :             case 0x8C:
<span class="lineNum">    5103 </span>            :             case 0x8D:
<span class="lineNum">    5104 </span>            :             case 0x8E:
<span class="lineNum">    5105 </span>            :             case 0x8F:
<span class="lineNum">    5106 </span>            :             case 0x90:
<span class="lineNum">    5107 </span>            :             case 0x91:
<span class="lineNum">    5108 </span>            :             case 0x92:
<span class="lineNum">    5109 </span>            :             case 0x93:
<span class="lineNum">    5110 </span>            :             case 0x94:
<span class="lineNum">    5111 </span>            :             case 0x95:
<span class="lineNum">    5112 </span>            :             case 0x96:
<span class="lineNum">    5113 </span>            :             case 0x97:
<span class="lineNum">    5114 </span>            :             {
<span class="lineNum">    5115 </span>            :                 return get_cbor_array(current &amp; 0x1F);
<span class="lineNum">    5116 </span>            :             }
<span class="lineNum">    5117 </span>            : 
<span class="lineNum">    5118 </span>            :             case 0x98: // array (one-byte uint8_t for n follows)
<span class="lineNum">    5119 </span>            :             {
<span class="lineNum">    5120 </span>            :                 return get_cbor_array(get_number&lt;uint8_t&gt;());
<span class="lineNum">    5121 </span>            :             }
<span class="lineNum">    5122 </span>            : 
<span class="lineNum">    5123 </span>            :             case 0x99: // array (two-byte uint16_t for n follow)
<span class="lineNum">    5124 </span>            :             {
<span class="lineNum">    5125 </span>            :                 return get_cbor_array(get_number&lt;uint16_t&gt;());
<span class="lineNum">    5126 </span>            :             }
<span class="lineNum">    5127 </span>            : 
<span class="lineNum">    5128 </span>            :             case 0x9A: // array (four-byte uint32_t for n follow)
<span class="lineNum">    5129 </span>            :             {
<span class="lineNum">    5130 </span>            :                 return get_cbor_array(get_number&lt;uint32_t&gt;());
<span class="lineNum">    5131 </span>            :             }
<span class="lineNum">    5132 </span>            : 
<span class="lineNum">    5133 </span>            :             case 0x9B: // array (eight-byte uint64_t for n follow)
<span class="lineNum">    5134 </span>            :             {
<span class="lineNum">    5135 </span>            :                 return get_cbor_array(get_number&lt;uint64_t&gt;());
<span class="lineNum">    5136 </span>            :             }
<span class="lineNum">    5137 </span>            : 
<span class="lineNum">    5138 </span>            :             case 0x9F: // array (indefinite length)
<span class="lineNum">    5139 </span>            :             {
<span class="lineNum">    5140 </span>            :                 BasicJsonType result = value_t::array;
<span class="lineNum">    5141 </span>            :                 while (get() != 0xFF)
<span class="lineNum">    5142 </span>            :                 {
<span class="lineNum">    5143 </span>            :                     result.push_back(parse_cbor_internal(false));
<span class="lineNum">    5144 </span>            :                 }
<span class="lineNum">    5145 </span>            :                 return result;
<span class="lineNum">    5146 </span>            :             }
<span class="lineNum">    5147 </span>            : 
<span class="lineNum">    5148 </span>            :             // map (0x00..0x17 pairs of data items follow)
<span class="lineNum">    5149 </span>            :             case 0xA0:
<span class="lineNum">    5150 </span>            :             case 0xA1:
<span class="lineNum">    5151 </span>            :             case 0xA2:
<span class="lineNum">    5152 </span>            :             case 0xA3:
<span class="lineNum">    5153 </span>            :             case 0xA4:
<span class="lineNum">    5154 </span>            :             case 0xA5:
<span class="lineNum">    5155 </span>            :             case 0xA6:
<span class="lineNum">    5156 </span>            :             case 0xA7:
<span class="lineNum">    5157 </span>            :             case 0xA8:
<span class="lineNum">    5158 </span>            :             case 0xA9:
<span class="lineNum">    5159 </span>            :             case 0xAA:
<span class="lineNum">    5160 </span>            :             case 0xAB:
<span class="lineNum">    5161 </span>            :             case 0xAC:
<span class="lineNum">    5162 </span>            :             case 0xAD:
<span class="lineNum">    5163 </span>            :             case 0xAE:
<span class="lineNum">    5164 </span>            :             case 0xAF:
<span class="lineNum">    5165 </span>            :             case 0xB0:
<span class="lineNum">    5166 </span>            :             case 0xB1:
<span class="lineNum">    5167 </span>            :             case 0xB2:
<span class="lineNum">    5168 </span>            :             case 0xB3:
<span class="lineNum">    5169 </span>            :             case 0xB4:
<span class="lineNum">    5170 </span>            :             case 0xB5:
<span class="lineNum">    5171 </span>            :             case 0xB6:
<span class="lineNum">    5172 </span>            :             case 0xB7:
<span class="lineNum">    5173 </span>            :             {
<span class="lineNum">    5174 </span>            :                 return get_cbor_object(current &amp; 0x1F);
<span class="lineNum">    5175 </span>            :             }
<span class="lineNum">    5176 </span>            : 
<span class="lineNum">    5177 </span>            :             case 0xB8: // map (one-byte uint8_t for n follows)
<span class="lineNum">    5178 </span>            :             {
<span class="lineNum">    5179 </span>            :                 return get_cbor_object(get_number&lt;uint8_t&gt;());
<span class="lineNum">    5180 </span>            :             }
<span class="lineNum">    5181 </span>            : 
<span class="lineNum">    5182 </span>            :             case 0xB9: // map (two-byte uint16_t for n follow)
<span class="lineNum">    5183 </span>            :             {
<span class="lineNum">    5184 </span>            :                 return get_cbor_object(get_number&lt;uint16_t&gt;());
<span class="lineNum">    5185 </span>            :             }
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span>            :             case 0xBA: // map (four-byte uint32_t for n follow)
<span class="lineNum">    5188 </span>            :             {
<span class="lineNum">    5189 </span>            :                 return get_cbor_object(get_number&lt;uint32_t&gt;());
<span class="lineNum">    5190 </span>            :             }
<span class="lineNum">    5191 </span>            : 
<span class="lineNum">    5192 </span>            :             case 0xBB: // map (eight-byte uint64_t for n follow)
<span class="lineNum">    5193 </span>            :             {
<span class="lineNum">    5194 </span>            :                 return get_cbor_object(get_number&lt;uint64_t&gt;());
<span class="lineNum">    5195 </span>            :             }
<span class="lineNum">    5196 </span>            : 
<span class="lineNum">    5197 </span>            :             case 0xBF: // map (indefinite length)
<span class="lineNum">    5198 </span>            :             {
<span class="lineNum">    5199 </span>            :                 BasicJsonType result = value_t::object;
<span class="lineNum">    5200 </span>            :                 while (get() != 0xFF)
<span class="lineNum">    5201 </span>            :                 {
<span class="lineNum">    5202 </span>            :                     auto key = get_cbor_string();
<span class="lineNum">    5203 </span>            :                     result[key] = parse_cbor_internal();
<span class="lineNum">    5204 </span>            :                 }
<span class="lineNum">    5205 </span>            :                 return result;
<span class="lineNum">    5206 </span>            :             }
<span class="lineNum">    5207 </span>            : 
<span class="lineNum">    5208 </span>            :             case 0xF4: // false
<span class="lineNum">    5209 </span>            :             {
<span class="lineNum">    5210 </span>            :                 return false;
<span class="lineNum">    5211 </span>            :             }
<span class="lineNum">    5212 </span>            : 
<span class="lineNum">    5213 </span>            :             case 0xF5: // true
<span class="lineNum">    5214 </span>            :             {
<span class="lineNum">    5215 </span>            :                 return true;
<span class="lineNum">    5216 </span>            :             }
<span class="lineNum">    5217 </span>            : 
<span class="lineNum">    5218 </span>            :             case 0xF6: // null
<span class="lineNum">    5219 </span>            :             {
<span class="lineNum">    5220 </span>            :                 return value_t::null;
<span class="lineNum">    5221 </span>            :             }
<span class="lineNum">    5222 </span>            : 
<span class="lineNum">    5223 </span>            :             case 0xF9: // Half-Precision Float (two-byte IEEE 754)
<span class="lineNum">    5224 </span>            :             {
<span class="lineNum">    5225 </span>            :                 const int byte1 = get();
<span class="lineNum">    5226 </span>            :                 unexpect_eof();
<span class="lineNum">    5227 </span>            :                 const int byte2 = get();
<span class="lineNum">    5228 </span>            :                 unexpect_eof();
<span class="lineNum">    5229 </span>            : 
<span class="lineNum">    5230 </span>            :                 // code from RFC 7049, Appendix D, Figure 3:
<span class="lineNum">    5231 </span>            :                 // As half-precision floating-point numbers were only added
<span class="lineNum">    5232 </span>            :                 // to IEEE 754 in 2008, today's programming platforms often
<span class="lineNum">    5233 </span>            :                 // still only have limited support for them. It is very
<span class="lineNum">    5234 </span>            :                 // easy to include at least decoding support for them even
<span class="lineNum">    5235 </span>            :                 // without such support. An example of a small decoder for
<span class="lineNum">    5236 </span>            :                 // half-precision floating-point numbers in the C language
<span class="lineNum">    5237 </span>            :                 // is shown in Fig. 3.
<span class="lineNum">    5238 </span>            :                 const int half = (byte1 &lt;&lt; 8) + byte2;
<span class="lineNum">    5239 </span>            :                 const int exp = (half &gt;&gt; 10) &amp; 0x1F;
<span class="lineNum">    5240 </span>            :                 const int mant = half &amp; 0x3FF;
<span class="lineNum">    5241 </span>            :                 double val;
<span class="lineNum">    5242 </span>            :                 if (exp == 0)
<span class="lineNum">    5243 </span>            :                 {
<span class="lineNum">    5244 </span>            :                     val = std::ldexp(mant, -24);
<span class="lineNum">    5245 </span>            :                 }
<span class="lineNum">    5246 </span>            :                 else if (exp != 31)
<span class="lineNum">    5247 </span>            :                 {
<span class="lineNum">    5248 </span>            :                     val = std::ldexp(mant + 1024, exp - 25);
<span class="lineNum">    5249 </span>            :                 }
<span class="lineNum">    5250 </span>            :                 else
<span class="lineNum">    5251 </span>            :                 {
<span class="lineNum">    5252 </span>            :                     val = (mant == 0) ? std::numeric_limits&lt;double&gt;::infinity()
<span class="lineNum">    5253 </span>            :                           : std::numeric_limits&lt;double&gt;::quiet_NaN();
<span class="lineNum">    5254 </span>            :                 }
<span class="lineNum">    5255 </span>            :                 return (half &amp; 0x8000) != 0 ? -val : val;
<span class="lineNum">    5256 </span>            :             }
<span class="lineNum">    5257 </span>            : 
<span class="lineNum">    5258 </span>            :             case 0xFA: // Single-Precision Float (four-byte IEEE 754)
<span class="lineNum">    5259 </span>            :             {
<span class="lineNum">    5260 </span>            :                 return get_number&lt;float&gt;();
<span class="lineNum">    5261 </span>            :             }
<span class="lineNum">    5262 </span>            : 
<span class="lineNum">    5263 </span>            :             case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
<span class="lineNum">    5264 </span>            :             {
<span class="lineNum">    5265 </span>            :                 return get_number&lt;double&gt;();
<span class="lineNum">    5266 </span>            :             }
<span class="lineNum">    5267 </span>            : 
<span class="lineNum">    5268 </span>            :             default: // anything else (0xFF is handled inside the other types)
<span class="lineNum">    5269 </span>            :             {
<span class="lineNum">    5270 </span>            :                 std::stringstream ss;
<span class="lineNum">    5271 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    5272 </span>            :                 JSON_THROW(parse_error::create(112, chars_read, &quot;error reading CBOR; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    5273 </span>            :             }
<span class="lineNum">    5274 </span>            :         }
<span class="lineNum">    5275 </span>            :     }
<span class="lineNum">    5276 </span>            : 
<span class="lineNum">    5277 </span>            :     BasicJsonType parse_msgpack_internal()
<span class="lineNum">    5278 </span>            :     {
<span class="lineNum">    5279 </span>            :         switch (get())
<span class="lineNum">    5280 </span>            :         {
<span class="lineNum">    5281 </span>            :             // EOF
<span class="lineNum">    5282 </span>            :             case std::char_traits&lt;char&gt;::eof():
<span class="lineNum">    5283 </span>            :                 JSON_THROW(parse_error::create(110, chars_read, &quot;unexpected end of input&quot;));
<span class="lineNum">    5284 </span>            : 
<span class="lineNum">    5285 </span>            :             // positive fixint
<span class="lineNum">    5286 </span>            :             case 0x00:
<span class="lineNum">    5287 </span>            :             case 0x01:
<span class="lineNum">    5288 </span>            :             case 0x02:
<span class="lineNum">    5289 </span>            :             case 0x03:
<span class="lineNum">    5290 </span>            :             case 0x04:
<span class="lineNum">    5291 </span>            :             case 0x05:
<span class="lineNum">    5292 </span>            :             case 0x06:
<span class="lineNum">    5293 </span>            :             case 0x07:
<span class="lineNum">    5294 </span>            :             case 0x08:
<span class="lineNum">    5295 </span>            :             case 0x09:
<span class="lineNum">    5296 </span>            :             case 0x0A:
<span class="lineNum">    5297 </span>            :             case 0x0B:
<span class="lineNum">    5298 </span>            :             case 0x0C:
<span class="lineNum">    5299 </span>            :             case 0x0D:
<span class="lineNum">    5300 </span>            :             case 0x0E:
<span class="lineNum">    5301 </span>            :             case 0x0F:
<span class="lineNum">    5302 </span>            :             case 0x10:
<span class="lineNum">    5303 </span>            :             case 0x11:
<span class="lineNum">    5304 </span>            :             case 0x12:
<span class="lineNum">    5305 </span>            :             case 0x13:
<span class="lineNum">    5306 </span>            :             case 0x14:
<span class="lineNum">    5307 </span>            :             case 0x15:
<span class="lineNum">    5308 </span>            :             case 0x16:
<span class="lineNum">    5309 </span>            :             case 0x17:
<span class="lineNum">    5310 </span>            :             case 0x18:
<span class="lineNum">    5311 </span>            :             case 0x19:
<span class="lineNum">    5312 </span>            :             case 0x1A:
<span class="lineNum">    5313 </span>            :             case 0x1B:
<span class="lineNum">    5314 </span>            :             case 0x1C:
<span class="lineNum">    5315 </span>            :             case 0x1D:
<span class="lineNum">    5316 </span>            :             case 0x1E:
<span class="lineNum">    5317 </span>            :             case 0x1F:
<span class="lineNum">    5318 </span>            :             case 0x20:
<span class="lineNum">    5319 </span>            :             case 0x21:
<span class="lineNum">    5320 </span>            :             case 0x22:
<span class="lineNum">    5321 </span>            :             case 0x23:
<span class="lineNum">    5322 </span>            :             case 0x24:
<span class="lineNum">    5323 </span>            :             case 0x25:
<span class="lineNum">    5324 </span>            :             case 0x26:
<span class="lineNum">    5325 </span>            :             case 0x27:
<span class="lineNum">    5326 </span>            :             case 0x28:
<span class="lineNum">    5327 </span>            :             case 0x29:
<span class="lineNum">    5328 </span>            :             case 0x2A:
<span class="lineNum">    5329 </span>            :             case 0x2B:
<span class="lineNum">    5330 </span>            :             case 0x2C:
<span class="lineNum">    5331 </span>            :             case 0x2D:
<span class="lineNum">    5332 </span>            :             case 0x2E:
<span class="lineNum">    5333 </span>            :             case 0x2F:
<span class="lineNum">    5334 </span>            :             case 0x30:
<span class="lineNum">    5335 </span>            :             case 0x31:
<span class="lineNum">    5336 </span>            :             case 0x32:
<span class="lineNum">    5337 </span>            :             case 0x33:
<span class="lineNum">    5338 </span>            :             case 0x34:
<span class="lineNum">    5339 </span>            :             case 0x35:
<span class="lineNum">    5340 </span>            :             case 0x36:
<span class="lineNum">    5341 </span>            :             case 0x37:
<span class="lineNum">    5342 </span>            :             case 0x38:
<span class="lineNum">    5343 </span>            :             case 0x39:
<span class="lineNum">    5344 </span>            :             case 0x3A:
<span class="lineNum">    5345 </span>            :             case 0x3B:
<span class="lineNum">    5346 </span>            :             case 0x3C:
<span class="lineNum">    5347 </span>            :             case 0x3D:
<span class="lineNum">    5348 </span>            :             case 0x3E:
<span class="lineNum">    5349 </span>            :             case 0x3F:
<span class="lineNum">    5350 </span>            :             case 0x40:
<span class="lineNum">    5351 </span>            :             case 0x41:
<span class="lineNum">    5352 </span>            :             case 0x42:
<span class="lineNum">    5353 </span>            :             case 0x43:
<span class="lineNum">    5354 </span>            :             case 0x44:
<span class="lineNum">    5355 </span>            :             case 0x45:
<span class="lineNum">    5356 </span>            :             case 0x46:
<span class="lineNum">    5357 </span>            :             case 0x47:
<span class="lineNum">    5358 </span>            :             case 0x48:
<span class="lineNum">    5359 </span>            :             case 0x49:
<span class="lineNum">    5360 </span>            :             case 0x4A:
<span class="lineNum">    5361 </span>            :             case 0x4B:
<span class="lineNum">    5362 </span>            :             case 0x4C:
<span class="lineNum">    5363 </span>            :             case 0x4D:
<span class="lineNum">    5364 </span>            :             case 0x4E:
<span class="lineNum">    5365 </span>            :             case 0x4F:
<span class="lineNum">    5366 </span>            :             case 0x50:
<span class="lineNum">    5367 </span>            :             case 0x51:
<span class="lineNum">    5368 </span>            :             case 0x52:
<span class="lineNum">    5369 </span>            :             case 0x53:
<span class="lineNum">    5370 </span>            :             case 0x54:
<span class="lineNum">    5371 </span>            :             case 0x55:
<span class="lineNum">    5372 </span>            :             case 0x56:
<span class="lineNum">    5373 </span>            :             case 0x57:
<span class="lineNum">    5374 </span>            :             case 0x58:
<span class="lineNum">    5375 </span>            :             case 0x59:
<span class="lineNum">    5376 </span>            :             case 0x5A:
<span class="lineNum">    5377 </span>            :             case 0x5B:
<span class="lineNum">    5378 </span>            :             case 0x5C:
<span class="lineNum">    5379 </span>            :             case 0x5D:
<span class="lineNum">    5380 </span>            :             case 0x5E:
<span class="lineNum">    5381 </span>            :             case 0x5F:
<span class="lineNum">    5382 </span>            :             case 0x60:
<span class="lineNum">    5383 </span>            :             case 0x61:
<span class="lineNum">    5384 </span>            :             case 0x62:
<span class="lineNum">    5385 </span>            :             case 0x63:
<span class="lineNum">    5386 </span>            :             case 0x64:
<span class="lineNum">    5387 </span>            :             case 0x65:
<span class="lineNum">    5388 </span>            :             case 0x66:
<span class="lineNum">    5389 </span>            :             case 0x67:
<span class="lineNum">    5390 </span>            :             case 0x68:
<span class="lineNum">    5391 </span>            :             case 0x69:
<span class="lineNum">    5392 </span>            :             case 0x6A:
<span class="lineNum">    5393 </span>            :             case 0x6B:
<span class="lineNum">    5394 </span>            :             case 0x6C:
<span class="lineNum">    5395 </span>            :             case 0x6D:
<span class="lineNum">    5396 </span>            :             case 0x6E:
<span class="lineNum">    5397 </span>            :             case 0x6F:
<span class="lineNum">    5398 </span>            :             case 0x70:
<span class="lineNum">    5399 </span>            :             case 0x71:
<span class="lineNum">    5400 </span>            :             case 0x72:
<span class="lineNum">    5401 </span>            :             case 0x73:
<span class="lineNum">    5402 </span>            :             case 0x74:
<span class="lineNum">    5403 </span>            :             case 0x75:
<span class="lineNum">    5404 </span>            :             case 0x76:
<span class="lineNum">    5405 </span>            :             case 0x77:
<span class="lineNum">    5406 </span>            :             case 0x78:
<span class="lineNum">    5407 </span>            :             case 0x79:
<span class="lineNum">    5408 </span>            :             case 0x7A:
<span class="lineNum">    5409 </span>            :             case 0x7B:
<span class="lineNum">    5410 </span>            :             case 0x7C:
<span class="lineNum">    5411 </span>            :             case 0x7D:
<span class="lineNum">    5412 </span>            :             case 0x7E:
<span class="lineNum">    5413 </span>            :             case 0x7F:
<span class="lineNum">    5414 </span>            :                 return static_cast&lt;number_unsigned_t&gt;(current);
<span class="lineNum">    5415 </span>            : 
<span class="lineNum">    5416 </span>            :             // fixmap
<span class="lineNum">    5417 </span>            :             case 0x80:
<span class="lineNum">    5418 </span>            :             case 0x81:
<span class="lineNum">    5419 </span>            :             case 0x82:
<span class="lineNum">    5420 </span>            :             case 0x83:
<span class="lineNum">    5421 </span>            :             case 0x84:
<span class="lineNum">    5422 </span>            :             case 0x85:
<span class="lineNum">    5423 </span>            :             case 0x86:
<span class="lineNum">    5424 </span>            :             case 0x87:
<span class="lineNum">    5425 </span>            :             case 0x88:
<span class="lineNum">    5426 </span>            :             case 0x89:
<span class="lineNum">    5427 </span>            :             case 0x8A:
<span class="lineNum">    5428 </span>            :             case 0x8B:
<span class="lineNum">    5429 </span>            :             case 0x8C:
<span class="lineNum">    5430 </span>            :             case 0x8D:
<span class="lineNum">    5431 </span>            :             case 0x8E:
<span class="lineNum">    5432 </span>            :             case 0x8F:
<span class="lineNum">    5433 </span>            :             {
<span class="lineNum">    5434 </span>            :                 return get_msgpack_object(current &amp; 0x0F);
<span class="lineNum">    5435 </span>            :             }
<span class="lineNum">    5436 </span>            : 
<span class="lineNum">    5437 </span>            :             // fixarray
<span class="lineNum">    5438 </span>            :             case 0x90:
<span class="lineNum">    5439 </span>            :             case 0x91:
<span class="lineNum">    5440 </span>            :             case 0x92:
<span class="lineNum">    5441 </span>            :             case 0x93:
<span class="lineNum">    5442 </span>            :             case 0x94:
<span class="lineNum">    5443 </span>            :             case 0x95:
<span class="lineNum">    5444 </span>            :             case 0x96:
<span class="lineNum">    5445 </span>            :             case 0x97:
<span class="lineNum">    5446 </span>            :             case 0x98:
<span class="lineNum">    5447 </span>            :             case 0x99:
<span class="lineNum">    5448 </span>            :             case 0x9A:
<span class="lineNum">    5449 </span>            :             case 0x9B:
<span class="lineNum">    5450 </span>            :             case 0x9C:
<span class="lineNum">    5451 </span>            :             case 0x9D:
<span class="lineNum">    5452 </span>            :             case 0x9E:
<span class="lineNum">    5453 </span>            :             case 0x9F:
<span class="lineNum">    5454 </span>            :             {
<span class="lineNum">    5455 </span>            :                 return get_msgpack_array(current &amp; 0x0F);
<span class="lineNum">    5456 </span>            :             }
<span class="lineNum">    5457 </span>            : 
<span class="lineNum">    5458 </span>            :             // fixstr
<span class="lineNum">    5459 </span>            :             case 0xA0:
<span class="lineNum">    5460 </span>            :             case 0xA1:
<span class="lineNum">    5461 </span>            :             case 0xA2:
<span class="lineNum">    5462 </span>            :             case 0xA3:
<span class="lineNum">    5463 </span>            :             case 0xA4:
<span class="lineNum">    5464 </span>            :             case 0xA5:
<span class="lineNum">    5465 </span>            :             case 0xA6:
<span class="lineNum">    5466 </span>            :             case 0xA7:
<span class="lineNum">    5467 </span>            :             case 0xA8:
<span class="lineNum">    5468 </span>            :             case 0xA9:
<span class="lineNum">    5469 </span>            :             case 0xAA:
<span class="lineNum">    5470 </span>            :             case 0xAB:
<span class="lineNum">    5471 </span>            :             case 0xAC:
<span class="lineNum">    5472 </span>            :             case 0xAD:
<span class="lineNum">    5473 </span>            :             case 0xAE:
<span class="lineNum">    5474 </span>            :             case 0xAF:
<span class="lineNum">    5475 </span>            :             case 0xB0:
<span class="lineNum">    5476 </span>            :             case 0xB1:
<span class="lineNum">    5477 </span>            :             case 0xB2:
<span class="lineNum">    5478 </span>            :             case 0xB3:
<span class="lineNum">    5479 </span>            :             case 0xB4:
<span class="lineNum">    5480 </span>            :             case 0xB5:
<span class="lineNum">    5481 </span>            :             case 0xB6:
<span class="lineNum">    5482 </span>            :             case 0xB7:
<span class="lineNum">    5483 </span>            :             case 0xB8:
<span class="lineNum">    5484 </span>            :             case 0xB9:
<span class="lineNum">    5485 </span>            :             case 0xBA:
<span class="lineNum">    5486 </span>            :             case 0xBB:
<span class="lineNum">    5487 </span>            :             case 0xBC:
<span class="lineNum">    5488 </span>            :             case 0xBD:
<span class="lineNum">    5489 </span>            :             case 0xBE:
<span class="lineNum">    5490 </span>            :             case 0xBF:
<span class="lineNum">    5491 </span>            :                 return get_msgpack_string();
<span class="lineNum">    5492 </span>            : 
<span class="lineNum">    5493 </span>            :             case 0xC0: // nil
<span class="lineNum">    5494 </span>            :                 return value_t::null;
<span class="lineNum">    5495 </span>            : 
<span class="lineNum">    5496 </span>            :             case 0xC2: // false
<span class="lineNum">    5497 </span>            :                 return false;
<span class="lineNum">    5498 </span>            : 
<span class="lineNum">    5499 </span>            :             case 0xC3: // true
<span class="lineNum">    5500 </span>            :                 return true;
<span class="lineNum">    5501 </span>            : 
<span class="lineNum">    5502 </span>            :             case 0xCA: // float 32
<span class="lineNum">    5503 </span>            :                 return get_number&lt;float&gt;();
<span class="lineNum">    5504 </span>            : 
<span class="lineNum">    5505 </span>            :             case 0xCB: // float 64
<span class="lineNum">    5506 </span>            :                 return get_number&lt;double&gt;();
<span class="lineNum">    5507 </span>            : 
<span class="lineNum">    5508 </span>            :             case 0xCC: // uint 8
<span class="lineNum">    5509 </span>            :                 return get_number&lt;uint8_t&gt;();
<span class="lineNum">    5510 </span>            : 
<span class="lineNum">    5511 </span>            :             case 0xCD: // uint 16
<span class="lineNum">    5512 </span>            :                 return get_number&lt;uint16_t&gt;();
<span class="lineNum">    5513 </span>            : 
<span class="lineNum">    5514 </span>            :             case 0xCE: // uint 32
<span class="lineNum">    5515 </span>            :                 return get_number&lt;uint32_t&gt;();
<span class="lineNum">    5516 </span>            : 
<span class="lineNum">    5517 </span>            :             case 0xCF: // uint 64
<span class="lineNum">    5518 </span>            :                 return get_number&lt;uint64_t&gt;();
<span class="lineNum">    5519 </span>            : 
<span class="lineNum">    5520 </span>            :             case 0xD0: // int 8
<span class="lineNum">    5521 </span>            :                 return get_number&lt;int8_t&gt;();
<span class="lineNum">    5522 </span>            : 
<span class="lineNum">    5523 </span>            :             case 0xD1: // int 16
<span class="lineNum">    5524 </span>            :                 return get_number&lt;int16_t&gt;();
<span class="lineNum">    5525 </span>            : 
<span class="lineNum">    5526 </span>            :             case 0xD2: // int 32
<span class="lineNum">    5527 </span>            :                 return get_number&lt;int32_t&gt;();
<span class="lineNum">    5528 </span>            : 
<span class="lineNum">    5529 </span>            :             case 0xD3: // int 64
<span class="lineNum">    5530 </span>            :                 return get_number&lt;int64_t&gt;();
<span class="lineNum">    5531 </span>            : 
<span class="lineNum">    5532 </span>            :             case 0xD9: // str 8
<span class="lineNum">    5533 </span>            :             case 0xDA: // str 16
<span class="lineNum">    5534 </span>            :             case 0xDB: // str 32
<span class="lineNum">    5535 </span>            :                 return get_msgpack_string();
<span class="lineNum">    5536 </span>            : 
<span class="lineNum">    5537 </span>            :             case 0xDC: // array 16
<span class="lineNum">    5538 </span>            :             {
<span class="lineNum">    5539 </span>            :                 return get_msgpack_array(get_number&lt;uint16_t&gt;());
<span class="lineNum">    5540 </span>            :             }
<span class="lineNum">    5541 </span>            : 
<span class="lineNum">    5542 </span>            :             case 0xDD: // array 32
<span class="lineNum">    5543 </span>            :             {
<span class="lineNum">    5544 </span>            :                 return get_msgpack_array(get_number&lt;uint32_t&gt;());
<span class="lineNum">    5545 </span>            :             }
<span class="lineNum">    5546 </span>            : 
<span class="lineNum">    5547 </span>            :             case 0xDE: // map 16
<span class="lineNum">    5548 </span>            :             {
<span class="lineNum">    5549 </span>            :                 return get_msgpack_object(get_number&lt;uint16_t&gt;());
<span class="lineNum">    5550 </span>            :             }
<span class="lineNum">    5551 </span>            : 
<span class="lineNum">    5552 </span>            :             case 0xDF: // map 32
<span class="lineNum">    5553 </span>            :             {
<span class="lineNum">    5554 </span>            :                 return get_msgpack_object(get_number&lt;uint32_t&gt;());
<span class="lineNum">    5555 </span>            :             }
<span class="lineNum">    5556 </span>            : 
<span class="lineNum">    5557 </span>            :             // positive fixint
<span class="lineNum">    5558 </span>            :             case 0xE0:
<span class="lineNum">    5559 </span>            :             case 0xE1:
<span class="lineNum">    5560 </span>            :             case 0xE2:
<span class="lineNum">    5561 </span>            :             case 0xE3:
<span class="lineNum">    5562 </span>            :             case 0xE4:
<span class="lineNum">    5563 </span>            :             case 0xE5:
<span class="lineNum">    5564 </span>            :             case 0xE6:
<span class="lineNum">    5565 </span>            :             case 0xE7:
<span class="lineNum">    5566 </span>            :             case 0xE8:
<span class="lineNum">    5567 </span>            :             case 0xE9:
<span class="lineNum">    5568 </span>            :             case 0xEA:
<span class="lineNum">    5569 </span>            :             case 0xEB:
<span class="lineNum">    5570 </span>            :             case 0xEC:
<span class="lineNum">    5571 </span>            :             case 0xED:
<span class="lineNum">    5572 </span>            :             case 0xEE:
<span class="lineNum">    5573 </span>            :             case 0xEF:
<span class="lineNum">    5574 </span>            :             case 0xF0:
<span class="lineNum">    5575 </span>            :             case 0xF1:
<span class="lineNum">    5576 </span>            :             case 0xF2:
<span class="lineNum">    5577 </span>            :             case 0xF3:
<span class="lineNum">    5578 </span>            :             case 0xF4:
<span class="lineNum">    5579 </span>            :             case 0xF5:
<span class="lineNum">    5580 </span>            :             case 0xF6:
<span class="lineNum">    5581 </span>            :             case 0xF7:
<span class="lineNum">    5582 </span>            :             case 0xF8:
<span class="lineNum">    5583 </span>            :             case 0xF9:
<span class="lineNum">    5584 </span>            :             case 0xFA:
<span class="lineNum">    5585 </span>            :             case 0xFB:
<span class="lineNum">    5586 </span>            :             case 0xFC:
<span class="lineNum">    5587 </span>            :             case 0xFD:
<span class="lineNum">    5588 </span>            :             case 0xFE:
<span class="lineNum">    5589 </span>            :             case 0xFF:
<span class="lineNum">    5590 </span>            :                 return static_cast&lt;int8_t&gt;(current);
<span class="lineNum">    5591 </span>            : 
<span class="lineNum">    5592 </span>            :             default: // anything else
<span class="lineNum">    5593 </span>            :             {
<span class="lineNum">    5594 </span>            :                 std::stringstream ss;
<span class="lineNum">    5595 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    5596 </span>            :                 JSON_THROW(parse_error::create(112, chars_read,
<span class="lineNum">    5597 </span>            :                                                &quot;error reading MessagePack; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    5598 </span>            :             }
<span class="lineNum">    5599 </span>            :         }
<span class="lineNum">    5600 </span>            :     }
<span class="lineNum">    5601 </span>            : 
<span class="lineNum">    5602 </span>            :     /*!
<span class="lineNum">    5603 </span>            :     @param[in] get_char  whether a new character should be retrieved from the
<span class="lineNum">    5604 </span>            :                          input (true, default) or whether the last read
<span class="lineNum">    5605 </span>            :                          character should be considered instead
<span class="lineNum">    5606 </span>            :     */
<span class="lineNum">    5607 </span>            :     BasicJsonType parse_ubjson_internal(const bool get_char = true)
<span class="lineNum">    5608 </span>            :     {
<span class="lineNum">    5609 </span>            :         return get_ubjson_value(get_char ? get_ignore_noop() : current);
<span class="lineNum">    5610 </span>            :     }
<span class="lineNum">    5611 </span>            : 
<span class="lineNum">    5612 </span>            :     /*!
<span class="lineNum">    5613 </span>            :     @brief get next character from the input
<span class="lineNum">    5614 </span>            : 
<span class="lineNum">    5615 </span>            :     This function provides the interface to the used input adapter. It does
<span class="lineNum">    5616 </span>            :     not throw in case the input reached EOF, but returns a -'ve valued
<span class="lineNum">    5617 </span>            :     `std::char_traits&lt;char&gt;::eof()` in that case.
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span>            :     @return character read from the input
<span class="lineNum">    5620 </span>            :     */
<span class="lineNum">    5621 </span>            :     int get()
<span class="lineNum">    5622 </span>            :     {
<span class="lineNum">    5623 </span>            :         ++chars_read;
<span class="lineNum">    5624 </span>            :         return (current = ia-&gt;get_character());
<span class="lineNum">    5625 </span>            :     }
<span class="lineNum">    5626 </span>            : 
<span class="lineNum">    5627 </span>            :     /*!
<span class="lineNum">    5628 </span>            :     @return character read from the input after ignoring all 'N' entries
<span class="lineNum">    5629 </span>            :     */
<span class="lineNum">    5630 </span>            :     int get_ignore_noop()
<span class="lineNum">    5631 </span>            :     {
<span class="lineNum">    5632 </span>            :         do
<span class="lineNum">    5633 </span>            :         {
<span class="lineNum">    5634 </span>            :             get();
<span class="lineNum">    5635 </span>            :         }
<span class="lineNum">    5636 </span>            :         while (current == 'N');
<span class="lineNum">    5637 </span>            : 
<span class="lineNum">    5638 </span>            :         return current;
<span class="lineNum">    5639 </span>            :     }
<span class="lineNum">    5640 </span>            : 
<span class="lineNum">    5641 </span>            :     /*
<span class="lineNum">    5642 </span>            :     @brief read a number from the input
<span class="lineNum">    5643 </span>            : 
<span class="lineNum">    5644 </span>            :     @tparam NumberType the type of the number
<span class="lineNum">    5645 </span>            : 
<span class="lineNum">    5646 </span>            :     @return number of type @a NumberType
<span class="lineNum">    5647 </span>            : 
<span class="lineNum">    5648 </span>            :     @note This function needs to respect the system's endianess, because
<span class="lineNum">    5649 </span>            :           bytes in CBOR and MessagePack are stored in network order (big
<span class="lineNum">    5650 </span>            :           endian) and therefore need reordering on little endian systems.
<span class="lineNum">    5651 </span>            : 
<span class="lineNum">    5652 </span>            :     @throw parse_error.110 if input has less than `sizeof(NumberType)` bytes
<span class="lineNum">    5653 </span>            :     */
<span class="lineNum">    5654 </span>            :     template&lt;typename NumberType&gt; NumberType get_number()
<span class="lineNum">    5655 </span>            :     {
<span class="lineNum">    5656 </span>            :         // step 1: read input into array with system's byte order
<span class="lineNum">    5657 </span>            :         std::array&lt;uint8_t, sizeof(NumberType)&gt; vec;
<span class="lineNum">    5658 </span>            :         for (std::size_t i = 0; i &lt; sizeof(NumberType); ++i)
<span class="lineNum">    5659 </span>            :         {
<span class="lineNum">    5660 </span>            :             get();
<span class="lineNum">    5661 </span>            :             unexpect_eof();
<span class="lineNum">    5662 </span>            : 
<span class="lineNum">    5663 </span>            :             // reverse byte order prior to conversion if necessary
<span class="lineNum">    5664 </span>            :             if (is_little_endian)
<span class="lineNum">    5665 </span>            :             {
<span class="lineNum">    5666 </span>            :                 vec[sizeof(NumberType) - i - 1] = static_cast&lt;uint8_t&gt;(current);
<span class="lineNum">    5667 </span>            :             }
<span class="lineNum">    5668 </span>            :             else
<span class="lineNum">    5669 </span>            :             {
<span class="lineNum">    5670 </span>            :                 vec[i] = static_cast&lt;uint8_t&gt;(current); // LCOV_EXCL_LINE
<span class="lineNum">    5671 </span>            :             }
<span class="lineNum">    5672 </span>            :         }
<span class="lineNum">    5673 </span>            : 
<span class="lineNum">    5674 </span>            :         // step 2: convert array into number of type T and return
<span class="lineNum">    5675 </span>            :         NumberType result;
<span class="lineNum">    5676 </span>            :         std::memcpy(&amp;result, vec.data(), sizeof(NumberType));
<span class="lineNum">    5677 </span>            :         return result;
<span class="lineNum">    5678 </span>            :     }
<span class="lineNum">    5679 </span>            : 
<span class="lineNum">    5680 </span>            :     /*!
<span class="lineNum">    5681 </span>            :     @brief create a string by reading characters from the input
<span class="lineNum">    5682 </span>            : 
<span class="lineNum">    5683 </span>            :     @param[in] len number of bytes to read
<span class="lineNum">    5684 </span>            : 
<span class="lineNum">    5685 </span>            :     @note We can not reserve @a len bytes for the result, because @a len
<span class="lineNum">    5686 </span>            :           may be too large. Usually, @ref unexpect_eof() detects the end of
<span class="lineNum">    5687 </span>            :           the input before we run out of string memory.
<span class="lineNum">    5688 </span>            : 
<span class="lineNum">    5689 </span>            :     @return string created by reading @a len bytes
<span class="lineNum">    5690 </span>            : 
<span class="lineNum">    5691 </span>            :     @throw parse_error.110 if input has less than @a len bytes
<span class="lineNum">    5692 </span>            :     */
<span class="lineNum">    5693 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    5694 </span>            :     string_t get_string(const NumberType len)
<span class="lineNum">    5695 </span>            :     {
<span class="lineNum">    5696 </span>            :         string_t result;
<span class="lineNum">    5697 </span>            :         std::generate_n(std::back_inserter(result), len, [this]()
<span class="lineNum">    5698 </span>            :         {
<span class="lineNum">    5699 </span>            :             get();
<span class="lineNum">    5700 </span>            :             unexpect_eof();
<span class="lineNum">    5701 </span>            :             return static_cast&lt;char&gt;(current);
<span class="lineNum">    5702 </span>            :         });
<span class="lineNum">    5703 </span>            :         return result;
<span class="lineNum">    5704 </span>            :     }
<span class="lineNum">    5705 </span>            : 
<span class="lineNum">    5706 </span>            :     /*!
<span class="lineNum">    5707 </span>            :     @brief reads a CBOR string
<span class="lineNum">    5708 </span>            : 
<span class="lineNum">    5709 </span>            :     This function first reads starting bytes to determine the expected
<span class="lineNum">    5710 </span>            :     string length and then copies this number of bytes into a string.
<span class="lineNum">    5711 </span>            :     Additionally, CBOR's strings with indefinite lengths are supported.
<span class="lineNum">    5712 </span>            : 
<span class="lineNum">    5713 </span>            :     @return string
<span class="lineNum">    5714 </span>            : 
<span class="lineNum">    5715 </span>            :     @throw parse_error.110 if input ended
<span class="lineNum">    5716 </span>            :     @throw parse_error.113 if an unexpected byte is read
<span class="lineNum">    5717 </span>            :     */
<span class="lineNum">    5718 </span>            :     string_t get_cbor_string()
<span class="lineNum">    5719 </span>            :     {
<span class="lineNum">    5720 </span>            :         unexpect_eof();
<span class="lineNum">    5721 </span>            : 
<span class="lineNum">    5722 </span>            :         switch (current)
<span class="lineNum">    5723 </span>            :         {
<span class="lineNum">    5724 </span>            :             // UTF-8 string (0x00..0x17 bytes follow)
<span class="lineNum">    5725 </span>            :             case 0x60:
<span class="lineNum">    5726 </span>            :             case 0x61:
<span class="lineNum">    5727 </span>            :             case 0x62:
<span class="lineNum">    5728 </span>            :             case 0x63:
<span class="lineNum">    5729 </span>            :             case 0x64:
<span class="lineNum">    5730 </span>            :             case 0x65:
<span class="lineNum">    5731 </span>            :             case 0x66:
<span class="lineNum">    5732 </span>            :             case 0x67:
<span class="lineNum">    5733 </span>            :             case 0x68:
<span class="lineNum">    5734 </span>            :             case 0x69:
<span class="lineNum">    5735 </span>            :             case 0x6A:
<span class="lineNum">    5736 </span>            :             case 0x6B:
<span class="lineNum">    5737 </span>            :             case 0x6C:
<span class="lineNum">    5738 </span>            :             case 0x6D:
<span class="lineNum">    5739 </span>            :             case 0x6E:
<span class="lineNum">    5740 </span>            :             case 0x6F:
<span class="lineNum">    5741 </span>            :             case 0x70:
<span class="lineNum">    5742 </span>            :             case 0x71:
<span class="lineNum">    5743 </span>            :             case 0x72:
<span class="lineNum">    5744 </span>            :             case 0x73:
<span class="lineNum">    5745 </span>            :             case 0x74:
<span class="lineNum">    5746 </span>            :             case 0x75:
<span class="lineNum">    5747 </span>            :             case 0x76:
<span class="lineNum">    5748 </span>            :             case 0x77:
<span class="lineNum">    5749 </span>            :             {
<span class="lineNum">    5750 </span>            :                 return get_string(current &amp; 0x1F);
<span class="lineNum">    5751 </span>            :             }
<span class="lineNum">    5752 </span>            : 
<span class="lineNum">    5753 </span>            :             case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
<span class="lineNum">    5754 </span>            :             {
<span class="lineNum">    5755 </span>            :                 return get_string(get_number&lt;uint8_t&gt;());
<span class="lineNum">    5756 </span>            :             }
<span class="lineNum">    5757 </span>            : 
<span class="lineNum">    5758 </span>            :             case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
<span class="lineNum">    5759 </span>            :             {
<span class="lineNum">    5760 </span>            :                 return get_string(get_number&lt;uint16_t&gt;());
<span class="lineNum">    5761 </span>            :             }
<span class="lineNum">    5762 </span>            : 
<span class="lineNum">    5763 </span>            :             case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
<span class="lineNum">    5764 </span>            :             {
<span class="lineNum">    5765 </span>            :                 return get_string(get_number&lt;uint32_t&gt;());
<span class="lineNum">    5766 </span>            :             }
<span class="lineNum">    5767 </span>            : 
<span class="lineNum">    5768 </span>            :             case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
<span class="lineNum">    5769 </span>            :             {
<span class="lineNum">    5770 </span>            :                 return get_string(get_number&lt;uint64_t&gt;());
<span class="lineNum">    5771 </span>            :             }
<span class="lineNum">    5772 </span>            : 
<span class="lineNum">    5773 </span>            :             case 0x7F: // UTF-8 string (indefinite length)
<span class="lineNum">    5774 </span>            :             {
<span class="lineNum">    5775 </span>            :                 string_t result;
<span class="lineNum">    5776 </span>            :                 while (get() != 0xFF)
<span class="lineNum">    5777 </span>            :                 {
<span class="lineNum">    5778 </span>            :                     result.append(get_cbor_string());
<span class="lineNum">    5779 </span>            :                 }
<span class="lineNum">    5780 </span>            :                 return result;
<span class="lineNum">    5781 </span>            :             }
<span class="lineNum">    5782 </span>            : 
<span class="lineNum">    5783 </span>            :             default:
<span class="lineNum">    5784 </span>            :             {
<span class="lineNum">    5785 </span>            :                 std::stringstream ss;
<span class="lineNum">    5786 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    5787 </span>            :                 JSON_THROW(parse_error::create(113, chars_read, &quot;expected a CBOR string; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    5788 </span>            :             }
<span class="lineNum">    5789 </span>            :         }
<span class="lineNum">    5790 </span>            :     }
<span class="lineNum">    5791 </span>            : 
<span class="lineNum">    5792 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    5793 </span>            :     BasicJsonType get_cbor_array(const NumberType len)
<span class="lineNum">    5794 </span>            :     {
<span class="lineNum">    5795 </span>            :         BasicJsonType result = value_t::array;
<span class="lineNum">    5796 </span>            :         std::generate_n(std::back_inserter(*result.m_value.array), len, [this]()
<span class="lineNum">    5797 </span>            :         {
<span class="lineNum">    5798 </span>            :             return parse_cbor_internal();
<span class="lineNum">    5799 </span>            :         });
<span class="lineNum">    5800 </span>            :         return result;
<span class="lineNum">    5801 </span>            :     }
<span class="lineNum">    5802 </span>            : 
<span class="lineNum">    5803 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    5804 </span>            :     BasicJsonType get_cbor_object(const NumberType len)
<span class="lineNum">    5805 </span>            :     {
<span class="lineNum">    5806 </span>            :         BasicJsonType result = value_t::object;
<span class="lineNum">    5807 </span>            :         std::generate_n(std::inserter(*result.m_value.object,
<span class="lineNum">    5808 </span>            :                                       result.m_value.object-&gt;end()),
<span class="lineNum">    5809 </span>            :                         len, [this]()
<span class="lineNum">    5810 </span>            :         {
<span class="lineNum">    5811 </span>            :             get();
<span class="lineNum">    5812 </span>            :             auto key = get_cbor_string();
<span class="lineNum">    5813 </span>            :             auto val = parse_cbor_internal();
<span class="lineNum">    5814 </span>            :             return std::make_pair(std::move(key), std::move(val));
<span class="lineNum">    5815 </span>            :         });
<span class="lineNum">    5816 </span>            :         return result;
<span class="lineNum">    5817 </span>            :     }
<span class="lineNum">    5818 </span>            : 
<span class="lineNum">    5819 </span>            :     /*!
<span class="lineNum">    5820 </span>            :     @brief reads a MessagePack string
<span class="lineNum">    5821 </span>            : 
<span class="lineNum">    5822 </span>            :     This function first reads starting bytes to determine the expected
<span class="lineNum">    5823 </span>            :     string length and then copies this number of bytes into a string.
<span class="lineNum">    5824 </span>            : 
<span class="lineNum">    5825 </span>            :     @return string
<span class="lineNum">    5826 </span>            : 
<span class="lineNum">    5827 </span>            :     @throw parse_error.110 if input ended
<span class="lineNum">    5828 </span>            :     @throw parse_error.113 if an unexpected byte is read
<span class="lineNum">    5829 </span>            :     */
<span class="lineNum">    5830 </span>            :     string_t get_msgpack_string()
<span class="lineNum">    5831 </span>            :     {
<span class="lineNum">    5832 </span>            :         unexpect_eof();
<span class="lineNum">    5833 </span>            : 
<span class="lineNum">    5834 </span>            :         switch (current)
<span class="lineNum">    5835 </span>            :         {
<span class="lineNum">    5836 </span>            :             // fixstr
<span class="lineNum">    5837 </span>            :             case 0xA0:
<span class="lineNum">    5838 </span>            :             case 0xA1:
<span class="lineNum">    5839 </span>            :             case 0xA2:
<span class="lineNum">    5840 </span>            :             case 0xA3:
<span class="lineNum">    5841 </span>            :             case 0xA4:
<span class="lineNum">    5842 </span>            :             case 0xA5:
<span class="lineNum">    5843 </span>            :             case 0xA6:
<span class="lineNum">    5844 </span>            :             case 0xA7:
<span class="lineNum">    5845 </span>            :             case 0xA8:
<span class="lineNum">    5846 </span>            :             case 0xA9:
<span class="lineNum">    5847 </span>            :             case 0xAA:
<span class="lineNum">    5848 </span>            :             case 0xAB:
<span class="lineNum">    5849 </span>            :             case 0xAC:
<span class="lineNum">    5850 </span>            :             case 0xAD:
<span class="lineNum">    5851 </span>            :             case 0xAE:
<span class="lineNum">    5852 </span>            :             case 0xAF:
<span class="lineNum">    5853 </span>            :             case 0xB0:
<span class="lineNum">    5854 </span>            :             case 0xB1:
<span class="lineNum">    5855 </span>            :             case 0xB2:
<span class="lineNum">    5856 </span>            :             case 0xB3:
<span class="lineNum">    5857 </span>            :             case 0xB4:
<span class="lineNum">    5858 </span>            :             case 0xB5:
<span class="lineNum">    5859 </span>            :             case 0xB6:
<span class="lineNum">    5860 </span>            :             case 0xB7:
<span class="lineNum">    5861 </span>            :             case 0xB8:
<span class="lineNum">    5862 </span>            :             case 0xB9:
<span class="lineNum">    5863 </span>            :             case 0xBA:
<span class="lineNum">    5864 </span>            :             case 0xBB:
<span class="lineNum">    5865 </span>            :             case 0xBC:
<span class="lineNum">    5866 </span>            :             case 0xBD:
<span class="lineNum">    5867 </span>            :             case 0xBE:
<span class="lineNum">    5868 </span>            :             case 0xBF:
<span class="lineNum">    5869 </span>            :             {
<span class="lineNum">    5870 </span>            :                 return get_string(current &amp; 0x1F);
<span class="lineNum">    5871 </span>            :             }
<span class="lineNum">    5872 </span>            : 
<span class="lineNum">    5873 </span>            :             case 0xD9: // str 8
<span class="lineNum">    5874 </span>            :             {
<span class="lineNum">    5875 </span>            :                 return get_string(get_number&lt;uint8_t&gt;());
<span class="lineNum">    5876 </span>            :             }
<span class="lineNum">    5877 </span>            : 
<span class="lineNum">    5878 </span>            :             case 0xDA: // str 16
<span class="lineNum">    5879 </span>            :             {
<span class="lineNum">    5880 </span>            :                 return get_string(get_number&lt;uint16_t&gt;());
<span class="lineNum">    5881 </span>            :             }
<span class="lineNum">    5882 </span>            : 
<span class="lineNum">    5883 </span>            :             case 0xDB: // str 32
<span class="lineNum">    5884 </span>            :             {
<span class="lineNum">    5885 </span>            :                 return get_string(get_number&lt;uint32_t&gt;());
<span class="lineNum">    5886 </span>            :             }
<span class="lineNum">    5887 </span>            : 
<span class="lineNum">    5888 </span>            :             default:
<span class="lineNum">    5889 </span>            :             {
<span class="lineNum">    5890 </span>            :                 std::stringstream ss;
<span class="lineNum">    5891 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    5892 </span>            :                 JSON_THROW(parse_error::create(113, chars_read,
<span class="lineNum">    5893 </span>            :                                                &quot;expected a MessagePack string; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    5894 </span>            :             }
<span class="lineNum">    5895 </span>            :         }
<span class="lineNum">    5896 </span>            :     }
<span class="lineNum">    5897 </span>            : 
<span class="lineNum">    5898 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    5899 </span>            :     BasicJsonType get_msgpack_array(const NumberType len)
<span class="lineNum">    5900 </span>            :     {
<span class="lineNum">    5901 </span>            :         BasicJsonType result = value_t::array;
<span class="lineNum">    5902 </span>            :         std::generate_n(std::back_inserter(*result.m_value.array), len, [this]()
<span class="lineNum">    5903 </span>            :         {
<span class="lineNum">    5904 </span>            :             return parse_msgpack_internal();
<span class="lineNum">    5905 </span>            :         });
<span class="lineNum">    5906 </span>            :         return result;
<span class="lineNum">    5907 </span>            :     }
<span class="lineNum">    5908 </span>            : 
<span class="lineNum">    5909 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    5910 </span>            :     BasicJsonType get_msgpack_object(const NumberType len)
<span class="lineNum">    5911 </span>            :     {
<span class="lineNum">    5912 </span>            :         BasicJsonType result = value_t::object;
<span class="lineNum">    5913 </span>            :         std::generate_n(std::inserter(*result.m_value.object,
<span class="lineNum">    5914 </span>            :                                       result.m_value.object-&gt;end()),
<span class="lineNum">    5915 </span>            :                         len, [this]()
<span class="lineNum">    5916 </span>            :         {
<span class="lineNum">    5917 </span>            :             get();
<span class="lineNum">    5918 </span>            :             auto key = get_msgpack_string();
<span class="lineNum">    5919 </span>            :             auto val = parse_msgpack_internal();
<span class="lineNum">    5920 </span>            :             return std::make_pair(std::move(key), std::move(val));
<span class="lineNum">    5921 </span>            :         });
<span class="lineNum">    5922 </span>            :         return result;
<span class="lineNum">    5923 </span>            :     }
<span class="lineNum">    5924 </span>            : 
<span class="lineNum">    5925 </span>            :     /*!
<span class="lineNum">    5926 </span>            :     @brief reads a UBJSON string
<span class="lineNum">    5927 </span>            : 
<span class="lineNum">    5928 </span>            :     This function is either called after reading the 'S' byte explicitly
<span class="lineNum">    5929 </span>            :     indicating a string, or in case of an object key where the 'S' byte can be
<span class="lineNum">    5930 </span>            :     left out.
<span class="lineNum">    5931 </span>            : 
<span class="lineNum">    5932 </span>            :     @param[in] get_char  whether a new character should be retrieved from the
<span class="lineNum">    5933 </span>            :                          input (true, default) or whether the last read
<span class="lineNum">    5934 </span>            :                          character should be considered instead
<span class="lineNum">    5935 </span>            : 
<span class="lineNum">    5936 </span>            :     @return string
<span class="lineNum">    5937 </span>            : 
<span class="lineNum">    5938 </span>            :     @throw parse_error.110 if input ended
<span class="lineNum">    5939 </span>            :     @throw parse_error.113 if an unexpected byte is read
<span class="lineNum">    5940 </span>            :     */
<span class="lineNum">    5941 </span>            :     string_t get_ubjson_string(const bool get_char = true)
<span class="lineNum">    5942 </span>            :     {
<span class="lineNum">    5943 </span>            :         if (get_char)
<span class="lineNum">    5944 </span>            :         {
<span class="lineNum">    5945 </span>            :             get();  // TODO: may we ignore N here?
<span class="lineNum">    5946 </span>            :         }
<span class="lineNum">    5947 </span>            : 
<span class="lineNum">    5948 </span>            :         unexpect_eof();
<span class="lineNum">    5949 </span>            : 
<span class="lineNum">    5950 </span>            :         switch (current)
<span class="lineNum">    5951 </span>            :         {
<span class="lineNum">    5952 </span>            :             case 'U':
<span class="lineNum">    5953 </span>            :                 return get_string(get_number&lt;uint8_t&gt;());
<span class="lineNum">    5954 </span>            :             case 'i':
<span class="lineNum">    5955 </span>            :                 return get_string(get_number&lt;int8_t&gt;());
<span class="lineNum">    5956 </span>            :             case 'I':
<span class="lineNum">    5957 </span>            :                 return get_string(get_number&lt;int16_t&gt;());
<span class="lineNum">    5958 </span>            :             case 'l':
<span class="lineNum">    5959 </span>            :                 return get_string(get_number&lt;int32_t&gt;());
<span class="lineNum">    5960 </span>            :             case 'L':
<span class="lineNum">    5961 </span>            :                 return get_string(get_number&lt;int64_t&gt;());
<span class="lineNum">    5962 </span>            :             default:
<span class="lineNum">    5963 </span>            :                 std::stringstream ss;
<span class="lineNum">    5964 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    5965 </span>            :                 JSON_THROW(parse_error::create(113, chars_read,
<span class="lineNum">    5966 </span>            :                                                &quot;expected a UBJSON string; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    5967 </span>            :         }
<span class="lineNum">    5968 </span>            :     }
<span class="lineNum">    5969 </span>            : 
<span class="lineNum">    5970 </span>            :     /*!
<span class="lineNum">    5971 </span>            :     @brief determine the type and size for a container
<span class="lineNum">    5972 </span>            : 
<span class="lineNum">    5973 </span>            :     In the optimized UBJSON format, a type and a size can be provided to allow
<span class="lineNum">    5974 </span>            :     for a more compact representation.
<span class="lineNum">    5975 </span>            : 
<span class="lineNum">    5976 </span>            :     @return pair of the size and the type
<span class="lineNum">    5977 </span>            :     */
<span class="lineNum">    5978 </span>            :     std::pair&lt;std::size_t, int&gt; get_ubjson_size_type()
<span class="lineNum">    5979 </span>            :     {
<span class="lineNum">    5980 </span>            :         std::size_t sz = string_t::npos;
<span class="lineNum">    5981 </span>            :         int tc = 0;
<span class="lineNum">    5982 </span>            : 
<span class="lineNum">    5983 </span>            :         get_ignore_noop();
<span class="lineNum">    5984 </span>            : 
<span class="lineNum">    5985 </span>            :         if (current == '$')
<span class="lineNum">    5986 </span>            :         {
<span class="lineNum">    5987 </span>            :             tc = get();  // must not ignore 'N', because 'N' maybe the type
<span class="lineNum">    5988 </span>            :             unexpect_eof();
<span class="lineNum">    5989 </span>            : 
<span class="lineNum">    5990 </span>            :             get_ignore_noop();
<span class="lineNum">    5991 </span>            :             if (current != '#')
<span class="lineNum">    5992 </span>            :             {
<span class="lineNum">    5993 </span>            :                 std::stringstream ss;
<span class="lineNum">    5994 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    5995 </span>            :                 JSON_THROW(parse_error::create(112, chars_read,
<span class="lineNum">    5996 </span>            :                                                &quot;expected '#' after UBJSON type information; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    5997 </span>            :             }
<span class="lineNum">    5998 </span>            :             sz = parse_ubjson_internal();
<span class="lineNum">    5999 </span>            :         }
<span class="lineNum">    6000 </span>            :         else if (current == '#')
<span class="lineNum">    6001 </span>            :         {
<span class="lineNum">    6002 </span>            :             sz = parse_ubjson_internal();
<span class="lineNum">    6003 </span>            :         }
<span class="lineNum">    6004 </span>            : 
<span class="lineNum">    6005 </span>            :         return std::make_pair(sz, tc);
<span class="lineNum">    6006 </span>            :     }
<span class="lineNum">    6007 </span>            : 
<span class="lineNum">    6008 </span>            :     BasicJsonType get_ubjson_value(const int prefix)
<span class="lineNum">    6009 </span>            :     {
<span class="lineNum">    6010 </span>            :         switch (prefix)
<span class="lineNum">    6011 </span>            :         {
<span class="lineNum">    6012 </span>            :             case std::char_traits&lt;char&gt;::eof():  // EOF
<span class="lineNum">    6013 </span>            :                 JSON_THROW(parse_error::create(110, chars_read, &quot;unexpected end of input&quot;));
<span class="lineNum">    6014 </span>            : 
<span class="lineNum">    6015 </span>            :             case 'T':  // true
<span class="lineNum">    6016 </span>            :                 return true;
<span class="lineNum">    6017 </span>            :             case 'F':  // false
<span class="lineNum">    6018 </span>            :                 return false;
<span class="lineNum">    6019 </span>            : 
<span class="lineNum">    6020 </span>            :             case 'Z':  // null
<span class="lineNum">    6021 </span>            :                 return nullptr;
<span class="lineNum">    6022 </span>            : 
<span class="lineNum">    6023 </span>            :             case 'U':
<span class="lineNum">    6024 </span>            :                 return get_number&lt;uint8_t&gt;();
<span class="lineNum">    6025 </span>            :             case 'i':
<span class="lineNum">    6026 </span>            :                 return get_number&lt;int8_t&gt;();
<span class="lineNum">    6027 </span>            :             case 'I':
<span class="lineNum">    6028 </span>            :                 return get_number&lt;int16_t&gt;();
<span class="lineNum">    6029 </span>            :             case 'l':
<span class="lineNum">    6030 </span>            :                 return get_number&lt;int32_t&gt;();
<span class="lineNum">    6031 </span>            :             case 'L':
<span class="lineNum">    6032 </span>            :                 return get_number&lt;int64_t&gt;();
<span class="lineNum">    6033 </span>            :             case 'd':
<span class="lineNum">    6034 </span>            :                 return get_number&lt;float&gt;();
<span class="lineNum">    6035 </span>            :             case 'D':
<span class="lineNum">    6036 </span>            :                 return get_number&lt;double&gt;();
<span class="lineNum">    6037 </span>            : 
<span class="lineNum">    6038 </span>            :             case 'C':  // char
<span class="lineNum">    6039 </span>            :             {
<span class="lineNum">    6040 </span>            :                 get();
<span class="lineNum">    6041 </span>            :                 unexpect_eof();
<span class="lineNum">    6042 </span>            :                 if (JSON_UNLIKELY(current &gt; 127))
<span class="lineNum">    6043 </span>            :                 {
<span class="lineNum">    6044 </span>            :                     std::stringstream ss;
<span class="lineNum">    6045 </span>            :                     ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    6046 </span>            :                     JSON_THROW(parse_error::create(113, chars_read,
<span class="lineNum">    6047 </span>            :                                                    &quot;byte after 'C' must be in range 0x00..0x7F; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    6048 </span>            :                 }
<span class="lineNum">    6049 </span>            :                 return string_t(1, static_cast&lt;char&gt;(current));
<span class="lineNum">    6050 </span>            :             }
<span class="lineNum">    6051 </span>            : 
<span class="lineNum">    6052 </span>            :             case 'S':  // string
<span class="lineNum">    6053 </span>            :                 return get_ubjson_string();
<span class="lineNum">    6054 </span>            : 
<span class="lineNum">    6055 </span>            :             case '[':  // array
<span class="lineNum">    6056 </span>            :                 return get_ubjson_array();
<span class="lineNum">    6057 </span>            : 
<span class="lineNum">    6058 </span>            :             case '{':  // object
<span class="lineNum">    6059 </span>            :                 return get_ubjson_object();
<span class="lineNum">    6060 </span>            : 
<span class="lineNum">    6061 </span>            :             default: // anything else
<span class="lineNum">    6062 </span>            :                 std::stringstream ss;
<span class="lineNum">    6063 </span>            :                 ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; current;
<span class="lineNum">    6064 </span>            :                 JSON_THROW(parse_error::create(112, chars_read,
<span class="lineNum">    6065 </span>            :                                                &quot;error reading UBJSON; last byte: 0x&quot; + ss.str()));
<span class="lineNum">    6066 </span>            :         }
<span class="lineNum">    6067 </span>            :     }
<span class="lineNum">    6068 </span>            : 
<span class="lineNum">    6069 </span>            :     BasicJsonType get_ubjson_array()
<span class="lineNum">    6070 </span>            :     {
<span class="lineNum">    6071 </span>            :         BasicJsonType result = value_t::array;
<span class="lineNum">    6072 </span>            :         const auto size_and_type = get_ubjson_size_type();
<span class="lineNum">    6073 </span>            : 
<span class="lineNum">    6074 </span>            :         if (size_and_type.first != string_t::npos)
<span class="lineNum">    6075 </span>            :         {
<span class="lineNum">    6076 </span>            :             if (JSON_UNLIKELY(size_and_type.first &gt; result.max_size()))
<span class="lineNum">    6077 </span>            :             {
<span class="lineNum">    6078 </span>            :                 JSON_THROW(out_of_range::create(408,
<span class="lineNum">    6079 </span>            :                                                 &quot;excessive array size: &quot; + std::to_string(size_and_type.first)));
<span class="lineNum">    6080 </span>            :             }
<span class="lineNum">    6081 </span>            : 
<span class="lineNum">    6082 </span>            :             if (size_and_type.second != 0)
<span class="lineNum">    6083 </span>            :             {
<span class="lineNum">    6084 </span>            :                 if (size_and_type.second != 'N')
<span class="lineNum">    6085 </span>            :                 {
<span class="lineNum">    6086 </span>            :                     std::generate_n(std::back_inserter(*result.m_value.array),
<span class="lineNum">    6087 </span>            :                                     size_and_type.first, [this, size_and_type]()
<span class="lineNum">    6088 </span>            :                     {
<span class="lineNum">    6089 </span>            :                         return get_ubjson_value(size_and_type.second);
<span class="lineNum">    6090 </span>            :                     });
<span class="lineNum">    6091 </span>            :                 }
<span class="lineNum">    6092 </span>            :             }
<span class="lineNum">    6093 </span>            :             else
<span class="lineNum">    6094 </span>            :             {
<span class="lineNum">    6095 </span>            :                 std::generate_n(std::back_inserter(*result.m_value.array),
<span class="lineNum">    6096 </span>            :                                 size_and_type.first, [this]()
<span class="lineNum">    6097 </span>            :                 {
<span class="lineNum">    6098 </span>            :                     return parse_ubjson_internal();
<span class="lineNum">    6099 </span>            :                 });
<span class="lineNum">    6100 </span>            :             }
<span class="lineNum">    6101 </span>            :         }
<span class="lineNum">    6102 </span>            :         else
<span class="lineNum">    6103 </span>            :         {
<span class="lineNum">    6104 </span>            :             while (current != ']')
<span class="lineNum">    6105 </span>            :             {
<span class="lineNum">    6106 </span>            :                 result.push_back(parse_ubjson_internal(false));
<span class="lineNum">    6107 </span>            :                 get_ignore_noop();
<span class="lineNum">    6108 </span>            :             }
<span class="lineNum">    6109 </span>            :         }
<span class="lineNum">    6110 </span>            : 
<span class="lineNum">    6111 </span>            :         return result;
<span class="lineNum">    6112 </span>            :     }
<span class="lineNum">    6113 </span>            : 
<span class="lineNum">    6114 </span>            :     BasicJsonType get_ubjson_object()
<span class="lineNum">    6115 </span>            :     {
<span class="lineNum">    6116 </span>            :         BasicJsonType result = value_t::object;
<span class="lineNum">    6117 </span>            :         const auto size_and_type = get_ubjson_size_type();
<span class="lineNum">    6118 </span>            : 
<span class="lineNum">    6119 </span>            :         if (size_and_type.first != string_t::npos)
<span class="lineNum">    6120 </span>            :         {
<span class="lineNum">    6121 </span>            :             if (JSON_UNLIKELY(size_and_type.first &gt; result.max_size()))
<span class="lineNum">    6122 </span>            :             {
<span class="lineNum">    6123 </span>            :                 JSON_THROW(out_of_range::create(408,
<span class="lineNum">    6124 </span>            :                                                 &quot;excessive object size: &quot; + std::to_string(size_and_type.first)));
<span class="lineNum">    6125 </span>            :             }
<span class="lineNum">    6126 </span>            : 
<span class="lineNum">    6127 </span>            :             if (size_and_type.second != 0)
<span class="lineNum">    6128 </span>            :             {
<span class="lineNum">    6129 </span>            :                 std::generate_n(std::inserter(*result.m_value.object,
<span class="lineNum">    6130 </span>            :                                               result.m_value.object-&gt;end()),
<span class="lineNum">    6131 </span>            :                                 size_and_type.first, [this, size_and_type]()
<span class="lineNum">    6132 </span>            :                 {
<span class="lineNum">    6133 </span>            :                     auto key = get_ubjson_string();
<span class="lineNum">    6134 </span>            :                     auto val = get_ubjson_value(size_and_type.second);
<span class="lineNum">    6135 </span>            :                     return std::make_pair(std::move(key), std::move(val));
<span class="lineNum">    6136 </span>            :                 });
<span class="lineNum">    6137 </span>            :             }
<span class="lineNum">    6138 </span>            :             else
<span class="lineNum">    6139 </span>            :             {
<span class="lineNum">    6140 </span>            :                 std::generate_n(std::inserter(*result.m_value.object,
<span class="lineNum">    6141 </span>            :                                               result.m_value.object-&gt;end()),
<span class="lineNum">    6142 </span>            :                                 size_and_type.first, [this]()
<span class="lineNum">    6143 </span>            :                 {
<span class="lineNum">    6144 </span>            :                     auto key = get_ubjson_string();
<span class="lineNum">    6145 </span>            :                     auto val = parse_ubjson_internal();
<span class="lineNum">    6146 </span>            :                     return std::make_pair(std::move(key), std::move(val));
<span class="lineNum">    6147 </span>            :                 });
<span class="lineNum">    6148 </span>            :             }
<span class="lineNum">    6149 </span>            :         }
<span class="lineNum">    6150 </span>            :         else
<span class="lineNum">    6151 </span>            :         {
<span class="lineNum">    6152 </span>            :             while (current != '}')
<span class="lineNum">    6153 </span>            :             {
<span class="lineNum">    6154 </span>            :                 auto key = get_ubjson_string(false);
<span class="lineNum">    6155 </span>            :                 result[std::move(key)] = parse_ubjson_internal();
<span class="lineNum">    6156 </span>            :                 get_ignore_noop();
<span class="lineNum">    6157 </span>            :             }
<span class="lineNum">    6158 </span>            :         }
<span class="lineNum">    6159 </span>            : 
<span class="lineNum">    6160 </span>            :         return result;
<span class="lineNum">    6161 </span>            :     }
<span class="lineNum">    6162 </span>            : 
<span class="lineNum">    6163 </span>            :     /*!
<span class="lineNum">    6164 </span>            :     @brief throw if end of input is not reached
<span class="lineNum">    6165 </span>            :     @throw parse_error.110 if input not ended
<span class="lineNum">    6166 </span>            :     */
<span class="lineNum">    6167 </span>            :     void expect_eof() const
<span class="lineNum">    6168 </span>            :     {
<span class="lineNum">    6169 </span>            :         if (JSON_UNLIKELY(current != std::char_traits&lt;char&gt;::eof()))
<span class="lineNum">    6170 </span>            :         {
<span class="lineNum">    6171 </span>            :             JSON_THROW(parse_error::create(110, chars_read, &quot;expected end of input&quot;));
<span class="lineNum">    6172 </span>            :         }
<span class="lineNum">    6173 </span>            :     }
<span class="lineNum">    6174 </span>            : 
<span class="lineNum">    6175 </span>            :     /*!
<span class="lineNum">    6176 </span>            :     @briefthrow if end of input is reached
<span class="lineNum">    6177 </span>            :     @throw parse_error.110 if input ended
<span class="lineNum">    6178 </span>            :     */
<span class="lineNum">    6179 </span>            :     void unexpect_eof() const
<span class="lineNum">    6180 </span>            :     {
<span class="lineNum">    6181 </span>            :         if (JSON_UNLIKELY(current == std::char_traits&lt;char&gt;::eof()))
<span class="lineNum">    6182 </span>            :         {
<span class="lineNum">    6183 </span>            :             JSON_THROW(parse_error::create(110, chars_read, &quot;unexpected end of input&quot;));
<span class="lineNum">    6184 </span>            :         }
<span class="lineNum">    6185 </span>            :     }
<span class="lineNum">    6186 </span>            : 
<span class="lineNum">    6187 </span>            :   private:
<span class="lineNum">    6188 </span>            :     /// input adapter
<span class="lineNum">    6189 </span>            :     input_adapter_t ia = nullptr;
<span class="lineNum">    6190 </span>            : 
<span class="lineNum">    6191 </span>            :     /// the current character
<span class="lineNum">    6192 </span>            :     int current = std::char_traits&lt;char&gt;::eof();
<span class="lineNum">    6193 </span>            : 
<span class="lineNum">    6194 </span>            :     /// the number of characters read
<span class="lineNum">    6195 </span>            :     std::size_t chars_read = 0;
<span class="lineNum">    6196 </span>            : 
<span class="lineNum">    6197 </span>            :     /// whether we can assume little endianess
<span class="lineNum">    6198 </span>            :     const bool is_little_endian = little_endianess();
<span class="lineNum">    6199 </span>            : };
<span class="lineNum">    6200 </span>            : }
<span class="lineNum">    6201 </span>            : }
<span class="lineNum">    6202 </span>            : 
<span class="lineNum">    6203 </span>            : // #include &lt;nlohmann/detail/output/binary_writer.hpp&gt;
<span class="lineNum">    6204 </span>            : 
<span class="lineNum">    6205 </span>            : 
<span class="lineNum">    6206 </span>            : #include &lt;algorithm&gt; // reverse
<span class="lineNum">    6207 </span>            : #include &lt;array&gt; // array
<span class="lineNum">    6208 </span>            : #include &lt;cstdint&gt; // uint8_t, uint16_t, uint32_t, uint64_t
<span class="lineNum">    6209 </span>            : #include &lt;cstring&gt; // memcpy
<span class="lineNum">    6210 </span>            : #include &lt;limits&gt; // numeric_limits
<span class="lineNum">    6211 </span>            : 
<span class="lineNum">    6212 </span>            : // #include &lt;nlohmann/detail/input/binary_reader.hpp&gt;
<span class="lineNum">    6213 </span>            : 
<span class="lineNum">    6214 </span>            : // #include &lt;nlohmann/detail/output/output_adapters.hpp&gt;
<span class="lineNum">    6215 </span>            : 
<span class="lineNum">    6216 </span>            : 
<span class="lineNum">    6217 </span>            : namespace rockets_nlohmann
<span class="lineNum">    6218 </span>            : {
<span class="lineNum">    6219 </span>            : namespace detail
<span class="lineNum">    6220 </span>            : {
<span class="lineNum">    6221 </span>            : ///////////////////
<span class="lineNum">    6222 </span>            : // binary writer //
<span class="lineNum">    6223 </span>            : ///////////////////
<span class="lineNum">    6224 </span>            : 
<span class="lineNum">    6225 </span>            : /*!
<span class="lineNum">    6226 </span>            : @brief serialization to CBOR and MessagePack values
<span class="lineNum">    6227 </span>            : */
<span class="lineNum">    6228 </span>            : template&lt;typename BasicJsonType, typename CharType&gt;
<span class="lineNum">    6229 </span>            : class binary_writer
<span class="lineNum">    6230 </span>            : {
<span class="lineNum">    6231 </span>            :   public:
<span class="lineNum">    6232 </span>            :     /*!
<span class="lineNum">    6233 </span>            :     @brief create a binary writer
<span class="lineNum">    6234 </span>            : 
<span class="lineNum">    6235 </span>            :     @param[in] adapter  output adapter to write to
<span class="lineNum">    6236 </span>            :     */
<span class="lineNum">    6237 </span>            :     explicit binary_writer(output_adapter_t&lt;CharType&gt; adapter) : oa(adapter)
<span class="lineNum">    6238 </span>            :     {
<span class="lineNum">    6239 </span>            :         assert(oa);
<span class="lineNum">    6240 </span>            :     }
<span class="lineNum">    6241 </span>            : 
<span class="lineNum">    6242 </span>            :     /*!
<span class="lineNum">    6243 </span>            :     @brief[in] j  JSON value to serialize
<span class="lineNum">    6244 </span>            :     */
<span class="lineNum">    6245 </span>            :     void write_cbor(const BasicJsonType&amp; j)
<span class="lineNum">    6246 </span>            :     {
<span class="lineNum">    6247 </span>            :         switch (j.type())
<span class="lineNum">    6248 </span>            :         {
<span class="lineNum">    6249 </span>            :             case value_t::null:
<span class="lineNum">    6250 </span>            :             {
<span class="lineNum">    6251 </span>            :                 oa-&gt;write_character(static_cast&lt;CharType&gt;(0xF6));
<span class="lineNum">    6252 </span>            :                 break;
<span class="lineNum">    6253 </span>            :             }
<span class="lineNum">    6254 </span>            : 
<span class="lineNum">    6255 </span>            :             case value_t::boolean:
<span class="lineNum">    6256 </span>            :             {
<span class="lineNum">    6257 </span>            :                 oa-&gt;write_character(j.m_value.boolean
<span class="lineNum">    6258 </span>            :                                     ? static_cast&lt;CharType&gt;(0xF5)
<span class="lineNum">    6259 </span>            :                                     : static_cast&lt;CharType&gt;(0xF4));
<span class="lineNum">    6260 </span>            :                 break;
<span class="lineNum">    6261 </span>            :             }
<span class="lineNum">    6262 </span>            : 
<span class="lineNum">    6263 </span>            :             case value_t::number_integer:
<span class="lineNum">    6264 </span>            :             {
<span class="lineNum">    6265 </span>            :                 if (j.m_value.number_integer &gt;= 0)
<span class="lineNum">    6266 </span>            :                 {
<span class="lineNum">    6267 </span>            :                     // CBOR does not differentiate between positive signed
<span class="lineNum">    6268 </span>            :                     // integers and unsigned integers. Therefore, we used the
<span class="lineNum">    6269 </span>            :                     // code from the value_t::number_unsigned case here.
<span class="lineNum">    6270 </span>            :                     if (j.m_value.number_integer &lt;= 0x17)
<span class="lineNum">    6271 </span>            :                     {
<span class="lineNum">    6272 </span>            :                         write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6273 </span>            :                     }
<span class="lineNum">    6274 </span>            :                     else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6275 </span>            :                     {
<span class="lineNum">    6276 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x18));
<span class="lineNum">    6277 </span>            :                         write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6278 </span>            :                     }
<span class="lineNum">    6279 </span>            :                     else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6280 </span>            :                     {
<span class="lineNum">    6281 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x19));
<span class="lineNum">    6282 </span>            :                         write_number(static_cast&lt;uint16_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6283 </span>            :                     }
<span class="lineNum">    6284 </span>            :                     else if (j.m_value.number_integer &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6285 </span>            :                     {
<span class="lineNum">    6286 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x1A));
<span class="lineNum">    6287 </span>            :                         write_number(static_cast&lt;uint32_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6288 </span>            :                     }
<span class="lineNum">    6289 </span>            :                     else
<span class="lineNum">    6290 </span>            :                     {
<span class="lineNum">    6291 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x1B));
<span class="lineNum">    6292 </span>            :                         write_number(static_cast&lt;uint64_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6293 </span>            :                     }
<span class="lineNum">    6294 </span>            :                 }
<span class="lineNum">    6295 </span>            :                 else
<span class="lineNum">    6296 </span>            :                 {
<span class="lineNum">    6297 </span>            :                     // The conversions below encode the sign in the first
<span class="lineNum">    6298 </span>            :                     // byte, and the value is converted to a positive number.
<span class="lineNum">    6299 </span>            :                     const auto positive_number = -1 - j.m_value.number_integer;
<span class="lineNum">    6300 </span>            :                     if (j.m_value.number_integer &gt;= -24)
<span class="lineNum">    6301 </span>            :                     {
<span class="lineNum">    6302 </span>            :                         write_number(static_cast&lt;uint8_t&gt;(0x20 + positive_number));
<span class="lineNum">    6303 </span>            :                     }
<span class="lineNum">    6304 </span>            :                     else if (positive_number &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6305 </span>            :                     {
<span class="lineNum">    6306 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x38));
<span class="lineNum">    6307 </span>            :                         write_number(static_cast&lt;uint8_t&gt;(positive_number));
<span class="lineNum">    6308 </span>            :                     }
<span class="lineNum">    6309 </span>            :                     else if (positive_number &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6310 </span>            :                     {
<span class="lineNum">    6311 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x39));
<span class="lineNum">    6312 </span>            :                         write_number(static_cast&lt;uint16_t&gt;(positive_number));
<span class="lineNum">    6313 </span>            :                     }
<span class="lineNum">    6314 </span>            :                     else if (positive_number &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6315 </span>            :                     {
<span class="lineNum">    6316 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x3A));
<span class="lineNum">    6317 </span>            :                         write_number(static_cast&lt;uint32_t&gt;(positive_number));
<span class="lineNum">    6318 </span>            :                     }
<span class="lineNum">    6319 </span>            :                     else
<span class="lineNum">    6320 </span>            :                     {
<span class="lineNum">    6321 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0x3B));
<span class="lineNum">    6322 </span>            :                         write_number(static_cast&lt;uint64_t&gt;(positive_number));
<span class="lineNum">    6323 </span>            :                     }
<span class="lineNum">    6324 </span>            :                 }
<span class="lineNum">    6325 </span>            :                 break;
<span class="lineNum">    6326 </span>            :             }
<span class="lineNum">    6327 </span>            : 
<span class="lineNum">    6328 </span>            :             case value_t::number_unsigned:
<span class="lineNum">    6329 </span>            :             {
<span class="lineNum">    6330 </span>            :                 if (j.m_value.number_unsigned &lt;= 0x17)
<span class="lineNum">    6331 </span>            :                 {
<span class="lineNum">    6332 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_unsigned));
<span class="lineNum">    6333 </span>            :                 }
<span class="lineNum">    6334 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6335 </span>            :                 {
<span class="lineNum">    6336 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x18));
<span class="lineNum">    6337 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_unsigned));
<span class="lineNum">    6338 </span>            :                 }
<span class="lineNum">    6339 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6340 </span>            :                 {
<span class="lineNum">    6341 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x19));
<span class="lineNum">    6342 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(j.m_value.number_unsigned));
<span class="lineNum">    6343 </span>            :                 }
<span class="lineNum">    6344 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6345 </span>            :                 {
<span class="lineNum">    6346 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x1A));
<span class="lineNum">    6347 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(j.m_value.number_unsigned));
<span class="lineNum">    6348 </span>            :                 }
<span class="lineNum">    6349 </span>            :                 else
<span class="lineNum">    6350 </span>            :                 {
<span class="lineNum">    6351 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x1B));
<span class="lineNum">    6352 </span>            :                     write_number(static_cast&lt;uint64_t&gt;(j.m_value.number_unsigned));
<span class="lineNum">    6353 </span>            :                 }
<span class="lineNum">    6354 </span>            :                 break;
<span class="lineNum">    6355 </span>            :             }
<span class="lineNum">    6356 </span>            : 
<span class="lineNum">    6357 </span>            :             case value_t::number_float: // Double-Precision Float
<span class="lineNum">    6358 </span>            :             {
<span class="lineNum">    6359 </span>            :                 oa-&gt;write_character(static_cast&lt;CharType&gt;(0xFB));
<span class="lineNum">    6360 </span>            :                 write_number(j.m_value.number_float);
<span class="lineNum">    6361 </span>            :                 break;
<span class="lineNum">    6362 </span>            :             }
<span class="lineNum">    6363 </span>            : 
<span class="lineNum">    6364 </span>            :             case value_t::string:
<span class="lineNum">    6365 </span>            :             {
<span class="lineNum">    6366 </span>            :                 // step 1: write control byte and the string length
<span class="lineNum">    6367 </span>            :                 const auto N = j.m_value.string-&gt;size();
<span class="lineNum">    6368 </span>            :                 if (N &lt;= 0x17)
<span class="lineNum">    6369 </span>            :                 {
<span class="lineNum">    6370 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(0x60 + N));
<span class="lineNum">    6371 </span>            :                 }
<span class="lineNum">    6372 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6373 </span>            :                 {
<span class="lineNum">    6374 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x78));
<span class="lineNum">    6375 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(N));
<span class="lineNum">    6376 </span>            :                 }
<span class="lineNum">    6377 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6378 </span>            :                 {
<span class="lineNum">    6379 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x79));
<span class="lineNum">    6380 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(N));
<span class="lineNum">    6381 </span>            :                 }
<span class="lineNum">    6382 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6383 </span>            :                 {
<span class="lineNum">    6384 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x7A));
<span class="lineNum">    6385 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(N));
<span class="lineNum">    6386 </span>            :                 }
<span class="lineNum">    6387 </span>            :                 // LCOV_EXCL_START
<span class="lineNum">    6388 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint64_t&gt;::max)())
<span class="lineNum">    6389 </span>            :                 {
<span class="lineNum">    6390 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x7B));
<span class="lineNum">    6391 </span>            :                     write_number(static_cast&lt;uint64_t&gt;(N));
<span class="lineNum">    6392 </span>            :                 }
<span class="lineNum">    6393 </span>            :                 // LCOV_EXCL_STOP
<span class="lineNum">    6394 </span>            : 
<span class="lineNum">    6395 </span>            :                 // step 2: write the string
<span class="lineNum">    6396 </span>            :                 oa-&gt;write_characters(
<span class="lineNum">    6397 </span>            :                     reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
<span class="lineNum">    6398 </span>            :                     j.m_value.string-&gt;size());
<span class="lineNum">    6399 </span>            :                 break;
<span class="lineNum">    6400 </span>            :             }
<span class="lineNum">    6401 </span>            : 
<span class="lineNum">    6402 </span>            :             case value_t::array:
<span class="lineNum">    6403 </span>            :             {
<span class="lineNum">    6404 </span>            :                 // step 1: write control byte and the array size
<span class="lineNum">    6405 </span>            :                 const auto N = j.m_value.array-&gt;size();
<span class="lineNum">    6406 </span>            :                 if (N &lt;= 0x17)
<span class="lineNum">    6407 </span>            :                 {
<span class="lineNum">    6408 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(0x80 + N));
<span class="lineNum">    6409 </span>            :                 }
<span class="lineNum">    6410 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6411 </span>            :                 {
<span class="lineNum">    6412 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x98));
<span class="lineNum">    6413 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(N));
<span class="lineNum">    6414 </span>            :                 }
<span class="lineNum">    6415 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6416 </span>            :                 {
<span class="lineNum">    6417 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x99));
<span class="lineNum">    6418 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(N));
<span class="lineNum">    6419 </span>            :                 }
<span class="lineNum">    6420 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6421 </span>            :                 {
<span class="lineNum">    6422 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x9A));
<span class="lineNum">    6423 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(N));
<span class="lineNum">    6424 </span>            :                 }
<span class="lineNum">    6425 </span>            :                 // LCOV_EXCL_START
<span class="lineNum">    6426 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint64_t&gt;::max)())
<span class="lineNum">    6427 </span>            :                 {
<span class="lineNum">    6428 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0x9B));
<span class="lineNum">    6429 </span>            :                     write_number(static_cast&lt;uint64_t&gt;(N));
<span class="lineNum">    6430 </span>            :                 }
<span class="lineNum">    6431 </span>            :                 // LCOV_EXCL_STOP
<span class="lineNum">    6432 </span>            : 
<span class="lineNum">    6433 </span>            :                 // step 2: write each element
<span class="lineNum">    6434 </span>            :                 for (const auto&amp; el : *j.m_value.array)
<span class="lineNum">    6435 </span>            :                 {
<span class="lineNum">    6436 </span>            :                     write_cbor(el);
<span class="lineNum">    6437 </span>            :                 }
<span class="lineNum">    6438 </span>            :                 break;
<span class="lineNum">    6439 </span>            :             }
<span class="lineNum">    6440 </span>            : 
<span class="lineNum">    6441 </span>            :             case value_t::object:
<span class="lineNum">    6442 </span>            :             {
<span class="lineNum">    6443 </span>            :                 // step 1: write control byte and the object size
<span class="lineNum">    6444 </span>            :                 const auto N = j.m_value.object-&gt;size();
<span class="lineNum">    6445 </span>            :                 if (N &lt;= 0x17)
<span class="lineNum">    6446 </span>            :                 {
<span class="lineNum">    6447 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(0xA0 + N));
<span class="lineNum">    6448 </span>            :                 }
<span class="lineNum">    6449 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6450 </span>            :                 {
<span class="lineNum">    6451 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xB8));
<span class="lineNum">    6452 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(N));
<span class="lineNum">    6453 </span>            :                 }
<span class="lineNum">    6454 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6455 </span>            :                 {
<span class="lineNum">    6456 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xB9));
<span class="lineNum">    6457 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(N));
<span class="lineNum">    6458 </span>            :                 }
<span class="lineNum">    6459 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6460 </span>            :                 {
<span class="lineNum">    6461 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xBA));
<span class="lineNum">    6462 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(N));
<span class="lineNum">    6463 </span>            :                 }
<span class="lineNum">    6464 </span>            :                 // LCOV_EXCL_START
<span class="lineNum">    6465 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint64_t&gt;::max)())
<span class="lineNum">    6466 </span>            :                 {
<span class="lineNum">    6467 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xBB));
<span class="lineNum">    6468 </span>            :                     write_number(static_cast&lt;uint64_t&gt;(N));
<span class="lineNum">    6469 </span>            :                 }
<span class="lineNum">    6470 </span>            :                 // LCOV_EXCL_STOP
<span class="lineNum">    6471 </span>            : 
<span class="lineNum">    6472 </span>            :                 // step 2: write each element
<span class="lineNum">    6473 </span>            :                 for (const auto&amp; el : *j.m_value.object)
<span class="lineNum">    6474 </span>            :                 {
<span class="lineNum">    6475 </span>            :                     write_cbor(el.first);
<span class="lineNum">    6476 </span>            :                     write_cbor(el.second);
<span class="lineNum">    6477 </span>            :                 }
<span class="lineNum">    6478 </span>            :                 break;
<span class="lineNum">    6479 </span>            :             }
<span class="lineNum">    6480 </span>            : 
<span class="lineNum">    6481 </span>            :             default:
<span class="lineNum">    6482 </span>            :                 break;
<span class="lineNum">    6483 </span>            :         }
<span class="lineNum">    6484 </span>            :     }
<span class="lineNum">    6485 </span>            : 
<span class="lineNum">    6486 </span>            :     /*!
<span class="lineNum">    6487 </span>            :     @brief[in] j  JSON value to serialize
<span class="lineNum">    6488 </span>            :     */
<span class="lineNum">    6489 </span>            :     void write_msgpack(const BasicJsonType&amp; j)
<span class="lineNum">    6490 </span>            :     {
<span class="lineNum">    6491 </span>            :         switch (j.type())
<span class="lineNum">    6492 </span>            :         {
<span class="lineNum">    6493 </span>            :             case value_t::null: // nil
<span class="lineNum">    6494 </span>            :             {
<span class="lineNum">    6495 </span>            :                 oa-&gt;write_character(static_cast&lt;CharType&gt;(0xC0));
<span class="lineNum">    6496 </span>            :                 break;
<span class="lineNum">    6497 </span>            :             }
<span class="lineNum">    6498 </span>            : 
<span class="lineNum">    6499 </span>            :             case value_t::boolean: // true and false
<span class="lineNum">    6500 </span>            :             {
<span class="lineNum">    6501 </span>            :                 oa-&gt;write_character(j.m_value.boolean
<span class="lineNum">    6502 </span>            :                                     ? static_cast&lt;CharType&gt;(0xC3)
<span class="lineNum">    6503 </span>            :                                     : static_cast&lt;CharType&gt;(0xC2));
<span class="lineNum">    6504 </span>            :                 break;
<span class="lineNum">    6505 </span>            :             }
<span class="lineNum">    6506 </span>            : 
<span class="lineNum">    6507 </span>            :             case value_t::number_integer:
<span class="lineNum">    6508 </span>            :             {
<span class="lineNum">    6509 </span>            :                 if (j.m_value.number_integer &gt;= 0)
<span class="lineNum">    6510 </span>            :                 {
<span class="lineNum">    6511 </span>            :                     // MessagePack does not differentiate between positive
<span class="lineNum">    6512 </span>            :                     // signed integers and unsigned integers. Therefore, we used
<span class="lineNum">    6513 </span>            :                     // the code from the value_t::number_unsigned case here.
<span class="lineNum">    6514 </span>            :                     if (j.m_value.number_unsigned &lt; 128)
<span class="lineNum">    6515 </span>            :                     {
<span class="lineNum">    6516 </span>            :                         // positive fixnum
<span class="lineNum">    6517 </span>            :                         write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6518 </span>            :                     }
<span class="lineNum">    6519 </span>            :                     else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6520 </span>            :                     {
<span class="lineNum">    6521 </span>            :                         // uint 8
<span class="lineNum">    6522 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCC));
<span class="lineNum">    6523 </span>            :                         write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6524 </span>            :                     }
<span class="lineNum">    6525 </span>            :                     else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6526 </span>            :                     {
<span class="lineNum">    6527 </span>            :                         // uint 16
<span class="lineNum">    6528 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCD));
<span class="lineNum">    6529 </span>            :                         write_number(static_cast&lt;uint16_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6530 </span>            :                     }
<span class="lineNum">    6531 </span>            :                     else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6532 </span>            :                     {
<span class="lineNum">    6533 </span>            :                         // uint 32
<span class="lineNum">    6534 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCE));
<span class="lineNum">    6535 </span>            :                         write_number(static_cast&lt;uint32_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6536 </span>            :                     }
<span class="lineNum">    6537 </span>            :                     else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint64_t&gt;::max)())
<span class="lineNum">    6538 </span>            :                     {
<span class="lineNum">    6539 </span>            :                         // uint 64
<span class="lineNum">    6540 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCF));
<span class="lineNum">    6541 </span>            :                         write_number(static_cast&lt;uint64_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6542 </span>            :                     }
<span class="lineNum">    6543 </span>            :                 }
<span class="lineNum">    6544 </span>            :                 else
<span class="lineNum">    6545 </span>            :                 {
<span class="lineNum">    6546 </span>            :                     if (j.m_value.number_integer &gt;= -32)
<span class="lineNum">    6547 </span>            :                     {
<span class="lineNum">    6548 </span>            :                         // negative fixnum
<span class="lineNum">    6549 </span>            :                         write_number(static_cast&lt;int8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6550 </span>            :                     }
<span class="lineNum">    6551 </span>            :                     else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;int8_t&gt;::min)() and
<span class="lineNum">    6552 </span>            :                              j.m_value.number_integer &lt;= (std::numeric_limits&lt;int8_t&gt;::max)())
<span class="lineNum">    6553 </span>            :                     {
<span class="lineNum">    6554 </span>            :                         // int 8
<span class="lineNum">    6555 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xD0));
<span class="lineNum">    6556 </span>            :                         write_number(static_cast&lt;int8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6557 </span>            :                     }
<span class="lineNum">    6558 </span>            :                     else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;int16_t&gt;::min)() and
<span class="lineNum">    6559 </span>            :                              j.m_value.number_integer &lt;= (std::numeric_limits&lt;int16_t&gt;::max)())
<span class="lineNum">    6560 </span>            :                     {
<span class="lineNum">    6561 </span>            :                         // int 16
<span class="lineNum">    6562 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xD1));
<span class="lineNum">    6563 </span>            :                         write_number(static_cast&lt;int16_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6564 </span>            :                     }
<span class="lineNum">    6565 </span>            :                     else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;int32_t&gt;::min)() and
<span class="lineNum">    6566 </span>            :                              j.m_value.number_integer &lt;= (std::numeric_limits&lt;int32_t&gt;::max)())
<span class="lineNum">    6567 </span>            :                     {
<span class="lineNum">    6568 </span>            :                         // int 32
<span class="lineNum">    6569 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xD2));
<span class="lineNum">    6570 </span>            :                         write_number(static_cast&lt;int32_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6571 </span>            :                     }
<span class="lineNum">    6572 </span>            :                     else if (j.m_value.number_integer &gt;= (std::numeric_limits&lt;int64_t&gt;::min)() and
<span class="lineNum">    6573 </span>            :                              j.m_value.number_integer &lt;= (std::numeric_limits&lt;int64_t&gt;::max)())
<span class="lineNum">    6574 </span>            :                     {
<span class="lineNum">    6575 </span>            :                         // int 64
<span class="lineNum">    6576 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(0xD3));
<span class="lineNum">    6577 </span>            :                         write_number(static_cast&lt;int64_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6578 </span>            :                     }
<span class="lineNum">    6579 </span>            :                 }
<span class="lineNum">    6580 </span>            :                 break;
<span class="lineNum">    6581 </span>            :             }
<span class="lineNum">    6582 </span>            : 
<span class="lineNum">    6583 </span>            :             case value_t::number_unsigned:
<span class="lineNum">    6584 </span>            :             {
<span class="lineNum">    6585 </span>            :                 if (j.m_value.number_unsigned &lt; 128)
<span class="lineNum">    6586 </span>            :                 {
<span class="lineNum">    6587 </span>            :                     // positive fixnum
<span class="lineNum">    6588 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6589 </span>            :                 }
<span class="lineNum">    6590 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6591 </span>            :                 {
<span class="lineNum">    6592 </span>            :                     // uint 8
<span class="lineNum">    6593 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCC));
<span class="lineNum">    6594 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6595 </span>            :                 }
<span class="lineNum">    6596 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6597 </span>            :                 {
<span class="lineNum">    6598 </span>            :                     // uint 16
<span class="lineNum">    6599 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCD));
<span class="lineNum">    6600 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6601 </span>            :                 }
<span class="lineNum">    6602 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6603 </span>            :                 {
<span class="lineNum">    6604 </span>            :                     // uint 32
<span class="lineNum">    6605 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCE));
<span class="lineNum">    6606 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6607 </span>            :                 }
<span class="lineNum">    6608 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint64_t&gt;::max)())
<span class="lineNum">    6609 </span>            :                 {
<span class="lineNum">    6610 </span>            :                     // uint 64
<span class="lineNum">    6611 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCF));
<span class="lineNum">    6612 </span>            :                     write_number(static_cast&lt;uint64_t&gt;(j.m_value.number_integer));
<span class="lineNum">    6613 </span>            :                 }
<span class="lineNum">    6614 </span>            :                 break;
<span class="lineNum">    6615 </span>            :             }
<span class="lineNum">    6616 </span>            : 
<span class="lineNum">    6617 </span>            :             case value_t::number_float: // float 64
<span class="lineNum">    6618 </span>            :             {
<span class="lineNum">    6619 </span>            :                 oa-&gt;write_character(static_cast&lt;CharType&gt;(0xCB));
<span class="lineNum">    6620 </span>            :                 write_number(j.m_value.number_float);
<span class="lineNum">    6621 </span>            :                 break;
<span class="lineNum">    6622 </span>            :             }
<span class="lineNum">    6623 </span>            : 
<span class="lineNum">    6624 </span>            :             case value_t::string:
<span class="lineNum">    6625 </span>            :             {
<span class="lineNum">    6626 </span>            :                 // step 1: write control byte and the string length
<span class="lineNum">    6627 </span>            :                 const auto N = j.m_value.string-&gt;size();
<span class="lineNum">    6628 </span>            :                 if (N &lt;= 31)
<span class="lineNum">    6629 </span>            :                 {
<span class="lineNum">    6630 </span>            :                     // fixstr
<span class="lineNum">    6631 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(0xA0 | N));
<span class="lineNum">    6632 </span>            :                 }
<span class="lineNum">    6633 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6634 </span>            :                 {
<span class="lineNum">    6635 </span>            :                     // str 8
<span class="lineNum">    6636 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xD9));
<span class="lineNum">    6637 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(N));
<span class="lineNum">    6638 </span>            :                 }
<span class="lineNum">    6639 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6640 </span>            :                 {
<span class="lineNum">    6641 </span>            :                     // str 16
<span class="lineNum">    6642 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xDA));
<span class="lineNum">    6643 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(N));
<span class="lineNum">    6644 </span>            :                 }
<span class="lineNum">    6645 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6646 </span>            :                 {
<span class="lineNum">    6647 </span>            :                     // str 32
<span class="lineNum">    6648 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xDB));
<span class="lineNum">    6649 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(N));
<span class="lineNum">    6650 </span>            :                 }
<span class="lineNum">    6651 </span>            : 
<span class="lineNum">    6652 </span>            :                 // step 2: write the string
<span class="lineNum">    6653 </span>            :                 oa-&gt;write_characters(
<span class="lineNum">    6654 </span>            :                     reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
<span class="lineNum">    6655 </span>            :                     j.m_value.string-&gt;size());
<span class="lineNum">    6656 </span>            :                 break;
<span class="lineNum">    6657 </span>            :             }
<span class="lineNum">    6658 </span>            : 
<span class="lineNum">    6659 </span>            :             case value_t::array:
<span class="lineNum">    6660 </span>            :             {
<span class="lineNum">    6661 </span>            :                 // step 1: write control byte and the array size
<span class="lineNum">    6662 </span>            :                 const auto N = j.m_value.array-&gt;size();
<span class="lineNum">    6663 </span>            :                 if (N &lt;= 15)
<span class="lineNum">    6664 </span>            :                 {
<span class="lineNum">    6665 </span>            :                     // fixarray
<span class="lineNum">    6666 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(0x90 | N));
<span class="lineNum">    6667 </span>            :                 }
<span class="lineNum">    6668 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6669 </span>            :                 {
<span class="lineNum">    6670 </span>            :                     // array 16
<span class="lineNum">    6671 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xDC));
<span class="lineNum">    6672 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(N));
<span class="lineNum">    6673 </span>            :                 }
<span class="lineNum">    6674 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6675 </span>            :                 {
<span class="lineNum">    6676 </span>            :                     // array 32
<span class="lineNum">    6677 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xDD));
<span class="lineNum">    6678 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(N));
<span class="lineNum">    6679 </span>            :                 }
<span class="lineNum">    6680 </span>            : 
<span class="lineNum">    6681 </span>            :                 // step 2: write each element
<span class="lineNum">    6682 </span>            :                 for (const auto&amp; el : *j.m_value.array)
<span class="lineNum">    6683 </span>            :                 {
<span class="lineNum">    6684 </span>            :                     write_msgpack(el);
<span class="lineNum">    6685 </span>            :                 }
<span class="lineNum">    6686 </span>            :                 break;
<span class="lineNum">    6687 </span>            :             }
<span class="lineNum">    6688 </span>            : 
<span class="lineNum">    6689 </span>            :             case value_t::object:
<span class="lineNum">    6690 </span>            :             {
<span class="lineNum">    6691 </span>            :                 // step 1: write control byte and the object size
<span class="lineNum">    6692 </span>            :                 const auto N = j.m_value.object-&gt;size();
<span class="lineNum">    6693 </span>            :                 if (N &lt;= 15)
<span class="lineNum">    6694 </span>            :                 {
<span class="lineNum">    6695 </span>            :                     // fixmap
<span class="lineNum">    6696 </span>            :                     write_number(static_cast&lt;uint8_t&gt;(0x80 | (N &amp; 0xF)));
<span class="lineNum">    6697 </span>            :                 }
<span class="lineNum">    6698 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint16_t&gt;::max)())
<span class="lineNum">    6699 </span>            :                 {
<span class="lineNum">    6700 </span>            :                     // map 16
<span class="lineNum">    6701 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xDE));
<span class="lineNum">    6702 </span>            :                     write_number(static_cast&lt;uint16_t&gt;(N));
<span class="lineNum">    6703 </span>            :                 }
<span class="lineNum">    6704 </span>            :                 else if (N &lt;= (std::numeric_limits&lt;uint32_t&gt;::max)())
<span class="lineNum">    6705 </span>            :                 {
<span class="lineNum">    6706 </span>            :                     // map 32
<span class="lineNum">    6707 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(0xDF));
<span class="lineNum">    6708 </span>            :                     write_number(static_cast&lt;uint32_t&gt;(N));
<span class="lineNum">    6709 </span>            :                 }
<span class="lineNum">    6710 </span>            : 
<span class="lineNum">    6711 </span>            :                 // step 2: write each element
<span class="lineNum">    6712 </span>            :                 for (const auto&amp; el : *j.m_value.object)
<span class="lineNum">    6713 </span>            :                 {
<span class="lineNum">    6714 </span>            :                     write_msgpack(el.first);
<span class="lineNum">    6715 </span>            :                     write_msgpack(el.second);
<span class="lineNum">    6716 </span>            :                 }
<span class="lineNum">    6717 </span>            :                 break;
<span class="lineNum">    6718 </span>            :             }
<span class="lineNum">    6719 </span>            : 
<span class="lineNum">    6720 </span>            :             default:
<span class="lineNum">    6721 </span>            :                 break;
<span class="lineNum">    6722 </span>            :         }
<span class="lineNum">    6723 </span>            :     }
<span class="lineNum">    6724 </span>            : 
<span class="lineNum">    6725 </span>            :     /*!
<span class="lineNum">    6726 </span>            :     @param[in] j  JSON value to serialize
<span class="lineNum">    6727 </span>            :     @param[in] use_count   whether to use '#' prefixes (optimized format)
<span class="lineNum">    6728 </span>            :     @param[in] use_type    whether to use '$' prefixes (optimized format)
<span class="lineNum">    6729 </span>            :     @param[in] add_prefix  whether prefixes need to be used for this value
<span class="lineNum">    6730 </span>            :     */
<span class="lineNum">    6731 </span>            :     void write_ubjson(const BasicJsonType&amp; j, const bool use_count,
<span class="lineNum">    6732 </span>            :                       const bool use_type, const bool add_prefix = true)
<span class="lineNum">    6733 </span>            :     {
<span class="lineNum">    6734 </span>            :         switch (j.type())
<span class="lineNum">    6735 </span>            :         {
<span class="lineNum">    6736 </span>            :             case value_t::null:
<span class="lineNum">    6737 </span>            :             {
<span class="lineNum">    6738 </span>            :                 if (add_prefix)
<span class="lineNum">    6739 </span>            :                 {
<span class="lineNum">    6740 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('Z'));
<span class="lineNum">    6741 </span>            :                 }
<span class="lineNum">    6742 </span>            :                 break;
<span class="lineNum">    6743 </span>            :             }
<span class="lineNum">    6744 </span>            : 
<span class="lineNum">    6745 </span>            :             case value_t::boolean:
<span class="lineNum">    6746 </span>            :             {
<span class="lineNum">    6747 </span>            :                 if (add_prefix)
<span class="lineNum">    6748 </span>            :                     oa-&gt;write_character(j.m_value.boolean
<span class="lineNum">    6749 </span>            :                                         ? static_cast&lt;CharType&gt;('T')
<span class="lineNum">    6750 </span>            :                                         : static_cast&lt;CharType&gt;('F'));
<span class="lineNum">    6751 </span>            :                 break;
<span class="lineNum">    6752 </span>            :             }
<span class="lineNum">    6753 </span>            : 
<span class="lineNum">    6754 </span>            :             case value_t::number_integer:
<span class="lineNum">    6755 </span>            :             {
<span class="lineNum">    6756 </span>            :                 write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
<span class="lineNum">    6757 </span>            :                 break;
<span class="lineNum">    6758 </span>            :             }
<span class="lineNum">    6759 </span>            : 
<span class="lineNum">    6760 </span>            :             case value_t::number_unsigned:
<span class="lineNum">    6761 </span>            :             {
<span class="lineNum">    6762 </span>            :                 write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
<span class="lineNum">    6763 </span>            :                 break;
<span class="lineNum">    6764 </span>            :             }
<span class="lineNum">    6765 </span>            : 
<span class="lineNum">    6766 </span>            :             case value_t::number_float:
<span class="lineNum">    6767 </span>            :             {
<span class="lineNum">    6768 </span>            :                 write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
<span class="lineNum">    6769 </span>            :                 break;
<span class="lineNum">    6770 </span>            :             }
<span class="lineNum">    6771 </span>            : 
<span class="lineNum">    6772 </span>            :             case value_t::string:
<span class="lineNum">    6773 </span>            :             {
<span class="lineNum">    6774 </span>            :                 if (add_prefix)
<span class="lineNum">    6775 </span>            :                 {
<span class="lineNum">    6776 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('S'));
<span class="lineNum">    6777 </span>            :                 }
<span class="lineNum">    6778 </span>            :                 write_number_with_ubjson_prefix(j.m_value.string-&gt;size(), true);
<span class="lineNum">    6779 </span>            :                 oa-&gt;write_characters(
<span class="lineNum">    6780 </span>            :                     reinterpret_cast&lt;const CharType*&gt;(j.m_value.string-&gt;c_str()),
<span class="lineNum">    6781 </span>            :                     j.m_value.string-&gt;size());
<span class="lineNum">    6782 </span>            :                 break;
<span class="lineNum">    6783 </span>            :             }
<span class="lineNum">    6784 </span>            : 
<span class="lineNum">    6785 </span>            :             case value_t::array:
<span class="lineNum">    6786 </span>            :             {
<span class="lineNum">    6787 </span>            :                 if (add_prefix)
<span class="lineNum">    6788 </span>            :                 {
<span class="lineNum">    6789 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('['));
<span class="lineNum">    6790 </span>            :                 }
<span class="lineNum">    6791 </span>            : 
<span class="lineNum">    6792 </span>            :                 bool prefix_required = true;
<span class="lineNum">    6793 </span>            :                 if (use_type and not j.m_value.array-&gt;empty())
<span class="lineNum">    6794 </span>            :                 {
<span class="lineNum">    6795 </span>            :                     assert(use_count);
<span class="lineNum">    6796 </span>            :                     const char first_prefix = ubjson_prefix(j.front());
<span class="lineNum">    6797 </span>            :                     const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
<span class="lineNum">    6798 </span>            :                                                          [this, first_prefix](const BasicJsonType &amp; v)
<span class="lineNum">    6799 </span>            :                     {
<span class="lineNum">    6800 </span>            :                         return ubjson_prefix(v) == first_prefix;
<span class="lineNum">    6801 </span>            :                     });
<span class="lineNum">    6802 </span>            : 
<span class="lineNum">    6803 </span>            :                     if (same_prefix)
<span class="lineNum">    6804 </span>            :                     {
<span class="lineNum">    6805 </span>            :                         prefix_required = false;
<span class="lineNum">    6806 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;('$'));
<span class="lineNum">    6807 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(first_prefix));
<span class="lineNum">    6808 </span>            :                     }
<span class="lineNum">    6809 </span>            :                 }
<span class="lineNum">    6810 </span>            : 
<span class="lineNum">    6811 </span>            :                 if (use_count)
<span class="lineNum">    6812 </span>            :                 {
<span class="lineNum">    6813 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('#'));
<span class="lineNum">    6814 </span>            :                     write_number_with_ubjson_prefix(j.m_value.array-&gt;size(), true);
<span class="lineNum">    6815 </span>            :                 }
<span class="lineNum">    6816 </span>            : 
<span class="lineNum">    6817 </span>            :                 for (const auto&amp; el : *j.m_value.array)
<span class="lineNum">    6818 </span>            :                 {
<span class="lineNum">    6819 </span>            :                     write_ubjson(el, use_count, use_type, prefix_required);
<span class="lineNum">    6820 </span>            :                 }
<span class="lineNum">    6821 </span>            : 
<span class="lineNum">    6822 </span>            :                 if (not use_count)
<span class="lineNum">    6823 </span>            :                 {
<span class="lineNum">    6824 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;(']'));
<span class="lineNum">    6825 </span>            :                 }
<span class="lineNum">    6826 </span>            : 
<span class="lineNum">    6827 </span>            :                 break;
<span class="lineNum">    6828 </span>            :             }
<span class="lineNum">    6829 </span>            : 
<span class="lineNum">    6830 </span>            :             case value_t::object:
<span class="lineNum">    6831 </span>            :             {
<span class="lineNum">    6832 </span>            :                 if (add_prefix)
<span class="lineNum">    6833 </span>            :                 {
<span class="lineNum">    6834 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('{'));
<span class="lineNum">    6835 </span>            :                 }
<span class="lineNum">    6836 </span>            : 
<span class="lineNum">    6837 </span>            :                 bool prefix_required = true;
<span class="lineNum">    6838 </span>            :                 if (use_type and not j.m_value.object-&gt;empty())
<span class="lineNum">    6839 </span>            :                 {
<span class="lineNum">    6840 </span>            :                     assert(use_count);
<span class="lineNum">    6841 </span>            :                     const char first_prefix = ubjson_prefix(j.front());
<span class="lineNum">    6842 </span>            :                     const bool same_prefix = std::all_of(j.begin(), j.end(),
<span class="lineNum">    6843 </span>            :                                                          [this, first_prefix](const BasicJsonType &amp; v)
<span class="lineNum">    6844 </span>            :                     {
<span class="lineNum">    6845 </span>            :                         return ubjson_prefix(v) == first_prefix;
<span class="lineNum">    6846 </span>            :                     });
<span class="lineNum">    6847 </span>            : 
<span class="lineNum">    6848 </span>            :                     if (same_prefix)
<span class="lineNum">    6849 </span>            :                     {
<span class="lineNum">    6850 </span>            :                         prefix_required = false;
<span class="lineNum">    6851 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;('$'));
<span class="lineNum">    6852 </span>            :                         oa-&gt;write_character(static_cast&lt;CharType&gt;(first_prefix));
<span class="lineNum">    6853 </span>            :                     }
<span class="lineNum">    6854 </span>            :                 }
<span class="lineNum">    6855 </span>            : 
<span class="lineNum">    6856 </span>            :                 if (use_count)
<span class="lineNum">    6857 </span>            :                 {
<span class="lineNum">    6858 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('#'));
<span class="lineNum">    6859 </span>            :                     write_number_with_ubjson_prefix(j.m_value.object-&gt;size(), true);
<span class="lineNum">    6860 </span>            :                 }
<span class="lineNum">    6861 </span>            : 
<span class="lineNum">    6862 </span>            :                 for (const auto&amp; el : *j.m_value.object)
<span class="lineNum">    6863 </span>            :                 {
<span class="lineNum">    6864 </span>            :                     write_number_with_ubjson_prefix(el.first.size(), true);
<span class="lineNum">    6865 </span>            :                     oa-&gt;write_characters(
<span class="lineNum">    6866 </span>            :                         reinterpret_cast&lt;const CharType*&gt;(el.first.c_str()),
<span class="lineNum">    6867 </span>            :                         el.first.size());
<span class="lineNum">    6868 </span>            :                     write_ubjson(el.second, use_count, use_type, prefix_required);
<span class="lineNum">    6869 </span>            :                 }
<span class="lineNum">    6870 </span>            : 
<span class="lineNum">    6871 </span>            :                 if (not use_count)
<span class="lineNum">    6872 </span>            :                 {
<span class="lineNum">    6873 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('}'));
<span class="lineNum">    6874 </span>            :                 }
<span class="lineNum">    6875 </span>            : 
<span class="lineNum">    6876 </span>            :                 break;
<span class="lineNum">    6877 </span>            :             }
<span class="lineNum">    6878 </span>            : 
<span class="lineNum">    6879 </span>            :             default:
<span class="lineNum">    6880 </span>            :                 break;
<span class="lineNum">    6881 </span>            :         }
<span class="lineNum">    6882 </span>            :     }
<span class="lineNum">    6883 </span>            : 
<span class="lineNum">    6884 </span>            :   private:
<span class="lineNum">    6885 </span>            :     /*
<span class="lineNum">    6886 </span>            :     @brief write a number to output input
<span class="lineNum">    6887 </span>            : 
<span class="lineNum">    6888 </span>            :     @param[in] n number of type @a NumberType
<span class="lineNum">    6889 </span>            :     @tparam NumberType the type of the number
<span class="lineNum">    6890 </span>            : 
<span class="lineNum">    6891 </span>            :     @note This function needs to respect the system's endianess, because bytes
<span class="lineNum">    6892 </span>            :           in CBOR, MessagePack, and UBJSON are stored in network order (big
<span class="lineNum">    6893 </span>            :           endian) and therefore need reordering on little endian systems.
<span class="lineNum">    6894 </span>            :     */
<span class="lineNum">    6895 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    6896 </span>            :     void write_number(const NumberType n)
<span class="lineNum">    6897 </span>            :     {
<span class="lineNum">    6898 </span>            :         // step 1: write number to array of length NumberType
<span class="lineNum">    6899 </span>            :         std::array&lt;CharType, sizeof(NumberType)&gt; vec;
<span class="lineNum">    6900 </span>            :         std::memcpy(vec.data(), &amp;n, sizeof(NumberType));
<span class="lineNum">    6901 </span>            : 
<span class="lineNum">    6902 </span>            :         // step 2: write array to output (with possible reordering)
<span class="lineNum">    6903 </span>            :         if (is_little_endian)
<span class="lineNum">    6904 </span>            :         {
<span class="lineNum">    6905 </span>            :             // reverse byte order prior to conversion if necessary
<span class="lineNum">    6906 </span>            :             std::reverse(vec.begin(), vec.end());
<span class="lineNum">    6907 </span>            :         }
<span class="lineNum">    6908 </span>            : 
<span class="lineNum">    6909 </span>            :         oa-&gt;write_characters(vec.data(), sizeof(NumberType));
<span class="lineNum">    6910 </span>            :     }
<span class="lineNum">    6911 </span>            : 
<span class="lineNum">    6912 </span>            :     template&lt;typename NumberType&gt;
<span class="lineNum">    6913 </span>            :     void write_number_with_ubjson_prefix(const NumberType n,
<span class="lineNum">    6914 </span>            :                                          const bool add_prefix)
<span class="lineNum">    6915 </span>            :     {
<span class="lineNum">    6916 </span>            :         if (std::is_floating_point&lt;NumberType&gt;::value)
<span class="lineNum">    6917 </span>            :         {
<span class="lineNum">    6918 </span>            :             if (add_prefix)
<span class="lineNum">    6919 </span>            :             {
<span class="lineNum">    6920 </span>            :                 oa-&gt;write_character(static_cast&lt;CharType&gt;('D'));  // float64
<span class="lineNum">    6921 </span>            :             }
<span class="lineNum">    6922 </span>            :             write_number(n);
<span class="lineNum">    6923 </span>            :         }
<span class="lineNum">    6924 </span>            :         else if (std::is_unsigned&lt;NumberType&gt;::value)
<span class="lineNum">    6925 </span>            :         {
<span class="lineNum">    6926 </span>            :             if (n &lt;= (std::numeric_limits&lt;int8_t&gt;::max)())
<span class="lineNum">    6927 </span>            :             {
<span class="lineNum">    6928 </span>            :                 if (add_prefix)
<span class="lineNum">    6929 </span>            :                 {
<span class="lineNum">    6930 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('i'));  // int8
<span class="lineNum">    6931 </span>            :                 }
<span class="lineNum">    6932 </span>            :                 write_number(static_cast&lt;uint8_t&gt;(n));
<span class="lineNum">    6933 </span>            :             }
<span class="lineNum">    6934 </span>            :             else if (n &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6935 </span>            :             {
<span class="lineNum">    6936 </span>            :                 if (add_prefix)
<span class="lineNum">    6937 </span>            :                 {
<span class="lineNum">    6938 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('U'));  // uint8
<span class="lineNum">    6939 </span>            :                 }
<span class="lineNum">    6940 </span>            :                 write_number(static_cast&lt;uint8_t&gt;(n));
<span class="lineNum">    6941 </span>            :             }
<span class="lineNum">    6942 </span>            :             else if (n &lt;= (std::numeric_limits&lt;int16_t&gt;::max)())
<span class="lineNum">    6943 </span>            :             {
<span class="lineNum">    6944 </span>            :                 if (add_prefix)
<span class="lineNum">    6945 </span>            :                 {
<span class="lineNum">    6946 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('I'));  // int16
<span class="lineNum">    6947 </span>            :                 }
<span class="lineNum">    6948 </span>            :                 write_number(static_cast&lt;int16_t&gt;(n));
<span class="lineNum">    6949 </span>            :             }
<span class="lineNum">    6950 </span>            :             else if (n &lt;= (std::numeric_limits&lt;int32_t&gt;::max)())
<span class="lineNum">    6951 </span>            :             {
<span class="lineNum">    6952 </span>            :                 if (add_prefix)
<span class="lineNum">    6953 </span>            :                 {
<span class="lineNum">    6954 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('l'));  // int32
<span class="lineNum">    6955 </span>            :                 }
<span class="lineNum">    6956 </span>            :                 write_number(static_cast&lt;int32_t&gt;(n));
<span class="lineNum">    6957 </span>            :             }
<span class="lineNum">    6958 </span>            :             else if (n &lt;= (std::numeric_limits&lt;int64_t&gt;::max)())
<span class="lineNum">    6959 </span>            :             {
<span class="lineNum">    6960 </span>            :                 if (add_prefix)
<span class="lineNum">    6961 </span>            :                 {
<span class="lineNum">    6962 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('L'));  // int64
<span class="lineNum">    6963 </span>            :                 }
<span class="lineNum">    6964 </span>            :                 write_number(static_cast&lt;int64_t&gt;(n));
<span class="lineNum">    6965 </span>            :             }
<span class="lineNum">    6966 </span>            :             else
<span class="lineNum">    6967 </span>            :             {
<span class="lineNum">    6968 </span>            :                 JSON_THROW(out_of_range::create(407, &quot;number overflow serializing &quot; + std::to_string(n)));
<span class="lineNum">    6969 </span>            :             }
<span class="lineNum">    6970 </span>            :         }
<span class="lineNum">    6971 </span>            :         else
<span class="lineNum">    6972 </span>            :         {
<span class="lineNum">    6973 </span>            :             if ((std::numeric_limits&lt;int8_t&gt;::min)() &lt;= n and n &lt;= (std::numeric_limits&lt;int8_t&gt;::max)())
<span class="lineNum">    6974 </span>            :             {
<span class="lineNum">    6975 </span>            :                 if (add_prefix)
<span class="lineNum">    6976 </span>            :                 {
<span class="lineNum">    6977 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('i'));  // int8
<span class="lineNum">    6978 </span>            :                 }
<span class="lineNum">    6979 </span>            :                 write_number(static_cast&lt;int8_t&gt;(n));
<span class="lineNum">    6980 </span>            :             }
<span class="lineNum">    6981 </span>            :             else if ((std::numeric_limits&lt;uint8_t&gt;::min)() &lt;= n and n &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    6982 </span>            :             {
<span class="lineNum">    6983 </span>            :                 if (add_prefix)
<span class="lineNum">    6984 </span>            :                 {
<span class="lineNum">    6985 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('U'));  // uint8
<span class="lineNum">    6986 </span>            :                 }
<span class="lineNum">    6987 </span>            :                 write_number(static_cast&lt;uint8_t&gt;(n));
<span class="lineNum">    6988 </span>            :             }
<span class="lineNum">    6989 </span>            :             else if ((std::numeric_limits&lt;int16_t&gt;::min)() &lt;= n and n &lt;= (std::numeric_limits&lt;int16_t&gt;::max)())
<span class="lineNum">    6990 </span>            :             {
<span class="lineNum">    6991 </span>            :                 if (add_prefix)
<span class="lineNum">    6992 </span>            :                 {
<span class="lineNum">    6993 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('I'));  // int16
<span class="lineNum">    6994 </span>            :                 }
<span class="lineNum">    6995 </span>            :                 write_number(static_cast&lt;int16_t&gt;(n));
<span class="lineNum">    6996 </span>            :             }
<span class="lineNum">    6997 </span>            :             else if ((std::numeric_limits&lt;int32_t&gt;::min)() &lt;= n and n &lt;= (std::numeric_limits&lt;int32_t&gt;::max)())
<span class="lineNum">    6998 </span>            :             {
<span class="lineNum">    6999 </span>            :                 if (add_prefix)
<span class="lineNum">    7000 </span>            :                 {
<span class="lineNum">    7001 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('l'));  // int32
<span class="lineNum">    7002 </span>            :                 }
<span class="lineNum">    7003 </span>            :                 write_number(static_cast&lt;int32_t&gt;(n));
<span class="lineNum">    7004 </span>            :             }
<span class="lineNum">    7005 </span>            :             else if ((std::numeric_limits&lt;int64_t&gt;::min)() &lt;= n and n &lt;= (std::numeric_limits&lt;int64_t&gt;::max)())
<span class="lineNum">    7006 </span>            :             {
<span class="lineNum">    7007 </span>            :                 if (add_prefix)
<span class="lineNum">    7008 </span>            :                 {
<span class="lineNum">    7009 </span>            :                     oa-&gt;write_character(static_cast&lt;CharType&gt;('L'));  // int64
<span class="lineNum">    7010 </span>            :                 }
<span class="lineNum">    7011 </span>            :                 write_number(static_cast&lt;int64_t&gt;(n));
<span class="lineNum">    7012 </span>            :             }
<span class="lineNum">    7013 </span>            :             // LCOV_EXCL_START
<span class="lineNum">    7014 </span>            :             else
<span class="lineNum">    7015 </span>            :             {
<span class="lineNum">    7016 </span>            :                 JSON_THROW(out_of_range::create(407, &quot;number overflow serializing &quot; + std::to_string(n)));
<span class="lineNum">    7017 </span>            :             }
<span class="lineNum">    7018 </span>            :             // LCOV_EXCL_STOP
<span class="lineNum">    7019 </span>            :         }
<span class="lineNum">    7020 </span>            :     }
<span class="lineNum">    7021 </span>            : 
<span class="lineNum">    7022 </span>            :     /*!
<span class="lineNum">    7023 </span>            :     @brief determine the type prefix of container values
<span class="lineNum">    7024 </span>            : 
<span class="lineNum">    7025 </span>            :     @note This function does not need to be 100% accurate when it comes to
<span class="lineNum">    7026 </span>            :           integer limits. In case a number exceeds the limits of int64_t,
<span class="lineNum">    7027 </span>            :           this will be detected by a later call to function
<span class="lineNum">    7028 </span>            :           write_number_with_ubjson_prefix. Therefore, we return 'L' for any
<span class="lineNum">    7029 </span>            :           value that does not fit the previous limits.
<span class="lineNum">    7030 </span>            :     */
<span class="lineNum">    7031 </span>            :     char ubjson_prefix(const BasicJsonType&amp; j) const noexcept
<span class="lineNum">    7032 </span>            :     {
<span class="lineNum">    7033 </span>            :         switch (j.type())
<span class="lineNum">    7034 </span>            :         {
<span class="lineNum">    7035 </span>            :             case value_t::null:
<span class="lineNum">    7036 </span>            :                 return 'Z';
<span class="lineNum">    7037 </span>            : 
<span class="lineNum">    7038 </span>            :             case value_t::boolean:
<span class="lineNum">    7039 </span>            :                 return j.m_value.boolean ? 'T' : 'F';
<span class="lineNum">    7040 </span>            : 
<span class="lineNum">    7041 </span>            :             case value_t::number_integer:
<span class="lineNum">    7042 </span>            :             {
<span class="lineNum">    7043 </span>            :                 if ((std::numeric_limits&lt;int8_t&gt;::min)() &lt;= j.m_value.number_integer and j.m_value.number_integer &lt;= (std::numeric_limits&lt;int8_t&gt;::max)())
<span class="lineNum">    7044 </span>            :                 {
<span class="lineNum">    7045 </span>            :                     return 'i';
<span class="lineNum">    7046 </span>            :                 }
<span class="lineNum">    7047 </span>            :                 else if ((std::numeric_limits&lt;uint8_t&gt;::min)() &lt;= j.m_value.number_integer and j.m_value.number_integer &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    7048 </span>            :                 {
<span class="lineNum">    7049 </span>            :                     return 'U';
<span class="lineNum">    7050 </span>            :                 }
<span class="lineNum">    7051 </span>            :                 else if ((std::numeric_limits&lt;int16_t&gt;::min)() &lt;= j.m_value.number_integer and j.m_value.number_integer &lt;= (std::numeric_limits&lt;int16_t&gt;::max)())
<span class="lineNum">    7052 </span>            :                 {
<span class="lineNum">    7053 </span>            :                     return 'I';
<span class="lineNum">    7054 </span>            :                 }
<span class="lineNum">    7055 </span>            :                 else if ((std::numeric_limits&lt;int32_t&gt;::min)() &lt;= j.m_value.number_integer and j.m_value.number_integer &lt;= (std::numeric_limits&lt;int32_t&gt;::max)())
<span class="lineNum">    7056 </span>            :                 {
<span class="lineNum">    7057 </span>            :                     return 'l';
<span class="lineNum">    7058 </span>            :                 }
<span class="lineNum">    7059 </span>            :                 else  // no check and assume int64_t (see note above)
<span class="lineNum">    7060 </span>            :                 {
<span class="lineNum">    7061 </span>            :                     return 'L';
<span class="lineNum">    7062 </span>            :                 }
<span class="lineNum">    7063 </span>            :             }
<span class="lineNum">    7064 </span>            : 
<span class="lineNum">    7065 </span>            :             case value_t::number_unsigned:
<span class="lineNum">    7066 </span>            :             {
<span class="lineNum">    7067 </span>            :                 if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;int8_t&gt;::max)())
<span class="lineNum">    7068 </span>            :                 {
<span class="lineNum">    7069 </span>            :                     return 'i';
<span class="lineNum">    7070 </span>            :                 }
<span class="lineNum">    7071 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;uint8_t&gt;::max)())
<span class="lineNum">    7072 </span>            :                 {
<span class="lineNum">    7073 </span>            :                     return 'U';
<span class="lineNum">    7074 </span>            :                 }
<span class="lineNum">    7075 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;int16_t&gt;::max)())
<span class="lineNum">    7076 </span>            :                 {
<span class="lineNum">    7077 </span>            :                     return 'I';
<span class="lineNum">    7078 </span>            :                 }
<span class="lineNum">    7079 </span>            :                 else if (j.m_value.number_unsigned &lt;= (std::numeric_limits&lt;int32_t&gt;::max)())
<span class="lineNum">    7080 </span>            :                 {
<span class="lineNum">    7081 </span>            :                     return 'l';
<span class="lineNum">    7082 </span>            :                 }
<span class="lineNum">    7083 </span>            :                 else  // no check and assume int64_t (see note above)
<span class="lineNum">    7084 </span>            :                 {
<span class="lineNum">    7085 </span>            :                     return 'L';
<span class="lineNum">    7086 </span>            :                 }
<span class="lineNum">    7087 </span>            :             }
<span class="lineNum">    7088 </span>            : 
<span class="lineNum">    7089 </span>            :             case value_t::number_float:
<span class="lineNum">    7090 </span>            :                 return 'D';
<span class="lineNum">    7091 </span>            : 
<span class="lineNum">    7092 </span>            :             case value_t::string:
<span class="lineNum">    7093 </span>            :                 return 'S';
<span class="lineNum">    7094 </span>            : 
<span class="lineNum">    7095 </span>            :             case value_t::array:
<span class="lineNum">    7096 </span>            :                 return '[';
<span class="lineNum">    7097 </span>            : 
<span class="lineNum">    7098 </span>            :             case value_t::object:
<span class="lineNum">    7099 </span>            :                 return '{';
<span class="lineNum">    7100 </span>            : 
<span class="lineNum">    7101 </span>            :             default:  // discarded values
<span class="lineNum">    7102 </span>            :                 return 'N';
<span class="lineNum">    7103 </span>            :         }
<span class="lineNum">    7104 </span>            :     }
<span class="lineNum">    7105 </span>            : 
<span class="lineNum">    7106 </span>            :   private:
<span class="lineNum">    7107 </span>            :     /// whether we can assume little endianess
<span class="lineNum">    7108 </span>            :     const bool is_little_endian = binary_reader&lt;BasicJsonType&gt;::little_endianess();
<span class="lineNum">    7109 </span>            : 
<span class="lineNum">    7110 </span>            :     /// the output
<span class="lineNum">    7111 </span>            :     output_adapter_t&lt;CharType&gt; oa = nullptr;
<span class="lineNum">    7112 </span>            : };
<span class="lineNum">    7113 </span>            : }
<span class="lineNum">    7114 </span>            : }
<span class="lineNum">    7115 </span>            : 
<span class="lineNum">    7116 </span>            : // #include &lt;nlohmann/detail/output/serializer.hpp&gt;
<span class="lineNum">    7117 </span>            : 
<span class="lineNum">    7118 </span>            : 
<span class="lineNum">    7119 </span>            : #include &lt;algorithm&gt; // reverse, remove, fill, find, none_of
<span class="lineNum">    7120 </span>            : #include &lt;array&gt; // array
<span class="lineNum">    7121 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">    7122 </span>            : #include &lt;ciso646&gt; // and, or
<span class="lineNum">    7123 </span>            : #include &lt;clocale&gt; // localeconv, lconv
<span class="lineNum">    7124 </span>            : #include &lt;cmath&gt; // labs, isfinite, isnan, signbit
<span class="lineNum">    7125 </span>            : #include &lt;cstddef&gt; // size_t, ptrdiff_t
<span class="lineNum">    7126 </span>            : #include &lt;cstdint&gt; // uint8_t
<span class="lineNum">    7127 </span>            : #include &lt;cstdio&gt; // snprintf
<span class="lineNum">    7128 </span>            : #include &lt;iomanip&gt; // setfill
<span class="lineNum">    7129 </span>            : #include &lt;iterator&gt; // next
<span class="lineNum">    7130 </span>            : #include &lt;limits&gt; // numeric_limits
<span class="lineNum">    7131 </span>            : #include &lt;sstream&gt; // stringstream
<span class="lineNum">    7132 </span>            : #include &lt;string&gt; // string
<span class="lineNum">    7133 </span>            : #include &lt;type_traits&gt; // is_same
<span class="lineNum">    7134 </span>            : 
<span class="lineNum">    7135 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">    7136 </span>            : 
<span class="lineNum">    7137 </span>            : // #include &lt;nlohmann/detail/conversions/to_chars.hpp&gt;
<span class="lineNum">    7138 </span>            : 
<span class="lineNum">    7139 </span>            : 
<span class="lineNum">    7140 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">    7141 </span>            : #include &lt;ciso646&gt; // or, and, not
<span class="lineNum">    7142 </span>            : #include &lt;cmath&gt;   // signbit, isfinite
<span class="lineNum">    7143 </span>            : #include &lt;cstdint&gt; // intN_t, uintN_t
<span class="lineNum">    7144 </span>            : #include &lt;cstring&gt; // memcpy, memmove
<span class="lineNum">    7145 </span>            : 
<span class="lineNum">    7146 </span>            : namespace rockets_nlohmann
<span class="lineNum">    7147 </span>            : {
<span class="lineNum">    7148 </span>            : namespace detail
<span class="lineNum">    7149 </span>            : {
<span class="lineNum">    7150 </span>            : 
<span class="lineNum">    7151 </span>            : /*!
<span class="lineNum">    7152 </span>            : @brief implements the Grisu2 algorithm for binary to decimal floating-point
<span class="lineNum">    7153 </span>            : conversion.
<span class="lineNum">    7154 </span>            : 
<span class="lineNum">    7155 </span>            : This implementation is a slightly modified version of the reference
<span class="lineNum">    7156 </span>            : implementation which may be obtained from
<span class="lineNum">    7157 </span>            : http://florian.loitsch.com/publications (bench.tar.gz).
<span class="lineNum">    7158 </span>            : 
<span class="lineNum">    7159 </span>            : The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.
<span class="lineNum">    7160 </span>            : 
<span class="lineNum">    7161 </span>            : For a detailed description of the algorithm see:
<span class="lineNum">    7162 </span>            : 
<span class="lineNum">    7163 </span>            : [1] Loitsch, &quot;Printing Floating-Point Numbers Quickly and Accurately with
<span class="lineNum">    7164 </span>            :     Integers&quot;, Proceedings of the ACM SIGPLAN 2010 Conference on Programming
<span class="lineNum">    7165 </span>            :     Language Design and Implementation, PLDI 2010
<span class="lineNum">    7166 </span>            : [2] Burger, Dybvig, &quot;Printing Floating-Point Numbers Quickly and Accurately&quot;,
<span class="lineNum">    7167 </span>            :     Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
<span class="lineNum">    7168 </span>            :     Design and Implementation, PLDI 1996
<span class="lineNum">    7169 </span>            : */
<span class="lineNum">    7170 </span>            : namespace dtoa_impl
<span class="lineNum">    7171 </span>            : {
<a name="7172"><span class="lineNum">    7172 </span>            : </a>
<span class="lineNum">    7173 </span>            : template &lt;typename Target, typename Source&gt;
<span class="lineNum">    7174 </span><span class="lineCov">          2 : Target reinterpret_bits(const Source source)</span>
<span class="lineNum">    7175 </span>            : {
<span class="lineNum">    7176 </span>            :     static_assert(sizeof(Target) == sizeof(Source), &quot;size mismatch&quot;);
<span class="lineNum">    7177 </span>            : 
<span class="lineNum">    7178 </span>            :     Target target;
<span class="lineNum">    7179 </span><span class="lineCov">          2 :     std::memcpy(&amp;target, &amp;source, sizeof(Source));</span>
<span class="lineNum">    7180 </span><span class="lineCov">          2 :     return target;</span>
<span class="lineNum">    7181 </span>            : }
<span class="lineNum">    7182 </span>            : 
<span class="lineNum">    7183 </span>            : struct diyfp // f * 2^e
<span class="lineNum">    7184 </span>            : {
<span class="lineNum">    7185 </span>            :     static constexpr int kPrecision = 64; // = q
<span class="lineNum">    7186 </span>            : 
<span class="lineNum">    7187 </span>            :     uint64_t f;
<span class="lineNum">    7188 </span>            :     int e;
<a name="7189"><span class="lineNum">    7189 </span>            : </a>
<span class="lineNum">    7190 </span>            :     constexpr diyfp() noexcept : f(0), e(0) {}
<span class="lineNum">    7191 </span><span class="lineCov">         26 :     constexpr diyfp(uint64_t f_, int e_) noexcept : f(f_), e(e_) {}</span>
<span class="lineNum">    7192 </span>            : 
<span class="lineNum">    7193 </span>            :     /*!
<span class="lineNum">    7194 </span>            :     @brief returns x - y
<a name="7195"><span class="lineNum">    7195 </span>            :     @pre x.e == y.e and x.f &gt;= y.f</a>
<span class="lineNum">    7196 </span>            :     */
<span class="lineNum">    7197 </span><span class="lineCov">          4 :     static diyfp sub(const diyfp&amp; x, const diyfp&amp; y) noexcept</span>
<span class="lineNum">    7198 </span>            :     {
<span class="lineNum">    7199 </span><span class="lineCov">          4 :         assert(x.e == y.e);</span>
<span class="lineNum">    7200 </span><span class="lineCov">          4 :         assert(x.f &gt;= y.f);</span>
<span class="lineNum">    7201 </span>            : 
<span class="lineNum">    7202 </span><span class="lineCov">          4 :         return diyfp(x.f - y.f, x.e);</span>
<span class="lineNum">    7203 </span>            :     }
<span class="lineNum">    7204 </span>            : 
<span class="lineNum">    7205 </span>            :     /*!
<span class="lineNum">    7206 </span>            :     @brief returns x * y
<a name="7207"><span class="lineNum">    7207 </span>            :     @note The result is rounded. (Only the upper q bits are returned.)</a>
<span class="lineNum">    7208 </span>            :     */
<span class="lineNum">    7209 </span><span class="lineCov">          6 :     static diyfp mul(const diyfp&amp; x, const diyfp&amp; y) noexcept</span>
<span class="lineNum">    7210 </span>            :     {
<span class="lineNum">    7211 </span>            :         static_assert(kPrecision == 64, &quot;internal error&quot;);
<span class="lineNum">    7212 </span>            : 
<span class="lineNum">    7213 </span>            :         // Computes:
<span class="lineNum">    7214 </span>            :         //  f = round((x.f * y.f) / 2^q)
<span class="lineNum">    7215 </span>            :         //  e = x.e + y.e + q
<span class="lineNum">    7216 </span>            : 
<span class="lineNum">    7217 </span>            :         // Emulate the 64-bit * 64-bit multiplication:
<span class="lineNum">    7218 </span>            :         //
<span class="lineNum">    7219 </span>            :         // p = u * v
<span class="lineNum">    7220 </span>            :         //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
<span class="lineNum">    7221 </span>            :         //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
<span class="lineNum">    7222 </span>            :         //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
<span class="lineNum">    7223 </span>            :         //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
<span class="lineNum">    7224 </span>            :         //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
<span class="lineNum">    7225 </span>            :         //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
<span class="lineNum">    7226 </span>            :         //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
<span class="lineNum">    7227 </span>            :         //
<span class="lineNum">    7228 </span>            :         // (Since Q might be larger than 2^32 - 1)
<span class="lineNum">    7229 </span>            :         //
<span class="lineNum">    7230 </span>            :         //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
<span class="lineNum">    7231 </span>            :         //
<span class="lineNum">    7232 </span>            :         // (Q_hi + H does not overflow a 64-bit int)
<span class="lineNum">    7233 </span>            :         //
<span class="lineNum">    7234 </span>            :         //   = p_lo + 2^64 p_hi
<span class="lineNum">    7235 </span>            : 
<span class="lineNum">    7236 </span><span class="lineCov">          6 :         const uint64_t u_lo = x.f &amp; 0xFFFFFFFF;</span>
<span class="lineNum">    7237 </span><span class="lineCov">          6 :         const uint64_t u_hi = x.f &gt;&gt; 32;</span>
<span class="lineNum">    7238 </span><span class="lineCov">          6 :         const uint64_t v_lo = y.f &amp; 0xFFFFFFFF;</span>
<span class="lineNum">    7239 </span><span class="lineCov">          6 :         const uint64_t v_hi = y.f &gt;&gt; 32;</span>
<span class="lineNum">    7240 </span>            : 
<span class="lineNum">    7241 </span><span class="lineCov">          6 :         const uint64_t p0 = u_lo * v_lo;</span>
<span class="lineNum">    7242 </span><span class="lineCov">          6 :         const uint64_t p1 = u_lo * v_hi;</span>
<span class="lineNum">    7243 </span><span class="lineCov">          6 :         const uint64_t p2 = u_hi * v_lo;</span>
<span class="lineNum">    7244 </span><span class="lineCov">          6 :         const uint64_t p3 = u_hi * v_hi;</span>
<span class="lineNum">    7245 </span>            : 
<span class="lineNum">    7246 </span><span class="lineCov">          6 :         const uint64_t p0_hi = p0 &gt;&gt; 32;</span>
<span class="lineNum">    7247 </span><span class="lineCov">          6 :         const uint64_t p1_lo = p1 &amp; 0xFFFFFFFF;</span>
<span class="lineNum">    7248 </span><span class="lineCov">          6 :         const uint64_t p1_hi = p1 &gt;&gt; 32;</span>
<span class="lineNum">    7249 </span><span class="lineCov">          6 :         const uint64_t p2_lo = p2 &amp; 0xFFFFFFFF;</span>
<span class="lineNum">    7250 </span><span class="lineCov">          6 :         const uint64_t p2_hi = p2 &gt;&gt; 32;</span>
<span class="lineNum">    7251 </span>            : 
<span class="lineNum">    7252 </span><span class="lineCov">          6 :         uint64_t Q = p0_hi + p1_lo + p2_lo;</span>
<span class="lineNum">    7253 </span>            : 
<span class="lineNum">    7254 </span>            :         // The full product might now be computed as
<span class="lineNum">    7255 </span>            :         //
<span class="lineNum">    7256 </span>            :         // p_hi = p3 + p2_hi + p1_hi + (Q &gt;&gt; 32)
<span class="lineNum">    7257 </span>            :         // p_lo = p0_lo + (Q &lt;&lt; 32)
<span class="lineNum">    7258 </span>            :         //
<span class="lineNum">    7259 </span>            :         // But in this particular case here, the full p_lo is not required.
<span class="lineNum">    7260 </span>            :         // Effectively we only need to add the highest bit in p_lo to p_hi (and
<span class="lineNum">    7261 </span>            :         // Q_hi + 1 does not overflow).
<span class="lineNum">    7262 </span>            : 
<span class="lineNum">    7263 </span><span class="lineCov">          6 :         Q += uint64_t{1} &lt;&lt; (64 - 32 - 1); // round, ties up</span>
<span class="lineNum">    7264 </span>            : 
<span class="lineNum">    7265 </span><span class="lineCov">          6 :         const uint64_t h = p3 + p2_hi + p1_hi + (Q &gt;&gt; 32);</span>
<span class="lineNum">    7266 </span>            : 
<span class="lineNum">    7267 </span><span class="lineCov">          6 :         return diyfp(h, x.e + y.e + 64);</span>
<span class="lineNum">    7268 </span>            :     }
<span class="lineNum">    7269 </span>            : 
<span class="lineNum">    7270 </span>            :     /*!
<span class="lineNum">    7271 </span>            :     @brief normalize x such that the significand is &gt;= 2^(q-1)
<a name="7272"><span class="lineNum">    7272 </span>            :     @pre x.f != 0</a>
<span class="lineNum">    7273 </span>            :     */
<span class="lineNum">    7274 </span><span class="lineCov">          4 :     static diyfp normalize(diyfp x) noexcept</span>
<span class="lineNum">    7275 </span>            :     {
<span class="lineNum">    7276 </span><span class="lineCov">          4 :         assert(x.f != 0);</span>
<span class="lineNum">    7277 </span>            : 
<span class="lineNum">    7278 </span><span class="lineCov">         88 :         while ((x.f &gt;&gt; 63) == 0)</span>
<span class="lineNum">    7279 </span>            :         {
<span class="lineNum">    7280 </span><span class="lineCov">         42 :             x.f &lt;&lt;= 1;</span>
<span class="lineNum">    7281 </span><span class="lineCov">         42 :             x.e--;</span>
<span class="lineNum">    7282 </span>            :         }
<span class="lineNum">    7283 </span>            : 
<span class="lineNum">    7284 </span><span class="lineCov">          4 :         return x;</span>
<span class="lineNum">    7285 </span>            :     }
<span class="lineNum">    7286 </span>            : 
<span class="lineNum">    7287 </span>            :     /*!
<span class="lineNum">    7288 </span>            :     @brief normalize x such that the result has the exponent E
<a name="7289"><span class="lineNum">    7289 </span>            :     @pre e &gt;= x.e and the upper e - x.e bits of x.f must be zero.</a>
<span class="lineNum">    7290 </span>            :     */
<span class="lineNum">    7291 </span><span class="lineCov">          2 :     static diyfp normalize_to(const diyfp&amp; x, const int target_exponent) noexcept</span>
<span class="lineNum">    7292 </span>            :     {
<span class="lineNum">    7293 </span><span class="lineCov">          2 :         const int delta = x.e - target_exponent;</span>
<span class="lineNum">    7294 </span>            : 
<span class="lineNum">    7295 </span><span class="lineCov">          2 :         assert(delta &gt;= 0);</span>
<span class="lineNum">    7296 </span><span class="lineCov">          2 :         assert(((x.f &lt;&lt; delta) &gt;&gt; delta) == x.f);</span>
<span class="lineNum">    7297 </span>            : 
<span class="lineNum">    7298 </span><span class="lineCov">          2 :         return diyfp(x.f &lt;&lt; delta, target_exponent);</span>
<span class="lineNum">    7299 </span>            :     }
<span class="lineNum">    7300 </span>            : };
<span class="lineNum">    7301 </span>            : 
<span class="lineNum">    7302 </span>            : struct boundaries
<span class="lineNum">    7303 </span>            : {
<span class="lineNum">    7304 </span>            :     diyfp w;
<span class="lineNum">    7305 </span>            :     diyfp minus;
<span class="lineNum">    7306 </span>            :     diyfp plus;
<span class="lineNum">    7307 </span>            : };
<span class="lineNum">    7308 </span>            : 
<span class="lineNum">    7309 </span>            : /*!
<span class="lineNum">    7310 </span>            : Compute the (normalized) diyfp representing the input number 'value' and its
<span class="lineNum">    7311 </span>            : boundaries.
<span class="lineNum">    7312 </span>            : 
<span class="lineNum">    7313 </span>            : @pre value must be finite and positive
<a name="7314"><span class="lineNum">    7314 </span>            : */</a>
<span class="lineNum">    7315 </span>            : template &lt;typename FloatType&gt;
<span class="lineNum">    7316 </span><span class="lineCov">          2 : boundaries compute_boundaries(FloatType value)</span>
<span class="lineNum">    7317 </span>            : {
<span class="lineNum">    7318 </span><span class="lineCov">          2 :     assert(std::isfinite(value));</span>
<span class="lineNum">    7319 </span><span class="lineCov">          2 :     assert(value &gt; 0);</span>
<span class="lineNum">    7320 </span>            : 
<span class="lineNum">    7321 </span>            :     // Convert the IEEE representation into a diyfp.
<span class="lineNum">    7322 </span>            :     //
<span class="lineNum">    7323 </span>            :     // If v is denormal:
<span class="lineNum">    7324 </span>            :     //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
<span class="lineNum">    7325 </span>            :     // If v is normalized:
<span class="lineNum">    7326 </span>            :     //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))
<span class="lineNum">    7327 </span>            : 
<span class="lineNum">    7328 </span>            :     static_assert(std::numeric_limits&lt;FloatType&gt;::is_iec559,
<span class="lineNum">    7329 </span>            :                   &quot;internal error: dtoa_short requires an IEEE-754 floating-point implementation&quot;);
<span class="lineNum">    7330 </span>            : 
<span class="lineNum">    7331 </span><span class="lineCov">          2 :     constexpr int      kPrecision = std::numeric_limits&lt;FloatType&gt;::digits; // = p (includes the hidden bit)</span>
<span class="lineNum">    7332 </span><span class="lineCov">          2 :     constexpr int      kBias      = std::numeric_limits&lt;FloatType&gt;::max_exponent - 1 + (kPrecision - 1);</span>
<span class="lineNum">    7333 </span><span class="lineCov">          2 :     constexpr int      kMinExp    = 1 - kBias;</span>
<span class="lineNum">    7334 </span><span class="lineCov">          2 :     constexpr uint64_t kHiddenBit = uint64_t{1} &lt;&lt; (kPrecision - 1); // = 2^(p-1)</span>
<span class="lineNum">    7335 </span>            : 
<span class="lineNum">    7336 </span>            :     using bits_type = typename std::conditional&lt; kPrecision == 24, uint32_t, uint64_t &gt;::type;
<span class="lineNum">    7337 </span>            : 
<span class="lineNum">    7338 </span><span class="lineCov">          2 :     const uint64_t bits = reinterpret_bits&lt;bits_type&gt;(value);</span>
<span class="lineNum">    7339 </span><span class="lineCov">          2 :     const uint64_t E = bits &gt;&gt; (kPrecision - 1);</span>
<span class="lineNum">    7340 </span><span class="lineCov">          2 :     const uint64_t F = bits &amp; (kHiddenBit - 1);</span>
<span class="lineNum">    7341 </span>            : 
<span class="lineNum">    7342 </span><span class="lineCov">          2 :     const bool is_denormal = (E == 0);</span>
<span class="lineNum">    7343 </span>            :     const diyfp v = is_denormal
<span class="lineNum">    7344 </span>            :                     ? diyfp(F, kMinExp)
<span class="lineNum">    7345 </span><span class="lineCov">          2 :                     : diyfp(F + kHiddenBit, static_cast&lt;int&gt;(E) - kBias);</span>
<span class="lineNum">    7346 </span>            : 
<span class="lineNum">    7347 </span>            :     // Compute the boundaries m- and m+ of the floating-point value
<span class="lineNum">    7348 </span>            :     // v = f * 2^e.
<span class="lineNum">    7349 </span>            :     //
<span class="lineNum">    7350 </span>            :     // Determine v- and v+, the floating-point predecessor and successor if v,
<span class="lineNum">    7351 </span>            :     // respectively.
<span class="lineNum">    7352 </span>            :     //
<span class="lineNum">    7353 </span>            :     //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
<span class="lineNum">    7354 </span>            :     //         = v - 2^(e-1)    if f == 2^(p-1) and e &gt; e_min                (B)
<span class="lineNum">    7355 </span>            :     //
<span class="lineNum">    7356 </span>            :     //      v+ = v + 2^e
<span class="lineNum">    7357 </span>            :     //
<span class="lineNum">    7358 </span>            :     // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
<span class="lineNum">    7359 </span>            :     // between m- and m+ round to v, regardless of how the input rounding
<span class="lineNum">    7360 </span>            :     // algorithm breaks ties.
<span class="lineNum">    7361 </span>            :     //
<span class="lineNum">    7362 </span>            :     //      ---+-------------+-------------+-------------+-------------+---  (A)
<span class="lineNum">    7363 </span>            :     //         v-            m-            v             m+            v+
<span class="lineNum">    7364 </span>            :     //
<span class="lineNum">    7365 </span>            :     //      -----------------+------+------+-------------+-------------+---  (B)
<span class="lineNum">    7366 </span>            :     //                       v-     m-     v             m+            v+
<span class="lineNum">    7367 </span>            : 
<span class="lineNum">    7368 </span><span class="lineCov">          2 :     const bool lower_boundary_is_closer = (F == 0 and E &gt; 1);</span>
<span class="lineNum">    7369 </span><span class="lineCov">          2 :     const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);</span>
<span class="lineNum">    7370 </span>            :     const diyfp m_minus = lower_boundary_is_closer
<span class="lineNum">    7371 </span><span class="lineCov">          4 :                           ? diyfp(4 * v.f - 1, v.e - 2)  // (B)</span>
<span class="lineNum">    7372 </span><span class="lineCov">          6 :                           : diyfp(2 * v.f - 1, v.e - 1); // (A)</span>
<span class="lineNum">    7373 </span>            : 
<span class="lineNum">    7374 </span>            :     // Determine the normalized w+ = m+.
<span class="lineNum">    7375 </span><span class="lineCov">          2 :     const diyfp w_plus = diyfp::normalize(m_plus);</span>
<span class="lineNum">    7376 </span>            : 
<span class="lineNum">    7377 </span>            :     // Determine w- = m- such that e_(w-) = e_(w+).
<span class="lineNum">    7378 </span><span class="lineCov">          2 :     const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);</span>
<span class="lineNum">    7379 </span>            : 
<span class="lineNum">    7380 </span><span class="lineCov">          2 :     return {diyfp::normalize(v), w_minus, w_plus};</span>
<span class="lineNum">    7381 </span>            : }
<span class="lineNum">    7382 </span>            : 
<span class="lineNum">    7383 </span>            : // Given normalized diyfp w, Grisu needs to find a (normalized) cached
<span class="lineNum">    7384 </span>            : // power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
<span class="lineNum">    7385 </span>            : // within a certain range [alpha, gamma] (Definition 3.2 from [1])
<span class="lineNum">    7386 </span>            : //
<span class="lineNum">    7387 </span>            : //      alpha &lt;= e = e_c + e_w + q &lt;= gamma
<span class="lineNum">    7388 </span>            : //
<span class="lineNum">    7389 </span>            : // or
<span class="lineNum">    7390 </span>            : //
<span class="lineNum">    7391 </span>            : //      f_c * f_w * 2^alpha &lt;= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
<span class="lineNum">    7392 </span>            : //                          &lt;= f_c * f_w * 2^gamma
<span class="lineNum">    7393 </span>            : //
<span class="lineNum">    7394 </span>            : // Since c and w are normalized, i.e. 2^(q-1) &lt;= f &lt; 2^q, this implies
<span class="lineNum">    7395 </span>            : //
<span class="lineNum">    7396 </span>            : //      2^(q-1) * 2^(q-1) * 2^alpha &lt;= c * w * 2^q &lt; 2^q * 2^q * 2^gamma
<span class="lineNum">    7397 </span>            : //
<span class="lineNum">    7398 </span>            : // or
<span class="lineNum">    7399 </span>            : //
<span class="lineNum">    7400 </span>            : //      2^(q - 2 + alpha) &lt;= c * w &lt; 2^(q + gamma)
<span class="lineNum">    7401 </span>            : //
<span class="lineNum">    7402 </span>            : // The choice of (alpha,gamma) determines the size of the table and the form of
<span class="lineNum">    7403 </span>            : // the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
<span class="lineNum">    7404 </span>            : // in practice:
<span class="lineNum">    7405 </span>            : //
<span class="lineNum">    7406 </span>            : // The idea is to cut the number c * w = f * 2^e into two parts, which can be
<span class="lineNum">    7407 </span>            : // processed independently: An integral part p1, and a fractional part p2:
<span class="lineNum">    7408 </span>            : //
<span class="lineNum">    7409 </span>            : //      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
<span class="lineNum">    7410 </span>            : //              = (f div 2^-e) + (f mod 2^-e) * 2^e
<span class="lineNum">    7411 </span>            : //              = p1 + p2 * 2^e
<span class="lineNum">    7412 </span>            : //
<span class="lineNum">    7413 </span>            : // The conversion of p1 into decimal form requires a series of divisions and
<span class="lineNum">    7414 </span>            : // modulos by (a power of) 10. These operations are faster for 32-bit than for
<span class="lineNum">    7415 </span>            : // 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
<span class="lineNum">    7416 </span>            : // achieved by choosing
<span class="lineNum">    7417 </span>            : //
<span class="lineNum">    7418 </span>            : //      -e &gt;= 32   or   e &lt;= -32 := gamma
<span class="lineNum">    7419 </span>            : //
<span class="lineNum">    7420 </span>            : // In order to convert the fractional part
<span class="lineNum">    7421 </span>            : //
<span class="lineNum">    7422 </span>            : //      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
<span class="lineNum">    7423 </span>            : //
<span class="lineNum">    7424 </span>            : // into decimal form, the fraction is repeatedly multiplied by 10 and the digits
<span class="lineNum">    7425 </span>            : // d[-i] are extracted in order:
<span class="lineNum">    7426 </span>            : //
<span class="lineNum">    7427 </span>            : //      (10 * p2) div 2^-e = d[-1]
<span class="lineNum">    7428 </span>            : //      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
<span class="lineNum">    7429 </span>            : //
<span class="lineNum">    7430 </span>            : // The multiplication by 10 must not overflow. It is sufficient to choose
<span class="lineNum">    7431 </span>            : //
<span class="lineNum">    7432 </span>            : //      10 * p2 &lt; 16 * p2 = 2^4 * p2 &lt;= 2^64.
<span class="lineNum">    7433 </span>            : //
<span class="lineNum">    7434 </span>            : // Since p2 = f mod 2^-e &lt; 2^-e,
<span class="lineNum">    7435 </span>            : //
<span class="lineNum">    7436 </span>            : //      -e &lt;= 60   or   e &gt;= -60 := alpha
<span class="lineNum">    7437 </span>            : 
<span class="lineNum">    7438 </span>            : constexpr int kAlpha = -60;
<span class="lineNum">    7439 </span>            : constexpr int kGamma = -32;
<span class="lineNum">    7440 </span>            : 
<span class="lineNum">    7441 </span>            : struct cached_power // c = f * 2^e ~= 10^k
<span class="lineNum">    7442 </span>            : {
<span class="lineNum">    7443 </span>            :     uint64_t f;
<span class="lineNum">    7444 </span>            :     int e;
<span class="lineNum">    7445 </span>            :     int k;
<span class="lineNum">    7446 </span>            : };
<span class="lineNum">    7447 </span>            : 
<span class="lineNum">    7448 </span>            : /*!
<span class="lineNum">    7449 </span>            : For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
<span class="lineNum">    7450 </span>            : power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
<span class="lineNum">    7451 </span>            : satisfies (Definition 3.2 from [1])
<span class="lineNum">    7452 </span>            : 
<a name="7453"><span class="lineNum">    7453 </span>            :      alpha &lt;= e_c + e + q &lt;= gamma.</a>
<span class="lineNum">    7454 </span>            : */
<span class="lineNum">    7455 </span><span class="lineCov">          2 : inline cached_power get_cached_power_for_binary_exponent(int e)</span>
<span class="lineNum">    7456 </span>            : {
<span class="lineNum">    7457 </span>            :     // Now
<span class="lineNum">    7458 </span>            :     //
<span class="lineNum">    7459 </span>            :     //      alpha &lt;= e_c + e + q &lt;= gamma                                    (1)
<span class="lineNum">    7460 </span>            :     //      ==&gt; f_c * 2^alpha &lt;= c * 2^e * 2^q
<span class="lineNum">    7461 </span>            :     //
<span class="lineNum">    7462 </span>            :     // and since the c's are normalized, 2^(q-1) &lt;= f_c,
<span class="lineNum">    7463 </span>            :     //
<span class="lineNum">    7464 </span>            :     //      ==&gt; 2^(q - 1 + alpha) &lt;= c * 2^(e + q)
<span class="lineNum">    7465 </span>            :     //      ==&gt; 2^(alpha - e - 1) &lt;= c
<span class="lineNum">    7466 </span>            :     //
<span class="lineNum">    7467 </span>            :     // If c were an exakt power of ten, i.e. c = 10^k, one may determine k as
<span class="lineNum">    7468 </span>            :     //
<span class="lineNum">    7469 </span>            :     //      k = ceil( log_10( 2^(alpha - e - 1) ) )
<span class="lineNum">    7470 </span>            :     //        = ceil( (alpha - e - 1) * log_10(2) )
<span class="lineNum">    7471 </span>            :     //
<span class="lineNum">    7472 </span>            :     // From the paper:
<span class="lineNum">    7473 </span>            :     // &quot;In theory the result of the procedure could be wrong since c is rounded,
<span class="lineNum">    7474 </span>            :     //  and the computation itself is approximated [...]. In practice, however,
<span class="lineNum">    7475 </span>            :     //  this simple function is sufficient.&quot;
<span class="lineNum">    7476 </span>            :     //
<span class="lineNum">    7477 </span>            :     // For IEEE double precision floating-point numbers converted into
<span class="lineNum">    7478 </span>            :     // normalized diyfp's w = f * 2^e, with q = 64,
<span class="lineNum">    7479 </span>            :     //
<span class="lineNum">    7480 </span>            :     //      e &gt;= -1022      (min IEEE exponent)
<span class="lineNum">    7481 </span>            :     //           -52        (p - 1)
<span class="lineNum">    7482 </span>            :     //           -52        (p - 1, possibly normalize denormal IEEE numbers)
<span class="lineNum">    7483 </span>            :     //           -11        (normalize the diyfp)
<span class="lineNum">    7484 </span>            :     //         = -1137
<span class="lineNum">    7485 </span>            :     //
<span class="lineNum">    7486 </span>            :     // and
<span class="lineNum">    7487 </span>            :     //
<span class="lineNum">    7488 </span>            :     //      e &lt;= +1023      (max IEEE exponent)
<span class="lineNum">    7489 </span>            :     //           -52        (p - 1)
<span class="lineNum">    7490 </span>            :     //           -11        (normalize the diyfp)
<span class="lineNum">    7491 </span>            :     //         = 960
<span class="lineNum">    7492 </span>            :     //
<span class="lineNum">    7493 </span>            :     // This binary exponent range [-1137,960] results in a decimal exponent
<span class="lineNum">    7494 </span>            :     // range [-307,324]. One does not need to store a cached power for each
<span class="lineNum">    7495 </span>            :     // k in this range. For each such k it suffices to find a cached power
<span class="lineNum">    7496 </span>            :     // such that the exponent of the product lies in [alpha,gamma].
<span class="lineNum">    7497 </span>            :     // This implies that the difference of the decimal exponents of adjacent
<span class="lineNum">    7498 </span>            :     // table entries must be less than or equal to
<span class="lineNum">    7499 </span>            :     //
<span class="lineNum">    7500 </span>            :     //      floor( (gamma - alpha) * log_10(2) ) = 8.
<span class="lineNum">    7501 </span>            :     //
<span class="lineNum">    7502 </span>            :     // (A smaller distance gamma-alpha would require a larger table.)
<span class="lineNum">    7503 </span>            : 
<span class="lineNum">    7504 </span>            :     // NB:
<span class="lineNum">    7505 </span>            :     // Actually this function returns c, such that -60 &lt;= e_c + e + 64 &lt;= -34.
<span class="lineNum">    7506 </span>            : 
<span class="lineNum">    7507 </span><span class="lineCov">          2 :     constexpr int kCachedPowersSize = 79;</span>
<span class="lineNum">    7508 </span><span class="lineCov">          2 :     constexpr int kCachedPowersMinDecExp = -300;</span>
<span class="lineNum">    7509 </span><span class="lineCov">          2 :     constexpr int kCachedPowersDecStep = 8;</span>
<span class="lineNum">    7510 </span>            : 
<span class="lineNum">    7511 </span>            :     static constexpr cached_power kCachedPowers[] =
<span class="lineNum">    7512 </span>            :     {
<span class="lineNum">    7513 </span>            :         { 0xAB70FE17C79AC6CA, -1060, -300 },
<span class="lineNum">    7514 </span>            :         { 0xFF77B1FCBEBCDC4F, -1034, -292 },
<span class="lineNum">    7515 </span>            :         { 0xBE5691EF416BD60C, -1007, -284 },
<span class="lineNum">    7516 </span>            :         { 0x8DD01FAD907FFC3C,  -980, -276 },
<span class="lineNum">    7517 </span>            :         { 0xD3515C2831559A83,  -954, -268 },
<span class="lineNum">    7518 </span>            :         { 0x9D71AC8FADA6C9B5,  -927, -260 },
<span class="lineNum">    7519 </span>            :         { 0xEA9C227723EE8BCB,  -901, -252 },
<span class="lineNum">    7520 </span>            :         { 0xAECC49914078536D,  -874, -244 },
<span class="lineNum">    7521 </span>            :         { 0x823C12795DB6CE57,  -847, -236 },
<span class="lineNum">    7522 </span>            :         { 0xC21094364DFB5637,  -821, -228 },
<span class="lineNum">    7523 </span>            :         { 0x9096EA6F3848984F,  -794, -220 },
<span class="lineNum">    7524 </span>            :         { 0xD77485CB25823AC7,  -768, -212 },
<span class="lineNum">    7525 </span>            :         { 0xA086CFCD97BF97F4,  -741, -204 },
<span class="lineNum">    7526 </span>            :         { 0xEF340A98172AACE5,  -715, -196 },
<span class="lineNum">    7527 </span>            :         { 0xB23867FB2A35B28E,  -688, -188 },
<span class="lineNum">    7528 </span>            :         { 0x84C8D4DFD2C63F3B,  -661, -180 },
<span class="lineNum">    7529 </span>            :         { 0xC5DD44271AD3CDBA,  -635, -172 },
<span class="lineNum">    7530 </span>            :         { 0x936B9FCEBB25C996,  -608, -164 },
<span class="lineNum">    7531 </span>            :         { 0xDBAC6C247D62A584,  -582, -156 },
<span class="lineNum">    7532 </span>            :         { 0xA3AB66580D5FDAF6,  -555, -148 },
<span class="lineNum">    7533 </span>            :         { 0xF3E2F893DEC3F126,  -529, -140 },
<span class="lineNum">    7534 </span>            :         { 0xB5B5ADA8AAFF80B8,  -502, -132 },
<span class="lineNum">    7535 </span>            :         { 0x87625F056C7C4A8B,  -475, -124 },
<span class="lineNum">    7536 </span>            :         { 0xC9BCFF6034C13053,  -449, -116 },
<span class="lineNum">    7537 </span>            :         { 0x964E858C91BA2655,  -422, -108 },
<span class="lineNum">    7538 </span>            :         { 0xDFF9772470297EBD,  -396, -100 },
<span class="lineNum">    7539 </span>            :         { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
<span class="lineNum">    7540 </span>            :         { 0xF8A95FCF88747D94,  -343,  -84 },
<span class="lineNum">    7541 </span>            :         { 0xB94470938FA89BCF,  -316,  -76 },
<span class="lineNum">    7542 </span>            :         { 0x8A08F0F8BF0F156B,  -289,  -68 },
<span class="lineNum">    7543 </span>            :         { 0xCDB02555653131B6,  -263,  -60 },
<span class="lineNum">    7544 </span>            :         { 0x993FE2C6D07B7FAC,  -236,  -52 },
<span class="lineNum">    7545 </span>            :         { 0xE45C10C42A2B3B06,  -210,  -44 },
<span class="lineNum">    7546 </span>            :         { 0xAA242499697392D3,  -183,  -36 },
<span class="lineNum">    7547 </span>            :         { 0xFD87B5F28300CA0E,  -157,  -28 },
<span class="lineNum">    7548 </span>            :         { 0xBCE5086492111AEB,  -130,  -20 },
<span class="lineNum">    7549 </span>            :         { 0x8CBCCC096F5088CC,  -103,  -12 },
<span class="lineNum">    7550 </span>            :         { 0xD1B71758E219652C,   -77,   -4 },
<span class="lineNum">    7551 </span>            :         { 0x9C40000000000000,   -50,    4 },
<span class="lineNum">    7552 </span>            :         { 0xE8D4A51000000000,   -24,   12 },
<span class="lineNum">    7553 </span>            :         { 0xAD78EBC5AC620000,     3,   20 },
<span class="lineNum">    7554 </span>            :         { 0x813F3978F8940984,    30,   28 },
<span class="lineNum">    7555 </span>            :         { 0xC097CE7BC90715B3,    56,   36 },
<span class="lineNum">    7556 </span>            :         { 0x8F7E32CE7BEA5C70,    83,   44 },
<span class="lineNum">    7557 </span>            :         { 0xD5D238A4ABE98068,   109,   52 },
<span class="lineNum">    7558 </span>            :         { 0x9F4F2726179A2245,   136,   60 },
<span class="lineNum">    7559 </span>            :         { 0xED63A231D4C4FB27,   162,   68 },
<span class="lineNum">    7560 </span>            :         { 0xB0DE65388CC8ADA8,   189,   76 },
<span class="lineNum">    7561 </span>            :         { 0x83C7088E1AAB65DB,   216,   84 },
<span class="lineNum">    7562 </span>            :         { 0xC45D1DF942711D9A,   242,   92 },
<span class="lineNum">    7563 </span>            :         { 0x924D692CA61BE758,   269,  100 },
<span class="lineNum">    7564 </span>            :         { 0xDA01EE641A708DEA,   295,  108 },
<span class="lineNum">    7565 </span>            :         { 0xA26DA3999AEF774A,   322,  116 },
<span class="lineNum">    7566 </span>            :         { 0xF209787BB47D6B85,   348,  124 },
<span class="lineNum">    7567 </span>            :         { 0xB454E4A179DD1877,   375,  132 },
<span class="lineNum">    7568 </span>            :         { 0x865B86925B9BC5C2,   402,  140 },
<span class="lineNum">    7569 </span>            :         { 0xC83553C5C8965D3D,   428,  148 },
<span class="lineNum">    7570 </span>            :         { 0x952AB45CFA97A0B3,   455,  156 },
<span class="lineNum">    7571 </span>            :         { 0xDE469FBD99A05FE3,   481,  164 },
<span class="lineNum">    7572 </span>            :         { 0xA59BC234DB398C25,   508,  172 },
<span class="lineNum">    7573 </span>            :         { 0xF6C69A72A3989F5C,   534,  180 },
<span class="lineNum">    7574 </span>            :         { 0xB7DCBF5354E9BECE,   561,  188 },
<span class="lineNum">    7575 </span>            :         { 0x88FCF317F22241E2,   588,  196 },
<span class="lineNum">    7576 </span>            :         { 0xCC20CE9BD35C78A5,   614,  204 },
<span class="lineNum">    7577 </span>            :         { 0x98165AF37B2153DF,   641,  212 },
<span class="lineNum">    7578 </span>            :         { 0xE2A0B5DC971F303A,   667,  220 },
<span class="lineNum">    7579 </span>            :         { 0xA8D9D1535CE3B396,   694,  228 },
<span class="lineNum">    7580 </span>            :         { 0xFB9B7CD9A4A7443C,   720,  236 },
<span class="lineNum">    7581 </span>            :         { 0xBB764C4CA7A44410,   747,  244 },
<span class="lineNum">    7582 </span>            :         { 0x8BAB8EEFB6409C1A,   774,  252 },
<span class="lineNum">    7583 </span>            :         { 0xD01FEF10A657842C,   800,  260 },
<span class="lineNum">    7584 </span>            :         { 0x9B10A4E5E9913129,   827,  268 },
<span class="lineNum">    7585 </span>            :         { 0xE7109BFBA19C0C9D,   853,  276 },
<span class="lineNum">    7586 </span>            :         { 0xAC2820D9623BF429,   880,  284 },
<span class="lineNum">    7587 </span>            :         { 0x80444B5E7AA7CF85,   907,  292 },
<span class="lineNum">    7588 </span>            :         { 0xBF21E44003ACDD2D,   933,  300 },
<span class="lineNum">    7589 </span>            :         { 0x8E679C2F5E44FF8F,   960,  308 },
<span class="lineNum">    7590 </span>            :         { 0xD433179D9C8CB841,   986,  316 },
<span class="lineNum">    7591 </span>            :         { 0x9E19DB92B4E31BA9,  1013,  324 },
<span class="lineNum">    7592 </span>            :     };
<span class="lineNum">    7593 </span>            : 
<span class="lineNum">    7594 </span>            :     // This computation gives exactly the same results for k as
<span class="lineNum">    7595 </span>            :     //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
<span class="lineNum">    7596 </span>            :     // for |e| &lt;= 1500, but doesn't require floating-point operations.
<span class="lineNum">    7597 </span>            :     // NB: log_10(2) ~= 78913 / 2^18
<span class="lineNum">    7598 </span><span class="lineCov">          2 :     assert(e &gt;= -1500);</span>
<span class="lineNum">    7599 </span><span class="lineCov">          2 :     assert(e &lt;=  1500);</span>
<span class="lineNum">    7600 </span><span class="lineCov">          2 :     const int f = kAlpha - e - 1;</span>
<span class="lineNum">    7601 </span><span class="lineCov">          2 :     const int k = (f * 78913) / (1 &lt;&lt; 18) + (f &gt; 0);</span>
<span class="lineNum">    7602 </span>            : 
<span class="lineNum">    7603 </span><span class="lineCov">          2 :     const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;</span>
<span class="lineNum">    7604 </span><span class="lineCov">          2 :     assert(index &gt;= 0);</span>
<span class="lineNum">    7605 </span><span class="lineCov">          2 :     assert(index &lt; kCachedPowersSize);</span>
<span class="lineNum">    7606 </span>            :     static_cast&lt;void&gt;(kCachedPowersSize); // Fix warning.
<span class="lineNum">    7607 </span>            : 
<span class="lineNum">    7608 </span><span class="lineCov">          2 :     const cached_power cached = kCachedPowers[index];</span>
<span class="lineNum">    7609 </span><span class="lineCov">          2 :     assert(kAlpha &lt;= cached.e + e + 64);</span>
<span class="lineNum">    7610 </span><span class="lineCov">          2 :     assert(kGamma &gt;= cached.e + e + 64);</span>
<span class="lineNum">    7611 </span>            : 
<span class="lineNum">    7612 </span><span class="lineCov">          2 :     return cached;</span>
<span class="lineNum">    7613 </span>            : }
<span class="lineNum">    7614 </span>            : 
<span class="lineNum">    7615 </span>            : /*!
<span class="lineNum">    7616 </span>            : For n != 0, returns k, such that pow10 := 10^(k-1) &lt;= n &lt; 10^k.
<a name="7617"><span class="lineNum">    7617 </span>            : For n == 0, returns 1 and sets pow10 := 1.</a>
<span class="lineNum">    7618 </span>            : */
<span class="lineNum">    7619 </span><span class="lineCov">          2 : inline int find_largest_pow10(const uint32_t n, uint32_t&amp; pow10)</span>
<span class="lineNum">    7620 </span>            : {
<span class="lineNum">    7621 </span>            :     // LCOV_EXCL_START
<span class="lineNum">    7622 </span>            :     if (n &gt;= 1000000000)
<span class="lineNum">    7623 </span>            :     {
<span class="lineNum">    7624 </span>            :         pow10 = 1000000000;
<span class="lineNum">    7625 </span>            :         return 10;
<span class="lineNum">    7626 </span>            :     }
<span class="lineNum">    7627 </span>            :     // LCOV_EXCL_STOP
<span class="lineNum">    7628 </span><span class="lineCov">          2 :     else if (n &gt;= 100000000)</span>
<span class="lineNum">    7629 </span>            :     {
<span class="lineNum">    7630 </span><span class="lineNoCov">          0 :         pow10 = 100000000;</span>
<span class="lineNum">    7631 </span><span class="lineNoCov">          0 :         return  9;</span>
<span class="lineNum">    7632 </span>            :     }
<span class="lineNum">    7633 </span><span class="lineCov">          2 :     else if (n &gt;= 10000000)</span>
<span class="lineNum">    7634 </span>            :     {
<span class="lineNum">    7635 </span><span class="lineNoCov">          0 :         pow10 = 10000000;</span>
<span class="lineNum">    7636 </span><span class="lineNoCov">          0 :         return  8;</span>
<span class="lineNum">    7637 </span>            :     }
<span class="lineNum">    7638 </span><span class="lineCov">          2 :     else if (n &gt;= 1000000)</span>
<span class="lineNum">    7639 </span>            :     {
<span class="lineNum">    7640 </span><span class="lineNoCov">          0 :         pow10 = 1000000;</span>
<span class="lineNum">    7641 </span><span class="lineNoCov">          0 :         return  7;</span>
<span class="lineNum">    7642 </span>            :     }
<span class="lineNum">    7643 </span><span class="lineCov">          2 :     else if (n &gt;= 100000)</span>
<span class="lineNum">    7644 </span>            :     {
<span class="lineNum">    7645 </span><span class="lineNoCov">          0 :         pow10 = 100000;</span>
<span class="lineNum">    7646 </span><span class="lineNoCov">          0 :         return  6;</span>
<span class="lineNum">    7647 </span>            :     }
<span class="lineNum">    7648 </span><span class="lineCov">          2 :     else if (n &gt;= 10000)</span>
<span class="lineNum">    7649 </span>            :     {
<span class="lineNum">    7650 </span><span class="lineCov">          2 :         pow10 = 10000;</span>
<span class="lineNum">    7651 </span><span class="lineCov">          2 :         return  5;</span>
<span class="lineNum">    7652 </span>            :     }
<span class="lineNum">    7653 </span><span class="lineNoCov">          0 :     else if (n &gt;= 1000)</span>
<span class="lineNum">    7654 </span>            :     {
<span class="lineNum">    7655 </span><span class="lineNoCov">          0 :         pow10 = 1000;</span>
<span class="lineNum">    7656 </span><span class="lineNoCov">          0 :         return  4;</span>
<span class="lineNum">    7657 </span>            :     }
<span class="lineNum">    7658 </span><span class="lineNoCov">          0 :     else if (n &gt;= 100)</span>
<span class="lineNum">    7659 </span>            :     {
<span class="lineNum">    7660 </span><span class="lineNoCov">          0 :         pow10 = 100;</span>
<span class="lineNum">    7661 </span><span class="lineNoCov">          0 :         return  3;</span>
<span class="lineNum">    7662 </span>            :     }
<span class="lineNum">    7663 </span><span class="lineNoCov">          0 :     else if (n &gt;= 10)</span>
<span class="lineNum">    7664 </span>            :     {
<span class="lineNum">    7665 </span><span class="lineNoCov">          0 :         pow10 = 10;</span>
<span class="lineNum">    7666 </span><span class="lineNoCov">          0 :         return  2;</span>
<span class="lineNum">    7667 </span>            :     }
<span class="lineNum">    7668 </span>            :     else
<span class="lineNum">    7669 </span>            :     {
<span class="lineNum">    7670 </span><span class="lineNoCov">          0 :         pow10 = 1;</span>
<span class="lineNum">    7671 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    7672 </span>            :     }
<a name="7673"><span class="lineNum">    7673 </span>            : }</a>
<span class="lineNum">    7674 </span>            : 
<span class="lineNum">    7675 </span><span class="lineCov">          2 : inline void grisu2_round(char* buf, int len, uint64_t dist, uint64_t delta,</span>
<span class="lineNum">    7676 </span>            :                          uint64_t rest, uint64_t ten_k)
<span class="lineNum">    7677 </span>            : {
<span class="lineNum">    7678 </span><span class="lineCov">          2 :     assert(len &gt;= 1);</span>
<span class="lineNum">    7679 </span><span class="lineCov">          2 :     assert(dist &lt;= delta);</span>
<span class="lineNum">    7680 </span><span class="lineCov">          2 :     assert(rest &lt;= delta);</span>
<span class="lineNum">    7681 </span><span class="lineCov">          2 :     assert(ten_k &gt; 0);</span>
<span class="lineNum">    7682 </span>            : 
<span class="lineNum">    7683 </span>            :     //               &lt;--------------------------- delta ----&gt;
<span class="lineNum">    7684 </span>            :     //                                  &lt;---- dist ---------&gt;
<span class="lineNum">    7685 </span>            :     // --------------[------------------+-------------------]--------------
<span class="lineNum">    7686 </span>            :     //               M-                 w                   M+
<span class="lineNum">    7687 </span>            :     //
<span class="lineNum">    7688 </span>            :     //                                  ten_k
<span class="lineNum">    7689 </span>            :     //                                &lt;------&gt;
<span class="lineNum">    7690 </span>            :     //                                       &lt;---- rest ----&gt;
<span class="lineNum">    7691 </span>            :     // --------------[------------------+----+--------------]--------------
<span class="lineNum">    7692 </span>            :     //                                  w    V
<span class="lineNum">    7693 </span>            :     //                                       = buf * 10^k
<span class="lineNum">    7694 </span>            :     //
<span class="lineNum">    7695 </span>            :     // ten_k represents a unit-in-the-last-place in the decimal representation
<span class="lineNum">    7696 </span>            :     // stored in buf.
<span class="lineNum">    7697 </span>            :     // Decrement buf by ten_k while this takes buf closer to w.
<span class="lineNum">    7698 </span>            : 
<span class="lineNum">    7699 </span>            :     // The tests are written in this order to avoid overflow in unsigned
<span class="lineNum">    7700 </span>            :     // integer arithmetic.
<span class="lineNum">    7701 </span>            : 
<span class="lineNum">    7702 </span><span class="lineNoCov">          0 :     while (rest &lt; dist</span>
<span class="lineNum">    7703 </span><span class="lineNoCov">          0 :             and delta - rest &gt;= ten_k</span>
<span class="lineNum">    7704 </span><span class="lineCov">          2 :             and (rest + ten_k &lt; dist or dist - rest &gt; rest + ten_k - dist))</span>
<span class="lineNum">    7705 </span>            :     {
<span class="lineNum">    7706 </span><span class="lineNoCov">          0 :         assert(buf[len - 1] != '0');</span>
<span class="lineNum">    7707 </span><span class="lineNoCov">          0 :         buf[len - 1]--;</span>
<span class="lineNum">    7708 </span><span class="lineNoCov">          0 :         rest += ten_k;</span>
<span class="lineNum">    7709 </span>            :     }
<span class="lineNum">    7710 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    7711 </span>            : 
<span class="lineNum">    7712 </span>            : /*!
<span class="lineNum">    7713 </span>            : Generates V = buffer * 10^decimal_exponent, such that M- &lt;= V &lt;= M+.
<a name="7714"><span class="lineNum">    7714 </span>            : M- and M+ must be normalized and share the same exponent -60 &lt;= e &lt;= -32.</a>
<span class="lineNum">    7715 </span>            : */
<span class="lineNum">    7716 </span><span class="lineCov">          2 : inline void grisu2_digit_gen(char* buffer, int&amp; length, int&amp; decimal_exponent,</span>
<span class="lineNum">    7717 </span>            :                              diyfp M_minus, diyfp w, diyfp M_plus)
<span class="lineNum">    7718 </span>            : {
<span class="lineNum">    7719 </span>            :     static_assert(kAlpha &gt;= -60, &quot;internal error&quot;);
<span class="lineNum">    7720 </span>            :     static_assert(kGamma &lt;= -32, &quot;internal error&quot;);
<span class="lineNum">    7721 </span>            : 
<span class="lineNum">    7722 </span>            :     // Generates the digits (and the exponent) of a decimal floating-point
<span class="lineNum">    7723 </span>            :     // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
<span class="lineNum">    7724 </span>            :     // w, M- and M+ share the same exponent e, which satisfies alpha &lt;= e &lt;= gamma.
<span class="lineNum">    7725 </span>            :     //
<span class="lineNum">    7726 </span>            :     //               &lt;--------------------------- delta ----&gt;
<span class="lineNum">    7727 </span>            :     //                                  &lt;---- dist ---------&gt;
<span class="lineNum">    7728 </span>            :     // --------------[------------------+-------------------]--------------
<span class="lineNum">    7729 </span>            :     //               M-                 w                   M+
<span class="lineNum">    7730 </span>            :     //
<span class="lineNum">    7731 </span>            :     // Grisu2 generates the digits of M+ from left to right and stops as soon as
<span class="lineNum">    7732 </span>            :     // V is in [M-,M+].
<span class="lineNum">    7733 </span>            : 
<span class="lineNum">    7734 </span><span class="lineCov">          2 :     assert(M_plus.e &gt;= kAlpha);</span>
<span class="lineNum">    7735 </span><span class="lineCov">          2 :     assert(M_plus.e &lt;= kGamma);</span>
<span class="lineNum">    7736 </span>            : 
<span class="lineNum">    7737 </span><span class="lineCov">          2 :     uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)</span>
<span class="lineNum">    7738 </span><span class="lineCov">          2 :     uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)</span>
<span class="lineNum">    7739 </span>            : 
<span class="lineNum">    7740 </span>            :     // Split M+ = f * 2^e into two parts p1 and p2 (note: e &lt; 0):
<span class="lineNum">    7741 </span>            :     //
<span class="lineNum">    7742 </span>            :     //      M+ = f * 2^e
<span class="lineNum">    7743 </span>            :     //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
<span class="lineNum">    7744 </span>            :     //         = ((p1        ) * 2^-e + (p2        )) * 2^e
<span class="lineNum">    7745 </span>            :     //         = p1 + p2 * 2^e
<span class="lineNum">    7746 </span>            : 
<span class="lineNum">    7747 </span><span class="lineCov">          2 :     const diyfp one(uint64_t{1} &lt;&lt; -M_plus.e, M_plus.e);</span>
<span class="lineNum">    7748 </span>            : 
<span class="lineNum">    7749 </span><span class="lineCov">          2 :     uint32_t p1 = static_cast&lt;uint32_t&gt;(M_plus.f &gt;&gt; -one.e); // p1 = f div 2^-e (Since -e &gt;= 32, p1 fits into a 32-bit int.)</span>
<span class="lineNum">    7750 </span><span class="lineCov">          2 :     uint64_t p2 = M_plus.f &amp; (one.f - 1);                    // p2 = f mod 2^-e</span>
<span class="lineNum">    7751 </span>            : 
<span class="lineNum">    7752 </span>            :     // 1)
<span class="lineNum">    7753 </span>            :     //
<span class="lineNum">    7754 </span>            :     // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]
<span class="lineNum">    7755 </span>            : 
<span class="lineNum">    7756 </span><span class="lineCov">          2 :     assert(p1 &gt; 0);</span>
<span class="lineNum">    7757 </span>            : 
<span class="lineNum">    7758 </span>            :     uint32_t pow10;
<span class="lineNum">    7759 </span><span class="lineCov">          2 :     const int k = find_largest_pow10(p1, pow10);</span>
<span class="lineNum">    7760 </span>            : 
<span class="lineNum">    7761 </span>            :     //      10^(k-1) &lt;= p1 &lt; 10^k, pow10 = 10^(k-1)
<span class="lineNum">    7762 </span>            :     //
<span class="lineNum">    7763 </span>            :     //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
<span class="lineNum">    7764 </span>            :     //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
<span class="lineNum">    7765 </span>            :     //
<span class="lineNum">    7766 </span>            :     //      M+ = p1                                             + p2 * 2^e
<span class="lineNum">    7767 </span>            :     //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
<span class="lineNum">    7768 </span>            :     //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
<span class="lineNum">    7769 </span>            :     //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
<span class="lineNum">    7770 </span>            :     //
<span class="lineNum">    7771 </span>            :     // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
<span class="lineNum">    7772 </span>            :     //
<span class="lineNum">    7773 </span>            :     //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
<span class="lineNum">    7774 </span>            :     //
<span class="lineNum">    7775 </span>            :     // but stop as soon as
<span class="lineNum">    7776 </span>            :     //
<span class="lineNum">    7777 </span>            :     //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e &lt;= delta * 2^e
<span class="lineNum">    7778 </span>            : 
<span class="lineNum">    7779 </span><span class="lineCov">          2 :     int n = k;</span>
<span class="lineNum">    7780 </span><span class="lineCov">          2 :     while (n &gt; 0)</span>
<span class="lineNum">    7781 </span>            :     {
<span class="lineNum">    7782 </span>            :         // Invariants:
<span class="lineNum">    7783 </span>            :         //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
<span class="lineNum">    7784 </span>            :         //      pow10 = 10^(n-1) &lt;= p1 &lt; 10^n
<span class="lineNum">    7785 </span>            :         //
<span class="lineNum">    7786 </span><span class="lineCov">          2 :         const uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)</span>
<span class="lineNum">    7787 </span><span class="lineCov">          2 :         const uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)</span>
<span class="lineNum">    7788 </span>            :         //
<span class="lineNum">    7789 </span>            :         //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
<span class="lineNum">    7790 </span>            :         //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
<span class="lineNum">    7791 </span>            :         //
<span class="lineNum">    7792 </span><span class="lineCov">          2 :         assert(d &lt;= 9);</span>
<span class="lineNum">    7793 </span><span class="lineCov">          2 :         buffer[length++] = static_cast&lt;char&gt;('0' + d); // buffer := buffer * 10 + d</span>
<span class="lineNum">    7794 </span>            :         //
<span class="lineNum">    7795 </span>            :         //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
<span class="lineNum">    7796 </span>            :         //
<span class="lineNum">    7797 </span><span class="lineCov">          2 :         p1 = r;</span>
<span class="lineNum">    7798 </span><span class="lineCov">          2 :         n--;</span>
<span class="lineNum">    7799 </span>            :         //
<span class="lineNum">    7800 </span>            :         //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
<span class="lineNum">    7801 </span>            :         //      pow10 = 10^n
<span class="lineNum">    7802 </span>            :         //
<span class="lineNum">    7803 </span>            : 
<span class="lineNum">    7804 </span>            :         // Now check if enough digits have been generated.
<span class="lineNum">    7805 </span>            :         // Compute
<span class="lineNum">    7806 </span>            :         //
<span class="lineNum">    7807 </span>            :         //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
<span class="lineNum">    7808 </span>            :         //
<span class="lineNum">    7809 </span>            :         // Note:
<span class="lineNum">    7810 </span>            :         // Since rest and delta share the same exponent e, it suffices to
<span class="lineNum">    7811 </span>            :         // compare the significands.
<span class="lineNum">    7812 </span><span class="lineCov">          2 :         const uint64_t rest = (uint64_t{p1} &lt;&lt; -one.e) + p2;</span>
<span class="lineNum">    7813 </span><span class="lineCov">          2 :         if (rest &lt;= delta)</span>
<span class="lineNum">    7814 </span>            :         {
<span class="lineNum">    7815 </span>            :             // V = buffer * 10^n, with M- &lt;= V &lt;= M+.
<span class="lineNum">    7816 </span>            : 
<span class="lineNum">    7817 </span><span class="lineCov">          2 :             decimal_exponent += n;</span>
<span class="lineNum">    7818 </span>            : 
<span class="lineNum">    7819 </span>            :             // We may now just stop. But instead look if the buffer could be
<span class="lineNum">    7820 </span>            :             // decremented to bring V closer to w.
<span class="lineNum">    7821 </span>            :             //
<span class="lineNum">    7822 </span>            :             // pow10 = 10^n is now 1 ulp in the decimal representation V.
<span class="lineNum">    7823 </span>            :             // The rounding procedure works with diyfp's with an implicit
<span class="lineNum">    7824 </span>            :             // exponent of e.
<span class="lineNum">    7825 </span>            :             //
<span class="lineNum">    7826 </span>            :             //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
<span class="lineNum">    7827 </span>            :             //
<span class="lineNum">    7828 </span><span class="lineCov">          2 :             const uint64_t ten_n = uint64_t{pow10} &lt;&lt; -one.e;</span>
<span class="lineNum">    7829 </span><span class="lineCov">          2 :             grisu2_round(buffer, length, dist, delta, rest, ten_n);</span>
<span class="lineNum">    7830 </span>            : 
<span class="lineNum">    7831 </span><span class="lineCov">          2 :             return;</span>
<span class="lineNum">    7832 </span>            :         }
<span class="lineNum">    7833 </span>            : 
<span class="lineNum">    7834 </span><span class="lineNoCov">          0 :         pow10 /= 10;</span>
<span class="lineNum">    7835 </span>            :         //
<span class="lineNum">    7836 </span>            :         //      pow10 = 10^(n-1) &lt;= p1 &lt; 10^n
<span class="lineNum">    7837 </span>            :         // Invariants restored.
<span class="lineNum">    7838 </span>            :     }
<span class="lineNum">    7839 </span>            : 
<span class="lineNum">    7840 </span>            :     // 2)
<span class="lineNum">    7841 </span>            :     //
<span class="lineNum">    7842 </span>            :     // The digits of the integral part have been generated:
<span class="lineNum">    7843 </span>            :     //
<span class="lineNum">    7844 </span>            :     //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
<span class="lineNum">    7845 </span>            :     //         = buffer            + p2 * 2^e
<span class="lineNum">    7846 </span>            :     //
<span class="lineNum">    7847 </span>            :     // Now generate the digits of the fractional part p2 * 2^e.
<span class="lineNum">    7848 </span>            :     //
<span class="lineNum">    7849 </span>            :     // Note:
<span class="lineNum">    7850 </span>            :     // No decimal point is generated: the exponent is adjusted instead.
<span class="lineNum">    7851 </span>            :     //
<span class="lineNum">    7852 </span>            :     // p2 actually represents the fraction
<span class="lineNum">    7853 </span>            :     //
<span class="lineNum">    7854 </span>            :     //      p2 * 2^e
<span class="lineNum">    7855 </span>            :     //          = p2 / 2^-e
<span class="lineNum">    7856 </span>            :     //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
<span class="lineNum">    7857 </span>            :     //
<span class="lineNum">    7858 </span>            :     // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
<span class="lineNum">    7859 </span>            :     //
<span class="lineNum">    7860 </span>            :     //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
<span class="lineNum">    7861 </span>            :     //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
<span class="lineNum">    7862 </span>            :     //
<span class="lineNum">    7863 </span>            :     // using
<span class="lineNum">    7864 </span>            :     //
<span class="lineNum">    7865 </span>            :     //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
<span class="lineNum">    7866 </span>            :     //                = (                   d) * 2^-e + (                   r)
<span class="lineNum">    7867 </span>            :     //
<span class="lineNum">    7868 </span>            :     // or
<span class="lineNum">    7869 </span>            :     //      10^m * p2 * 2^e = d + r * 2^e
<span class="lineNum">    7870 </span>            :     //
<span class="lineNum">    7871 </span>            :     // i.e.
<span class="lineNum">    7872 </span>            :     //
<span class="lineNum">    7873 </span>            :     //      M+ = buffer + p2 * 2^e
<span class="lineNum">    7874 </span>            :     //         = buffer + 10^-m * (d + r * 2^e)
<span class="lineNum">    7875 </span>            :     //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
<span class="lineNum">    7876 </span>            :     //
<span class="lineNum">    7877 </span>            :     // and stop as soon as 10^-m * r * 2^e &lt;= delta * 2^e
<span class="lineNum">    7878 </span>            : 
<span class="lineNum">    7879 </span><span class="lineNoCov">          0 :     assert(p2 &gt; delta);</span>
<span class="lineNum">    7880 </span>            : 
<span class="lineNum">    7881 </span><span class="lineNoCov">          0 :     int m = 0;</span>
<span class="lineNum">    7882 </span>            :     for (;;)
<span class="lineNum">    7883 </span>            :     {
<span class="lineNum">    7884 </span>            :         // Invariant:
<span class="lineNum">    7885 </span>            :         //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
<span class="lineNum">    7886 </span>            :         //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
<span class="lineNum">    7887 </span>            :         //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
<span class="lineNum">    7888 </span>            :         //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
<span class="lineNum">    7889 </span>            :         //
<span class="lineNum">    7890 </span><span class="lineNoCov">          0 :         assert(p2 &lt;= UINT64_MAX / 10);</span>
<span class="lineNum">    7891 </span><span class="lineNoCov">          0 :         p2 *= 10;</span>
<span class="lineNum">    7892 </span><span class="lineNoCov">          0 :         const uint64_t d = p2 &gt;&gt; -one.e;     // d = (10 * p2) div 2^-e</span>
<span class="lineNum">    7893 </span><span class="lineNoCov">          0 :         const uint64_t r = p2 &amp; (one.f - 1); // r = (10 * p2) mod 2^-e</span>
<span class="lineNum">    7894 </span>            :         //
<span class="lineNum">    7895 </span>            :         //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
<span class="lineNum">    7896 </span>            :         //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
<span class="lineNum">    7897 </span>            :         //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
<span class="lineNum">    7898 </span>            :         //
<span class="lineNum">    7899 </span><span class="lineNoCov">          0 :         assert(d &lt;= 9);</span>
<span class="lineNum">    7900 </span><span class="lineNoCov">          0 :         buffer[length++] = static_cast&lt;char&gt;('0' + d); // buffer := buffer * 10 + d</span>
<span class="lineNum">    7901 </span>            :         //
<span class="lineNum">    7902 </span>            :         //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
<span class="lineNum">    7903 </span>            :         //
<span class="lineNum">    7904 </span><span class="lineNoCov">          0 :         p2 = r;</span>
<span class="lineNum">    7905 </span><span class="lineNoCov">          0 :         m++;</span>
<span class="lineNum">    7906 </span>            :         //
<span class="lineNum">    7907 </span>            :         //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
<span class="lineNum">    7908 </span>            :         // Invariant restored.
<span class="lineNum">    7909 </span>            : 
<span class="lineNum">    7910 </span>            :         // Check if enough digits have been generated.
<span class="lineNum">    7911 </span>            :         //
<span class="lineNum">    7912 </span>            :         //      10^-m * p2 * 2^e &lt;= delta * 2^e
<span class="lineNum">    7913 </span>            :         //              p2 * 2^e &lt;= 10^m * delta * 2^e
<span class="lineNum">    7914 </span>            :         //                    p2 &lt;= 10^m * delta
<span class="lineNum">    7915 </span><span class="lineNoCov">          0 :         delta *= 10;</span>
<span class="lineNum">    7916 </span><span class="lineNoCov">          0 :         dist  *= 10;</span>
<span class="lineNum">    7917 </span><span class="lineNoCov">          0 :         if (p2 &lt;= delta)</span>
<span class="lineNum">    7918 </span>            :         {
<span class="lineNum">    7919 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    7920 </span>            :         }
<span class="lineNum">    7921 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    7922 </span>            : 
<span class="lineNum">    7923 </span>            :     // V = buffer * 10^-m, with M- &lt;= V &lt;= M+.
<span class="lineNum">    7924 </span>            : 
<span class="lineNum">    7925 </span><span class="lineNoCov">          0 :     decimal_exponent -= m;</span>
<span class="lineNum">    7926 </span>            : 
<span class="lineNum">    7927 </span>            :     // 1 ulp in the decimal representation is now 10^-m.
<span class="lineNum">    7928 </span>            :     // Since delta and dist are now scaled by 10^m, we need to do the
<span class="lineNum">    7929 </span>            :     // same with ulp in order to keep the units in sync.
<span class="lineNum">    7930 </span>            :     //
<span class="lineNum">    7931 </span>            :     //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
<span class="lineNum">    7932 </span>            :     //
<span class="lineNum">    7933 </span><span class="lineNoCov">          0 :     const uint64_t ten_m = one.f;</span>
<span class="lineNum">    7934 </span><span class="lineNoCov">          0 :     grisu2_round(buffer, length, dist, delta, p2, ten_m);</span>
<span class="lineNum">    7935 </span>            : 
<span class="lineNum">    7936 </span>            :     // By construction this algorithm generates the shortest possible decimal
<span class="lineNum">    7937 </span>            :     // number (Loitsch, Theorem 6.2) which rounds back to w.
<span class="lineNum">    7938 </span>            :     // For an input number of precision p, at least
<span class="lineNum">    7939 </span>            :     //
<span class="lineNum">    7940 </span>            :     //      N = 1 + ceil(p * log_10(2))
<span class="lineNum">    7941 </span>            :     //
<span class="lineNum">    7942 </span>            :     // decimal digits are sufficient to identify all binary floating-point
<span class="lineNum">    7943 </span>            :     // numbers (Matula, &quot;In-and-Out conversions&quot;).
<span class="lineNum">    7944 </span>            :     // This implies that the algorithm does not produce more than N decimal
<span class="lineNum">    7945 </span>            :     // digits.
<span class="lineNum">    7946 </span>            :     //
<span class="lineNum">    7947 </span>            :     //      N = 17 for p = 53 (IEEE double precision)
<span class="lineNum">    7948 </span>            :     //      N = 9  for p = 24 (IEEE single precision)
<span class="lineNum">    7949 </span>            : }
<span class="lineNum">    7950 </span>            : 
<span class="lineNum">    7951 </span>            : /*!
<span class="lineNum">    7952 </span>            : v = buf * 10^decimal_exponent
<span class="lineNum">    7953 </span>            : len is the length of the buffer (number of decimal digits)
<a name="7954"><span class="lineNum">    7954 </span>            : The buffer must be large enough, i.e. &gt;= max_digits10.</a>
<span class="lineNum">    7955 </span>            : */
<span class="lineNum">    7956 </span><span class="lineCov">          2 : inline void grisu2(char* buf, int&amp; len, int&amp; decimal_exponent,</span>
<span class="lineNum">    7957 </span>            :                    diyfp m_minus, diyfp v, diyfp m_plus)
<span class="lineNum">    7958 </span>            : {
<span class="lineNum">    7959 </span><span class="lineCov">          2 :     assert(m_plus.e == m_minus.e);</span>
<span class="lineNum">    7960 </span><span class="lineCov">          2 :     assert(m_plus.e == v.e);</span>
<span class="lineNum">    7961 </span>            : 
<span class="lineNum">    7962 </span>            :     //  --------(-----------------------+-----------------------)--------    (A)
<span class="lineNum">    7963 </span>            :     //          m-                      v                       m+
<span class="lineNum">    7964 </span>            :     //
<span class="lineNum">    7965 </span>            :     //  --------------------(-----------+-----------------------)--------    (B)
<span class="lineNum">    7966 </span>            :     //                      m-          v                       m+
<span class="lineNum">    7967 </span>            :     //
<span class="lineNum">    7968 </span>            :     // First scale v (and m- and m+) such that the exponent is in the range
<span class="lineNum">    7969 </span>            :     // [alpha, gamma].
<span class="lineNum">    7970 </span>            : 
<span class="lineNum">    7971 </span><span class="lineCov">          2 :     const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);</span>
<span class="lineNum">    7972 </span>            : 
<span class="lineNum">    7973 </span><span class="lineCov">          2 :     const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k</span>
<span class="lineNum">    7974 </span>            : 
<span class="lineNum">    7975 </span>            :     // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
<span class="lineNum">    7976 </span><span class="lineCov">          2 :     const diyfp w       = diyfp::mul(v,       c_minus_k);</span>
<span class="lineNum">    7977 </span><span class="lineCov">          2 :     const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);</span>
<span class="lineNum">    7978 </span><span class="lineCov">          2 :     const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);</span>
<span class="lineNum">    7979 </span>            : 
<span class="lineNum">    7980 </span>            :     //  ----(---+---)---------------(---+---)---------------(---+---)----
<span class="lineNum">    7981 </span>            :     //          w-                      w                       w+
<span class="lineNum">    7982 </span>            :     //          = c*m-                  = c*v                   = c*m+
<span class="lineNum">    7983 </span>            :     //
<span class="lineNum">    7984 </span>            :     // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
<span class="lineNum">    7985 </span>            :     // w+ are now off by a small amount.
<span class="lineNum">    7986 </span>            :     // In fact:
<span class="lineNum">    7987 </span>            :     //
<span class="lineNum">    7988 </span>            :     //      w - v * 10^k &lt; 1 ulp
<span class="lineNum">    7989 </span>            :     //
<span class="lineNum">    7990 </span>            :     // To account for this inaccuracy, add resp. subtract 1 ulp.
<span class="lineNum">    7991 </span>            :     //
<span class="lineNum">    7992 </span>            :     //  --------+---[---------------(---+---)---------------]---+--------
<span class="lineNum">    7993 </span>            :     //          w-  M-                  w                   M+  w+
<span class="lineNum">    7994 </span>            :     //
<span class="lineNum">    7995 </span>            :     // Now any number in [M-, M+] (bounds included) will round to w when input,
<span class="lineNum">    7996 </span>            :     // regardless of how the input rounding algorithm breaks ties.
<span class="lineNum">    7997 </span>            :     //
<span class="lineNum">    7998 </span>            :     // And digit_gen generates the shortest possible such number in [M-, M+].
<span class="lineNum">    7999 </span>            :     // Note that this does not mean that Grisu2 always generates the shortest
<span class="lineNum">    8000 </span>            :     // possible number in the interval (m-, m+).
<span class="lineNum">    8001 </span><span class="lineCov">          2 :     const diyfp M_minus(w_minus.f + 1, w_minus.e);</span>
<span class="lineNum">    8002 </span><span class="lineCov">          2 :     const diyfp M_plus (w_plus.f  - 1, w_plus.e );</span>
<span class="lineNum">    8003 </span>            : 
<span class="lineNum">    8004 </span><span class="lineCov">          2 :     decimal_exponent = -cached.k; // = -(-k) = k</span>
<span class="lineNum">    8005 </span>            : 
<span class="lineNum">    8006 </span><span class="lineCov">          2 :     grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);</span>
<span class="lineNum">    8007 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    8008 </span>            : 
<span class="lineNum">    8009 </span>            : /*!
<span class="lineNum">    8010 </span>            : v = buf * 10^decimal_exponent
<span class="lineNum">    8011 </span>            : len is the length of the buffer (number of decimal digits)
<span class="lineNum">    8012 </span>            : The buffer must be large enough, i.e. &gt;= max_digits10.
<a name="8013"><span class="lineNum">    8013 </span>            : */</a>
<span class="lineNum">    8014 </span>            : template &lt;typename FloatType&gt;
<span class="lineNum">    8015 </span><span class="lineCov">          2 : void grisu2(char* buf, int&amp; len, int&amp; decimal_exponent, FloatType value)</span>
<span class="lineNum">    8016 </span>            : {
<span class="lineNum">    8017 </span>            :     static_assert(diyfp::kPrecision &gt;= std::numeric_limits&lt;FloatType&gt;::digits + 3,
<span class="lineNum">    8018 </span>            :                   &quot;internal error: not enough precision&quot;);
<span class="lineNum">    8019 </span>            : 
<span class="lineNum">    8020 </span><span class="lineCov">          2 :     assert(std::isfinite(value));</span>
<span class="lineNum">    8021 </span><span class="lineCov">          2 :     assert(value &gt; 0);</span>
<span class="lineNum">    8022 </span>            : 
<span class="lineNum">    8023 </span>            :     // If the neighbors (and boundaries) of 'value' are always computed for double-precision
<span class="lineNum">    8024 </span>            :     // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
<span class="lineNum">    8025 </span>            :     // decimal representations are not exactly &quot;short&quot;.
<span class="lineNum">    8026 </span>            :     //
<span class="lineNum">    8027 </span>            :     // The documentation for 'std::to_chars' (http://en.cppreference.com/w/cpp/utility/to_chars)
<span class="lineNum">    8028 </span>            :     // says &quot;value is converted to a string as if by std::sprintf in the default (&quot;C&quot;) locale&quot;
<span class="lineNum">    8029 </span>            :     // and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
<span class="lineNum">    8030 </span>            :     // does.
<span class="lineNum">    8031 </span>            :     // On the other hand, the documentation for 'std::to_chars' requires that &quot;parsing the
<span class="lineNum">    8032 </span>            :     // representation using the corresponding std::from_chars function recovers value exactly&quot;. That
<span class="lineNum">    8033 </span>            :     // indicates that single precision floating-point numbers should be recovered using
<span class="lineNum">    8034 </span>            :     // 'std::strtof'.
<span class="lineNum">    8035 </span>            :     //
<span class="lineNum">    8036 </span>            :     // NB: If the neighbors are computed for single-precision numbers, there is a single float
<span class="lineNum">    8037 </span>            :     //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
<span class="lineNum">    8038 </span>            :     //     value is off by 1 ulp.
<span class="lineNum">    8039 </span>            : #if 0
<span class="lineNum">    8040 </span>            :     const boundaries w = compute_boundaries(static_cast&lt;double&gt;(value));
<span class="lineNum">    8041 </span>            : #else
<span class="lineNum">    8042 </span><span class="lineCov">          2 :     const boundaries w = compute_boundaries(value);</span>
<span class="lineNum">    8043 </span>            : #endif
<span class="lineNum">    8044 </span>            : 
<span class="lineNum">    8045 </span><span class="lineCov">          2 :     grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);</span>
<span class="lineNum">    8046 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    8047 </span>            : 
<span class="lineNum">    8048 </span>            : /*!
<span class="lineNum">    8049 </span>            : @brief appends a decimal representation of e to buf
<span class="lineNum">    8050 </span>            : @return a pointer to the element following the exponent.
<a name="8051"><span class="lineNum">    8051 </span>            : @pre -1000 &lt; e &lt; 1000</a>
<span class="lineNum">    8052 </span>            : */
<span class="lineNum">    8053 </span><span class="lineNoCov">          0 : inline char* append_exponent(char* buf, int e)</span>
<span class="lineNum">    8054 </span>            : {
<span class="lineNum">    8055 </span><span class="lineNoCov">          0 :     assert(e &gt; -1000);</span>
<span class="lineNum">    8056 </span><span class="lineNoCov">          0 :     assert(e &lt;  1000);</span>
<span class="lineNum">    8057 </span>            : 
<span class="lineNum">    8058 </span><span class="lineNoCov">          0 :     if (e &lt; 0)</span>
<span class="lineNum">    8059 </span>            :     {
<span class="lineNum">    8060 </span><span class="lineNoCov">          0 :         e = -e;</span>
<span class="lineNum">    8061 </span><span class="lineNoCov">          0 :         *buf++ = '-';</span>
<span class="lineNum">    8062 </span>            :     }
<span class="lineNum">    8063 </span>            :     else
<span class="lineNum">    8064 </span>            :     {
<span class="lineNum">    8065 </span><span class="lineNoCov">          0 :         *buf++ = '+';</span>
<span class="lineNum">    8066 </span>            :     }
<span class="lineNum">    8067 </span>            : 
<span class="lineNum">    8068 </span><span class="lineNoCov">          0 :     uint32_t k = static_cast&lt;uint32_t&gt;(e);</span>
<span class="lineNum">    8069 </span><span class="lineNoCov">          0 :     if (k &lt; 10)</span>
<span class="lineNum">    8070 </span>            :     {
<span class="lineNum">    8071 </span>            :         // Always print at least two digits in the exponent.
<span class="lineNum">    8072 </span>            :         // This is for compatibility with printf(&quot;%g&quot;).
<span class="lineNum">    8073 </span><span class="lineNoCov">          0 :         *buf++ = '0';</span>
<span class="lineNum">    8074 </span><span class="lineNoCov">          0 :         *buf++ = static_cast&lt;char&gt;('0' + k);</span>
<span class="lineNum">    8075 </span>            :     }
<span class="lineNum">    8076 </span><span class="lineNoCov">          0 :     else if (k &lt; 100)</span>
<span class="lineNum">    8077 </span>            :     {
<span class="lineNum">    8078 </span><span class="lineNoCov">          0 :         *buf++ = static_cast&lt;char&gt;('0' + k / 10);</span>
<span class="lineNum">    8079 </span><span class="lineNoCov">          0 :         k %= 10;</span>
<span class="lineNum">    8080 </span><span class="lineNoCov">          0 :         *buf++ = static_cast&lt;char&gt;('0' + k);</span>
<span class="lineNum">    8081 </span>            :     }
<span class="lineNum">    8082 </span>            :     else
<span class="lineNum">    8083 </span>            :     {
<span class="lineNum">    8084 </span><span class="lineNoCov">          0 :         *buf++ = static_cast&lt;char&gt;('0' + k / 100);</span>
<span class="lineNum">    8085 </span><span class="lineNoCov">          0 :         k %= 100;</span>
<span class="lineNum">    8086 </span><span class="lineNoCov">          0 :         *buf++ = static_cast&lt;char&gt;('0' + k / 10);</span>
<span class="lineNum">    8087 </span><span class="lineNoCov">          0 :         k %= 10;</span>
<span class="lineNum">    8088 </span><span class="lineNoCov">          0 :         *buf++ = static_cast&lt;char&gt;('0' + k);</span>
<span class="lineNum">    8089 </span>            :     }
<span class="lineNum">    8090 </span>            : 
<span class="lineNum">    8091 </span><span class="lineNoCov">          0 :     return buf;</span>
<span class="lineNum">    8092 </span>            : }
<span class="lineNum">    8093 </span>            : 
<span class="lineNum">    8094 </span>            : /*!
<span class="lineNum">    8095 </span>            : @brief prettify v = buf * 10^decimal_exponent
<span class="lineNum">    8096 </span>            : 
<span class="lineNum">    8097 </span>            : If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
<span class="lineNum">    8098 </span>            : notation. Otherwise it will be printed in exponential notation.
<span class="lineNum">    8099 </span>            : 
<span class="lineNum">    8100 </span>            : @pre min_exp &lt; 0
<a name="8101"><span class="lineNum">    8101 </span>            : @pre max_exp &gt; 0</a>
<span class="lineNum">    8102 </span>            : */
<span class="lineNum">    8103 </span><span class="lineCov">          2 : inline char* format_buffer(char* buf, int len, int decimal_exponent,</span>
<span class="lineNum">    8104 </span>            :                            int min_exp, int max_exp)
<span class="lineNum">    8105 </span>            : {
<span class="lineNum">    8106 </span><span class="lineCov">          2 :     assert(min_exp &lt; 0);</span>
<span class="lineNum">    8107 </span><span class="lineCov">          2 :     assert(max_exp &gt; 0);</span>
<span class="lineNum">    8108 </span>            : 
<span class="lineNum">    8109 </span><span class="lineCov">          2 :     const int k = len;</span>
<span class="lineNum">    8110 </span><span class="lineCov">          2 :     const int n = len + decimal_exponent;</span>
<span class="lineNum">    8111 </span>            : 
<span class="lineNum">    8112 </span>            :     // v = buf * 10^(n-k)
<span class="lineNum">    8113 </span>            :     // k is the length of the buffer (number of decimal digits)
<span class="lineNum">    8114 </span>            :     // n is the position of the decimal point relative to the start of the buffer.
<span class="lineNum">    8115 </span>            : 
<span class="lineNum">    8116 </span><span class="lineCov">          2 :     if (k &lt;= n and n &lt;= max_exp)</span>
<span class="lineNum">    8117 </span>            :     {
<span class="lineNum">    8118 </span>            :         // digits[000]
<span class="lineNum">    8119 </span>            :         // len &lt;= max_exp + 2
<span class="lineNum">    8120 </span>            : 
<span class="lineNum">    8121 </span><span class="lineCov">          2 :         std::memset(buf + k, '0', static_cast&lt;size_t&gt;(n - k));</span>
<span class="lineNum">    8122 </span>            :         // Make it look like a floating-point number (#362, #378)
<span class="lineNum">    8123 </span><span class="lineCov">          2 :         buf[n + 0] = '.';</span>
<span class="lineNum">    8124 </span><span class="lineCov">          2 :         buf[n + 1] = '0';</span>
<span class="lineNum">    8125 </span><span class="lineCov">          2 :         return buf + (n + 2);</span>
<span class="lineNum">    8126 </span>            :     }
<span class="lineNum">    8127 </span>            : 
<span class="lineNum">    8128 </span><span class="lineNoCov">          0 :     if (0 &lt; n and n &lt;= max_exp)</span>
<span class="lineNum">    8129 </span>            :     {
<span class="lineNum">    8130 </span>            :         // dig.its
<span class="lineNum">    8131 </span>            :         // len &lt;= max_digits10 + 1
<span class="lineNum">    8132 </span>            : 
<span class="lineNum">    8133 </span><span class="lineNoCov">          0 :         assert(k &gt; n);</span>
<span class="lineNum">    8134 </span>            : 
<span class="lineNum">    8135 </span><span class="lineNoCov">          0 :         std::memmove(buf + (n + 1), buf + n, static_cast&lt;size_t&gt;(k - n));</span>
<span class="lineNum">    8136 </span><span class="lineNoCov">          0 :         buf[n] = '.';</span>
<span class="lineNum">    8137 </span><span class="lineNoCov">          0 :         return buf + (k + 1);</span>
<span class="lineNum">    8138 </span>            :     }
<span class="lineNum">    8139 </span>            : 
<span class="lineNum">    8140 </span><span class="lineNoCov">          0 :     if (min_exp &lt; n and n &lt;= 0)</span>
<span class="lineNum">    8141 </span>            :     {
<span class="lineNum">    8142 </span>            :         // 0.[000]digits
<span class="lineNum">    8143 </span>            :         // len &lt;= 2 + (-min_exp - 1) + max_digits10
<span class="lineNum">    8144 </span>            : 
<span class="lineNum">    8145 </span><span class="lineNoCov">          0 :         std::memmove(buf + (2 + -n), buf, static_cast&lt;size_t&gt;(k));</span>
<span class="lineNum">    8146 </span><span class="lineNoCov">          0 :         buf[0] = '0';</span>
<span class="lineNum">    8147 </span><span class="lineNoCov">          0 :         buf[1] = '.';</span>
<span class="lineNum">    8148 </span><span class="lineNoCov">          0 :         std::memset(buf + 2, '0', static_cast&lt;size_t&gt;(-n));</span>
<span class="lineNum">    8149 </span><span class="lineNoCov">          0 :         return buf + (2 + (-n) + k);</span>
<span class="lineNum">    8150 </span>            :     }
<span class="lineNum">    8151 </span>            : 
<span class="lineNum">    8152 </span><span class="lineNoCov">          0 :     if (k == 1)</span>
<span class="lineNum">    8153 </span>            :     {
<span class="lineNum">    8154 </span>            :         // dE+123
<span class="lineNum">    8155 </span>            :         // len &lt;= 1 + 5
<span class="lineNum">    8156 </span>            : 
<span class="lineNum">    8157 </span><span class="lineNoCov">          0 :         buf += 1;</span>
<span class="lineNum">    8158 </span>            :     }
<span class="lineNum">    8159 </span>            :     else
<span class="lineNum">    8160 </span>            :     {
<span class="lineNum">    8161 </span>            :         // d.igitsE+123
<span class="lineNum">    8162 </span>            :         // len &lt;= max_digits10 + 1 + 5
<span class="lineNum">    8163 </span>            : 
<span class="lineNum">    8164 </span><span class="lineNoCov">          0 :         std::memmove(buf + 2, buf + 1, static_cast&lt;size_t&gt;(k - 1));</span>
<span class="lineNum">    8165 </span><span class="lineNoCov">          0 :         buf[1] = '.';</span>
<span class="lineNum">    8166 </span><span class="lineNoCov">          0 :         buf += 1 + k;</span>
<span class="lineNum">    8167 </span>            :     }
<span class="lineNum">    8168 </span>            : 
<span class="lineNum">    8169 </span><span class="lineNoCov">          0 :     *buf++ = 'e';</span>
<span class="lineNum">    8170 </span><span class="lineNoCov">          0 :     return append_exponent(buf, n - 1);</span>
<span class="lineNum">    8171 </span>            : }
<span class="lineNum">    8172 </span>            : 
<span class="lineNum">    8173 </span>            : } // namespace dtoa_impl
<span class="lineNum">    8174 </span>            : 
<span class="lineNum">    8175 </span>            : /*!
<span class="lineNum">    8176 </span>            : @brief generates a decimal representation of the floating-point number value in [first, last).
<span class="lineNum">    8177 </span>            : 
<span class="lineNum">    8178 </span>            : The format of the resulting decimal representation is similar to printf's %g
<span class="lineNum">    8179 </span>            : format. Returns an iterator pointing past-the-end of the decimal representation.
<span class="lineNum">    8180 </span>            : 
<span class="lineNum">    8181 </span>            : @note The input number must be finite, i.e. NaN's and Inf's are not supported.
<span class="lineNum">    8182 </span>            : @note The buffer must be large enough.
<span class="lineNum">    8183 </span>            : @note The result is NOT null-terminated.
<a name="8184"><span class="lineNum">    8184 </span>            : */</a>
<span class="lineNum">    8185 </span>            : template &lt;typename FloatType&gt;
<span class="lineNum">    8186 </span><span class="lineCov">          2 : char* to_chars(char* first, char* last, FloatType value)</span>
<span class="lineNum">    8187 </span>            : {
<span class="lineNum">    8188 </span>            :     static_cast&lt;void&gt;(last); // maybe unused - fix warning
<span class="lineNum">    8189 </span><span class="lineCov">          2 :     assert(std::isfinite(value));</span>
<span class="lineNum">    8190 </span>            : 
<span class="lineNum">    8191 </span>            :     // Use signbit(value) instead of (value &lt; 0) since signbit works for -0.
<span class="lineNum">    8192 </span><span class="lineCov">          2 :     if (std::signbit(value))</span>
<span class="lineNum">    8193 </span>            :     {
<span class="lineNum">    8194 </span><span class="lineNoCov">          0 :         value = -value;</span>
<span class="lineNum">    8195 </span><span class="lineNoCov">          0 :         *first++ = '-';</span>
<span class="lineNum">    8196 </span>            :     }
<span class="lineNum">    8197 </span>            : 
<span class="lineNum">    8198 </span><span class="lineCov">          2 :     if (value == 0) // +-0</span>
<span class="lineNum">    8199 </span>            :     {
<span class="lineNum">    8200 </span><span class="lineNoCov">          0 :         *first++ = '0';</span>
<span class="lineNum">    8201 </span>            :         // Make it look like a floating-point number (#362, #378)
<span class="lineNum">    8202 </span><span class="lineNoCov">          0 :         *first++ = '.';</span>
<span class="lineNum">    8203 </span><span class="lineNoCov">          0 :         *first++ = '0';</span>
<span class="lineNum">    8204 </span><span class="lineNoCov">          0 :         return first;</span>
<span class="lineNum">    8205 </span>            :     }
<span class="lineNum">    8206 </span>            : 
<span class="lineNum">    8207 </span><span class="lineCov">          2 :     assert(last - first &gt;= std::numeric_limits&lt;FloatType&gt;::max_digits10);</span>
<span class="lineNum">    8208 </span>            : 
<span class="lineNum">    8209 </span>            :     // Compute v = buffer * 10^decimal_exponent.
<span class="lineNum">    8210 </span>            :     // The decimal digits are stored in the buffer, which needs to be interpreted
<span class="lineNum">    8211 </span>            :     // as an unsigned decimal integer.
<span class="lineNum">    8212 </span>            :     // len is the length of the buffer, i.e. the number of decimal digits.
<span class="lineNum">    8213 </span><span class="lineCov">          2 :     int len = 0;</span>
<span class="lineNum">    8214 </span><span class="lineCov">          2 :     int decimal_exponent = 0;</span>
<span class="lineNum">    8215 </span><span class="lineCov">          2 :     dtoa_impl::grisu2(first, len, decimal_exponent, value);</span>
<span class="lineNum">    8216 </span>            : 
<span class="lineNum">    8217 </span><span class="lineCov">          2 :     assert(len &lt;= std::numeric_limits&lt;FloatType&gt;::max_digits10);</span>
<span class="lineNum">    8218 </span>            : 
<span class="lineNum">    8219 </span>            :     // Format the buffer like printf(&quot;%.*g&quot;, prec, value)
<span class="lineNum">    8220 </span><span class="lineCov">          2 :     constexpr int kMinExp = -4;</span>
<span class="lineNum">    8221 </span>            :     // Use digits10 here to increase compatibility with version 2.
<span class="lineNum">    8222 </span><span class="lineCov">          2 :     constexpr int kMaxExp = std::numeric_limits&lt;FloatType&gt;::digits10;</span>
<span class="lineNum">    8223 </span>            : 
<span class="lineNum">    8224 </span><span class="lineCov">          2 :     assert(last - first &gt;= kMaxExp + 2);</span>
<span class="lineNum">    8225 </span><span class="lineCov">          2 :     assert(last - first &gt;= 2 + (-kMinExp - 1) + std::numeric_limits&lt;FloatType&gt;::max_digits10);</span>
<span class="lineNum">    8226 </span><span class="lineCov">          2 :     assert(last - first &gt;= std::numeric_limits&lt;FloatType&gt;::max_digits10 + 6);</span>
<span class="lineNum">    8227 </span>            : 
<span class="lineNum">    8228 </span><span class="lineCov">          2 :     return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);</span>
<span class="lineNum">    8229 </span>            : }
<span class="lineNum">    8230 </span>            : 
<span class="lineNum">    8231 </span>            : } // namespace detail
<span class="lineNum">    8232 </span>            : } // namespace nlohmann
<span class="lineNum">    8233 </span>            : 
<span class="lineNum">    8234 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    8235 </span>            : 
<span class="lineNum">    8236 </span>            : // #include &lt;nlohmann/detail/meta.hpp&gt;
<span class="lineNum">    8237 </span>            : 
<span class="lineNum">    8238 </span>            : // #include &lt;nlohmann/detail/output/output_adapters.hpp&gt;
<span class="lineNum">    8239 </span>            : 
<span class="lineNum">    8240 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    8241 </span>            : 
<span class="lineNum">    8242 </span>            : 
<span class="lineNum">    8243 </span>            : namespace rockets_nlohmann
<span class="lineNum">    8244 </span>            : {
<span class="lineNum">    8245 </span>            : namespace detail
<span class="lineNum">    8246 </span>            : {
<span class="lineNum">    8247 </span>            : ///////////////////
<span class="lineNum">    8248 </span>            : // serialization //
<span class="lineNum">    8249 </span>            : ///////////////////
<a name="8250"><span class="lineNum">    8250 </span>            : </a>
<span class="lineNum">    8251 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    8252 </span><span class="lineCov">        123 : class serializer</span>
<span class="lineNum">    8253 </span>            : {
<span class="lineNum">    8254 </span>            :     using string_t = typename BasicJsonType::string_t;
<span class="lineNum">    8255 </span>            :     using number_float_t = typename BasicJsonType::number_float_t;
<span class="lineNum">    8256 </span>            :     using number_integer_t = typename BasicJsonType::number_integer_t;
<span class="lineNum">    8257 </span>            :     using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
<span class="lineNum">    8258 </span>            :     static constexpr uint8_t UTF8_ACCEPT = 0;
<span class="lineNum">    8259 </span>            :     static constexpr uint8_t UTF8_REJECT = 1;
<span class="lineNum">    8260 </span>            : 
<span class="lineNum">    8261 </span>            :   public:
<span class="lineNum">    8262 </span>            :     /*!
<span class="lineNum">    8263 </span>            :     @param[in] s  output stream to serialize to
<a name="8264"><span class="lineNum">    8264 </span>            :     @param[in] ichar  indentation character to use</a>
<span class="lineNum">    8265 </span>            :     */
<span class="lineNum">    8266 </span><span class="lineCov">        123 :     serializer(output_adapter_t&lt;char&gt; s, const char ichar)</span>
<span class="lineNum">    8267 </span><span class="lineCov">        246 :         : o(std::move(s)), loc(std::localeconv()),</span>
<span class="lineNum">    8268 </span><span class="lineCov">        246 :           thousands_sep(loc-&gt;thousands_sep == nullptr ? '\0' : * (loc-&gt;thousands_sep)),</span>
<span class="lineNum">    8269 </span><span class="lineCov">        246 :           decimal_point(loc-&gt;decimal_point == nullptr ? '\0' : * (loc-&gt;decimal_point)),</span>
<span class="lineNum">    8270 </span><span class="lineCov">        738 :           indent_char(ichar), indent_string(512, indent_char)</span>
<span class="lineNum">    8271 </span><span class="lineCov">        123 :     {}</span>
<span class="lineNum">    8272 </span>            : 
<span class="lineNum">    8273 </span>            :     // delete because of pointer members
<span class="lineNum">    8274 </span>            :     serializer(const serializer&amp;) = delete;
<span class="lineNum">    8275 </span>            :     serializer&amp; operator=(const serializer&amp;) = delete;
<span class="lineNum">    8276 </span>            : 
<span class="lineNum">    8277 </span>            :     /*!
<span class="lineNum">    8278 </span>            :     @brief internal implementation of the serialization function
<span class="lineNum">    8279 </span>            : 
<span class="lineNum">    8280 </span>            :     This function is called by the public member function dump and organizes
<span class="lineNum">    8281 </span>            :     the serialization internally. The indentation level is propagated as
<span class="lineNum">    8282 </span>            :     additional parameter. In case of arrays and objects, the function is
<span class="lineNum">    8283 </span>            :     called recursively.
<span class="lineNum">    8284 </span>            : 
<span class="lineNum">    8285 </span>            :     - strings and object keys are escaped using `escape_string()`
<span class="lineNum">    8286 </span>            :     - integer numbers are converted implicitly via `operator&lt;&lt;`
<span class="lineNum">    8287 </span>            :     - floating-point numbers are converted to a string using `&quot;%g&quot;` format
<span class="lineNum">    8288 </span>            : 
<span class="lineNum">    8289 </span>            :     @param[in] val             value to serialize
<span class="lineNum">    8290 </span>            :     @param[in] pretty_print    whether the output shall be pretty-printed
<span class="lineNum">    8291 </span>            :     @param[in] indent_step     the indent level
<a name="8292"><span class="lineNum">    8292 </span>            :     @param[in] current_indent  the current indent level (only used internally)</a>
<span class="lineNum">    8293 </span>            :     */
<span class="lineNum">    8294 </span><span class="lineCov">        537 :     void dump(const BasicJsonType&amp; val, const bool pretty_print,</span>
<span class="lineNum">    8295 </span>            :               const bool ensure_ascii,
<span class="lineNum">    8296 </span>            :               const unsigned int indent_step,
<span class="lineNum">    8297 </span>            :               const unsigned int current_indent = 0)
<span class="lineNum">    8298 </span>            :     {
<span class="lineNum">    8299 </span><span class="lineCov">        537 :         switch (val.m_type)</span>
<span class="lineNum">    8300 </span>            :         {
<span class="lineNum">    8301 </span>            :             case value_t::object:
<span class="lineNum">    8302 </span>            :             {
<span class="lineNum">    8303 </span><span class="lineCov">        129 :                 if (val.m_value.object-&gt;empty())</span>
<span class="lineNum">    8304 </span>            :                 {
<span class="lineNum">    8305 </span><span class="lineNoCov">          0 :                     o-&gt;write_characters(&quot;{}&quot;, 2);</span>
<span class="lineNum">    8306 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    8307 </span>            :                 }
<span class="lineNum">    8308 </span>            : 
<span class="lineNum">    8309 </span><span class="lineCov">        129 :                 if (pretty_print)</span>
<span class="lineNum">    8310 </span>            :                 {
<span class="lineNum">    8311 </span><span class="lineCov">        128 :                     o-&gt;write_characters(&quot;{\n&quot;, 2);</span>
<span class="lineNum">    8312 </span>            : 
<span class="lineNum">    8313 </span>            :                     // variable to hold indentation for recursive calls
<span class="lineNum">    8314 </span><span class="lineCov">        128 :                     const auto new_indent = current_indent + indent_step;</span>
<span class="lineNum">    8315 </span><span class="lineCov">        128 :                     if (JSON_UNLIKELY(indent_string.size() &lt; new_indent))</span>
<span class="lineNum">    8316 </span>            :                     {
<span class="lineNum">    8317 </span><span class="lineNoCov">          0 :                         indent_string.resize(indent_string.size() * 2, ' ');</span>
<span class="lineNum">    8318 </span>            :                     }
<span class="lineNum">    8319 </span>            : 
<span class="lineNum">    8320 </span>            :                     // first n-1 elements
<span class="lineNum">    8321 </span><span class="lineCov">        128 :                     auto i = val.m_value.object-&gt;cbegin();</span>
<span class="lineNum">    8322 </span><span class="lineCov">        293 :                     for (std::size_t cnt = 0; cnt &lt; val.m_value.object-&gt;size() - 1; ++cnt, ++i)</span>
<span class="lineNum">    8323 </span>            :                     {
<span class="lineNum">    8324 </span><span class="lineCov">        165 :                         o-&gt;write_characters(indent_string.c_str(), new_indent);</span>
<span class="lineNum">    8325 </span><span class="lineCov">        165 :                         o-&gt;write_character('\&quot;');</span>
<span class="lineNum">    8326 </span><span class="lineCov">        165 :                         dump_escaped(i-&gt;first, ensure_ascii);</span>
<span class="lineNum">    8327 </span><span class="lineCov">        165 :                         o-&gt;write_characters(&quot;\&quot;: &quot;, 3);</span>
<span class="lineNum">    8328 </span><span class="lineCov">        165 :                         dump(i-&gt;second, true, ensure_ascii, indent_step, new_indent);</span>
<span class="lineNum">    8329 </span><span class="lineCov">        165 :                         o-&gt;write_characters(&quot;,\n&quot;, 2);</span>
<span class="lineNum">    8330 </span>            :                     }
<span class="lineNum">    8331 </span>            : 
<span class="lineNum">    8332 </span>            :                     // last element
<span class="lineNum">    8333 </span><span class="lineCov">        128 :                     assert(i != val.m_value.object-&gt;cend());</span>
<span class="lineNum">    8334 </span><span class="lineCov">        128 :                     assert(std::next(i) == val.m_value.object-&gt;cend());</span>
<span class="lineNum">    8335 </span><span class="lineCov">        128 :                     o-&gt;write_characters(indent_string.c_str(), new_indent);</span>
<span class="lineNum">    8336 </span><span class="lineCov">        128 :                     o-&gt;write_character('\&quot;');</span>
<span class="lineNum">    8337 </span><span class="lineCov">        128 :                     dump_escaped(i-&gt;first, ensure_ascii);</span>
<span class="lineNum">    8338 </span><span class="lineCov">        128 :                     o-&gt;write_characters(&quot;\&quot;: &quot;, 3);</span>
<span class="lineNum">    8339 </span><span class="lineCov">        128 :                     dump(i-&gt;second, true, ensure_ascii, indent_step, new_indent);</span>
<span class="lineNum">    8340 </span>            : 
<span class="lineNum">    8341 </span><span class="lineCov">        128 :                     o-&gt;write_character('\n');</span>
<span class="lineNum">    8342 </span><span class="lineCov">        128 :                     o-&gt;write_characters(indent_string.c_str(), current_indent);</span>
<span class="lineNum">    8343 </span><span class="lineCov">        128 :                     o-&gt;write_character('}');</span>
<span class="lineNum">    8344 </span>            :                 }
<span class="lineNum">    8345 </span>            :                 else
<span class="lineNum">    8346 </span>            :                 {
<span class="lineNum">    8347 </span><span class="lineCov">          1 :                     o-&gt;write_character('{');</span>
<span class="lineNum">    8348 </span>            : 
<span class="lineNum">    8349 </span>            :                     // first n-1 elements
<span class="lineNum">    8350 </span><span class="lineCov">          1 :                     auto i = val.m_value.object-&gt;cbegin();</span>
<span class="lineNum">    8351 </span><span class="lineCov">          3 :                     for (std::size_t cnt = 0; cnt &lt; val.m_value.object-&gt;size() - 1; ++cnt, ++i)</span>
<span class="lineNum">    8352 </span>            :                     {
<span class="lineNum">    8353 </span><span class="lineCov">          2 :                         o-&gt;write_character('\&quot;');</span>
<span class="lineNum">    8354 </span><span class="lineCov">          2 :                         dump_escaped(i-&gt;first, ensure_ascii);</span>
<span class="lineNum">    8355 </span><span class="lineCov">          2 :                         o-&gt;write_characters(&quot;\&quot;:&quot;, 2);</span>
<span class="lineNum">    8356 </span><span class="lineCov">          2 :                         dump(i-&gt;second, false, ensure_ascii, indent_step, current_indent);</span>
<span class="lineNum">    8357 </span><span class="lineCov">          2 :                         o-&gt;write_character(',');</span>
<span class="lineNum">    8358 </span>            :                     }
<span class="lineNum">    8359 </span>            : 
<span class="lineNum">    8360 </span>            :                     // last element
<span class="lineNum">    8361 </span><span class="lineCov">          1 :                     assert(i != val.m_value.object-&gt;cend());</span>
<span class="lineNum">    8362 </span><span class="lineCov">          1 :                     assert(std::next(i) == val.m_value.object-&gt;cend());</span>
<span class="lineNum">    8363 </span><span class="lineCov">          1 :                     o-&gt;write_character('\&quot;');</span>
<span class="lineNum">    8364 </span><span class="lineCov">          1 :                     dump_escaped(i-&gt;first, ensure_ascii);</span>
<span class="lineNum">    8365 </span><span class="lineCov">          1 :                     o-&gt;write_characters(&quot;\&quot;:&quot;, 2);</span>
<span class="lineNum">    8366 </span><span class="lineCov">          1 :                     dump(i-&gt;second, false, ensure_ascii, indent_step, current_indent);</span>
<span class="lineNum">    8367 </span>            : 
<span class="lineNum">    8368 </span><span class="lineCov">          1 :                     o-&gt;write_character('}');</span>
<span class="lineNum">    8369 </span>            :                 }
<span class="lineNum">    8370 </span>            : 
<span class="lineNum">    8371 </span><span class="lineCov">        129 :                 return;</span>
<span class="lineNum">    8372 </span>            :             }
<span class="lineNum">    8373 </span>            : 
<span class="lineNum">    8374 </span>            :             case value_t::array:
<span class="lineNum">    8375 </span>            :             {
<span class="lineNum">    8376 </span><span class="lineCov">         54 :                 if (val.m_value.array-&gt;empty())</span>
<span class="lineNum">    8377 </span>            :                 {
<span class="lineNum">    8378 </span><span class="lineNoCov">          0 :                     o-&gt;write_characters(&quot;[]&quot;, 2);</span>
<span class="lineNum">    8379 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    8380 </span>            :                 }
<span class="lineNum">    8381 </span>            : 
<span class="lineNum">    8382 </span><span class="lineCov">         54 :                 if (pretty_print)</span>
<span class="lineNum">    8383 </span>            :                 {
<span class="lineNum">    8384 </span><span class="lineCov">         54 :                     o-&gt;write_characters(&quot;[\n&quot;, 2);</span>
<span class="lineNum">    8385 </span>            : 
<span class="lineNum">    8386 </span>            :                     // variable to hold indentation for recursive calls
<span class="lineNum">    8387 </span><span class="lineCov">         54 :                     const auto new_indent = current_indent + indent_step;</span>
<span class="lineNum">    8388 </span><span class="lineCov">         54 :                     if (JSON_UNLIKELY(indent_string.size() &lt; new_indent))</span>
<span class="lineNum">    8389 </span>            :                     {
<span class="lineNum">    8390 </span><span class="lineNoCov">          0 :                         indent_string.resize(indent_string.size() * 2, ' ');</span>
<span class="lineNum">    8391 </span>            :                     }
<span class="lineNum">    8392 </span>            : 
<span class="lineNum">    8393 </span>            :                     // first n-1 elements
<span class="lineNum">    8394 </span><span class="lineCov">        354 :                     for (auto i = val.m_value.array-&gt;cbegin();</span>
<span class="lineNum">    8395 </span><span class="lineCov">        236 :                             i != val.m_value.array-&gt;cend() - 1; ++i)</span>
<span class="lineNum">    8396 </span>            :                     {
<span class="lineNum">    8397 </span><span class="lineCov">         64 :                         o-&gt;write_characters(indent_string.c_str(), new_indent);</span>
<span class="lineNum">    8398 </span><span class="lineCov">         64 :                         dump(*i, true, ensure_ascii, indent_step, new_indent);</span>
<span class="lineNum">    8399 </span><span class="lineCov">         64 :                         o-&gt;write_characters(&quot;,\n&quot;, 2);</span>
<span class="lineNum">    8400 </span>            :                     }
<span class="lineNum">    8401 </span>            : 
<span class="lineNum">    8402 </span>            :                     // last element
<span class="lineNum">    8403 </span><span class="lineCov">         54 :                     assert(not val.m_value.array-&gt;empty());</span>
<span class="lineNum">    8404 </span><span class="lineCov">         54 :                     o-&gt;write_characters(indent_string.c_str(), new_indent);</span>
<span class="lineNum">    8405 </span><span class="lineCov">         54 :                     dump(val.m_value.array-&gt;back(), true, ensure_ascii, indent_step, new_indent);</span>
<span class="lineNum">    8406 </span>            : 
<span class="lineNum">    8407 </span><span class="lineCov">         54 :                     o-&gt;write_character('\n');</span>
<span class="lineNum">    8408 </span><span class="lineCov">         54 :                     o-&gt;write_characters(indent_string.c_str(), current_indent);</span>
<span class="lineNum">    8409 </span><span class="lineCov">         54 :                     o-&gt;write_character(']');</span>
<span class="lineNum">    8410 </span>            :                 }
<span class="lineNum">    8411 </span>            :                 else
<span class="lineNum">    8412 </span>            :                 {
<span class="lineNum">    8413 </span><span class="lineNoCov">          0 :                     o-&gt;write_character('[');</span>
<span class="lineNum">    8414 </span>            : 
<span class="lineNum">    8415 </span>            :                     // first n-1 elements
<span class="lineNum">    8416 </span><span class="lineNoCov">          0 :                     for (auto i = val.m_value.array-&gt;cbegin();</span>
<span class="lineNum">    8417 </span><span class="lineNoCov">          0 :                             i != val.m_value.array-&gt;cend() - 1; ++i)</span>
<span class="lineNum">    8418 </span>            :                     {
<span class="lineNum">    8419 </span><span class="lineNoCov">          0 :                         dump(*i, false, ensure_ascii, indent_step, current_indent);</span>
<span class="lineNum">    8420 </span><span class="lineNoCov">          0 :                         o-&gt;write_character(',');</span>
<span class="lineNum">    8421 </span>            :                     }
<span class="lineNum">    8422 </span>            : 
<span class="lineNum">    8423 </span>            :                     // last element
<span class="lineNum">    8424 </span><span class="lineNoCov">          0 :                     assert(not val.m_value.array-&gt;empty());</span>
<span class="lineNum">    8425 </span><span class="lineNoCov">          0 :                     dump(val.m_value.array-&gt;back(), false, ensure_ascii, indent_step, current_indent);</span>
<span class="lineNum">    8426 </span>            : 
<span class="lineNum">    8427 </span><span class="lineNoCov">          0 :                     o-&gt;write_character(']');</span>
<span class="lineNum">    8428 </span>            :                 }
<span class="lineNum">    8429 </span>            : 
<span class="lineNum">    8430 </span><span class="lineCov">         54 :                 return;</span>
<span class="lineNum">    8431 </span>            :             }
<span class="lineNum">    8432 </span>            : 
<span class="lineNum">    8433 </span>            :             case value_t::string:
<span class="lineNum">    8434 </span>            :             {
<span class="lineNum">    8435 </span><span class="lineCov">        165 :                 o-&gt;write_character('\&quot;');</span>
<span class="lineNum">    8436 </span><span class="lineCov">        165 :                 dump_escaped(*val.m_value.string, ensure_ascii);</span>
<span class="lineNum">    8437 </span><span class="lineCov">        165 :                 o-&gt;write_character('\&quot;');</span>
<span class="lineNum">    8438 </span><span class="lineCov">        165 :                 return;</span>
<span class="lineNum">    8439 </span>            :             }
<span class="lineNum">    8440 </span>            : 
<span class="lineNum">    8441 </span>            :             case value_t::boolean:
<span class="lineNum">    8442 </span>            :             {
<span class="lineNum">    8443 </span><span class="lineCov">         12 :                 if (val.m_value.boolean)</span>
<span class="lineNum">    8444 </span>            :                 {
<span class="lineNum">    8445 </span><span class="lineCov">         11 :                     o-&gt;write_characters(&quot;true&quot;, 4);</span>
<span class="lineNum">    8446 </span>            :                 }
<span class="lineNum">    8447 </span>            :                 else
<span class="lineNum">    8448 </span>            :                 {
<span class="lineNum">    8449 </span><span class="lineCov">          1 :                     o-&gt;write_characters(&quot;false&quot;, 5);</span>
<span class="lineNum">    8450 </span>            :                 }
<span class="lineNum">    8451 </span><span class="lineCov">         12 :                 return;</span>
<span class="lineNum">    8452 </span>            :             }
<span class="lineNum">    8453 </span>            : 
<span class="lineNum">    8454 </span>            :             case value_t::number_integer:
<span class="lineNum">    8455 </span>            :             {
<span class="lineNum">    8456 </span><span class="lineCov">         25 :                 dump_integer(val.m_value.number_integer);</span>
<span class="lineNum">    8457 </span><span class="lineCov">         25 :                 return;</span>
<span class="lineNum">    8458 </span>            :             }
<span class="lineNum">    8459 </span>            : 
<span class="lineNum">    8460 </span>            :             case value_t::number_unsigned:
<span class="lineNum">    8461 </span>            :             {
<span class="lineNum">    8462 </span><span class="lineCov">        141 :                 dump_integer(val.m_value.number_unsigned);</span>
<span class="lineNum">    8463 </span><span class="lineCov">        141 :                 return;</span>
<span class="lineNum">    8464 </span>            :             }
<span class="lineNum">    8465 </span>            : 
<span class="lineNum">    8466 </span>            :             case value_t::number_float:
<span class="lineNum">    8467 </span>            :             {
<span class="lineNum">    8468 </span><span class="lineCov">          2 :                 dump_float(val.m_value.number_float);</span>
<span class="lineNum">    8469 </span><span class="lineCov">          2 :                 return;</span>
<span class="lineNum">    8470 </span>            :             }
<span class="lineNum">    8471 </span>            : 
<span class="lineNum">    8472 </span>            :             case value_t::discarded:
<span class="lineNum">    8473 </span>            :             {
<span class="lineNum">    8474 </span><span class="lineNoCov">          0 :                 o-&gt;write_characters(&quot;&lt;discarded&gt;&quot;, 11);</span>
<span class="lineNum">    8475 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8476 </span>            :             }
<span class="lineNum">    8477 </span>            : 
<span class="lineNum">    8478 </span>            :             case value_t::null:
<span class="lineNum">    8479 </span>            :             {
<span class="lineNum">    8480 </span><span class="lineCov">          9 :                 o-&gt;write_characters(&quot;null&quot;, 4);</span>
<span class="lineNum">    8481 </span><span class="lineCov">          9 :                 return;</span>
<span class="lineNum">    8482 </span>            :             }
<span class="lineNum">    8483 </span>            :         }
<span class="lineNum">    8484 </span>            :     }
<span class="lineNum">    8485 </span>            : 
<span class="lineNum">    8486 </span>            :   private:
<span class="lineNum">    8487 </span>            :     /*!
<span class="lineNum">    8488 </span>            :     @brief dump escaped string
<span class="lineNum">    8489 </span>            : 
<span class="lineNum">    8490 </span>            :     Escape a string by replacing certain special characters by a sequence of an
<span class="lineNum">    8491 </span>            :     escape character (backslash) and another character and other control
<span class="lineNum">    8492 </span>            :     characters by a sequence of &quot;\u&quot; followed by a four-digit hex
<span class="lineNum">    8493 </span>            :     representation. The escaped string is written to output stream @a o.
<span class="lineNum">    8494 </span>            : 
<span class="lineNum">    8495 </span>            :     @param[in] s  the string to escape
<span class="lineNum">    8496 </span>            :     @param[in] ensure_ascii  whether to escape non-ASCII characters with
<span class="lineNum">    8497 </span>            :                              \uXXXX sequences
<span class="lineNum">    8498 </span>            : 
<a name="8499"><span class="lineNum">    8499 </span>            :     @complexity Linear in the length of string @a s.</a>
<span class="lineNum">    8500 </span>            :     */
<span class="lineNum">    8501 </span><span class="lineCov">        461 :     void dump_escaped(const string_t&amp; s, const bool ensure_ascii)</span>
<span class="lineNum">    8502 </span>            :     {
<span class="lineNum">    8503 </span>            :         uint32_t codepoint;
<span class="lineNum">    8504 </span><span class="lineCov">        461 :         uint8_t state = UTF8_ACCEPT;</span>
<span class="lineNum">    8505 </span><span class="lineCov">        461 :         std::size_t bytes = 0;  // number of bytes written to string_buffer</span>
<span class="lineNum">    8506 </span>            : 
<span class="lineNum">    8507 </span><span class="lineCov">       2914 :         for (std::size_t i = 0; i &lt; s.size(); ++i)</span>
<span class="lineNum">    8508 </span>            :         {
<span class="lineNum">    8509 </span><span class="lineCov">       2453 :             const auto byte = static_cast&lt;uint8_t&gt;(s[i]);</span>
<span class="lineNum">    8510 </span>            : 
<span class="lineNum">    8511 </span><span class="lineCov">       2453 :             switch (decode(state, codepoint, byte))</span>
<span class="lineNum">    8512 </span>            :             {
<span class="lineNum">    8513 </span>            :                 case UTF8_ACCEPT:  // decode found a new code point
<span class="lineNum">    8514 </span>            :                 {
<span class="lineNum">    8515 </span><span class="lineCov">       2453 :                     switch (codepoint)</span>
<span class="lineNum">    8516 </span>            :                     {
<span class="lineNum">    8517 </span>            :                         case 0x08: // backspace
<span class="lineNum">    8518 </span>            :                         {
<span class="lineNum">    8519 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8520 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = 'b';</span>
<span class="lineNum">    8521 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8522 </span>            :                         }
<span class="lineNum">    8523 </span>            : 
<span class="lineNum">    8524 </span>            :                         case 0x09: // horizontal tab
<span class="lineNum">    8525 </span>            :                         {
<span class="lineNum">    8526 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8527 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = 't';</span>
<span class="lineNum">    8528 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8529 </span>            :                         }
<span class="lineNum">    8530 </span>            : 
<span class="lineNum">    8531 </span>            :                         case 0x0A: // newline
<span class="lineNum">    8532 </span>            :                         {
<span class="lineNum">    8533 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8534 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = 'n';</span>
<span class="lineNum">    8535 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8536 </span>            :                         }
<span class="lineNum">    8537 </span>            : 
<span class="lineNum">    8538 </span>            :                         case 0x0C: // formfeed
<span class="lineNum">    8539 </span>            :                         {
<span class="lineNum">    8540 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8541 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = 'f';</span>
<span class="lineNum">    8542 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8543 </span>            :                         }
<span class="lineNum">    8544 </span>            : 
<span class="lineNum">    8545 </span>            :                         case 0x0D: // carriage return
<span class="lineNum">    8546 </span>            :                         {
<span class="lineNum">    8547 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8548 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = 'r';</span>
<span class="lineNum">    8549 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8550 </span>            :                         }
<span class="lineNum">    8551 </span>            : 
<span class="lineNum">    8552 </span>            :                         case 0x22: // quotation mark
<span class="lineNum">    8553 </span>            :                         {
<span class="lineNum">    8554 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8555 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\&quot;';</span>
<span class="lineNum">    8556 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8557 </span>            :                         }
<span class="lineNum">    8558 </span>            : 
<span class="lineNum">    8559 </span>            :                         case 0x5C: // reverse solidus
<span class="lineNum">    8560 </span>            :                         {
<span class="lineNum">    8561 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8562 </span><span class="lineNoCov">          0 :                             string_buffer[bytes++] = '\\';</span>
<span class="lineNum">    8563 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    8564 </span>            :                         }
<span class="lineNum">    8565 </span>            : 
<span class="lineNum">    8566 </span>            :                         default:
<span class="lineNum">    8567 </span>            :                         {
<span class="lineNum">    8568 </span>            :                             // escape control characters (0x00..0x1F) or, if
<span class="lineNum">    8569 </span>            :                             // ensure_ascii parameter is used, non-ASCII characters
<span class="lineNum">    8570 </span><span class="lineCov">       2453 :                             if ((codepoint &lt;= 0x1F) or (ensure_ascii and (codepoint &gt;= 0x7F)))</span>
<span class="lineNum">    8571 </span>            :                             {
<span class="lineNum">    8572 </span><span class="lineNoCov">          0 :                                 if (codepoint &lt;= 0xFFFF)</span>
<span class="lineNum">    8573 </span>            :                                 {
<span class="lineNum">    8574 </span><span class="lineNoCov">          0 :                                     std::snprintf(string_buffer.data() + bytes, 7, &quot;\\u%04x&quot;,</span>
<span class="lineNum">    8575 </span>            :                                                   static_cast&lt;uint16_t&gt;(codepoint));
<span class="lineNum">    8576 </span><span class="lineNoCov">          0 :                                     bytes += 6;</span>
<span class="lineNum">    8577 </span>            :                                 }
<span class="lineNum">    8578 </span>            :                                 else
<span class="lineNum">    8579 </span>            :                                 {
<span class="lineNum">    8580 </span><span class="lineNoCov">          0 :                                     std::snprintf(string_buffer.data() + bytes, 13, &quot;\\u%04x\\u%04x&quot;,</span>
<span class="lineNum">    8581 </span><span class="lineNoCov">          0 :                                                   static_cast&lt;uint16_t&gt;(0xD7C0 + (codepoint &gt;&gt; 10)),</span>
<span class="lineNum">    8582 </span><span class="lineNoCov">          0 :                                                   static_cast&lt;uint16_t&gt;(0xDC00 + (codepoint &amp; 0x3FF)));</span>
<span class="lineNum">    8583 </span><span class="lineNoCov">          0 :                                     bytes += 12;</span>
<span class="lineNum">    8584 </span>            :                                 }
<span class="lineNum">    8585 </span>            :                             }
<span class="lineNum">    8586 </span>            :                             else
<span class="lineNum">    8587 </span>            :                             {
<span class="lineNum">    8588 </span>            :                                 // copy byte to buffer (all previous bytes
<span class="lineNum">    8589 </span>            :                                 // been copied have in default case above)
<span class="lineNum">    8590 </span><span class="lineCov">       2453 :                                 string_buffer[bytes++] = s[i];</span>
<span class="lineNum">    8591 </span>            :                             }
<span class="lineNum">    8592 </span><span class="lineCov">       2453 :                             break;</span>
<span class="lineNum">    8593 </span>            :                         }
<span class="lineNum">    8594 </span>            :                     }
<span class="lineNum">    8595 </span>            : 
<span class="lineNum">    8596 </span>            :                     // write buffer and reset index; there must be 13 bytes
<span class="lineNum">    8597 </span>            :                     // left, as this is the maximal number of bytes to be
<span class="lineNum">    8598 </span>            :                     // written (&quot;\uxxxx\uxxxx\0&quot;) for one code point
<span class="lineNum">    8599 </span><span class="lineCov">       2453 :                     if (string_buffer.size() - bytes &lt; 13)</span>
<span class="lineNum">    8600 </span>            :                     {
<span class="lineNum">    8601 </span><span class="lineNoCov">          0 :                         o-&gt;write_characters(string_buffer.data(), bytes);</span>
<span class="lineNum">    8602 </span><span class="lineNoCov">          0 :                         bytes = 0;</span>
<span class="lineNum">    8603 </span>            :                     }
<span class="lineNum">    8604 </span><span class="lineCov">       2453 :                     break;</span>
<span class="lineNum">    8605 </span>            :                 }
<span class="lineNum">    8606 </span>            : 
<span class="lineNum">    8607 </span>            :                 case UTF8_REJECT:  // decode found invalid UTF-8 byte
<span class="lineNum">    8608 </span>            :                 {
<span class="lineNum">    8609 </span><span class="lineNoCov">          0 :                     std::stringstream ss;</span>
<span class="lineNum">    8610 </span><span class="lineNoCov">          0 :                     ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(byte);</span>
<span class="lineNum">    8611 </span><span class="lineNoCov">          0 :                     JSON_THROW(type_error::create(316, &quot;invalid UTF-8 byte at index &quot; + std::to_string(i) + &quot;: 0x&quot; + ss.str()));</span>
<span class="lineNum">    8612 </span>            :                 }
<span class="lineNum">    8613 </span>            : 
<span class="lineNum">    8614 </span>            :                 default:  // decode found yet incomplete multi-byte code point
<span class="lineNum">    8615 </span>            :                 {
<span class="lineNum">    8616 </span><span class="lineNoCov">          0 :                     if (not ensure_ascii)</span>
<span class="lineNum">    8617 </span>            :                     {
<span class="lineNum">    8618 </span>            :                         // code point will not be escaped - copy byte to buffer
<span class="lineNum">    8619 </span><span class="lineNoCov">          0 :                         string_buffer[bytes++] = s[i];</span>
<span class="lineNum">    8620 </span>            :                     }
<span class="lineNum">    8621 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    8622 </span>            :                 }
<span class="lineNum">    8623 </span>            :             }
<span class="lineNum">    8624 </span>            :         }
<span class="lineNum">    8625 </span>            : 
<span class="lineNum">    8626 </span><span class="lineCov">        461 :         if (JSON_LIKELY(state == UTF8_ACCEPT))</span>
<span class="lineNum">    8627 </span>            :         {
<span class="lineNum">    8628 </span>            :             // write buffer
<span class="lineNum">    8629 </span><span class="lineCov">        461 :             if (bytes &gt; 0)</span>
<span class="lineNum">    8630 </span>            :             {
<span class="lineNum">    8631 </span><span class="lineCov">        461 :                 o-&gt;write_characters(string_buffer.data(), bytes);</span>
<span class="lineNum">    8632 </span>            :             }
<span class="lineNum">    8633 </span>            :         }
<span class="lineNum">    8634 </span>            :         else
<span class="lineNum">    8635 </span>            :         {
<span class="lineNum">    8636 </span>            :             // we finish reading, but do not accept: string was incomplete
<span class="lineNum">    8637 </span><span class="lineNoCov">          0 :             std::stringstream ss;</span>
<span class="lineNum">    8638 </span><span class="lineNoCov">          0 :             ss &lt;&lt; std::setw(2) &lt;&lt; std::uppercase &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(static_cast&lt;uint8_t&gt;(s.back()));</span>
<span class="lineNum">    8639 </span><span class="lineNoCov">          0 :             JSON_THROW(type_error::create(316, &quot;incomplete UTF-8 string; last byte: 0x&quot; + ss.str()));</span>
<span class="lineNum">    8640 </span>            :         }
<span class="lineNum">    8641 </span><span class="lineCov">        461 :     }</span>
<span class="lineNum">    8642 </span>            : 
<span class="lineNum">    8643 </span>            :     /*!
<span class="lineNum">    8644 </span>            :     @brief dump an integer
<span class="lineNum">    8645 </span>            : 
<span class="lineNum">    8646 </span>            :     Dump a given integer to output stream @a o. Works internally with
<span class="lineNum">    8647 </span>            :     @a number_buffer.
<span class="lineNum">    8648 </span>            : 
<span class="lineNum">    8649 </span>            :     @param[in] x  integer number (signed or unsigned) to dump
<span class="lineNum">    8650 </span>            :     @tparam NumberType either @a number_integer_t or @a number_unsigned_t
<span class="lineNum">    8651 </span>            :     */
<span class="lineNum">    8652 </span>            :     template&lt;typename NumberType, detail::enable_if_t&lt;
<span class="lineNum">    8653 </span>            :                  std::is_same&lt;NumberType, number_unsigned_t&gt;::value or
<a name="8654"><span class="lineNum">    8654 </span>            :                  std::is_same&lt;NumberType, number_integer_t&gt;::value,</a>
<span class="lineNum">    8655 </span>            :                  int&gt; = 0&gt;
<span class="lineNum">    8656 </span><span class="lineCov">        166 :     void dump_integer(NumberType x)</span>
<span class="lineNum">    8657 </span>            :     {
<span class="lineNum">    8658 </span>            :         // special case for &quot;0&quot;
<span class="lineNum">    8659 </span><span class="lineCov">        166 :         if (x == 0)</span>
<span class="lineNum">    8660 </span>            :         {
<span class="lineNum">    8661 </span><span class="lineCov">         19 :             o-&gt;write_character('0');</span>
<span class="lineNum">    8662 </span><span class="lineCov">         19 :             return;</span>
<span class="lineNum">    8663 </span>            :         }
<span class="lineNum">    8664 </span>            : 
<span class="lineNum">    8665 </span><span class="lineCov">        147 :         const bool is_negative = (x &lt;= 0) and (x != 0);  // see issue #755</span>
<span class="lineNum">    8666 </span><span class="lineCov">        147 :         std::size_t i = 0;</span>
<span class="lineNum">    8667 </span>            : 
<span class="lineNum">    8668 </span><span class="lineCov">        785 :         while (x != 0)</span>
<span class="lineNum">    8669 </span>            :         {
<span class="lineNum">    8670 </span>            :             // spare 1 byte for '\0'
<span class="lineNum">    8671 </span><span class="lineCov">        319 :             assert(i &lt; number_buffer.size() - 1);</span>
<span class="lineNum">    8672 </span>            : 
<span class="lineNum">    8673 </span><span class="lineCov">        319 :             const auto digit = std::labs(static_cast&lt;long&gt;(x % 10));</span>
<span class="lineNum">    8674 </span><span class="lineCov">        319 :             number_buffer[i++] = static_cast&lt;char&gt;('0' + digit);</span>
<span class="lineNum">    8675 </span><span class="lineCov">        319 :             x /= 10;</span>
<span class="lineNum">    8676 </span>            :         }
<span class="lineNum">    8677 </span>            : 
<span class="lineNum">    8678 </span><span class="lineCov">        147 :         if (is_negative)</span>
<span class="lineNum">    8679 </span>            :         {
<span class="lineNum">    8680 </span>            :             // make sure there is capacity for the '-'
<span class="lineNum">    8681 </span><span class="lineCov">         23 :             assert(i &lt; number_buffer.size() - 2);</span>
<span class="lineNum">    8682 </span><span class="lineCov">         23 :             number_buffer[i++] = '-';</span>
<span class="lineNum">    8683 </span>            :         }
<span class="lineNum">    8684 </span>            : 
<span class="lineNum">    8685 </span><span class="lineCov">        147 :         std::reverse(number_buffer.begin(), number_buffer.begin() + i);</span>
<span class="lineNum">    8686 </span><span class="lineCov">        147 :         o-&gt;write_characters(number_buffer.data(), i);</span>
<span class="lineNum">    8687 </span>            :     }
<span class="lineNum">    8688 </span>            : 
<span class="lineNum">    8689 </span>            :     /*!
<span class="lineNum">    8690 </span>            :     @brief dump a floating-point number
<span class="lineNum">    8691 </span>            : 
<span class="lineNum">    8692 </span>            :     Dump a given floating-point number to output stream @a o. Works internally
<span class="lineNum">    8693 </span>            :     with @a number_buffer.
<span class="lineNum">    8694 </span>            : 
<a name="8695"><span class="lineNum">    8695 </span>            :     @param[in] x  floating-point number to dump</a>
<span class="lineNum">    8696 </span>            :     */
<span class="lineNum">    8697 </span><span class="lineCov">          2 :     void dump_float(number_float_t x)</span>
<span class="lineNum">    8698 </span>            :     {
<span class="lineNum">    8699 </span>            :         // NaN / inf
<span class="lineNum">    8700 </span><span class="lineCov">          2 :         if (not std::isfinite(x))</span>
<span class="lineNum">    8701 </span>            :         {
<span class="lineNum">    8702 </span><span class="lineNoCov">          0 :             o-&gt;write_characters(&quot;null&quot;, 4);</span>
<span class="lineNum">    8703 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    8704 </span>            :         }
<span class="lineNum">    8705 </span>            : 
<span class="lineNum">    8706 </span>            :         // If number_float_t is an IEEE-754 single or double precision number,
<span class="lineNum">    8707 </span>            :         // use the Grisu2 algorithm to produce short numbers which are
<span class="lineNum">    8708 </span>            :         // guaranteed to round-trip, using strtof and strtod, resp.
<span class="lineNum">    8709 </span>            :         //
<span class="lineNum">    8710 </span>            :         // NB: The test below works if &lt;long double&gt; == &lt;double&gt;.
<span class="lineNum">    8711 </span>            :         static constexpr bool is_ieee_single_or_double
<span class="lineNum">    8712 </span>            :             = (std::numeric_limits&lt;number_float_t&gt;::is_iec559 and std::numeric_limits&lt;number_float_t&gt;::digits == 24 and std::numeric_limits&lt;number_float_t&gt;::max_exponent == 128) or
<span class="lineNum">    8713 </span>            :               (std::numeric_limits&lt;number_float_t&gt;::is_iec559 and std::numeric_limits&lt;number_float_t&gt;::digits == 53 and std::numeric_limits&lt;number_float_t&gt;::max_exponent == 1024);
<span class="lineNum">    8714 </span>            : 
<span class="lineNum">    8715 </span><span class="lineCov">          2 :         dump_float(x, std::integral_constant&lt;bool, is_ieee_single_or_double&gt;());</span>
<a name="8716"><span class="lineNum">    8716 </span>            :     }</a>
<span class="lineNum">    8717 </span>            : 
<span class="lineNum">    8718 </span><span class="lineCov">          2 :     void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)</span>
<span class="lineNum">    8719 </span>            :     {
<span class="lineNum">    8720 </span><span class="lineCov">          2 :         char* begin = number_buffer.data();</span>
<span class="lineNum">    8721 </span><span class="lineCov">          2 :         char* end = ::rockets_nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);</span>
<span class="lineNum">    8722 </span>            : 
<span class="lineNum">    8723 </span><span class="lineCov">          2 :         o-&gt;write_characters(begin, static_cast&lt;size_t&gt;(end - begin));</span>
<span class="lineNum">    8724 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    8725 </span>            : 
<span class="lineNum">    8726 </span>            :     void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
<span class="lineNum">    8727 </span>            :     {
<span class="lineNum">    8728 </span>            :         // get number of digits for a float -&gt; text -&gt; float round-trip
<span class="lineNum">    8729 </span>            :         static constexpr auto d = std::numeric_limits&lt;number_float_t&gt;::max_digits10;
<span class="lineNum">    8730 </span>            : 
<span class="lineNum">    8731 </span>            :         // the actual conversion
<span class="lineNum">    8732 </span>            :         std::ptrdiff_t len = snprintf(number_buffer.data(), number_buffer.size(), &quot;%.*g&quot;, d, x);
<span class="lineNum">    8733 </span>            : 
<span class="lineNum">    8734 </span>            :         // negative value indicates an error
<span class="lineNum">    8735 </span>            :         assert(len &gt; 0);
<span class="lineNum">    8736 </span>            :         // check if buffer was large enough
<span class="lineNum">    8737 </span>            :         assert(static_cast&lt;std::size_t&gt;(len) &lt; number_buffer.size());
<span class="lineNum">    8738 </span>            : 
<span class="lineNum">    8739 </span>            :         // erase thousands separator
<span class="lineNum">    8740 </span>            :         if (thousands_sep != '\0')
<span class="lineNum">    8741 </span>            :         {
<span class="lineNum">    8742 </span>            :             const auto end = std::remove(number_buffer.begin(),
<span class="lineNum">    8743 </span>            :                                          number_buffer.begin() + len, thousands_sep);
<span class="lineNum">    8744 </span>            :             std::fill(end, number_buffer.end(), '\0');
<span class="lineNum">    8745 </span>            :             assert((end - number_buffer.begin()) &lt;= len);
<span class="lineNum">    8746 </span>            :             len = (end - number_buffer.begin());
<span class="lineNum">    8747 </span>            :         }
<span class="lineNum">    8748 </span>            : 
<span class="lineNum">    8749 </span>            :         // convert decimal point to '.'
<span class="lineNum">    8750 </span>            :         if (decimal_point != '\0' and decimal_point != '.')
<span class="lineNum">    8751 </span>            :         {
<span class="lineNum">    8752 </span>            :             const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
<span class="lineNum">    8753 </span>            :             if (dec_pos != number_buffer.end())
<span class="lineNum">    8754 </span>            :             {
<span class="lineNum">    8755 </span>            :                 *dec_pos = '.';
<span class="lineNum">    8756 </span>            :             }
<span class="lineNum">    8757 </span>            :         }
<span class="lineNum">    8758 </span>            : 
<span class="lineNum">    8759 </span>            :         o-&gt;write_characters(number_buffer.data(), static_cast&lt;std::size_t&gt;(len));
<span class="lineNum">    8760 </span>            : 
<span class="lineNum">    8761 </span>            :         // determine if need to append &quot;.0&quot;
<span class="lineNum">    8762 </span>            :         const bool value_is_int_like =
<span class="lineNum">    8763 </span>            :             std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
<span class="lineNum">    8764 </span>            :                          [](char c)
<span class="lineNum">    8765 </span>            :         {
<span class="lineNum">    8766 </span>            :             return (c == '.' or c == 'e');
<span class="lineNum">    8767 </span>            :         });
<span class="lineNum">    8768 </span>            : 
<span class="lineNum">    8769 </span>            :         if (value_is_int_like)
<span class="lineNum">    8770 </span>            :         {
<span class="lineNum">    8771 </span>            :             o-&gt;write_characters(&quot;.0&quot;, 2);
<span class="lineNum">    8772 </span>            :         }
<span class="lineNum">    8773 </span>            :     }
<span class="lineNum">    8774 </span>            : 
<span class="lineNum">    8775 </span>            :     /*!
<span class="lineNum">    8776 </span>            :     @brief check whether a string is UTF-8 encoded
<span class="lineNum">    8777 </span>            : 
<span class="lineNum">    8778 </span>            :     The function checks each byte of a string whether it is UTF-8 encoded. The
<span class="lineNum">    8779 </span>            :     result of the check is stored in the @a state parameter. The function must
<span class="lineNum">    8780 </span>            :     be called initially with state 0 (accept). State 1 means the string must
<span class="lineNum">    8781 </span>            :     be rejected, because the current byte is not allowed. If the string is
<span class="lineNum">    8782 </span>            :     completely processed, but the state is non-zero, the string ended
<span class="lineNum">    8783 </span>            :     prematurely; that is, the last byte indicated more bytes should have
<span class="lineNum">    8784 </span>            :     followed.
<span class="lineNum">    8785 </span>            : 
<span class="lineNum">    8786 </span>            :     @param[in,out] state  the state of the decoding
<span class="lineNum">    8787 </span>            :     @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
<span class="lineNum">    8788 </span>            :     @param[in] byte       next byte to decode
<span class="lineNum">    8789 </span>            :     @return               new state
<span class="lineNum">    8790 </span>            : 
<span class="lineNum">    8791 </span>            :     @note The function has been edited: a std::array is used.
<span class="lineNum">    8792 </span>            : 
<span class="lineNum">    8793 </span>            :     @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann &lt;bjoern@hoehrmann.de&gt;
<a name="8794"><span class="lineNum">    8794 </span>            :     @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/</a>
<span class="lineNum">    8795 </span>            :     */
<span class="lineNum">    8796 </span><span class="lineCov">       2453 :     static uint8_t decode(uint8_t&amp; state, uint32_t&amp; codep, const uint8_t byte) noexcept</span>
<span class="lineNum">    8797 </span>            :     {
<span class="lineNum">    8798 </span>            :         static const std::array&lt;uint8_t, 400&gt; utf8d =
<span class="lineNum">    8799 </span>            :         {
<span class="lineNum">    8800 </span>            :             {
<span class="lineNum">    8801 </span>            :                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
<span class="lineNum">    8802 </span>            :                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
<span class="lineNum">    8803 </span>            :                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
<span class="lineNum">    8804 </span>            :                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
<span class="lineNum">    8805 </span>            :                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
<span class="lineNum">    8806 </span>            :                 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
<span class="lineNum">    8807 </span>            :                 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
<span class="lineNum">    8808 </span>            :                 0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
<span class="lineNum">    8809 </span>            :                 0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
<span class="lineNum">    8810 </span>            :                 0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
<span class="lineNum">    8811 </span>            :                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
<span class="lineNum">    8812 </span>            :                 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
<span class="lineNum">    8813 </span>            :                 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
<span class="lineNum">    8814 </span>            :                 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
<span class="lineNum">    8815 </span>            :             }
<span class="lineNum">    8816 </span>            :         };
<span class="lineNum">    8817 </span>            : 
<span class="lineNum">    8818 </span><span class="lineCov">       2453 :         const uint8_t type = utf8d[byte];</span>
<span class="lineNum">    8819 </span>            : 
<span class="lineNum">    8820 </span><span class="lineCov">       4906 :         codep = (state != UTF8_ACCEPT)</span>
<span class="lineNum">    8821 </span><span class="lineNoCov">          0 :                 ? (byte &amp; 0x3fu) | (codep &lt;&lt; 6)</span>
<span class="lineNum">    8822 </span><span class="lineCov">       2453 :                 : static_cast&lt;uint32_t&gt;(0xff &gt;&gt; type) &amp; (byte);</span>
<span class="lineNum">    8823 </span>            : 
<span class="lineNum">    8824 </span><span class="lineCov">       2453 :         state = utf8d[256u + state * 16u + type];</span>
<span class="lineNum">    8825 </span><span class="lineCov">       2453 :         return state;</span>
<span class="lineNum">    8826 </span>            :     }
<span class="lineNum">    8827 </span>            : 
<span class="lineNum">    8828 </span>            :   private:
<span class="lineNum">    8829 </span>            :     /// the output of the serializer
<span class="lineNum">    8830 </span>            :     output_adapter_t&lt;char&gt; o = nullptr;
<span class="lineNum">    8831 </span>            : 
<span class="lineNum">    8832 </span>            :     /// a (hopefully) large enough character buffer
<span class="lineNum">    8833 </span>            :     std::array&lt;char, 64&gt; number_buffer{{}};
<span class="lineNum">    8834 </span>            : 
<span class="lineNum">    8835 </span>            :     /// the locale
<span class="lineNum">    8836 </span>            :     const std::lconv* loc = nullptr;
<span class="lineNum">    8837 </span>            :     /// the locale's thousand separator character
<span class="lineNum">    8838 </span>            :     const char thousands_sep = '\0';
<span class="lineNum">    8839 </span>            :     /// the locale's decimal point character
<span class="lineNum">    8840 </span>            :     const char decimal_point = '\0';
<span class="lineNum">    8841 </span>            : 
<span class="lineNum">    8842 </span>            :     /// string buffer
<span class="lineNum">    8843 </span>            :     std::array&lt;char, 512&gt; string_buffer{{}};
<span class="lineNum">    8844 </span>            : 
<span class="lineNum">    8845 </span>            :     /// the indentation character
<span class="lineNum">    8846 </span>            :     const char indent_char;
<span class="lineNum">    8847 </span>            :     /// the indentation string
<span class="lineNum">    8848 </span>            :     string_t indent_string;
<span class="lineNum">    8849 </span>            : };
<span class="lineNum">    8850 </span>            : }
<span class="lineNum">    8851 </span>            : }
<span class="lineNum">    8852 </span>            : 
<span class="lineNum">    8853 </span>            : // #include &lt;nlohmann/detail/json_ref.hpp&gt;
<span class="lineNum">    8854 </span>            : 
<span class="lineNum">    8855 </span>            : 
<span class="lineNum">    8856 </span>            : #include &lt;initializer_list&gt;
<span class="lineNum">    8857 </span>            : #include &lt;utility&gt;
<span class="lineNum">    8858 </span>            : 
<span class="lineNum">    8859 </span>            : namespace rockets_nlohmann
<span class="lineNum">    8860 </span>            : {
<span class="lineNum">    8861 </span>            : namespace detail
<a name="8862"><span class="lineNum">    8862 </span>            : {</a>
<span class="lineNum">    8863 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    8864 </span><span class="lineCov">        687 : class json_ref</span>
<span class="lineNum">    8865 </span>            : {
<span class="lineNum">    8866 </span>            :   public:
<a name="8867"><span class="lineNum">    8867 </span>            :     using value_type = BasicJsonType;</a>
<span class="lineNum">    8868 </span>            : 
<span class="lineNum">    8869 </span><span class="lineCov">         13 :     json_ref(value_type&amp;&amp; value)</span>
<span class="lineNum">    8870 </span><span class="lineCov">         13 :         : owned_value(std::move(value)), value_ref(&amp;owned_value), is_rvalue(true)</span>
<a name="8871"><span class="lineNum">    8871 </span><span class="lineCov">         13 :     {}</span></a>
<span class="lineNum">    8872 </span>            : 
<span class="lineNum">    8873 </span><span class="lineCov">         85 :     json_ref(const value_type&amp; value)</span>
<span class="lineNum">    8874 </span><span class="lineCov">         85 :         : value_ref(const_cast&lt;value_type*&gt;(&amp;value)), is_rvalue(false)</span>
<a name="8875"><span class="lineNum">    8875 </span><span class="lineCov">         85 :     {}</span></a>
<span class="lineNum">    8876 </span>            : 
<span class="lineNum">    8877 </span><span class="lineCov">        225 :     json_ref(std::initializer_list&lt;json_ref&gt; init)</span>
<span class="lineNum">    8878 </span><span class="lineCov">        225 :         : owned_value(init), value_ref(&amp;owned_value), is_rvalue(true)</span>
<span class="lineNum">    8879 </span><span class="lineCov">        225 :     {}</span>
<a name="8880"><span class="lineNum">    8880 </span>            : </a>
<span class="lineNum">    8881 </span>            :     template&lt;class... Args&gt;
<span class="lineNum">    8882 </span><span class="lineCov">        364 :     json_ref(Args&amp;&amp; ... args)</span>
<span class="lineNum">    8883 </span><span class="lineCov">        364 :         : owned_value(std::forward&lt;Args&gt;(args)...), value_ref(&amp;owned_value), is_rvalue(true)</span>
<span class="lineNum">    8884 </span><span class="lineCov">        364 :     {}</span>
<span class="lineNum">    8885 </span>            : 
<span class="lineNum">    8886 </span>            :     // class should be movable only
<span class="lineNum">    8887 </span>            :     json_ref(json_ref&amp;&amp;) = default;
<span class="lineNum">    8888 </span>            :     json_ref(const json_ref&amp;) = delete;
<a name="8889"><span class="lineNum">    8889 </span>            :     json_ref&amp; operator=(const json_ref&amp;) = delete;</a>
<span class="lineNum">    8890 </span>            : 
<span class="lineNum">    8891 </span><span class="lineCov">        687 :     value_type moved_or_copied() const</span>
<span class="lineNum">    8892 </span>            :     {
<span class="lineNum">    8893 </span><span class="lineCov">        687 :         if (is_rvalue)</span>
<span class="lineNum">    8894 </span>            :         {
<span class="lineNum">    8895 </span><span class="lineCov">        602 :             return std::move(*value_ref);</span>
<span class="lineNum">    8896 </span>            :         }
<span class="lineNum">    8897 </span><span class="lineCov">         85 :         return *value_ref;</span>
<a name="8898"><span class="lineNum">    8898 </span>            :     }</a>
<span class="lineNum">    8899 </span>            : 
<span class="lineNum">    8900 </span><span class="lineCov">        225 :     value_type const&amp; operator*() const</span>
<span class="lineNum">    8901 </span>            :     {
<span class="lineNum">    8902 </span><span class="lineCov">        225 :         return *static_cast&lt;value_type const*&gt;(value_ref);</span>
<a name="8903"><span class="lineNum">    8903 </span>            :     }</a>
<span class="lineNum">    8904 </span>            : 
<span class="lineNum">    8905 </span><span class="lineCov">        687 :     value_type const* operator-&gt;() const</span>
<span class="lineNum">    8906 </span>            :     {
<span class="lineNum">    8907 </span><span class="lineCov">        687 :         return static_cast&lt;value_type const*&gt;(value_ref);</span>
<span class="lineNum">    8908 </span>            :     }
<span class="lineNum">    8909 </span>            : 
<span class="lineNum">    8910 </span>            :   private:
<span class="lineNum">    8911 </span>            :     mutable value_type owned_value = nullptr;
<span class="lineNum">    8912 </span>            :     value_type* value_ref = nullptr;
<span class="lineNum">    8913 </span>            :     const bool is_rvalue;
<span class="lineNum">    8914 </span>            : };
<span class="lineNum">    8915 </span>            : }
<span class="lineNum">    8916 </span>            : }
<span class="lineNum">    8917 </span>            : 
<span class="lineNum">    8918 </span>            : // #include &lt;nlohmann/detail/json_pointer.hpp&gt;
<span class="lineNum">    8919 </span>            : 
<span class="lineNum">    8920 </span>            : 
<span class="lineNum">    8921 </span>            : #include &lt;cassert&gt; // assert
<span class="lineNum">    8922 </span>            : #include &lt;numeric&gt; // accumulate
<span class="lineNum">    8923 </span>            : #include &lt;string&gt; // string
<span class="lineNum">    8924 </span>            : #include &lt;vector&gt; // vector
<span class="lineNum">    8925 </span>            : 
<span class="lineNum">    8926 </span>            : // #include &lt;nlohmann/detail/macro_scope.hpp&gt;
<span class="lineNum">    8927 </span>            : 
<span class="lineNum">    8928 </span>            : // #include &lt;nlohmann/detail/exceptions.hpp&gt;
<span class="lineNum">    8929 </span>            : 
<span class="lineNum">    8930 </span>            : // #include &lt;nlohmann/detail/value_t.hpp&gt;
<span class="lineNum">    8931 </span>            : 
<span class="lineNum">    8932 </span>            : 
<span class="lineNum">    8933 </span>            : namespace rockets_nlohmann
<span class="lineNum">    8934 </span>            : {
<span class="lineNum">    8935 </span>            : template&lt;typename BasicJsonType&gt;
<span class="lineNum">    8936 </span>            : class json_pointer
<span class="lineNum">    8937 </span>            : {
<span class="lineNum">    8938 </span>            :     // allow basic_json to access private members
<span class="lineNum">    8939 </span>            :     NLOHMANN_BASIC_JSON_TPL_DECLARATION
<span class="lineNum">    8940 </span>            :     friend class basic_json;
<span class="lineNum">    8941 </span>            : 
<span class="lineNum">    8942 </span>            :   public:
<span class="lineNum">    8943 </span>            :     /*!
<span class="lineNum">    8944 </span>            :     @brief create JSON pointer
<span class="lineNum">    8945 </span>            : 
<span class="lineNum">    8946 </span>            :     Create a JSON pointer according to the syntax described in
<span class="lineNum">    8947 </span>            :     [Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).
<span class="lineNum">    8948 </span>            : 
<span class="lineNum">    8949 </span>            :     @param[in] s  string representing the JSON pointer; if omitted, the empty
<span class="lineNum">    8950 </span>            :                   string is assumed which references the whole JSON value
<span class="lineNum">    8951 </span>            : 
<span class="lineNum">    8952 </span>            :     @throw parse_error.107 if the given JSON pointer @a s is nonempty and does
<span class="lineNum">    8953 </span>            :                            not begin with a slash (`/`); see example below
<span class="lineNum">    8954 </span>            : 
<span class="lineNum">    8955 </span>            :     @throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
<span class="lineNum">    8956 </span>            :     not followed by `0` (representing `~`) or `1` (representing `/`); see
<span class="lineNum">    8957 </span>            :     example below
<span class="lineNum">    8958 </span>            : 
<span class="lineNum">    8959 </span>            :     @liveexample{The example shows the construction several valid JSON pointers
<span class="lineNum">    8960 </span>            :     as well as the exceptional behavior.,json_pointer}
<span class="lineNum">    8961 </span>            : 
<span class="lineNum">    8962 </span>            :     @since version 2.0.0
<span class="lineNum">    8963 </span>            :     */
<span class="lineNum">    8964 </span>            :     explicit json_pointer(const std::string&amp; s = &quot;&quot;)
<span class="lineNum">    8965 </span>            :         : reference_tokens(split(s))
<span class="lineNum">    8966 </span>            :     {}
<span class="lineNum">    8967 </span>            : 
<span class="lineNum">    8968 </span>            :     /*!
<span class="lineNum">    8969 </span>            :     @brief return a string representation of the JSON pointer
<span class="lineNum">    8970 </span>            : 
<span class="lineNum">    8971 </span>            :     @invariant For each JSON pointer `ptr`, it holds:
<span class="lineNum">    8972 </span>            :     @code {.cpp}
<span class="lineNum">    8973 </span>            :     ptr == json_pointer(ptr.to_string());
<span class="lineNum">    8974 </span>            :     @endcode
<span class="lineNum">    8975 </span>            : 
<span class="lineNum">    8976 </span>            :     @return a string representation of the JSON pointer
<span class="lineNum">    8977 </span>            : 
<span class="lineNum">    8978 </span>            :     @liveexample{The example shows the result of `to_string`.,
<span class="lineNum">    8979 </span>            :     json_pointer__to_string}
<span class="lineNum">    8980 </span>            : 
<span class="lineNum">    8981 </span>            :     @since version 2.0.0
<span class="lineNum">    8982 </span>            :     */
<span class="lineNum">    8983 </span>            :     std::string to_string() const noexcept
<span class="lineNum">    8984 </span>            :     {
<span class="lineNum">    8985 </span>            :         return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
<span class="lineNum">    8986 </span>            :                                std::string{},
<span class="lineNum">    8987 </span>            :                                [](const std::string &amp; a, const std::string &amp; b)
<span class="lineNum">    8988 </span>            :         {
<span class="lineNum">    8989 </span>            :             return a + &quot;/&quot; + escape(b);
<span class="lineNum">    8990 </span>            :         });
<span class="lineNum">    8991 </span>            :     }
<span class="lineNum">    8992 </span>            : 
<span class="lineNum">    8993 </span>            :     /// @copydoc to_string()
<span class="lineNum">    8994 </span>            :     operator std::string() const
<span class="lineNum">    8995 </span>            :     {
<span class="lineNum">    8996 </span>            :         return to_string();
<span class="lineNum">    8997 </span>            :     }
<span class="lineNum">    8998 </span>            : 
<span class="lineNum">    8999 </span>            :     /*!
<span class="lineNum">    9000 </span>            :     @param[in] s  reference token to be converted into an array index
<span class="lineNum">    9001 </span>            : 
<span class="lineNum">    9002 </span>            :     @return integer representation of @a s
<span class="lineNum">    9003 </span>            : 
<span class="lineNum">    9004 </span>            :     @throw out_of_range.404 if string @a s could not be converted to an integer
<span class="lineNum">    9005 </span>            :     */
<span class="lineNum">    9006 </span>            :     static int array_index(const std::string&amp; s)
<span class="lineNum">    9007 </span>            :     {
<span class="lineNum">    9008 </span>            :         std::size_t processed_chars = 0;
<span class="lineNum">    9009 </span>            :         const int res = std::stoi(s, &amp;processed_chars);
<span class="lineNum">    9010 </span>            : 
<span class="lineNum">    9011 </span>            :         // check if the string was completely read
<span class="lineNum">    9012 </span>            :         if (JSON_UNLIKELY(processed_chars != s.size()))
<span class="lineNum">    9013 </span>            :         {
<span class="lineNum">    9014 </span>            :             JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token '&quot; + s + &quot;'&quot;));
<span class="lineNum">    9015 </span>            :         }
<span class="lineNum">    9016 </span>            : 
<span class="lineNum">    9017 </span>            :         return res;
<span class="lineNum">    9018 </span>            :     }
<span class="lineNum">    9019 </span>            : 
<span class="lineNum">    9020 </span>            :   private:
<span class="lineNum">    9021 </span>            :     /*!
<span class="lineNum">    9022 </span>            :     @brief remove and return last reference pointer
<span class="lineNum">    9023 </span>            :     @throw out_of_range.405 if JSON pointer has no parent
<span class="lineNum">    9024 </span>            :     */
<span class="lineNum">    9025 </span>            :     std::string pop_back()
<span class="lineNum">    9026 </span>            :     {
<span class="lineNum">    9027 </span>            :         if (JSON_UNLIKELY(is_root()))
<span class="lineNum">    9028 </span>            :         {
<span class="lineNum">    9029 </span>            :             JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;));
<span class="lineNum">    9030 </span>            :         }
<span class="lineNum">    9031 </span>            : 
<span class="lineNum">    9032 </span>            :         auto last = reference_tokens.back();
<span class="lineNum">    9033 </span>            :         reference_tokens.pop_back();
<span class="lineNum">    9034 </span>            :         return last;
<span class="lineNum">    9035 </span>            :     }
<span class="lineNum">    9036 </span>            : 
<span class="lineNum">    9037 </span>            :     /// return whether pointer points to the root document
<span class="lineNum">    9038 </span>            :     bool is_root() const
<span class="lineNum">    9039 </span>            :     {
<span class="lineNum">    9040 </span>            :         return reference_tokens.empty();
<span class="lineNum">    9041 </span>            :     }
<span class="lineNum">    9042 </span>            : 
<span class="lineNum">    9043 </span>            :     json_pointer top() const
<span class="lineNum">    9044 </span>            :     {
<span class="lineNum">    9045 </span>            :         if (JSON_UNLIKELY(is_root()))
<span class="lineNum">    9046 </span>            :         {
<span class="lineNum">    9047 </span>            :             JSON_THROW(detail::out_of_range::create(405, &quot;JSON pointer has no parent&quot;));
<span class="lineNum">    9048 </span>            :         }
<span class="lineNum">    9049 </span>            : 
<span class="lineNum">    9050 </span>            :         json_pointer result = *this;
<span class="lineNum">    9051 </span>            :         result.reference_tokens = {reference_tokens[0]};
<span class="lineNum">    9052 </span>            :         return result;
<span class="lineNum">    9053 </span>            :     }
<span class="lineNum">    9054 </span>            : 
<span class="lineNum">    9055 </span>            :     /*!
<span class="lineNum">    9056 </span>            :     @brief create and return a reference to the pointed to value
<span class="lineNum">    9057 </span>            : 
<span class="lineNum">    9058 </span>            :     @complexity Linear in the number of reference tokens.
<span class="lineNum">    9059 </span>            : 
<span class="lineNum">    9060 </span>            :     @throw parse_error.109 if array index is not a number
<span class="lineNum">    9061 </span>            :     @throw type_error.313 if value cannot be unflattened
<span class="lineNum">    9062 </span>            :     */
<span class="lineNum">    9063 </span>            :     BasicJsonType&amp; get_and_create(BasicJsonType&amp; j) const
<span class="lineNum">    9064 </span>            :     {
<span class="lineNum">    9065 </span>            :         using size_type = typename BasicJsonType::size_type;
<span class="lineNum">    9066 </span>            :         auto result = &amp;j;
<span class="lineNum">    9067 </span>            : 
<span class="lineNum">    9068 </span>            :         // in case no reference tokens exist, return a reference to the JSON value
<span class="lineNum">    9069 </span>            :         // j which will be overwritten by a primitive value
<span class="lineNum">    9070 </span>            :         for (const auto&amp; reference_token : reference_tokens)
<span class="lineNum">    9071 </span>            :         {
<span class="lineNum">    9072 </span>            :             switch (result-&gt;m_type)
<span class="lineNum">    9073 </span>            :             {
<span class="lineNum">    9074 </span>            :                 case detail::value_t::null:
<span class="lineNum">    9075 </span>            :                 {
<span class="lineNum">    9076 </span>            :                     if (reference_token == &quot;0&quot;)
<span class="lineNum">    9077 </span>            :                     {
<span class="lineNum">    9078 </span>            :                         // start a new array if reference token is 0
<span class="lineNum">    9079 </span>            :                         result = &amp;result-&gt;operator[](0);
<span class="lineNum">    9080 </span>            :                     }
<span class="lineNum">    9081 </span>            :                     else
<span class="lineNum">    9082 </span>            :                     {
<span class="lineNum">    9083 </span>            :                         // start a new object otherwise
<span class="lineNum">    9084 </span>            :                         result = &amp;result-&gt;operator[](reference_token);
<span class="lineNum">    9085 </span>            :                     }
<span class="lineNum">    9086 </span>            :                     break;
<span class="lineNum">    9087 </span>            :                 }
<span class="lineNum">    9088 </span>            : 
<span class="lineNum">    9089 </span>            :                 case detail::value_t::object:
<span class="lineNum">    9090 </span>            :                 {
<span class="lineNum">    9091 </span>            :                     // create an entry in the object
<span class="lineNum">    9092 </span>            :                     result = &amp;result-&gt;operator[](reference_token);
<span class="lineNum">    9093 </span>            :                     break;
<span class="lineNum">    9094 </span>            :                 }
<span class="lineNum">    9095 </span>            : 
<span class="lineNum">    9096 </span>            :                 case detail::value_t::array:
<span class="lineNum">    9097 </span>            :                 {
<span class="lineNum">    9098 </span>            :                     // create an entry in the array
<span class="lineNum">    9099 </span>            :                     JSON_TRY
<span class="lineNum">    9100 </span>            :                     {
<span class="lineNum">    9101 </span>            :                         result = &amp;result-&gt;operator[](static_cast&lt;size_type&gt;(array_index(reference_token)));
<span class="lineNum">    9102 </span>            :                     }
<span class="lineNum">    9103 </span>            :                     JSON_CATCH(std::invalid_argument&amp;)
<span class="lineNum">    9104 </span>            :                     {
<span class="lineNum">    9105 </span>            :                         JSON_THROW(detail::parse_error::create(109, 0, &quot;array index '&quot; + reference_token + &quot;' is not a number&quot;));
<span class="lineNum">    9106 </span>            :                     }
<span class="lineNum">    9107 </span>            :                     break;
<span class="lineNum">    9108 </span>            :                 }
<span class="lineNum">    9109 </span>            : 
<span class="lineNum">    9110 </span>            :                 /*
<span class="lineNum">    9111 </span>            :                 The following code is only reached if there exists a reference
<span class="lineNum">    9112 </span>            :                 token _and_ the current value is primitive. In this case, we have
<span class="lineNum">    9113 </span>            :                 an error situation, because primitive values may only occur as
<span class="lineNum">    9114 </span>            :                 single value; that is, with an empty list of reference tokens.
<span class="lineNum">    9115 </span>            :                 */
<span class="lineNum">    9116 </span>            :                 default:
<span class="lineNum">    9117 </span>            :                     JSON_THROW(detail::type_error::create(313, &quot;invalid value to unflatten&quot;));
<span class="lineNum">    9118 </span>            :             }
<span class="lineNum">    9119 </span>            :         }
<span class="lineNum">    9120 </span>            : 
<span class="lineNum">    9121 </span>            :         return *result;
<span class="lineNum">    9122 </span>            :     }
<span class="lineNum">    9123 </span>            : 
<span class="lineNum">    9124 </span>            :     /*!
<span class="lineNum">    9125 </span>            :     @brief return a reference to the pointed to value
<span class="lineNum">    9126 </span>            : 
<span class="lineNum">    9127 </span>            :     @note This version does not throw if a value is not present, but tries to
<span class="lineNum">    9128 </span>            :           create nested values instead. For instance, calling this function
<span class="lineNum">    9129 </span>            :           with pointer `&quot;/this/that&quot;` on a null value is equivalent to calling
<span class="lineNum">    9130 </span>            :           `operator[](&quot;this&quot;).operator[](&quot;that&quot;)` on that value, effectively
<span class="lineNum">    9131 </span>            :           changing the null value to an object.
<span class="lineNum">    9132 </span>            : 
<span class="lineNum">    9133 </span>            :     @param[in] ptr  a JSON value
<span class="lineNum">    9134 </span>            : 
<span class="lineNum">    9135 </span>            :     @return reference to the JSON value pointed to by the JSON pointer
<span class="lineNum">    9136 </span>            : 
<span class="lineNum">    9137 </span>            :     @complexity Linear in the length of the JSON pointer.
<span class="lineNum">    9138 </span>            : 
<span class="lineNum">    9139 </span>            :     @throw parse_error.106   if an array index begins with '0'
<span class="lineNum">    9140 </span>            :     @throw parse_error.109   if an array index was not a number
<span class="lineNum">    9141 </span>            :     @throw out_of_range.404  if the JSON pointer can not be resolved
<span class="lineNum">    9142 </span>            :     */
<span class="lineNum">    9143 </span>            :     BasicJsonType&amp; get_unchecked(BasicJsonType* ptr) const
<span class="lineNum">    9144 </span>            :     {
<span class="lineNum">    9145 </span>            :         using size_type = typename BasicJsonType::size_type;
<span class="lineNum">    9146 </span>            :         for (const auto&amp; reference_token : reference_tokens)
<span class="lineNum">    9147 </span>            :         {
<span class="lineNum">    9148 </span>            :             // convert null values to arrays or objects before continuing
<span class="lineNum">    9149 </span>            :             if (ptr-&gt;m_type == detail::value_t::null)
<span class="lineNum">    9150 </span>            :             {
<span class="lineNum">    9151 </span>            :                 // check if reference token is a number
<span class="lineNum">    9152 </span>            :                 const bool nums =
<span class="lineNum">    9153 </span>            :                     std::all_of(reference_token.begin(), reference_token.end(),
<span class="lineNum">    9154 </span>            :                                 [](const char x)
<span class="lineNum">    9155 </span>            :                 {
<span class="lineNum">    9156 </span>            :                     return (x &gt;= '0' and x &lt;= '9');
<span class="lineNum">    9157 </span>            :                 });
<span class="lineNum">    9158 </span>            : 
<span class="lineNum">    9159 </span>            :                 // change value to array for numbers or &quot;-&quot; or to object otherwise
<span class="lineNum">    9160 </span>            :                 *ptr = (nums or reference_token == &quot;-&quot;)
<span class="lineNum">    9161 </span>            :                        ? detail::value_t::array
<span class="lineNum">    9162 </span>            :                        : detail::value_t::object;
<span class="lineNum">    9163 </span>            :             }
<span class="lineNum">    9164 </span>            : 
<span class="lineNum">    9165 </span>            :             switch (ptr-&gt;m_type)
<span class="lineNum">    9166 </span>            :             {
<span class="lineNum">    9167 </span>            :                 case detail::value_t::object:
<span class="lineNum">    9168 </span>            :                 {
<span class="lineNum">    9169 </span>            :                     // use unchecked object access
<span class="lineNum">    9170 </span>            :                     ptr = &amp;ptr-&gt;operator[](reference_token);
<span class="lineNum">    9171 </span>            :                     break;
<span class="lineNum">    9172 </span>            :                 }
<span class="lineNum">    9173 </span>            : 
<span class="lineNum">    9174 </span>            :                 case detail::value_t::array:
<span class="lineNum">    9175 </span>            :                 {
<span class="lineNum">    9176 </span>            :                     // error condition (cf. RFC 6901, Sect. 4)
<span class="lineNum">    9177 </span>            :                     if (JSON_UNLIKELY(reference_token.size() &gt; 1 and reference_token[0] == '0'))
<span class="lineNum">    9178 </span>            :                     {
<span class="lineNum">    9179 </span>            :                         JSON_THROW(detail::parse_error::create(106, 0,
<span class="lineNum">    9180 </span>            :                                                                &quot;array index '&quot; + reference_token +
<span class="lineNum">    9181 </span>            :                                                                &quot;' must not begin with '0'&quot;));
<span class="lineNum">    9182 </span>            :                     }
<span class="lineNum">    9183 </span>            : 
<span class="lineNum">    9184 </span>            :                     if (reference_token == &quot;-&quot;)
<span class="lineNum">    9185 </span>            :                     {
<span class="lineNum">    9186 </span>            :                         // explicitly treat &quot;-&quot; as index beyond the end
<span class="lineNum">    9187 </span>            :                         ptr = &amp;ptr-&gt;operator[](ptr-&gt;m_value.array-&gt;size());
<span class="lineNum">    9188 </span>            :                     }
<span class="lineNum">    9189 </span>            :                     else
<span class="lineNum">    9190 </span>            :                     {
<span class="lineNum">    9191 </span>            :                         // convert array index to number; unchecked access
<span class="lineNum">    9192 </span>            :                         JSON_TRY
<span class="lineNum">    9193 </span>            :                         {
<span class="lineNum">    9194 </span>            :                             ptr = &amp;ptr-&gt;operator[](
<span class="lineNum">    9195 </span>            :                                 static_cast&lt;size_type&gt;(array_index(reference_token)));
<span class="lineNum">    9196 </span>            :                         }
<span class="lineNum">    9197 </span>            :                         JSON_CATCH(std::invalid_argument&amp;)
<span class="lineNum">    9198 </span>            :                         {
<span class="lineNum">    9199 </span>            :                             JSON_THROW(detail::parse_error::create(109, 0, &quot;array index '&quot; + reference_token + &quot;' is not a number&quot;));
<span class="lineNum">    9200 </span>            :                         }
<span class="lineNum">    9201 </span>            :                     }
<span class="lineNum">    9202 </span>            :                     break;
<span class="lineNum">    9203 </span>            :                 }
<span class="lineNum">    9204 </span>            : 
<span class="lineNum">    9205 </span>            :                 default:
<span class="lineNum">    9206 </span>            :                     JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token '&quot; + reference_token + &quot;'&quot;));
<span class="lineNum">    9207 </span>            :             }
<span class="lineNum">    9208 </span>            :         }
<span class="lineNum">    9209 </span>            : 
<span class="lineNum">    9210 </span>            :         return *ptr;
<span class="lineNum">    9211 </span>            :     }
<span class="lineNum">    9212 </span>            : 
<span class="lineNum">    9213 </span>            :     /*!
<span class="lineNum">    9214 </span>            :     @throw parse_error.106   if an array index begins with '0'
<span class="lineNum">    9215 </span>            :     @throw parse_error.109   if an array index was not a number
<span class="lineNum">    9216 </span>            :     @throw out_of_range.402  if the array index '-' is used
<span class="lineNum">    9217 </span>            :     @throw out_of_range.404  if the JSON pointer can not be resolved
<span class="lineNum">    9218 </span>            :     */
<span class="lineNum">    9219 </span>            :     BasicJsonType&amp; get_checked(BasicJsonType* ptr) const
<span class="lineNum">    9220 </span>            :     {
<span class="lineNum">    9221 </span>            :         using size_type = typename BasicJsonType::size_type;
<span class="lineNum">    9222 </span>            :         for (const auto&amp; reference_token : reference_tokens)
<span class="lineNum">    9223 </span>            :         {
<span class="lineNum">    9224 </span>            :             switch (ptr-&gt;m_type)
<span class="lineNum">    9225 </span>            :             {
<span class="lineNum">    9226 </span>            :                 case detail::value_t::object:
<span class="lineNum">    9227 </span>            :                 {
<span class="lineNum">    9228 </span>            :                     // note: at performs range check
<span class="lineNum">    9229 </span>            :                     ptr = &amp;ptr-&gt;at(reference_token);
<span class="lineNum">    9230 </span>            :                     break;
<span class="lineNum">    9231 </span>            :                 }
<span class="lineNum">    9232 </span>            : 
<span class="lineNum">    9233 </span>            :                 case detail::value_t::array:
<span class="lineNum">    9234 </span>            :                 {
<span class="lineNum">    9235 </span>            :                     if (JSON_UNLIKELY(reference_token == &quot;-&quot;))
<span class="lineNum">    9236 </span>            :                     {
<span class="lineNum">    9237 </span>            :                         // &quot;-&quot; always fails the range check
<span class="lineNum">    9238 </span>            :                         JSON_THROW(detail::out_of_range::create(402,
<span class="lineNum">    9239 </span>            :                                                                 &quot;array index '-' (&quot; + std::to_string(ptr-&gt;m_value.array-&gt;size()) +
<span class="lineNum">    9240 </span>            :                                                                 &quot;) is out of range&quot;));
<span class="lineNum">    9241 </span>            :                     }
<span class="lineNum">    9242 </span>            : 
<span class="lineNum">    9243 </span>            :                     // error condition (cf. RFC 6901, Sect. 4)
<span class="lineNum">    9244 </span>            :                     if (JSON_UNLIKELY(reference_token.size() &gt; 1 and reference_token[0] == '0'))
<span class="lineNum">    9245 </span>            :                     {
<span class="lineNum">    9246 </span>            :                         JSON_THROW(detail::parse_error::create(106, 0,
<span class="lineNum">    9247 </span>            :                                                                &quot;array index '&quot; + reference_token +
<span class="lineNum">    9248 </span>            :                                                                &quot;' must not begin with '0'&quot;));
<span class="lineNum">    9249 </span>            :                     }
<span class="lineNum">    9250 </span>            : 
<span class="lineNum">    9251 </span>            :                     // note: at performs range check
<span class="lineNum">    9252 </span>            :                     JSON_TRY
<span class="lineNum">    9253 </span>            :                     {
<span class="lineNum">    9254 </span>            :                         ptr = &amp;ptr-&gt;at(static_cast&lt;size_type&gt;(array_index(reference_token)));
<span class="lineNum">    9255 </span>            :                     }
<span class="lineNum">    9256 </span>            :                     JSON_CATCH(std::invalid_argument&amp;)
<span class="lineNum">    9257 </span>            :                     {
<span class="lineNum">    9258 </span>            :                         JSON_THROW(detail::parse_error::create(109, 0, &quot;array index '&quot; + reference_token + &quot;' is not a number&quot;));
<span class="lineNum">    9259 </span>            :                     }
<span class="lineNum">    9260 </span>            :                     break;
<span class="lineNum">    9261 </span>            :                 }
<span class="lineNum">    9262 </span>            : 
<span class="lineNum">    9263 </span>            :                 default:
<span class="lineNum">    9264 </span>            :                     JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token '&quot; + reference_token + &quot;'&quot;));
<span class="lineNum">    9265 </span>            :             }
<span class="lineNum">    9266 </span>            :         }
<span class="lineNum">    9267 </span>            : 
<span class="lineNum">    9268 </span>            :         return *ptr;
<span class="lineNum">    9269 </span>            :     }
<span class="lineNum">    9270 </span>            : 
<span class="lineNum">    9271 </span>            :     /*!
<span class="lineNum">    9272 </span>            :     @brief return a const reference to the pointed to value
<span class="lineNum">    9273 </span>            : 
<span class="lineNum">    9274 </span>            :     @param[in] ptr  a JSON value
<span class="lineNum">    9275 </span>            : 
<span class="lineNum">    9276 </span>            :     @return const reference to the JSON value pointed to by the JSON
<span class="lineNum">    9277 </span>            :     pointer
<span class="lineNum">    9278 </span>            : 
<span class="lineNum">    9279 </span>            :     @throw parse_error.106   if an array index begins with '0'
<span class="lineNum">    9280 </span>            :     @throw parse_error.109   if an array index was not a number
<span class="lineNum">    9281 </span>            :     @throw out_of_range.402  if the array index '-' is used
<span class="lineNum">    9282 </span>            :     @throw out_of_range.404  if the JSON pointer can not be resolved
<span class="lineNum">    9283 </span>            :     */
<span class="lineNum">    9284 </span>            :     const BasicJsonType&amp; get_unchecked(const BasicJsonType* ptr) const
<span class="lineNum">    9285 </span>            :     {
<span class="lineNum">    9286 </span>            :         using size_type = typename BasicJsonType::size_type;
<span class="lineNum">    9287 </span>            :         for (const auto&amp; reference_token : reference_tokens)
<span class="lineNum">    9288 </span>            :         {
<span class="lineNum">    9289 </span>            :             switch (ptr-&gt;m_type)
<span class="lineNum">    9290 </span>            :             {
<span class="lineNum">    9291 </span>            :                 case detail::value_t::object:
<span class="lineNum">    9292 </span>            :                 {
<span class="lineNum">    9293 </span>            :                     // use unchecked object access
<span class="lineNum">    9294 </span>            :                     ptr = &amp;ptr-&gt;operator[](reference_token);
<span class="lineNum">    9295 </span>            :                     break;
<span class="lineNum">    9296 </span>            :                 }
<span class="lineNum">    9297 </span>            : 
<span class="lineNum">    9298 </span>            :                 case detail::value_t::array:
<span class="lineNum">    9299 </span>            :                 {
<span class="lineNum">    9300 </span>            :                     if (JSON_UNLIKELY(reference_token == &quot;-&quot;))
<span class="lineNum">    9301 </span>            :                     {
<span class="lineNum">    9302 </span>            :                         // &quot;-&quot; cannot be used for const access
<span class="lineNum">    9303 </span>            :                         JSON_THROW(detail::out_of_range::create(402,
<span class="lineNum">    9304 </span>            :                                                                 &quot;array index '-' (&quot; + std::to_string(ptr-&gt;m_value.array-&gt;size()) +
<span class="lineNum">    9305 </span>            :                                                                 &quot;) is out of range&quot;));
<span class="lineNum">    9306 </span>            :                     }
<span class="lineNum">    9307 </span>            : 
<span class="lineNum">    9308 </span>            :                     // error condition (cf. RFC 6901, Sect. 4)
<span class="lineNum">    9309 </span>            :                     if (JSON_UNLIKELY(reference_token.size() &gt; 1 and reference_token[0] == '0'))
<span class="lineNum">    9310 </span>            :                     {
<span class="lineNum">    9311 </span>            :                         JSON_THROW(detail::parse_error::create(106, 0,
<span class="lineNum">    9312 </span>            :                                                                &quot;array index '&quot; + reference_token +
<span class="lineNum">    9313 </span>            :                                                                &quot;' must not begin with '0'&quot;));
<span class="lineNum">    9314 </span>            :                     }
<span class="lineNum">    9315 </span>            : 
<span class="lineNum">    9316 </span>            :                     // use unchecked array access
<span class="lineNum">    9317 </span>            :                     JSON_TRY
<span class="lineNum">    9318 </span>            :                     {
<span class="lineNum">    9319 </span>            :                         ptr = &amp;ptr-&gt;operator[](
<span class="lineNum">    9320 </span>            :                             static_cast&lt;size_type&gt;(array_index(reference_token)));
<span class="lineNum">    9321 </span>            :                     }
<span class="lineNum">    9322 </span>            :                     JSON_CATCH(std::invalid_argument&amp;)
<span class="lineNum">    9323 </span>            :                     {
<span class="lineNum">    9324 </span>            :                         JSON_THROW(detail::parse_error::create(109, 0, &quot;array index '&quot; + reference_token + &quot;' is not a number&quot;));
<span class="lineNum">    9325 </span>            :                     }
<span class="lineNum">    9326 </span>            :                     break;
<span class="lineNum">    9327 </span>            :                 }
<span class="lineNum">    9328 </span>            : 
<span class="lineNum">    9329 </span>            :                 default:
<span class="lineNum">    9330 </span>            :                     JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token '&quot; + reference_token + &quot;'&quot;));
<span class="lineNum">    9331 </span>            :             }
<span class="lineNum">    9332 </span>            :         }
<span class="lineNum">    9333 </span>            : 
<span class="lineNum">    9334 </span>            :         return *ptr;
<span class="lineNum">    9335 </span>            :     }
<span class="lineNum">    9336 </span>            : 
<span class="lineNum">    9337 </span>            :     /*!
<span class="lineNum">    9338 </span>            :     @throw parse_error.106   if an array index begins with '0'
<span class="lineNum">    9339 </span>            :     @throw parse_error.109   if an array index was not a number
<span class="lineNum">    9340 </span>            :     @throw out_of_range.402  if the array index '-' is used
<span class="lineNum">    9341 </span>            :     @throw out_of_range.404  if the JSON pointer can not be resolved
<span class="lineNum">    9342 </span>            :     */
<span class="lineNum">    9343 </span>            :     const BasicJsonType&amp; get_checked(const BasicJsonType* ptr) const
<span class="lineNum">    9344 </span>            :     {
<span class="lineNum">    9345 </span>            :         using size_type = typename BasicJsonType::size_type;
<span class="lineNum">    9346 </span>            :         for (const auto&amp; reference_token : reference_tokens)
<span class="lineNum">    9347 </span>            :         {
<span class="lineNum">    9348 </span>            :             switch (ptr-&gt;m_type)
<span class="lineNum">    9349 </span>            :             {
<span class="lineNum">    9350 </span>            :                 case detail::value_t::object:
<span class="lineNum">    9351 </span>            :                 {
<span class="lineNum">    9352 </span>            :                     // note: at performs range check
<span class="lineNum">    9353 </span>            :                     ptr = &amp;ptr-&gt;at(reference_token);
<span class="lineNum">    9354 </span>            :                     break;
<span class="lineNum">    9355 </span>            :                 }
<span class="lineNum">    9356 </span>            : 
<span class="lineNum">    9357 </span>            :                 case detail::value_t::array:
<span class="lineNum">    9358 </span>            :                 {
<span class="lineNum">    9359 </span>            :                     if (JSON_UNLIKELY(reference_token == &quot;-&quot;))
<span class="lineNum">    9360 </span>            :                     {
<span class="lineNum">    9361 </span>            :                         // &quot;-&quot; always fails the range check
<span class="lineNum">    9362 </span>            :                         JSON_THROW(detail::out_of_range::create(402,
<span class="lineNum">    9363 </span>            :                                                                 &quot;array index '-' (&quot; + std::to_string(ptr-&gt;m_value.array-&gt;size()) +
<span class="lineNum">    9364 </span>            :                                                                 &quot;) is out of range&quot;));
<span class="lineNum">    9365 </span>            :                     }
<span class="lineNum">    9366 </span>            : 
<span class="lineNum">    9367 </span>            :                     // error condition (cf. RFC 6901, Sect. 4)
<span class="lineNum">    9368 </span>            :                     if (JSON_UNLIKELY(reference_token.size() &gt; 1 and reference_token[0] == '0'))
<span class="lineNum">    9369 </span>            :                     {
<span class="lineNum">    9370 </span>            :                         JSON_THROW(detail::parse_error::create(106, 0,
<span class="lineNum">    9371 </span>            :                                                                &quot;array index '&quot; + reference_token +
<span class="lineNum">    9372 </span>            :                                                                &quot;' must not begin with '0'&quot;));
<span class="lineNum">    9373 </span>            :                     }
<span class="lineNum">    9374 </span>            : 
<span class="lineNum">    9375 </span>            :                     // note: at performs range check
<span class="lineNum">    9376 </span>            :                     JSON_TRY
<span class="lineNum">    9377 </span>            :                     {
<span class="lineNum">    9378 </span>            :                         ptr = &amp;ptr-&gt;at(static_cast&lt;size_type&gt;(array_index(reference_token)));
<span class="lineNum">    9379 </span>            :                     }
<span class="lineNum">    9380 </span>            :                     JSON_CATCH(std::invalid_argument&amp;)
<span class="lineNum">    9381 </span>            :                     {
<span class="lineNum">    9382 </span>            :                         JSON_THROW(detail::parse_error::create(109, 0, &quot;array index '&quot; + reference_token + &quot;' is not a number&quot;));
<span class="lineNum">    9383 </span>            :                     }
<span class="lineNum">    9384 </span>            :                     break;
<span class="lineNum">    9385 </span>            :                 }
<span class="lineNum">    9386 </span>            : 
<span class="lineNum">    9387 </span>            :                 default:
<span class="lineNum">    9388 </span>            :                     JSON_THROW(detail::out_of_range::create(404, &quot;unresolved reference token '&quot; + reference_token + &quot;'&quot;));
<span class="lineNum">    9389 </span>            :             }
<span class="lineNum">    9390 </span>            :         }
<span class="lineNum">    9391 </span>            : 
<span class="lineNum">    9392 </span>            :         return *ptr;
<span class="lineNum">    9393 </span>            :     }
<span class="lineNum">    9394 </span>            : 
<span class="lineNum">    9395 </span>            :     /*!
<span class="lineNum">    9396 </span>            :     @brief split the string input to reference tokens
<span class="lineNum">    9397 </span>            : 
<span class="lineNum">    9398 </span>            :     @note This function is only called by the json_pointer constructor.
<span class="lineNum">    9399 </span>            :           All exceptions below are documented there.
<span class="lineNum">    9400 </span>            : 
<span class="lineNum">    9401 </span>            :     @throw parse_error.107  if the pointer is not empty or begins with '/'
<span class="lineNum">    9402 </span>            :     @throw parse_error.108  if character '~' is not followed by '0' or '1'
<span class="lineNum">    9403 </span>            :     */
<span class="lineNum">    9404 </span>            :     static std::vector&lt;std::string&gt; split(const std::string&amp; reference_string)
<span class="lineNum">    9405 </span>            :     {
<span class="lineNum">    9406 </span>            :         std::vector&lt;std::string&gt; result;
<span class="lineNum">    9407 </span>            : 
<span class="lineNum">    9408 </span>            :         // special case: empty reference string -&gt; no reference tokens
<span class="lineNum">    9409 </span>            :         if (reference_string.empty())
<span class="lineNum">    9410 </span>            :         {
<span class="lineNum">    9411 </span>            :             return result;
<span class="lineNum">    9412 </span>            :         }
<span class="lineNum">    9413 </span>            : 
<span class="lineNum">    9414 </span>            :         // check if nonempty reference string begins with slash
<span class="lineNum">    9415 </span>            :         if (JSON_UNLIKELY(reference_string[0] != '/'))
<span class="lineNum">    9416 </span>            :         {
<span class="lineNum">    9417 </span>            :             JSON_THROW(detail::parse_error::create(107, 1,
<span class="lineNum">    9418 </span>            :                                                    &quot;JSON pointer must be empty or begin with '/' - was: '&quot; +
<span class="lineNum">    9419 </span>            :                                                    reference_string + &quot;'&quot;));
<span class="lineNum">    9420 </span>            :         }
<span class="lineNum">    9421 </span>            : 
<span class="lineNum">    9422 </span>            :         // extract the reference tokens:
<span class="lineNum">    9423 </span>            :         // - slash: position of the last read slash (or end of string)
<span class="lineNum">    9424 </span>            :         // - start: position after the previous slash
<span class="lineNum">    9425 </span>            :         for (
<span class="lineNum">    9426 </span>            :             // search for the first slash after the first character
<span class="lineNum">    9427 </span>            :             std::size_t slash = reference_string.find_first_of('/', 1),
<span class="lineNum">    9428 </span>            :             // set the beginning of the first reference token
<span class="lineNum">    9429 </span>            :             start = 1;
<span class="lineNum">    9430 </span>            :             // we can stop if start == string::npos+1 = 0
<span class="lineNum">    9431 </span>            :             start != 0;
<span class="lineNum">    9432 </span>            :             // set the beginning of the next reference token
<span class="lineNum">    9433 </span>            :             // (will eventually be 0 if slash == std::string::npos)
<span class="lineNum">    9434 </span>            :             start = slash + 1,
<span class="lineNum">    9435 </span>            :             // find next slash
<span class="lineNum">    9436 </span>            :             slash = reference_string.find_first_of('/', start))
<span class="lineNum">    9437 </span>            :         {
<span class="lineNum">    9438 </span>            :             // use the text between the beginning of the reference token
<span class="lineNum">    9439 </span>            :             // (start) and the last slash (slash).
<span class="lineNum">    9440 </span>            :             auto reference_token = reference_string.substr(start, slash - start);
<span class="lineNum">    9441 </span>            : 
<span class="lineNum">    9442 </span>            :             // check reference tokens are properly escaped
<span class="lineNum">    9443 </span>            :             for (std::size_t pos = reference_token.find_first_of('~');
<span class="lineNum">    9444 </span>            :                     pos != std::string::npos;
<span class="lineNum">    9445 </span>            :                     pos = reference_token.find_first_of('~', pos + 1))
<span class="lineNum">    9446 </span>            :             {
<span class="lineNum">    9447 </span>            :                 assert(reference_token[pos] == '~');
<span class="lineNum">    9448 </span>            : 
<span class="lineNum">    9449 </span>            :                 // ~ must be followed by 0 or 1
<span class="lineNum">    9450 </span>            :                 if (JSON_UNLIKELY(pos == reference_token.size() - 1 or
<span class="lineNum">    9451 </span>            :                                   (reference_token[pos + 1] != '0' and
<span class="lineNum">    9452 </span>            :                                    reference_token[pos + 1] != '1')))
<span class="lineNum">    9453 </span>            :                 {
<span class="lineNum">    9454 </span>            :                     JSON_THROW(detail::parse_error::create(108, 0, &quot;escape character '~' must be followed with '0' or '1'&quot;));
<span class="lineNum">    9455 </span>            :                 }
<span class="lineNum">    9456 </span>            :             }
<span class="lineNum">    9457 </span>            : 
<span class="lineNum">    9458 </span>            :             // finally, store the reference token
<span class="lineNum">    9459 </span>            :             unescape(reference_token);
<span class="lineNum">    9460 </span>            :             result.push_back(reference_token);
<span class="lineNum">    9461 </span>            :         }
<span class="lineNum">    9462 </span>            : 
<span class="lineNum">    9463 </span>            :         return result;
<span class="lineNum">    9464 </span>            :     }
<span class="lineNum">    9465 </span>            : 
<span class="lineNum">    9466 </span>            :     /*!
<span class="lineNum">    9467 </span>            :     @brief replace all occurrences of a substring by another string
<span class="lineNum">    9468 </span>            : 
<span class="lineNum">    9469 </span>            :     @param[in,out] s  the string to manipulate; changed so that all
<span class="lineNum">    9470 </span>            :                    occurrences of @a f are replaced with @a t
<span class="lineNum">    9471 </span>            :     @param[in]     f  the substring to replace with @a t
<span class="lineNum">    9472 </span>            :     @param[in]     t  the string to replace @a f
<span class="lineNum">    9473 </span>            : 
<span class="lineNum">    9474 </span>            :     @pre The search string @a f must not be empty. **This precondition is
<span class="lineNum">    9475 </span>            :     enforced with an assertion.**
<span class="lineNum">    9476 </span>            : 
<span class="lineNum">    9477 </span>            :     @since version 2.0.0
<span class="lineNum">    9478 </span>            :     */
<span class="lineNum">    9479 </span>            :     static void replace_substring(std::string&amp; s, const std::string&amp; f,
<span class="lineNum">    9480 </span>            :                                   const std::string&amp; t)
<span class="lineNum">    9481 </span>            :     {
<span class="lineNum">    9482 </span>            :         assert(not f.empty());
<span class="lineNum">    9483 </span>            :         for (auto pos = s.find(f);                // find first occurrence of f
<span class="lineNum">    9484 </span>            :                 pos != std::string::npos;         // make sure f was found
<span class="lineNum">    9485 </span>            :                 s.replace(pos, f.size(), t),      // replace with t, and
<span class="lineNum">    9486 </span>            :                 pos = s.find(f, pos + t.size()))  // find next occurrence of f
<span class="lineNum">    9487 </span>            :         {}
<span class="lineNum">    9488 </span>            :     }
<span class="lineNum">    9489 </span>            : 
<span class="lineNum">    9490 </span>            :     /// escape &quot;~&quot;&quot; to &quot;~0&quot; and &quot;/&quot; to &quot;~1&quot;
<span class="lineNum">    9491 </span>            :     static std::string escape(std::string s)
<span class="lineNum">    9492 </span>            :     {
<span class="lineNum">    9493 </span>            :         replace_substring(s, &quot;~&quot;, &quot;~0&quot;);
<span class="lineNum">    9494 </span>            :         replace_substring(s, &quot;/&quot;, &quot;~1&quot;);
<span class="lineNum">    9495 </span>            :         return s;
<span class="lineNum">    9496 </span>            :     }
<span class="lineNum">    9497 </span>            : 
<span class="lineNum">    9498 </span>            :     /// unescape &quot;~1&quot; to tilde and &quot;~0&quot; to slash (order is important!)
<span class="lineNum">    9499 </span>            :     static void unescape(std::string&amp; s)
<span class="lineNum">    9500 </span>            :     {
<span class="lineNum">    9501 </span>            :         replace_substring(s, &quot;~1&quot;, &quot;/&quot;);
<span class="lineNum">    9502 </span>            :         replace_substring(s, &quot;~0&quot;, &quot;~&quot;);
<span class="lineNum">    9503 </span>            :     }
<span class="lineNum">    9504 </span>            : 
<span class="lineNum">    9505 </span>            :     /*!
<span class="lineNum">    9506 </span>            :     @param[in] reference_string  the reference string to the current value
<span class="lineNum">    9507 </span>            :     @param[in] value             the value to consider
<span class="lineNum">    9508 </span>            :     @param[in,out] result        the result object to insert values to
<span class="lineNum">    9509 </span>            : 
<span class="lineNum">    9510 </span>            :     @note Empty objects or arrays are flattened to `null`.
<span class="lineNum">    9511 </span>            :     */
<span class="lineNum">    9512 </span>            :     static void flatten(const std::string&amp; reference_string,
<span class="lineNum">    9513 </span>            :                         const BasicJsonType&amp; value,
<span class="lineNum">    9514 </span>            :                         BasicJsonType&amp; result)
<span class="lineNum">    9515 </span>            :     {
<span class="lineNum">    9516 </span>            :         switch (value.m_type)
<span class="lineNum">    9517 </span>            :         {
<span class="lineNum">    9518 </span>            :             case detail::value_t::array:
<span class="lineNum">    9519 </span>            :             {
<span class="lineNum">    9520 </span>            :                 if (value.m_value.array-&gt;empty())
<span class="lineNum">    9521 </span>            :                 {
<span class="lineNum">    9522 </span>            :                     // flatten empty array as null
<span class="lineNum">    9523 </span>            :                     result[reference_string] = nullptr;
<span class="lineNum">    9524 </span>            :                 }
<span class="lineNum">    9525 </span>            :                 else
<span class="lineNum">    9526 </span>            :                 {
<span class="lineNum">    9527 </span>            :                     // iterate array and use index as reference string
<span class="lineNum">    9528 </span>            :                     for (std::size_t i = 0; i &lt; value.m_value.array-&gt;size(); ++i)
<span class="lineNum">    9529 </span>            :                     {
<span class="lineNum">    9530 </span>            :                         flatten(reference_string + &quot;/&quot; + std::to_string(i),
<span class="lineNum">    9531 </span>            :                                 value.m_value.array-&gt;operator[](i), result);
<span class="lineNum">    9532 </span>            :                     }
<span class="lineNum">    9533 </span>            :                 }
<span class="lineNum">    9534 </span>            :                 break;
<span class="lineNum">    9535 </span>            :             }
<span class="lineNum">    9536 </span>            : 
<span class="lineNum">    9537 </span>            :             case detail::value_t::object:
<span class="lineNum">    9538 </span>            :             {
<span class="lineNum">    9539 </span>            :                 if (value.m_value.object-&gt;empty())
<span class="lineNum">    9540 </span>            :                 {
<span class="lineNum">    9541 </span>            :                     // flatten empty object as null
<span class="lineNum">    9542 </span>            :                     result[reference_string] = nullptr;
<span class="lineNum">    9543 </span>            :                 }
<span class="lineNum">    9544 </span>            :                 else
<span class="lineNum">    9545 </span>            :                 {
<span class="lineNum">    9546 </span>            :                     // iterate object and use keys as reference string
<span class="lineNum">    9547 </span>            :                     for (const auto&amp; element : *value.m_value.object)
<span class="lineNum">    9548 </span>            :                     {
<span class="lineNum">    9549 </span>            :                         flatten(reference_string + &quot;/&quot; + escape(element.first), element.second, result);
<span class="lineNum">    9550 </span>            :                     }
<span class="lineNum">    9551 </span>            :                 }
<span class="lineNum">    9552 </span>            :                 break;
<span class="lineNum">    9553 </span>            :             }
<span class="lineNum">    9554 </span>            : 
<span class="lineNum">    9555 </span>            :             default:
<span class="lineNum">    9556 </span>            :             {
<span class="lineNum">    9557 </span>            :                 // add primitive value with its reference string
<span class="lineNum">    9558 </span>            :                 result[reference_string] = value;
<span class="lineNum">    9559 </span>            :                 break;
<span class="lineNum">    9560 </span>            :             }
<span class="lineNum">    9561 </span>            :         }
<span class="lineNum">    9562 </span>            :     }
<span class="lineNum">    9563 </span>            : 
<span class="lineNum">    9564 </span>            :     /*!
<span class="lineNum">    9565 </span>            :     @param[in] value  flattened JSON
<span class="lineNum">    9566 </span>            : 
<span class="lineNum">    9567 </span>            :     @return unflattened JSON
<span class="lineNum">    9568 </span>            : 
<span class="lineNum">    9569 </span>            :     @throw parse_error.109 if array index is not a number
<span class="lineNum">    9570 </span>            :     @throw type_error.314  if value is not an object
<span class="lineNum">    9571 </span>            :     @throw type_error.315  if object values are not primitive
<span class="lineNum">    9572 </span>            :     @throw type_error.313  if value cannot be unflattened
<span class="lineNum">    9573 </span>            :     */
<span class="lineNum">    9574 </span>            :     static BasicJsonType
<span class="lineNum">    9575 </span>            :     unflatten(const BasicJsonType&amp; value)
<span class="lineNum">    9576 </span>            :     {
<span class="lineNum">    9577 </span>            :         if (JSON_UNLIKELY(not value.is_object()))
<span class="lineNum">    9578 </span>            :         {
<span class="lineNum">    9579 </span>            :             JSON_THROW(detail::type_error::create(314, &quot;only objects can be unflattened&quot;));
<span class="lineNum">    9580 </span>            :         }
<span class="lineNum">    9581 </span>            : 
<span class="lineNum">    9582 </span>            :         BasicJsonType result;
<span class="lineNum">    9583 </span>            : 
<span class="lineNum">    9584 </span>            :         // iterate the JSON object values
<span class="lineNum">    9585 </span>            :         for (const auto&amp; element : *value.m_value.object)
<span class="lineNum">    9586 </span>            :         {
<span class="lineNum">    9587 </span>            :             if (JSON_UNLIKELY(not element.second.is_primitive()))
<span class="lineNum">    9588 </span>            :             {
<span class="lineNum">    9589 </span>            :                 JSON_THROW(detail::type_error::create(315, &quot;values in object must be primitive&quot;));
<span class="lineNum">    9590 </span>            :             }
<span class="lineNum">    9591 </span>            : 
<span class="lineNum">    9592 </span>            :             // assign value to reference pointed to by JSON pointer; Note that if
<span class="lineNum">    9593 </span>            :             // the JSON pointer is &quot;&quot; (i.e., points to the whole value), function
<span class="lineNum">    9594 </span>            :             // get_and_create returns a reference to result itself. An assignment
<span class="lineNum">    9595 </span>            :             // will then create a primitive value.
<span class="lineNum">    9596 </span>            :             json_pointer(element.first).get_and_create(result) = element.second;
<span class="lineNum">    9597 </span>            :         }
<span class="lineNum">    9598 </span>            : 
<span class="lineNum">    9599 </span>            :         return result;
<span class="lineNum">    9600 </span>            :     }
<span class="lineNum">    9601 </span>            : 
<span class="lineNum">    9602 </span>            :     friend bool operator==(json_pointer const&amp; lhs,
<span class="lineNum">    9603 </span>            :                            json_pointer const&amp; rhs) noexcept
<span class="lineNum">    9604 </span>            :     {
<span class="lineNum">    9605 </span>            :         return (lhs.reference_tokens == rhs.reference_tokens);
<span class="lineNum">    9606 </span>            :     }
<span class="lineNum">    9607 </span>            : 
<span class="lineNum">    9608 </span>            :     friend bool operator!=(json_pointer const&amp; lhs,
<span class="lineNum">    9609 </span>            :                            json_pointer const&amp; rhs) noexcept
<span class="lineNum">    9610 </span>            :     {
<span class="lineNum">    9611 </span>            :         return not (lhs == rhs);
<span class="lineNum">    9612 </span>            :     }
<span class="lineNum">    9613 </span>            : 
<span class="lineNum">    9614 </span>            :     /// the reference tokens
<span class="lineNum">    9615 </span>            :     std::vector&lt;std::string&gt; reference_tokens;
<span class="lineNum">    9616 </span>            : };
<span class="lineNum">    9617 </span>            : }
<span class="lineNum">    9618 </span>            : 
<span class="lineNum">    9619 </span>            : // #include &lt;nlohmann/adl_serializer.hpp&gt;
<span class="lineNum">    9620 </span>            : 
<span class="lineNum">    9621 </span>            : 
<span class="lineNum">    9622 </span>            : #include &lt;utility&gt;
<span class="lineNum">    9623 </span>            : 
<span class="lineNum">    9624 </span>            : // #include &lt;nlohmann/detail/conversions/from_json.hpp&gt;
<span class="lineNum">    9625 </span>            : 
<span class="lineNum">    9626 </span>            : // #include &lt;nlohmann/detail/conversions/to_json.hpp&gt;
<span class="lineNum">    9627 </span>            : 
<span class="lineNum">    9628 </span>            : 
<span class="lineNum">    9629 </span>            : namespace rockets_nlohmann
<span class="lineNum">    9630 </span>            : {
<span class="lineNum">    9631 </span>            : template&lt;typename, typename&gt;
<span class="lineNum">    9632 </span>            : struct adl_serializer
<span class="lineNum">    9633 </span>            : {
<span class="lineNum">    9634 </span>            :     /*!
<span class="lineNum">    9635 </span>            :     @brief convert a JSON value to any value type
<span class="lineNum">    9636 </span>            : 
<span class="lineNum">    9637 </span>            :     This function is usually called by the `get()` function of the
<span class="lineNum">    9638 </span>            :     @ref basic_json class (either explicit or via conversion operators).
<span class="lineNum">    9639 </span>            : 
<span class="lineNum">    9640 </span>            :     @param[in] j         JSON value to read from
<span class="lineNum">    9641 </span>            :     @param[in,out] val  value to write to
<a name="9642"><span class="lineNum">    9642 </span>            :     */</a>
<span class="lineNum">    9643 </span>            :     template&lt;typename BasicJsonType, typename ValueType&gt;
<span class="lineNum">    9644 </span><span class="lineCov">        169 :     static void from_json(BasicJsonType&amp;&amp; j, ValueType&amp; val) noexcept(</span>
<span class="lineNum">    9645 </span>            :         noexcept(::rockets_nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val)))
<span class="lineNum">    9646 </span>            :     {
<span class="lineNum">    9647 </span><span class="lineCov">        169 :         ::rockets_nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val);</span>
<span class="lineNum">    9648 </span><span class="lineCov">        169 :     }</span>
<span class="lineNum">    9649 </span>            : 
<span class="lineNum">    9650 </span>            :     /*!
<span class="lineNum">    9651 </span>            :     @brief convert any value type to a JSON value
<span class="lineNum">    9652 </span>            : 
<span class="lineNum">    9653 </span>            :     This function is usually called by the constructors of the @ref basic_json
<span class="lineNum">    9654 </span>            :     class.
<span class="lineNum">    9655 </span>            : 
<span class="lineNum">    9656 </span>            :     @param[in,out] j  JSON value to write to
<span class="lineNum">    9657 </span>            :     @param[in] val     value to read from
<a name="9658"><span class="lineNum">    9658 </span>            :     */</a>
<span class="lineNum">    9659 </span>            :     template&lt;typename BasicJsonType, typename ValueType&gt;
<span class="lineNum">    9660 </span><span class="lineCov">        386 :     static void to_json(BasicJsonType&amp; j, ValueType&amp;&amp; val) noexcept(</span>
<span class="lineNum">    9661 </span>            :         noexcept(::rockets_nlohmann::to_json(j, std::forward&lt;ValueType&gt;(val))))
<span class="lineNum">    9662 </span>            :     {
<span class="lineNum">    9663 </span><span class="lineCov">        386 :         ::rockets_nlohmann::to_json(j, std::forward&lt;ValueType&gt;(val));</span>
<span class="lineNum">    9664 </span><span class="lineCov">        386 :     }</span>
<span class="lineNum">    9665 </span>            : };
<span class="lineNum">    9666 </span>            : }
<span class="lineNum">    9667 </span>            : 
<span class="lineNum">    9668 </span>            : 
<span class="lineNum">    9669 </span>            : /*!
<span class="lineNum">    9670 </span>            : @brief namespace for Niels Lohmann
<span class="lineNum">    9671 </span>            : @see https://github.com/nlohmann
<span class="lineNum">    9672 </span>            : @since version 1.0.0
<span class="lineNum">    9673 </span>            : */
<span class="lineNum">    9674 </span>            : namespace rockets_nlohmann
<span class="lineNum">    9675 </span>            : {
<span class="lineNum">    9676 </span>            : 
<span class="lineNum">    9677 </span>            : /*!
<span class="lineNum">    9678 </span>            : @brief a class to store JSON values
<span class="lineNum">    9679 </span>            : 
<span class="lineNum">    9680 </span>            : @tparam ObjectType type for JSON objects (`std::map` by default; will be used
<span class="lineNum">    9681 </span>            : in @ref object_t)
<span class="lineNum">    9682 </span>            : @tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
<span class="lineNum">    9683 </span>            : in @ref array_t)
<span class="lineNum">    9684 </span>            : @tparam StringType type for JSON strings and object keys (`std::string` by
<span class="lineNum">    9685 </span>            : default; will be used in @ref string_t)
<span class="lineNum">    9686 </span>            : @tparam BooleanType type for JSON booleans (`bool` by default; will be used
<span class="lineNum">    9687 </span>            : in @ref boolean_t)
<span class="lineNum">    9688 </span>            : @tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
<span class="lineNum">    9689 </span>            : default; will be used in @ref number_integer_t)
<span class="lineNum">    9690 </span>            : @tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
<span class="lineNum">    9691 </span>            : `uint64_t` by default; will be used in @ref number_unsigned_t)
<span class="lineNum">    9692 </span>            : @tparam NumberFloatType type for JSON floating-point numbers (`double` by
<span class="lineNum">    9693 </span>            : default; will be used in @ref number_float_t)
<span class="lineNum">    9694 </span>            : @tparam AllocatorType type of the allocator to use (`std::allocator` by
<span class="lineNum">    9695 </span>            : default)
<span class="lineNum">    9696 </span>            : @tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
<span class="lineNum">    9697 </span>            : and `from_json()` (@ref adl_serializer by default)
<span class="lineNum">    9698 </span>            : 
<span class="lineNum">    9699 </span>            : @requirement The class satisfies the following concept requirements:
<span class="lineNum">    9700 </span>            : - Basic
<span class="lineNum">    9701 </span>            :  - [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible):
<span class="lineNum">    9702 </span>            :    JSON values can be default constructed. The result will be a JSON null
<span class="lineNum">    9703 </span>            :    value.
<span class="lineNum">    9704 </span>            :  - [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible):
<span class="lineNum">    9705 </span>            :    A JSON value can be constructed from an rvalue argument.
<span class="lineNum">    9706 </span>            :  - [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible):
<span class="lineNum">    9707 </span>            :    A JSON value can be copy-constructed from an lvalue expression.
<span class="lineNum">    9708 </span>            :  - [MoveAssignable](http://en.cppreference.com/w/cpp/concept/MoveAssignable):
<span class="lineNum">    9709 </span>            :    A JSON value van be assigned from an rvalue argument.
<span class="lineNum">    9710 </span>            :  - [CopyAssignable](http://en.cppreference.com/w/cpp/concept/CopyAssignable):
<span class="lineNum">    9711 </span>            :    A JSON value can be copy-assigned from an lvalue expression.
<span class="lineNum">    9712 </span>            :  - [Destructible](http://en.cppreference.com/w/cpp/concept/Destructible):
<span class="lineNum">    9713 </span>            :    JSON values can be destructed.
<span class="lineNum">    9714 </span>            : - Layout
<span class="lineNum">    9715 </span>            :  - [StandardLayoutType](http://en.cppreference.com/w/cpp/concept/StandardLayoutType):
<span class="lineNum">    9716 </span>            :    JSON values have
<span class="lineNum">    9717 </span>            :    [standard layout](http://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
<span class="lineNum">    9718 </span>            :    All non-static data members are private and standard layout types, the
<span class="lineNum">    9719 </span>            :    class has no virtual functions or (virtual) base classes.
<span class="lineNum">    9720 </span>            : - Library-wide
<span class="lineNum">    9721 </span>            :  - [EqualityComparable](http://en.cppreference.com/w/cpp/concept/EqualityComparable):
<span class="lineNum">    9722 </span>            :    JSON values can be compared with `==`, see @ref
<span class="lineNum">    9723 </span>            :    operator==(const_reference,const_reference).
<span class="lineNum">    9724 </span>            :  - [LessThanComparable](http://en.cppreference.com/w/cpp/concept/LessThanComparable):
<span class="lineNum">    9725 </span>            :    JSON values can be compared with `&lt;`, see @ref
<span class="lineNum">    9726 </span>            :    operator&lt;(const_reference,const_reference).
<span class="lineNum">    9727 </span>            :  - [Swappable](http://en.cppreference.com/w/cpp/concept/Swappable):
<span class="lineNum">    9728 </span>            :    Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
<span class="lineNum">    9729 </span>            :    other compatible types, using unqualified function call @ref swap().
<span class="lineNum">    9730 </span>            :  - [NullablePointer](http://en.cppreference.com/w/cpp/concept/NullablePointer):
<span class="lineNum">    9731 </span>            :    JSON values can be compared against `std::nullptr_t` objects which are used
<span class="lineNum">    9732 </span>            :    to model the `null` value.
<span class="lineNum">    9733 </span>            : - Container
<span class="lineNum">    9734 </span>            :  - [Container](http://en.cppreference.com/w/cpp/concept/Container):
<span class="lineNum">    9735 </span>            :    JSON values can be used like STL containers and provide iterator access.
<span class="lineNum">    9736 </span>            :  - [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer);
<span class="lineNum">    9737 </span>            :    JSON values can be used like STL containers and provide reverse iterator
<span class="lineNum">    9738 </span>            :    access.
<span class="lineNum">    9739 </span>            : 
<span class="lineNum">    9740 </span>            : @invariant The member variables @a m_value and @a m_type have the following
<span class="lineNum">    9741 </span>            : relationship:
<span class="lineNum">    9742 </span>            : - If `m_type == value_t::object`, then `m_value.object != nullptr`.
<span class="lineNum">    9743 </span>            : - If `m_type == value_t::array`, then `m_value.array != nullptr`.
<span class="lineNum">    9744 </span>            : - If `m_type == value_t::string`, then `m_value.string != nullptr`.
<span class="lineNum">    9745 </span>            : The invariants are checked by member function assert_invariant().
<span class="lineNum">    9746 </span>            : 
<span class="lineNum">    9747 </span>            : @internal
<span class="lineNum">    9748 </span>            : @note ObjectType trick from http://stackoverflow.com/a/9860911
<span class="lineNum">    9749 </span>            : @endinternal
<span class="lineNum">    9750 </span>            : 
<span class="lineNum">    9751 </span>            : @see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
<span class="lineNum">    9752 </span>            : Format](http://rfc7159.net/rfc7159)
<span class="lineNum">    9753 </span>            : 
<span class="lineNum">    9754 </span>            : @since version 1.0.0
<span class="lineNum">    9755 </span>            : 
<span class="lineNum">    9756 </span>            : @nosubgrouping
<span class="lineNum">    9757 </span>            : */
<span class="lineNum">    9758 </span>            : NLOHMANN_BASIC_JSON_TPL_DECLARATION
<span class="lineNum">    9759 </span>            : class basic_json
<span class="lineNum">    9760 </span>            : {
<span class="lineNum">    9761 </span>            :   private:
<span class="lineNum">    9762 </span>            :     template&lt;detail::value_t&gt; friend struct detail::external_constructor;
<span class="lineNum">    9763 </span>            :     friend ::rockets_nlohmann::json_pointer&lt;basic_json&gt;;
<span class="lineNum">    9764 </span>            :     friend ::rockets_nlohmann::detail::parser&lt;basic_json&gt;;
<span class="lineNum">    9765 </span>            :     friend ::rockets_nlohmann::detail::serializer&lt;basic_json&gt;;
<span class="lineNum">    9766 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    9767 </span>            :     friend class ::rockets_nlohmann::detail::iter_impl;
<span class="lineNum">    9768 </span>            :     template&lt;typename BasicJsonType, typename CharType&gt;
<span class="lineNum">    9769 </span>            :     friend class ::rockets_nlohmann::detail::binary_writer;
<span class="lineNum">    9770 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    9771 </span>            :     friend class ::rockets_nlohmann::detail::binary_reader;
<span class="lineNum">    9772 </span>            : 
<span class="lineNum">    9773 </span>            :     /// workaround type for MSVC
<span class="lineNum">    9774 </span>            :     using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
<span class="lineNum">    9775 </span>            : 
<span class="lineNum">    9776 </span>            :     // convenience aliases for types residing in namespace detail;
<span class="lineNum">    9777 </span>            :     using lexer = ::rockets_nlohmann::detail::lexer&lt;basic_json&gt;;
<span class="lineNum">    9778 </span>            :     using parser = ::rockets_nlohmann::detail::parser&lt;basic_json&gt;;
<span class="lineNum">    9779 </span>            : 
<span class="lineNum">    9780 </span>            :     using primitive_iterator_t = ::rockets_nlohmann::detail::primitive_iterator_t;
<span class="lineNum">    9781 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    9782 </span>            :     using internal_iterator = ::rockets_nlohmann::detail::internal_iterator&lt;BasicJsonType&gt;;
<span class="lineNum">    9783 </span>            :     template&lt;typename BasicJsonType&gt;
<span class="lineNum">    9784 </span>            :     using iter_impl = ::rockets_nlohmann::detail::iter_impl&lt;BasicJsonType&gt;;
<span class="lineNum">    9785 </span>            :     template&lt;typename Iterator&gt;
<span class="lineNum">    9786 </span>            :     using iteration_proxy = ::rockets_nlohmann::detail::iteration_proxy&lt;Iterator&gt;;
<span class="lineNum">    9787 </span>            :     template&lt;typename Base&gt; using json_reverse_iterator = ::rockets_nlohmann::detail::json_reverse_iterator&lt;Base&gt;;
<span class="lineNum">    9788 </span>            : 
<span class="lineNum">    9789 </span>            :     template&lt;typename CharType&gt;
<span class="lineNum">    9790 </span>            :     using output_adapter_t = ::rockets_nlohmann::detail::output_adapter_t&lt;CharType&gt;;
<span class="lineNum">    9791 </span>            : 
<span class="lineNum">    9792 </span>            :     using binary_reader = ::rockets_nlohmann::detail::binary_reader&lt;basic_json&gt;;
<span class="lineNum">    9793 </span>            :     template&lt;typename CharType&gt; using binary_writer = ::rockets_nlohmann::detail::binary_writer&lt;basic_json, CharType&gt;;
<span class="lineNum">    9794 </span>            : 
<span class="lineNum">    9795 </span>            :     using serializer = ::rockets_nlohmann::detail::serializer&lt;basic_json&gt;;
<span class="lineNum">    9796 </span>            : 
<span class="lineNum">    9797 </span>            :   public:
<span class="lineNum">    9798 </span>            :     using value_t = detail::value_t;
<span class="lineNum">    9799 </span>            :     /// @copydoc nlohmann::json_pointer
<span class="lineNum">    9800 </span>            :     using json_pointer = ::rockets_nlohmann::json_pointer&lt;basic_json&gt;;
<span class="lineNum">    9801 </span>            :     template&lt;typename T, typename SFINAE&gt;
<span class="lineNum">    9802 </span>            :     using json_serializer = JSONSerializer&lt;T, SFINAE&gt;;
<span class="lineNum">    9803 </span>            :     /// helper type for initializer lists of basic_json values
<span class="lineNum">    9804 </span>            :     using initializer_list_t = std::initializer_list&lt;detail::json_ref&lt;basic_json&gt;&gt;;
<span class="lineNum">    9805 </span>            : 
<span class="lineNum">    9806 </span>            :     ////////////////
<span class="lineNum">    9807 </span>            :     // exceptions //
<span class="lineNum">    9808 </span>            :     ////////////////
<span class="lineNum">    9809 </span>            : 
<span class="lineNum">    9810 </span>            :     /// @name exceptions
<span class="lineNum">    9811 </span>            :     /// Classes to implement user-defined exceptions.
<span class="lineNum">    9812 </span>            :     /// @{
<span class="lineNum">    9813 </span>            : 
<span class="lineNum">    9814 </span>            :     /// @copydoc detail::exception
<span class="lineNum">    9815 </span>            :     using exception = detail::exception;
<span class="lineNum">    9816 </span>            :     /// @copydoc detail::parse_error
<span class="lineNum">    9817 </span>            :     using parse_error = detail::parse_error;
<span class="lineNum">    9818 </span>            :     /// @copydoc detail::invalid_iterator
<span class="lineNum">    9819 </span>            :     using invalid_iterator = detail::invalid_iterator;
<span class="lineNum">    9820 </span>            :     /// @copydoc detail::type_error
<span class="lineNum">    9821 </span>            :     using type_error = detail::type_error;
<span class="lineNum">    9822 </span>            :     /// @copydoc detail::out_of_range
<span class="lineNum">    9823 </span>            :     using out_of_range = detail::out_of_range;
<span class="lineNum">    9824 </span>            :     /// @copydoc detail::other_error
<span class="lineNum">    9825 </span>            :     using other_error = detail::other_error;
<span class="lineNum">    9826 </span>            : 
<span class="lineNum">    9827 </span>            :     /// @}
<span class="lineNum">    9828 </span>            : 
<span class="lineNum">    9829 </span>            : 
<span class="lineNum">    9830 </span>            :     /////////////////////
<span class="lineNum">    9831 </span>            :     // container types //
<span class="lineNum">    9832 </span>            :     /////////////////////
<span class="lineNum">    9833 </span>            : 
<span class="lineNum">    9834 </span>            :     /// @name container types
<span class="lineNum">    9835 </span>            :     /// The canonic container types to use @ref basic_json like any other STL
<span class="lineNum">    9836 </span>            :     /// container.
<span class="lineNum">    9837 </span>            :     /// @{
<span class="lineNum">    9838 </span>            : 
<span class="lineNum">    9839 </span>            :     /// the type of elements in a basic_json container
<span class="lineNum">    9840 </span>            :     using value_type = basic_json;
<span class="lineNum">    9841 </span>            : 
<span class="lineNum">    9842 </span>            :     /// the type of an element reference
<span class="lineNum">    9843 </span>            :     using reference = value_type&amp;;
<span class="lineNum">    9844 </span>            :     /// the type of an element const reference
<span class="lineNum">    9845 </span>            :     using const_reference = const value_type&amp;;
<span class="lineNum">    9846 </span>            : 
<span class="lineNum">    9847 </span>            :     /// a type to represent differences between iterators
<span class="lineNum">    9848 </span>            :     using difference_type = std::ptrdiff_t;
<span class="lineNum">    9849 </span>            :     /// a type to represent container sizes
<span class="lineNum">    9850 </span>            :     using size_type = std::size_t;
<span class="lineNum">    9851 </span>            : 
<span class="lineNum">    9852 </span>            :     /// the allocator type
<span class="lineNum">    9853 </span>            :     using allocator_type = AllocatorType&lt;basic_json&gt;;
<span class="lineNum">    9854 </span>            : 
<span class="lineNum">    9855 </span>            :     /// the type of an element pointer
<span class="lineNum">    9856 </span>            :     using pointer = typename std::allocator_traits&lt;allocator_type&gt;::pointer;
<span class="lineNum">    9857 </span>            :     /// the type of an element const pointer
<span class="lineNum">    9858 </span>            :     using const_pointer = typename std::allocator_traits&lt;allocator_type&gt;::const_pointer;
<span class="lineNum">    9859 </span>            : 
<span class="lineNum">    9860 </span>            :     /// an iterator for a basic_json container
<span class="lineNum">    9861 </span>            :     using iterator = iter_impl&lt;basic_json&gt;;
<span class="lineNum">    9862 </span>            :     /// a const iterator for a basic_json container
<span class="lineNum">    9863 </span>            :     using const_iterator = iter_impl&lt;const basic_json&gt;;
<span class="lineNum">    9864 </span>            :     /// a reverse iterator for a basic_json container
<span class="lineNum">    9865 </span>            :     using reverse_iterator = json_reverse_iterator&lt;typename basic_json::iterator&gt;;
<span class="lineNum">    9866 </span>            :     /// a const reverse iterator for a basic_json container
<span class="lineNum">    9867 </span>            :     using const_reverse_iterator = json_reverse_iterator&lt;typename basic_json::const_iterator&gt;;
<span class="lineNum">    9868 </span>            : 
<span class="lineNum">    9869 </span>            :     /// @}
<span class="lineNum">    9870 </span>            : 
<span class="lineNum">    9871 </span>            : 
<span class="lineNum">    9872 </span>            :     /*!
<span class="lineNum">    9873 </span>            :     @brief returns the allocator associated with the container
<span class="lineNum">    9874 </span>            :     */
<span class="lineNum">    9875 </span>            :     static allocator_type get_allocator()
<span class="lineNum">    9876 </span>            :     {
<span class="lineNum">    9877 </span>            :         return allocator_type();
<span class="lineNum">    9878 </span>            :     }
<span class="lineNum">    9879 </span>            : 
<span class="lineNum">    9880 </span>            :     /*!
<span class="lineNum">    9881 </span>            :     @brief returns version information on the library
<span class="lineNum">    9882 </span>            : 
<span class="lineNum">    9883 </span>            :     This function returns a JSON object with information about the library,
<span class="lineNum">    9884 </span>            :     including the version number and information on the platform and compiler.
<span class="lineNum">    9885 </span>            : 
<span class="lineNum">    9886 </span>            :     @return JSON object holding version information
<span class="lineNum">    9887 </span>            :     key         | description
<span class="lineNum">    9888 </span>            :     ----------- | ---------------
<span class="lineNum">    9889 </span>            :     `compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
<span class="lineNum">    9890 </span>            :     `copyright` | The copyright line for the library as string.
<span class="lineNum">    9891 </span>            :     `name`      | The name of the library as string.
<span class="lineNum">    9892 </span>            :     `platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
<span class="lineNum">    9893 </span>            :     `url`       | The URL of the project as string.
<span class="lineNum">    9894 </span>            :     `version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).
<span class="lineNum">    9895 </span>            : 
<span class="lineNum">    9896 </span>            :     @liveexample{The following code shows an example output of the `meta()`
<span class="lineNum">    9897 </span>            :     function.,meta}
<span class="lineNum">    9898 </span>            : 
<span class="lineNum">    9899 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">    9900 </span>            :     changes to any JSON value.
<span class="lineNum">    9901 </span>            : 
<span class="lineNum">    9902 </span>            :     @complexity Constant.
<span class="lineNum">    9903 </span>            : 
<span class="lineNum">    9904 </span>            :     @since 2.1.0
<span class="lineNum">    9905 </span>            :     */
<span class="lineNum">    9906 </span>            :     static basic_json meta()
<span class="lineNum">    9907 </span>            :     {
<span class="lineNum">    9908 </span>            :         basic_json result;
<span class="lineNum">    9909 </span>            : 
<span class="lineNum">    9910 </span>            :         result[&quot;copyright&quot;] = &quot;(C) 2013-2017 Niels Lohmann&quot;;
<span class="lineNum">    9911 </span>            :         result[&quot;name&quot;] = &quot;JSON for Modern C++&quot;;
<span class="lineNum">    9912 </span>            :         result[&quot;url&quot;] = &quot;https://github.com/nlohmann/json&quot;;
<span class="lineNum">    9913 </span>            :         result[&quot;version&quot;][&quot;string&quot;] =
<span class="lineNum">    9914 </span>            :             std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + &quot;.&quot; +
<span class="lineNum">    9915 </span>            :             std::to_string(NLOHMANN_JSON_VERSION_MINOR) + &quot;.&quot; +
<span class="lineNum">    9916 </span>            :             std::to_string(NLOHMANN_JSON_VERSION_PATCH);
<span class="lineNum">    9917 </span>            :         result[&quot;version&quot;][&quot;major&quot;] = NLOHMANN_JSON_VERSION_MAJOR;
<span class="lineNum">    9918 </span>            :         result[&quot;version&quot;][&quot;minor&quot;] = NLOHMANN_JSON_VERSION_MINOR;
<span class="lineNum">    9919 </span>            :         result[&quot;version&quot;][&quot;patch&quot;] = NLOHMANN_JSON_VERSION_PATCH;
<span class="lineNum">    9920 </span>            : 
<span class="lineNum">    9921 </span>            : #ifdef _WIN32
<span class="lineNum">    9922 </span>            :         result[&quot;platform&quot;] = &quot;win32&quot;;
<span class="lineNum">    9923 </span>            : #elif defined __linux__
<span class="lineNum">    9924 </span>            :         result[&quot;platform&quot;] = &quot;linux&quot;;
<span class="lineNum">    9925 </span>            : #elif defined __APPLE__
<span class="lineNum">    9926 </span>            :         result[&quot;platform&quot;] = &quot;apple&quot;;
<span class="lineNum">    9927 </span>            : #elif defined __unix__
<span class="lineNum">    9928 </span>            :         result[&quot;platform&quot;] = &quot;unix&quot;;
<span class="lineNum">    9929 </span>            : #else
<span class="lineNum">    9930 </span>            :         result[&quot;platform&quot;] = &quot;unknown&quot;;
<span class="lineNum">    9931 </span>            : #endif
<span class="lineNum">    9932 </span>            : 
<span class="lineNum">    9933 </span>            : #if defined(__ICC) || defined(__INTEL_COMPILER)
<span class="lineNum">    9934 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;icc&quot;}, {&quot;version&quot;, __INTEL_COMPILER}};
<span class="lineNum">    9935 </span>            : #elif defined(__clang__)
<span class="lineNum">    9936 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;clang&quot;}, {&quot;version&quot;, __clang_version__}};
<span class="lineNum">    9937 </span>            : #elif defined(__GNUC__) || defined(__GNUG__)
<span class="lineNum">    9938 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;gcc&quot;}, {&quot;version&quot;, std::to_string(__GNUC__) + &quot;.&quot; + std::to_string(__GNUC_MINOR__) + &quot;.&quot; + std::to_string(__GNUC_PATCHLEVEL__)}};
<span class="lineNum">    9939 </span>            : #elif defined(__HP_cc) || defined(__HP_aCC)
<span class="lineNum">    9940 </span>            :         result[&quot;compiler&quot;] = &quot;hp&quot;
<span class="lineNum">    9941 </span>            : #elif defined(__IBMCPP__)
<span class="lineNum">    9942 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;ilecpp&quot;}, {&quot;version&quot;, __IBMCPP__}};
<span class="lineNum">    9943 </span>            : #elif defined(_MSC_VER)
<span class="lineNum">    9944 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;msvc&quot;}, {&quot;version&quot;, _MSC_VER}};
<span class="lineNum">    9945 </span>            : #elif defined(__PGI)
<span class="lineNum">    9946 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;pgcpp&quot;}, {&quot;version&quot;, __PGI}};
<span class="lineNum">    9947 </span>            : #elif defined(__SUNPRO_CC)
<span class="lineNum">    9948 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;sunpro&quot;}, {&quot;version&quot;, __SUNPRO_CC}};
<span class="lineNum">    9949 </span>            : #else
<span class="lineNum">    9950 </span>            :         result[&quot;compiler&quot;] = {{&quot;family&quot;, &quot;unknown&quot;}, {&quot;version&quot;, &quot;unknown&quot;}};
<span class="lineNum">    9951 </span>            : #endif
<span class="lineNum">    9952 </span>            : 
<span class="lineNum">    9953 </span>            : #ifdef __cplusplus
<span class="lineNum">    9954 </span>            :         result[&quot;compiler&quot;][&quot;c++&quot;] = std::to_string(__cplusplus);
<span class="lineNum">    9955 </span>            : #else
<span class="lineNum">    9956 </span>            :         result[&quot;compiler&quot;][&quot;c++&quot;] = &quot;unknown&quot;;
<span class="lineNum">    9957 </span>            : #endif
<span class="lineNum">    9958 </span>            :         return result;
<span class="lineNum">    9959 </span>            :     }
<span class="lineNum">    9960 </span>            : 
<span class="lineNum">    9961 </span>            : 
<span class="lineNum">    9962 </span>            :     ///////////////////////////
<span class="lineNum">    9963 </span>            :     // JSON value data types //
<span class="lineNum">    9964 </span>            :     ///////////////////////////
<span class="lineNum">    9965 </span>            : 
<span class="lineNum">    9966 </span>            :     /// @name JSON value data types
<span class="lineNum">    9967 </span>            :     /// The data types to store a JSON value. These types are derived from
<span class="lineNum">    9968 </span>            :     /// the template arguments passed to class @ref basic_json.
<span class="lineNum">    9969 </span>            :     /// @{
<span class="lineNum">    9970 </span>            : 
<span class="lineNum">    9971 </span>            : #if defined(JSON_HAS_CPP_14)
<span class="lineNum">    9972 </span>            :     // Use transparent comparator if possible, combined with perfect forwarding
<span class="lineNum">    9973 </span>            :     // on find() and count() calls prevents unnecessary string construction.
<span class="lineNum">    9974 </span>            :     using object_comparator_t = std::less&lt;&gt;;
<span class="lineNum">    9975 </span>            : #else
<span class="lineNum">    9976 </span>            :     using object_comparator_t = std::less&lt;StringType&gt;;
<span class="lineNum">    9977 </span>            : #endif
<span class="lineNum">    9978 </span>            : 
<span class="lineNum">    9979 </span>            :     /*!
<span class="lineNum">    9980 </span>            :     @brief a type for an object
<span class="lineNum">    9981 </span>            : 
<span class="lineNum">    9982 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
<span class="lineNum">    9983 </span>            :     &gt; An object is an unordered collection of zero or more name/value pairs,
<span class="lineNum">    9984 </span>            :     &gt; where a name is a string and a value is a string, number, boolean, null,
<span class="lineNum">    9985 </span>            :     &gt; object, or array.
<span class="lineNum">    9986 </span>            : 
<span class="lineNum">    9987 </span>            :     To store objects in C++, a type is defined by the template parameters
<span class="lineNum">    9988 </span>            :     described below.
<span class="lineNum">    9989 </span>            : 
<span class="lineNum">    9990 </span>            :     @tparam ObjectType  the container to store objects (e.g., `std::map` or
<span class="lineNum">    9991 </span>            :     `std::unordered_map`)
<span class="lineNum">    9992 </span>            :     @tparam StringType the type of the keys or names (e.g., `std::string`).
<span class="lineNum">    9993 </span>            :     The comparison function `std::less&lt;StringType&gt;` is used to order elements
<span class="lineNum">    9994 </span>            :     inside the container.
<span class="lineNum">    9995 </span>            :     @tparam AllocatorType the allocator to use for objects (e.g.,
<span class="lineNum">    9996 </span>            :     `std::allocator`)
<span class="lineNum">    9997 </span>            : 
<span class="lineNum">    9998 </span>            :     #### Default type
<span class="lineNum">    9999 </span>            : 
<span class="lineNum">   10000 </span>            :     With the default values for @a ObjectType (`std::map`), @a StringType
<span class="lineNum">   10001 </span>            :     (`std::string`), and @a AllocatorType (`std::allocator`), the default
<span class="lineNum">   10002 </span>            :     value for @a object_t is:
<span class="lineNum">   10003 </span>            : 
<span class="lineNum">   10004 </span>            :     @code {.cpp}
<span class="lineNum">   10005 </span>            :     std::map&lt;
<span class="lineNum">   10006 </span>            :       std::string, // key_type
<span class="lineNum">   10007 </span>            :       basic_json, // value_type
<span class="lineNum">   10008 </span>            :       std::less&lt;std::string&gt;, // key_compare
<span class="lineNum">   10009 </span>            :       std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; // allocator_type
<span class="lineNum">   10010 </span>            :     &gt;
<span class="lineNum">   10011 </span>            :     @endcode
<span class="lineNum">   10012 </span>            : 
<span class="lineNum">   10013 </span>            :     #### Behavior
<span class="lineNum">   10014 </span>            : 
<span class="lineNum">   10015 </span>            :     The choice of @a object_t influences the behavior of the JSON class. With
<span class="lineNum">   10016 </span>            :     the default type, objects have the following behavior:
<span class="lineNum">   10017 </span>            : 
<span class="lineNum">   10018 </span>            :     - When all names are unique, objects will be interoperable in the sense
<span class="lineNum">   10019 </span>            :       that all software implementations receiving that object will agree on
<span class="lineNum">   10020 </span>            :       the name-value mappings.
<span class="lineNum">   10021 </span>            :     - When the names within an object are not unique, it is unspecified which
<span class="lineNum">   10022 </span>            :       one of the values for a given key will be chosen. For instance,
<span class="lineNum">   10023 </span>            :       `{&quot;key&quot;: 2, &quot;key&quot;: 1}` could be equal to either `{&quot;key&quot;: 1}` or
<span class="lineNum">   10024 </span>            :       `{&quot;key&quot;: 2}`.
<span class="lineNum">   10025 </span>            :     - Internally, name/value pairs are stored in lexicographical order of the
<span class="lineNum">   10026 </span>            :       names. Objects will also be serialized (see @ref dump) in this order.
<span class="lineNum">   10027 </span>            :       For instance, `{&quot;b&quot;: 1, &quot;a&quot;: 2}` and `{&quot;a&quot;: 2, &quot;b&quot;: 1}` will be stored
<span class="lineNum">   10028 </span>            :       and serialized as `{&quot;a&quot;: 2, &quot;b&quot;: 1}`.
<span class="lineNum">   10029 </span>            :     - When comparing objects, the order of the name/value pairs is irrelevant.
<span class="lineNum">   10030 </span>            :       This makes objects interoperable in the sense that they will not be
<span class="lineNum">   10031 </span>            :       affected by these differences. For instance, `{&quot;b&quot;: 1, &quot;a&quot;: 2}` and
<span class="lineNum">   10032 </span>            :       `{&quot;a&quot;: 2, &quot;b&quot;: 1}` will be treated as equal.
<span class="lineNum">   10033 </span>            : 
<span class="lineNum">   10034 </span>            :     #### Limits
<span class="lineNum">   10035 </span>            : 
<span class="lineNum">   10036 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) specifies:
<span class="lineNum">   10037 </span>            :     &gt; An implementation may set limits on the maximum depth of nesting.
<span class="lineNum">   10038 </span>            : 
<span class="lineNum">   10039 </span>            :     In this class, the object's limit of nesting is not explicitly constrained.
<span class="lineNum">   10040 </span>            :     However, a maximum depth of nesting may be introduced by the compiler or
<span class="lineNum">   10041 </span>            :     runtime environment. A theoretical limit can be queried by calling the
<span class="lineNum">   10042 </span>            :     @ref max_size function of a JSON object.
<span class="lineNum">   10043 </span>            : 
<span class="lineNum">   10044 </span>            :     #### Storage
<span class="lineNum">   10045 </span>            : 
<span class="lineNum">   10046 </span>            :     Objects are stored as pointers in a @ref basic_json type. That is, for any
<span class="lineNum">   10047 </span>            :     access to object values, a pointer of type `object_t*` must be
<span class="lineNum">   10048 </span>            :     dereferenced.
<span class="lineNum">   10049 </span>            : 
<span class="lineNum">   10050 </span>            :     @sa @ref array_t -- type for an array value
<span class="lineNum">   10051 </span>            : 
<span class="lineNum">   10052 </span>            :     @since version 1.0.0
<span class="lineNum">   10053 </span>            : 
<span class="lineNum">   10054 </span>            :     @note The order name/value pairs are added to the object is *not*
<span class="lineNum">   10055 </span>            :     preserved by the library. Therefore, iterating an object may return
<span class="lineNum">   10056 </span>            :     name/value pairs in a different order than they were originally stored. In
<span class="lineNum">   10057 </span>            :     fact, keys will be traversed in alphabetical order as `std::map` with
<span class="lineNum">   10058 </span>            :     `std::less` is used by default. Please note this behavior conforms to [RFC
<span class="lineNum">   10059 </span>            :     7159](http://rfc7159.net/rfc7159), because any order implements the
<span class="lineNum">   10060 </span>            :     specified &quot;unordered&quot; nature of JSON objects.
<span class="lineNum">   10061 </span>            :     */
<span class="lineNum">   10062 </span>            :     using object_t = ObjectType&lt;StringType,
<span class="lineNum">   10063 </span>            :           basic_json,
<span class="lineNum">   10064 </span>            :           object_comparator_t,
<span class="lineNum">   10065 </span>            :           AllocatorType&lt;std::pair&lt;const StringType,
<span class="lineNum">   10066 </span>            :           basic_json&gt;&gt;&gt;;
<span class="lineNum">   10067 </span>            : 
<span class="lineNum">   10068 </span>            :     /*!
<span class="lineNum">   10069 </span>            :     @brief a type for an array
<span class="lineNum">   10070 </span>            : 
<span class="lineNum">   10071 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
<span class="lineNum">   10072 </span>            :     &gt; An array is an ordered sequence of zero or more values.
<span class="lineNum">   10073 </span>            : 
<span class="lineNum">   10074 </span>            :     To store objects in C++, a type is defined by the template parameters
<span class="lineNum">   10075 </span>            :     explained below.
<span class="lineNum">   10076 </span>            : 
<span class="lineNum">   10077 </span>            :     @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
<span class="lineNum">   10078 </span>            :     `std::list`)
<span class="lineNum">   10079 </span>            :     @tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)
<span class="lineNum">   10080 </span>            : 
<span class="lineNum">   10081 </span>            :     #### Default type
<span class="lineNum">   10082 </span>            : 
<span class="lineNum">   10083 </span>            :     With the default values for @a ArrayType (`std::vector`) and @a
<span class="lineNum">   10084 </span>            :     AllocatorType (`std::allocator`), the default value for @a array_t is:
<span class="lineNum">   10085 </span>            : 
<span class="lineNum">   10086 </span>            :     @code {.cpp}
<span class="lineNum">   10087 </span>            :     std::vector&lt;
<span class="lineNum">   10088 </span>            :       basic_json, // value_type
<span class="lineNum">   10089 </span>            :       std::allocator&lt;basic_json&gt; // allocator_type
<span class="lineNum">   10090 </span>            :     &gt;
<span class="lineNum">   10091 </span>            :     @endcode
<span class="lineNum">   10092 </span>            : 
<span class="lineNum">   10093 </span>            :     #### Limits
<span class="lineNum">   10094 </span>            : 
<span class="lineNum">   10095 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) specifies:
<span class="lineNum">   10096 </span>            :     &gt; An implementation may set limits on the maximum depth of nesting.
<span class="lineNum">   10097 </span>            : 
<span class="lineNum">   10098 </span>            :     In this class, the array's limit of nesting is not explicitly constrained.
<span class="lineNum">   10099 </span>            :     However, a maximum depth of nesting may be introduced by the compiler or
<span class="lineNum">   10100 </span>            :     runtime environment. A theoretical limit can be queried by calling the
<span class="lineNum">   10101 </span>            :     @ref max_size function of a JSON array.
<span class="lineNum">   10102 </span>            : 
<span class="lineNum">   10103 </span>            :     #### Storage
<span class="lineNum">   10104 </span>            : 
<span class="lineNum">   10105 </span>            :     Arrays are stored as pointers in a @ref basic_json type. That is, for any
<span class="lineNum">   10106 </span>            :     access to array values, a pointer of type `array_t*` must be dereferenced.
<span class="lineNum">   10107 </span>            : 
<span class="lineNum">   10108 </span>            :     @sa @ref object_t -- type for an object value
<span class="lineNum">   10109 </span>            : 
<span class="lineNum">   10110 </span>            :     @since version 1.0.0
<span class="lineNum">   10111 </span>            :     */
<span class="lineNum">   10112 </span>            :     using array_t = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;
<span class="lineNum">   10113 </span>            : 
<span class="lineNum">   10114 </span>            :     /*!
<span class="lineNum">   10115 </span>            :     @brief a type for a string
<span class="lineNum">   10116 </span>            : 
<span class="lineNum">   10117 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
<span class="lineNum">   10118 </span>            :     &gt; A string is a sequence of zero or more Unicode characters.
<span class="lineNum">   10119 </span>            : 
<span class="lineNum">   10120 </span>            :     To store objects in C++, a type is defined by the template parameter
<span class="lineNum">   10121 </span>            :     described below. Unicode values are split by the JSON class into
<span class="lineNum">   10122 </span>            :     byte-sized characters during deserialization.
<span class="lineNum">   10123 </span>            : 
<span class="lineNum">   10124 </span>            :     @tparam StringType  the container to store strings (e.g., `std::string`).
<span class="lineNum">   10125 </span>            :     Note this container is used for keys/names in objects, see @ref object_t.
<span class="lineNum">   10126 </span>            : 
<span class="lineNum">   10127 </span>            :     #### Default type
<span class="lineNum">   10128 </span>            : 
<span class="lineNum">   10129 </span>            :     With the default values for @a StringType (`std::string`), the default
<span class="lineNum">   10130 </span>            :     value for @a string_t is:
<span class="lineNum">   10131 </span>            : 
<span class="lineNum">   10132 </span>            :     @code {.cpp}
<span class="lineNum">   10133 </span>            :     std::string
<span class="lineNum">   10134 </span>            :     @endcode
<span class="lineNum">   10135 </span>            : 
<span class="lineNum">   10136 </span>            :     #### Encoding
<span class="lineNum">   10137 </span>            : 
<span class="lineNum">   10138 </span>            :     Strings are stored in UTF-8 encoding. Therefore, functions like
<span class="lineNum">   10139 </span>            :     `std::string::size()` or `std::string::length()` return the number of
<span class="lineNum">   10140 </span>            :     bytes in the string rather than the number of characters or glyphs.
<span class="lineNum">   10141 </span>            : 
<span class="lineNum">   10142 </span>            :     #### String comparison
<span class="lineNum">   10143 </span>            : 
<span class="lineNum">   10144 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) states:
<span class="lineNum">   10145 </span>            :     &gt; Software implementations are typically required to test names of object
<span class="lineNum">   10146 </span>            :     &gt; members for equality. Implementations that transform the textual
<span class="lineNum">   10147 </span>            :     &gt; representation into sequences of Unicode code units and then perform the
<span class="lineNum">   10148 </span>            :     &gt; comparison numerically, code unit by code unit, are interoperable in the
<span class="lineNum">   10149 </span>            :     &gt; sense that implementations will agree in all cases on equality or
<span class="lineNum">   10150 </span>            :     &gt; inequality of two strings. For example, implementations that compare
<span class="lineNum">   10151 </span>            :     &gt; strings with escaped characters unconverted may incorrectly find that
<span class="lineNum">   10152 </span>            :     &gt; `&quot;a\\b&quot;` and `&quot;a\u005Cb&quot;` are not equal.
<span class="lineNum">   10153 </span>            : 
<span class="lineNum">   10154 </span>            :     This implementation is interoperable as it does compare strings code unit
<span class="lineNum">   10155 </span>            :     by code unit.
<span class="lineNum">   10156 </span>            : 
<span class="lineNum">   10157 </span>            :     #### Storage
<span class="lineNum">   10158 </span>            : 
<span class="lineNum">   10159 </span>            :     String values are stored as pointers in a @ref basic_json type. That is,
<span class="lineNum">   10160 </span>            :     for any access to string values, a pointer of type `string_t*` must be
<span class="lineNum">   10161 </span>            :     dereferenced.
<span class="lineNum">   10162 </span>            : 
<span class="lineNum">   10163 </span>            :     @since version 1.0.0
<span class="lineNum">   10164 </span>            :     */
<span class="lineNum">   10165 </span>            :     using string_t = StringType;
<span class="lineNum">   10166 </span>            : 
<span class="lineNum">   10167 </span>            :     /*!
<span class="lineNum">   10168 </span>            :     @brief a type for a boolean
<span class="lineNum">   10169 </span>            : 
<span class="lineNum">   10170 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
<span class="lineNum">   10171 </span>            :     type which differentiates the two literals `true` and `false`.
<span class="lineNum">   10172 </span>            : 
<span class="lineNum">   10173 </span>            :     To store objects in C++, a type is defined by the template parameter @a
<span class="lineNum">   10174 </span>            :     BooleanType which chooses the type to use.
<span class="lineNum">   10175 </span>            : 
<span class="lineNum">   10176 </span>            :     #### Default type
<span class="lineNum">   10177 </span>            : 
<span class="lineNum">   10178 </span>            :     With the default values for @a BooleanType (`bool`), the default value for
<span class="lineNum">   10179 </span>            :     @a boolean_t is:
<span class="lineNum">   10180 </span>            : 
<span class="lineNum">   10181 </span>            :     @code {.cpp}
<span class="lineNum">   10182 </span>            :     bool
<span class="lineNum">   10183 </span>            :     @endcode
<span class="lineNum">   10184 </span>            : 
<span class="lineNum">   10185 </span>            :     #### Storage
<span class="lineNum">   10186 </span>            : 
<span class="lineNum">   10187 </span>            :     Boolean values are stored directly inside a @ref basic_json type.
<span class="lineNum">   10188 </span>            : 
<span class="lineNum">   10189 </span>            :     @since version 1.0.0
<span class="lineNum">   10190 </span>            :     */
<span class="lineNum">   10191 </span>            :     using boolean_t = BooleanType;
<span class="lineNum">   10192 </span>            : 
<span class="lineNum">   10193 </span>            :     /*!
<span class="lineNum">   10194 </span>            :     @brief a type for a number (integer)
<span class="lineNum">   10195 </span>            : 
<span class="lineNum">   10196 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
<span class="lineNum">   10197 </span>            :     &gt; The representation of numbers is similar to that used in most
<span class="lineNum">   10198 </span>            :     &gt; programming languages. A number is represented in base 10 using decimal
<span class="lineNum">   10199 </span>            :     &gt; digits. It contains an integer component that may be prefixed with an
<span class="lineNum">   10200 </span>            :     &gt; optional minus sign, which may be followed by a fraction part and/or an
<span class="lineNum">   10201 </span>            :     &gt; exponent part. Leading zeros are not allowed. (...) Numeric values that
<span class="lineNum">   10202 </span>            :     &gt; cannot be represented in the grammar below (such as Infinity and NaN)
<span class="lineNum">   10203 </span>            :     &gt; are not permitted.
<span class="lineNum">   10204 </span>            : 
<span class="lineNum">   10205 </span>            :     This description includes both integer and floating-point numbers.
<span class="lineNum">   10206 </span>            :     However, C++ allows more precise storage if it is known whether the number
<span class="lineNum">   10207 </span>            :     is a signed integer, an unsigned integer or a floating-point number.
<span class="lineNum">   10208 </span>            :     Therefore, three different types, @ref number_integer_t, @ref
<span class="lineNum">   10209 </span>            :     number_unsigned_t and @ref number_float_t are used.
<span class="lineNum">   10210 </span>            : 
<span class="lineNum">   10211 </span>            :     To store integer numbers in C++, a type is defined by the template
<span class="lineNum">   10212 </span>            :     parameter @a NumberIntegerType which chooses the type to use.
<span class="lineNum">   10213 </span>            : 
<span class="lineNum">   10214 </span>            :     #### Default type
<span class="lineNum">   10215 </span>            : 
<span class="lineNum">   10216 </span>            :     With the default values for @a NumberIntegerType (`int64_t`), the default
<span class="lineNum">   10217 </span>            :     value for @a number_integer_t is:
<span class="lineNum">   10218 </span>            : 
<span class="lineNum">   10219 </span>            :     @code {.cpp}
<span class="lineNum">   10220 </span>            :     int64_t
<span class="lineNum">   10221 </span>            :     @endcode
<span class="lineNum">   10222 </span>            : 
<span class="lineNum">   10223 </span>            :     #### Default behavior
<span class="lineNum">   10224 </span>            : 
<span class="lineNum">   10225 </span>            :     - The restrictions about leading zeros is not enforced in C++. Instead,
<span class="lineNum">   10226 </span>            :       leading zeros in integer literals lead to an interpretation as octal
<span class="lineNum">   10227 </span>            :       number. Internally, the value will be stored as decimal number. For
<span class="lineNum">   10228 </span>            :       instance, the C++ integer literal `010` will be serialized to `8`.
<span class="lineNum">   10229 </span>            :       During deserialization, leading zeros yield an error.
<span class="lineNum">   10230 </span>            :     - Not-a-number (NaN) values will be serialized to `null`.
<span class="lineNum">   10231 </span>            : 
<span class="lineNum">   10232 </span>            :     #### Limits
<span class="lineNum">   10233 </span>            : 
<span class="lineNum">   10234 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) specifies:
<span class="lineNum">   10235 </span>            :     &gt; An implementation may set limits on the range and precision of numbers.
<span class="lineNum">   10236 </span>            : 
<span class="lineNum">   10237 </span>            :     When the default type is used, the maximal integer number that can be
<span class="lineNum">   10238 </span>            :     stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
<span class="lineNum">   10239 </span>            :     that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
<span class="lineNum">   10240 </span>            :     that are out of range will yield over/underflow when used in a
<span class="lineNum">   10241 </span>            :     constructor. During deserialization, too large or small integer numbers
<span class="lineNum">   10242 </span>            :     will be automatically be stored as @ref number_unsigned_t or @ref
<span class="lineNum">   10243 </span>            :     number_float_t.
<span class="lineNum">   10244 </span>            : 
<span class="lineNum">   10245 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) further states:
<span class="lineNum">   10246 </span>            :     &gt; Note that when such software is used, numbers that are integers and are
<span class="lineNum">   10247 </span>            :     &gt; in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
<span class="lineNum">   10248 </span>            :     &gt; that implementations will agree exactly on their numeric values.
<span class="lineNum">   10249 </span>            : 
<span class="lineNum">   10250 </span>            :     As this range is a subrange of the exactly supported range [INT64_MIN,
<span class="lineNum">   10251 </span>            :     INT64_MAX], this class's integer type is interoperable.
<span class="lineNum">   10252 </span>            : 
<span class="lineNum">   10253 </span>            :     #### Storage
<span class="lineNum">   10254 </span>            : 
<span class="lineNum">   10255 </span>            :     Integer number values are stored directly inside a @ref basic_json type.
<span class="lineNum">   10256 </span>            : 
<span class="lineNum">   10257 </span>            :     @sa @ref number_float_t -- type for number values (floating-point)
<span class="lineNum">   10258 </span>            : 
<span class="lineNum">   10259 </span>            :     @sa @ref number_unsigned_t -- type for number values (unsigned integer)
<span class="lineNum">   10260 </span>            : 
<span class="lineNum">   10261 </span>            :     @since version 1.0.0
<span class="lineNum">   10262 </span>            :     */
<span class="lineNum">   10263 </span>            :     using number_integer_t = NumberIntegerType;
<span class="lineNum">   10264 </span>            : 
<span class="lineNum">   10265 </span>            :     /*!
<span class="lineNum">   10266 </span>            :     @brief a type for a number (unsigned)
<span class="lineNum">   10267 </span>            : 
<span class="lineNum">   10268 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
<span class="lineNum">   10269 </span>            :     &gt; The representation of numbers is similar to that used in most
<span class="lineNum">   10270 </span>            :     &gt; programming languages. A number is represented in base 10 using decimal
<span class="lineNum">   10271 </span>            :     &gt; digits. It contains an integer component that may be prefixed with an
<span class="lineNum">   10272 </span>            :     &gt; optional minus sign, which may be followed by a fraction part and/or an
<span class="lineNum">   10273 </span>            :     &gt; exponent part. Leading zeros are not allowed. (...) Numeric values that
<span class="lineNum">   10274 </span>            :     &gt; cannot be represented in the grammar below (such as Infinity and NaN)
<span class="lineNum">   10275 </span>            :     &gt; are not permitted.
<span class="lineNum">   10276 </span>            : 
<span class="lineNum">   10277 </span>            :     This description includes both integer and floating-point numbers.
<span class="lineNum">   10278 </span>            :     However, C++ allows more precise storage if it is known whether the number
<span class="lineNum">   10279 </span>            :     is a signed integer, an unsigned integer or a floating-point number.
<span class="lineNum">   10280 </span>            :     Therefore, three different types, @ref number_integer_t, @ref
<span class="lineNum">   10281 </span>            :     number_unsigned_t and @ref number_float_t are used.
<span class="lineNum">   10282 </span>            : 
<span class="lineNum">   10283 </span>            :     To store unsigned integer numbers in C++, a type is defined by the
<span class="lineNum">   10284 </span>            :     template parameter @a NumberUnsignedType which chooses the type to use.
<span class="lineNum">   10285 </span>            : 
<span class="lineNum">   10286 </span>            :     #### Default type
<span class="lineNum">   10287 </span>            : 
<span class="lineNum">   10288 </span>            :     With the default values for @a NumberUnsignedType (`uint64_t`), the
<span class="lineNum">   10289 </span>            :     default value for @a number_unsigned_t is:
<span class="lineNum">   10290 </span>            : 
<span class="lineNum">   10291 </span>            :     @code {.cpp}
<span class="lineNum">   10292 </span>            :     uint64_t
<span class="lineNum">   10293 </span>            :     @endcode
<span class="lineNum">   10294 </span>            : 
<span class="lineNum">   10295 </span>            :     #### Default behavior
<span class="lineNum">   10296 </span>            : 
<span class="lineNum">   10297 </span>            :     - The restrictions about leading zeros is not enforced in C++. Instead,
<span class="lineNum">   10298 </span>            :       leading zeros in integer literals lead to an interpretation as octal
<span class="lineNum">   10299 </span>            :       number. Internally, the value will be stored as decimal number. For
<span class="lineNum">   10300 </span>            :       instance, the C++ integer literal `010` will be serialized to `8`.
<span class="lineNum">   10301 </span>            :       During deserialization, leading zeros yield an error.
<span class="lineNum">   10302 </span>            :     - Not-a-number (NaN) values will be serialized to `null`.
<span class="lineNum">   10303 </span>            : 
<span class="lineNum">   10304 </span>            :     #### Limits
<span class="lineNum">   10305 </span>            : 
<span class="lineNum">   10306 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) specifies:
<span class="lineNum">   10307 </span>            :     &gt; An implementation may set limits on the range and precision of numbers.
<span class="lineNum">   10308 </span>            : 
<span class="lineNum">   10309 </span>            :     When the default type is used, the maximal integer number that can be
<span class="lineNum">   10310 </span>            :     stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
<span class="lineNum">   10311 </span>            :     number that can be stored is `0`. Integer numbers that are out of range
<span class="lineNum">   10312 </span>            :     will yield over/underflow when used in a constructor. During
<span class="lineNum">   10313 </span>            :     deserialization, too large or small integer numbers will be automatically
<span class="lineNum">   10314 </span>            :     be stored as @ref number_integer_t or @ref number_float_t.
<span class="lineNum">   10315 </span>            : 
<span class="lineNum">   10316 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) further states:
<span class="lineNum">   10317 </span>            :     &gt; Note that when such software is used, numbers that are integers and are
<span class="lineNum">   10318 </span>            :     &gt; in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
<span class="lineNum">   10319 </span>            :     &gt; that implementations will agree exactly on their numeric values.
<span class="lineNum">   10320 </span>            : 
<span class="lineNum">   10321 </span>            :     As this range is a subrange (when considered in conjunction with the
<span class="lineNum">   10322 </span>            :     number_integer_t type) of the exactly supported range [0, UINT64_MAX],
<span class="lineNum">   10323 </span>            :     this class's integer type is interoperable.
<span class="lineNum">   10324 </span>            : 
<span class="lineNum">   10325 </span>            :     #### Storage
<span class="lineNum">   10326 </span>            : 
<span class="lineNum">   10327 </span>            :     Integer number values are stored directly inside a @ref basic_json type.
<span class="lineNum">   10328 </span>            : 
<span class="lineNum">   10329 </span>            :     @sa @ref number_float_t -- type for number values (floating-point)
<span class="lineNum">   10330 </span>            :     @sa @ref number_integer_t -- type for number values (integer)
<span class="lineNum">   10331 </span>            : 
<span class="lineNum">   10332 </span>            :     @since version 2.0.0
<span class="lineNum">   10333 </span>            :     */
<span class="lineNum">   10334 </span>            :     using number_unsigned_t = NumberUnsignedType;
<span class="lineNum">   10335 </span>            : 
<span class="lineNum">   10336 </span>            :     /*!
<span class="lineNum">   10337 </span>            :     @brief a type for a number (floating-point)
<span class="lineNum">   10338 </span>            : 
<span class="lineNum">   10339 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
<span class="lineNum">   10340 </span>            :     &gt; The representation of numbers is similar to that used in most
<span class="lineNum">   10341 </span>            :     &gt; programming languages. A number is represented in base 10 using decimal
<span class="lineNum">   10342 </span>            :     &gt; digits. It contains an integer component that may be prefixed with an
<span class="lineNum">   10343 </span>            :     &gt; optional minus sign, which may be followed by a fraction part and/or an
<span class="lineNum">   10344 </span>            :     &gt; exponent part. Leading zeros are not allowed. (...) Numeric values that
<span class="lineNum">   10345 </span>            :     &gt; cannot be represented in the grammar below (such as Infinity and NaN)
<span class="lineNum">   10346 </span>            :     &gt; are not permitted.
<span class="lineNum">   10347 </span>            : 
<span class="lineNum">   10348 </span>            :     This description includes both integer and floating-point numbers.
<span class="lineNum">   10349 </span>            :     However, C++ allows more precise storage if it is known whether the number
<span class="lineNum">   10350 </span>            :     is a signed integer, an unsigned integer or a floating-point number.
<span class="lineNum">   10351 </span>            :     Therefore, three different types, @ref number_integer_t, @ref
<span class="lineNum">   10352 </span>            :     number_unsigned_t and @ref number_float_t are used.
<span class="lineNum">   10353 </span>            : 
<span class="lineNum">   10354 </span>            :     To store floating-point numbers in C++, a type is defined by the template
<span class="lineNum">   10355 </span>            :     parameter @a NumberFloatType which chooses the type to use.
<span class="lineNum">   10356 </span>            : 
<span class="lineNum">   10357 </span>            :     #### Default type
<span class="lineNum">   10358 </span>            : 
<span class="lineNum">   10359 </span>            :     With the default values for @a NumberFloatType (`double`), the default
<span class="lineNum">   10360 </span>            :     value for @a number_float_t is:
<span class="lineNum">   10361 </span>            : 
<span class="lineNum">   10362 </span>            :     @code {.cpp}
<span class="lineNum">   10363 </span>            :     double
<span class="lineNum">   10364 </span>            :     @endcode
<span class="lineNum">   10365 </span>            : 
<span class="lineNum">   10366 </span>            :     #### Default behavior
<span class="lineNum">   10367 </span>            : 
<span class="lineNum">   10368 </span>            :     - The restrictions about leading zeros is not enforced in C++. Instead,
<span class="lineNum">   10369 </span>            :       leading zeros in floating-point literals will be ignored. Internally,
<span class="lineNum">   10370 </span>            :       the value will be stored as decimal number. For instance, the C++
<span class="lineNum">   10371 </span>            :       floating-point literal `01.2` will be serialized to `1.2`. During
<span class="lineNum">   10372 </span>            :       deserialization, leading zeros yield an error.
<span class="lineNum">   10373 </span>            :     - Not-a-number (NaN) values will be serialized to `null`.
<span class="lineNum">   10374 </span>            : 
<span class="lineNum">   10375 </span>            :     #### Limits
<span class="lineNum">   10376 </span>            : 
<span class="lineNum">   10377 </span>            :     [RFC 7159](http://rfc7159.net/rfc7159) states:
<span class="lineNum">   10378 </span>            :     &gt; This specification allows implementations to set limits on the range and
<span class="lineNum">   10379 </span>            :     &gt; precision of numbers accepted. Since software that implements IEEE
<span class="lineNum">   10380 </span>            :     &gt; 754-2008 binary64 (double precision) numbers is generally available and
<span class="lineNum">   10381 </span>            :     &gt; widely used, good interoperability can be achieved by implementations
<span class="lineNum">   10382 </span>            :     &gt; that expect no more precision or range than these provide, in the sense
<span class="lineNum">   10383 </span>            :     &gt; that implementations will approximate JSON numbers within the expected
<span class="lineNum">   10384 </span>            :     &gt; precision.
<span class="lineNum">   10385 </span>            : 
<span class="lineNum">   10386 </span>            :     This implementation does exactly follow this approach, as it uses double
<span class="lineNum">   10387 </span>            :     precision floating-point numbers. Note values smaller than
<span class="lineNum">   10388 </span>            :     `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
<span class="lineNum">   10389 </span>            :     will be stored as NaN internally and be serialized to `null`.
<span class="lineNum">   10390 </span>            : 
<span class="lineNum">   10391 </span>            :     #### Storage
<span class="lineNum">   10392 </span>            : 
<span class="lineNum">   10393 </span>            :     Floating-point number values are stored directly inside a @ref basic_json
<span class="lineNum">   10394 </span>            :     type.
<span class="lineNum">   10395 </span>            : 
<span class="lineNum">   10396 </span>            :     @sa @ref number_integer_t -- type for number values (integer)
<span class="lineNum">   10397 </span>            : 
<span class="lineNum">   10398 </span>            :     @sa @ref number_unsigned_t -- type for number values (unsigned integer)
<span class="lineNum">   10399 </span>            : 
<span class="lineNum">   10400 </span>            :     @since version 1.0.0
<span class="lineNum">   10401 </span>            :     */
<span class="lineNum">   10402 </span>            :     using number_float_t = NumberFloatType;
<span class="lineNum">   10403 </span>            : 
<span class="lineNum">   10404 </span>            :     /// @}
<span class="lineNum">   10405 </span>            : 
<span class="lineNum">   10406 </span>            :   private:
<span class="lineNum">   10407 </span>            : 
<a name="10408"><span class="lineNum">   10408 </span>            :     /// helper for exception-safe object creation</a>
<span class="lineNum">   10409 </span>            :     template&lt;typename T, typename... Args&gt;
<span class="lineNum">   10410 </span><span class="lineCov">       1102 :     static T* create(Args&amp;&amp; ... args)</span>
<span class="lineNum">   10411 </span>            :     {
<span class="lineNum">   10412 </span><span class="lineCov">       2204 :         AllocatorType&lt;T&gt; alloc;</span>
<a name="10413"><span class="lineNum">   10413 </span>            :         using AllocatorTraits = std::allocator_traits&lt;AllocatorType&lt;T&gt;&gt;;</a>
<span class="lineNum">   10414 </span>            : 
<span class="lineNum">   10415 </span><span class="lineNoCov">          0 :         auto deleter = [&amp;](T * object)</span>
<span class="lineNum">   10416 </span>            :         {
<span class="lineNum">   10417 </span><span class="lineNoCov">          0 :             AllocatorTraits::deallocate(alloc, object, 1);</span>
<span class="lineNum">   10418 </span><span class="lineCov">       1102 :         };</span>
<span class="lineNum">   10419 </span><span class="lineCov">       2204 :         std::unique_ptr&lt;T, decltype(deleter)&gt; object(AllocatorTraits::allocate(alloc, 1), deleter);</span>
<span class="lineNum">   10420 </span><span class="lineCov">       1102 :         AllocatorTraits::construct(alloc, object.get(), std::forward&lt;Args&gt;(args)...);</span>
<span class="lineNum">   10421 </span><span class="lineCov">       1102 :         assert(object != nullptr);</span>
<span class="lineNum">   10422 </span><span class="lineCov">       2204 :         return object.release();</span>
<span class="lineNum">   10423 </span>            :     }
<span class="lineNum">   10424 </span>            : 
<span class="lineNum">   10425 </span>            :     ////////////////////////
<span class="lineNum">   10426 </span>            :     // JSON value storage //
<span class="lineNum">   10427 </span>            :     ////////////////////////
<span class="lineNum">   10428 </span>            : 
<span class="lineNum">   10429 </span>            :     /*!
<span class="lineNum">   10430 </span>            :     @brief a JSON value
<span class="lineNum">   10431 </span>            : 
<span class="lineNum">   10432 </span>            :     The actual storage for a JSON value of the @ref basic_json class. This
<span class="lineNum">   10433 </span>            :     union combines the different storage types for the JSON value types
<span class="lineNum">   10434 </span>            :     defined in @ref value_t.
<span class="lineNum">   10435 </span>            : 
<span class="lineNum">   10436 </span>            :     JSON type | value_t type    | used type
<span class="lineNum">   10437 </span>            :     --------- | --------------- | ------------------------
<span class="lineNum">   10438 </span>            :     object    | object          | pointer to @ref object_t
<span class="lineNum">   10439 </span>            :     array     | array           | pointer to @ref array_t
<span class="lineNum">   10440 </span>            :     string    | string          | pointer to @ref string_t
<span class="lineNum">   10441 </span>            :     boolean   | boolean         | @ref boolean_t
<span class="lineNum">   10442 </span>            :     number    | number_integer  | @ref number_integer_t
<span class="lineNum">   10443 </span>            :     number    | number_unsigned | @ref number_unsigned_t
<span class="lineNum">   10444 </span>            :     number    | number_float    | @ref number_float_t
<span class="lineNum">   10445 </span>            :     null      | null            | *no value is stored*
<span class="lineNum">   10446 </span>            : 
<span class="lineNum">   10447 </span>            :     @note Variable-length types (objects, arrays, and strings) are stored as
<span class="lineNum">   10448 </span>            :     pointers. The size of the union should not exceed 64 bits if the default
<span class="lineNum">   10449 </span>            :     value types are used.
<span class="lineNum">   10450 </span>            : 
<span class="lineNum">   10451 </span>            :     @since version 1.0.0
<span class="lineNum">   10452 </span>            :     */
<span class="lineNum">   10453 </span>            :     union json_value
<span class="lineNum">   10454 </span>            :     {
<span class="lineNum">   10455 </span>            :         /// object (stored with pointer to save storage)
<span class="lineNum">   10456 </span>            :         object_t* object;
<span class="lineNum">   10457 </span>            :         /// array (stored with pointer to save storage)
<span class="lineNum">   10458 </span>            :         array_t* array;
<span class="lineNum">   10459 </span>            :         /// string (stored with pointer to save storage)
<span class="lineNum">   10460 </span>            :         string_t* string;
<span class="lineNum">   10461 </span>            :         /// boolean
<span class="lineNum">   10462 </span>            :         boolean_t boolean;
<span class="lineNum">   10463 </span>            :         /// number (integer)
<span class="lineNum">   10464 </span>            :         number_integer_t number_integer;
<span class="lineNum">   10465 </span>            :         /// number (unsigned integer)
<span class="lineNum">   10466 </span>            :         number_unsigned_t number_unsigned;
<span class="lineNum">   10467 </span>            :         /// number (floating-point)
<span class="lineNum">   10468 </span>            :         number_float_t number_float;
<span class="lineNum">   10469 </span>            : 
<span class="lineNum">   10470 </span>            :         /// default constructor (for null values)
<a name="10471"><span class="lineNum">   10471 </span>            :         json_value() = default;</a>
<span class="lineNum">   10472 </span>            :         /// constructor for booleans
<a name="10473"><span class="lineNum">   10473 </span><span class="lineCov">         14 :         json_value(boolean_t v) noexcept : boolean(v) {}</span></a>
<span class="lineNum">   10474 </span>            :         /// constructor for numbers (integer)
<a name="10475"><span class="lineNum">   10475 </span><span class="lineCov">         48 :         json_value(number_integer_t v) noexcept : number_integer(v) {}</span></a>
<span class="lineNum">   10476 </span>            :         /// constructor for numbers (unsigned)
<a name="10477"><span class="lineNum">   10477 </span><span class="lineCov">        449 :         json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}</span></a>
<span class="lineNum">   10478 </span>            :         /// constructor for numbers (floating-point)
<a name="10479"><span class="lineNum">   10479 </span><span class="lineCov">          2 :         json_value(number_float_t v) noexcept : number_float(v) {}</span></a>
<span class="lineNum">   10480 </span>            :         /// constructor for empty values of a given type
<span class="lineNum">   10481 </span><span class="lineCov">        787 :         json_value(value_t t)</span>
<span class="lineNum">   10482 </span>            :         {
<span class="lineNum">   10483 </span><span class="lineCov">        787 :             switch (t)</span>
<span class="lineNum">   10484 </span>            :             {
<span class="lineNum">   10485 </span>            :                 case value_t::object:
<span class="lineNum">   10486 </span>            :                 {
<span class="lineNum">   10487 </span><span class="lineCov">        210 :                     object = create&lt;object_t&gt;();</span>
<span class="lineNum">   10488 </span><span class="lineCov">        210 :                     break;</span>
<span class="lineNum">   10489 </span>            :                 }
<span class="lineNum">   10490 </span>            : 
<span class="lineNum">   10491 </span>            :                 case value_t::array:
<span class="lineNum">   10492 </span>            :                 {
<span class="lineNum">   10493 </span><span class="lineCov">         74 :                     array = create&lt;array_t&gt;();</span>
<span class="lineNum">   10494 </span><span class="lineCov">         74 :                     break;</span>
<span class="lineNum">   10495 </span>            :                 }
<span class="lineNum">   10496 </span>            : 
<span class="lineNum">   10497 </span>            :                 case value_t::string:
<span class="lineNum">   10498 </span>            :                 {
<span class="lineNum">   10499 </span><span class="lineNoCov">          0 :                     string = create&lt;string_t&gt;(&quot;&quot;);</span>
<span class="lineNum">   10500 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">   10501 </span>            :                 }
<span class="lineNum">   10502 </span>            : 
<span class="lineNum">   10503 </span>            :                 case value_t::boolean:
<span class="lineNum">   10504 </span>            :                 {
<span class="lineNum">   10505 </span><span class="lineNoCov">          0 :                     boolean = boolean_t(false);</span>
<span class="lineNum">   10506 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">   10507 </span>            :                 }
<span class="lineNum">   10508 </span>            : 
<span class="lineNum">   10509 </span>            :                 case value_t::number_integer:
<span class="lineNum">   10510 </span>            :                 {
<span class="lineNum">   10511 </span><span class="lineNoCov">          0 :                     number_integer = number_integer_t(0);</span>
<span class="lineNum">   10512 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">   10513 </span>            :                 }
<span class="lineNum">   10514 </span>            : 
<span class="lineNum">   10515 </span>            :                 case value_t::number_unsigned:
<span class="lineNum">   10516 </span>            :                 {
<span class="lineNum">   10517 </span><span class="lineNoCov">          0 :                     number_unsigned = number_unsigned_t(0);</span>
<span class="lineNum">   10518 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">   10519 </span>            :                 }
<span class="lineNum">   10520 </span>            : 
<span class="lineNum">   10521 </span>            :                 case value_t::number_float:
<span class="lineNum">   10522 </span>            :                 {
<span class="lineNum">   10523 </span><span class="lineNoCov">          0 :                     number_float = number_float_t(0.0);</span>
<span class="lineNum">   10524 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">   10525 </span>            :                 }
<span class="lineNum">   10526 </span>            : 
<span class="lineNum">   10527 </span>            :                 case value_t::null:
<span class="lineNum">   10528 </span>            :                 {
<span class="lineNum">   10529 </span><span class="lineCov">        500 :                     object = nullptr;  // silence warning, see #821</span>
<span class="lineNum">   10530 </span><span class="lineCov">        500 :                     break;</span>
<span class="lineNum">   10531 </span>            :                 }
<span class="lineNum">   10532 </span>            : 
<span class="lineNum">   10533 </span>            :                 default:
<span class="lineNum">   10534 </span>            :                 {
<span class="lineNum">   10535 </span><span class="lineCov">          3 :                     object = nullptr;  // silence warning, see #821</span>
<span class="lineNum">   10536 </span><span class="lineCov">          3 :                     if (JSON_UNLIKELY(t == value_t::null))</span>
<span class="lineNum">   10537 </span>            :                     {
<span class="lineNum">   10538 </span>            :                         JSON_THROW(other_error::create(500, &quot;961c151d2e87f2686a955a9be24d316f1362bf21 3.1.1&quot;)); // LCOV_EXCL_LINE
<span class="lineNum">   10539 </span>            :                     }
<span class="lineNum">   10540 </span><span class="lineCov">          3 :                     break;</span>
<span class="lineNum">   10541 </span>            :                 }
<span class="lineNum">   10542 </span>            :             }
<span class="lineNum">   10543 </span><span class="lineCov">        787 :         }</span>
<a name="10544"><span class="lineNum">   10544 </span>            : </a>
<span class="lineNum">   10545 </span>            :         /// constructor for strings
<span class="lineNum">   10546 </span><span class="lineCov">         70 :         json_value(const string_t&amp; value)</span>
<span class="lineNum">   10547 </span>            :         {
<span class="lineNum">   10548 </span><span class="lineCov">         70 :             string = create&lt;string_t&gt;(value);</span>
<span class="lineNum">   10549 </span><span class="lineCov">         70 :         }</span>
<a name="10550"><span class="lineNum">   10550 </span>            : </a>
<span class="lineNum">   10551 </span>            :         /// constructor for rvalue strings
<span class="lineNum">   10552 </span><span class="lineCov">        479 :         json_value(string_t&amp;&amp; value)</span>
<span class="lineNum">   10553 </span>            :         {
<span class="lineNum">   10554 </span><span class="lineCov">        479 :             string = create&lt;string_t&gt;(std::move(value));</span>
<span class="lineNum">   10555 </span><span class="lineCov">        479 :         }</span>
<a name="10556"><span class="lineNum">   10556 </span>            : </a>
<span class="lineNum">   10557 </span>            :         /// constructor for objects
<span class="lineNum">   10558 </span><span class="lineCov">         26 :         json_value(const object_t&amp; value)</span>
<span class="lineNum">   10559 </span>            :         {
<span class="lineNum">   10560 </span><span class="lineCov">         26 :             object = create&lt;object_t&gt;(value);</span>
<span class="lineNum">   10561 </span><span class="lineCov">         26 :         }</span>
<span class="lineNum">   10562 </span>            : 
<span class="lineNum">   10563 </span>            :         /// constructor for rvalue objects
<span class="lineNum">   10564 </span>            :         json_value(object_t&amp;&amp; value)
<span class="lineNum">   10565 </span>            :         {
<span class="lineNum">   10566 </span>            :             object = create&lt;object_t&gt;(std::move(value));
<span class="lineNum">   10567 </span>            :         }
<a name="10568"><span class="lineNum">   10568 </span>            : </a>
<span class="lineNum">   10569 </span>            :         /// constructor for arrays
<span class="lineNum">   10570 </span><span class="lineNoCov">          0 :         json_value(const array_t&amp; value)</span>
<span class="lineNum">   10571 </span>            :         {
<span class="lineNum">   10572 </span><span class="lineNoCov">          0 :             array = create&lt;array_t&gt;(value);</span>
<span class="lineNum">   10573 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10574 </span>            : 
<span class="lineNum">   10575 </span>            :         /// constructor for rvalue arrays
<span class="lineNum">   10576 </span>            :         json_value(array_t&amp;&amp; value)
<span class="lineNum">   10577 </span>            :         {
<span class="lineNum">   10578 </span>            :             array = create&lt;array_t&gt;(std::move(value));
<a name="10579"><span class="lineNum">   10579 </span>            :         }</a>
<span class="lineNum">   10580 </span>            : 
<span class="lineNum">   10581 </span><span class="lineCov">       3596 :         void destroy(value_t t) noexcept</span>
<span class="lineNum">   10582 </span>            :         {
<span class="lineNum">   10583 </span><span class="lineCov">       3596 :             switch (t)</span>
<span class="lineNum">   10584 </span>            :             {
<span class="lineNum">   10585 </span>            :                 case value_t::object:
<span class="lineNum">   10586 </span>            :                 {
<span class="lineNum">   10587 </span><span class="lineCov">        484 :                     AllocatorType&lt;object_t&gt; alloc;</span>
<span class="lineNum">   10588 </span><span class="lineCov">        242 :                     std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, object);</span>
<span class="lineNum">   10589 </span><span class="lineCov">        242 :                     std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, object, 1);</span>
<span class="lineNum">   10590 </span><span class="lineCov">        242 :                     break;</span>
<span class="lineNum">   10591 </span>            :                 }
<span class="lineNum">   10592 </span>            : 
<span class="lineNum">   10593 </span>            :                 case value_t::array:
<span class="lineNum">   10594 </span>            :                 {
<span class="lineNum">   10595 </span><span class="lineCov">        622 :                     AllocatorType&lt;array_t&gt; alloc;</span>
<span class="lineNum">   10596 </span><span class="lineCov">        311 :                     std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, array);</span>
<span class="lineNum">   10597 </span><span class="lineCov">        311 :                     std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, array, 1);</span>
<span class="lineNum">   10598 </span><span class="lineCov">        311 :                     break;</span>
<span class="lineNum">   10599 </span>            :                 }
<span class="lineNum">   10600 </span>            : 
<span class="lineNum">   10601 </span>            :                 case value_t::string:
<span class="lineNum">   10602 </span>            :                 {
<span class="lineNum">   10603 </span><span class="lineCov">       1098 :                     AllocatorType&lt;string_t&gt; alloc;</span>
<span class="lineNum">   10604 </span><span class="lineCov">        549 :                     std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, string);</span>
<span class="lineNum">   10605 </span><span class="lineCov">        549 :                     std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, string, 1);</span>
<span class="lineNum">   10606 </span><span class="lineCov">        549 :                     break;</span>
<span class="lineNum">   10607 </span>            :                 }
<span class="lineNum">   10608 </span>            : 
<span class="lineNum">   10609 </span>            :                 default:
<span class="lineNum">   10610 </span>            :                 {
<span class="lineNum">   10611 </span><span class="lineCov">       2494 :                     break;</span>
<span class="lineNum">   10612 </span>            :                 }
<span class="lineNum">   10613 </span>            :             }
<span class="lineNum">   10614 </span><span class="lineCov">       3596 :         }</span>
<span class="lineNum">   10615 </span>            :     };
<span class="lineNum">   10616 </span>            : 
<span class="lineNum">   10617 </span>            :     /*!
<span class="lineNum">   10618 </span>            :     @brief checks the class invariants
<span class="lineNum">   10619 </span>            : 
<span class="lineNum">   10620 </span>            :     This function asserts the class invariants. It needs to be called at the
<span class="lineNum">   10621 </span>            :     end of every constructor to make sure that created objects respect the
<span class="lineNum">   10622 </span>            :     invariant. Furthermore, it has to be called each time the type of a JSON
<span class="lineNum">   10623 </span>            :     value is changed, because the invariant expresses a relationship between
<a name="10624"><span class="lineNum">   10624 </span>            :     @a m_type and @a m_value.</a>
<span class="lineNum">   10625 </span>            :     */
<span class="lineNum">   10626 </span><span class="lineCov">       8845 :     void assert_invariant() const noexcept</span>
<span class="lineNum">   10627 </span>            :     {
<span class="lineNum">   10628 </span><span class="lineCov">       8845 :         assert(m_type != value_t::object or m_value.object != nullptr);</span>
<span class="lineNum">   10629 </span><span class="lineCov">       8845 :         assert(m_type != value_t::array or m_value.array != nullptr);</span>
<span class="lineNum">   10630 </span><span class="lineCov">       8845 :         assert(m_type != value_t::string or m_value.string != nullptr);</span>
<span class="lineNum">   10631 </span><span class="lineCov">       8845 :     }</span>
<span class="lineNum">   10632 </span>            : 
<span class="lineNum">   10633 </span>            :   public:
<span class="lineNum">   10634 </span>            :     //////////////////////////
<span class="lineNum">   10635 </span>            :     // JSON parser callback //
<span class="lineNum">   10636 </span>            :     //////////////////////////
<span class="lineNum">   10637 </span>            : 
<span class="lineNum">   10638 </span>            :     /*!
<span class="lineNum">   10639 </span>            :     @brief parser event types
<span class="lineNum">   10640 </span>            : 
<span class="lineNum">   10641 </span>            :     The parser callback distinguishes the following events:
<span class="lineNum">   10642 </span>            :     - `object_start`: the parser read `{` and started to process a JSON object
<span class="lineNum">   10643 </span>            :     - `key`: the parser read a key of a value in an object
<span class="lineNum">   10644 </span>            :     - `object_end`: the parser read `}` and finished processing a JSON object
<span class="lineNum">   10645 </span>            :     - `array_start`: the parser read `[` and started to process a JSON array
<span class="lineNum">   10646 </span>            :     - `array_end`: the parser read `]` and finished processing a JSON array
<span class="lineNum">   10647 </span>            :     - `value`: the parser finished reading a JSON value
<span class="lineNum">   10648 </span>            : 
<span class="lineNum">   10649 </span>            :     @image html callback_events.png &quot;Example when certain parse events are triggered&quot;
<span class="lineNum">   10650 </span>            : 
<span class="lineNum">   10651 </span>            :     @sa @ref parser_callback_t for more information and examples
<span class="lineNum">   10652 </span>            :     */
<span class="lineNum">   10653 </span>            :     using parse_event_t = typename parser::parse_event_t;
<span class="lineNum">   10654 </span>            : 
<span class="lineNum">   10655 </span>            :     /*!
<span class="lineNum">   10656 </span>            :     @brief per-element parser callback type
<span class="lineNum">   10657 </span>            : 
<span class="lineNum">   10658 </span>            :     With a parser callback function, the result of parsing a JSON text can be
<span class="lineNum">   10659 </span>            :     influenced. When passed to @ref parse, it is called on certain events
<span class="lineNum">   10660 </span>            :     (passed as @ref parse_event_t via parameter @a event) with a set recursion
<span class="lineNum">   10661 </span>            :     depth @a depth and context JSON value @a parsed. The return value of the
<span class="lineNum">   10662 </span>            :     callback function is a boolean indicating whether the element that emitted
<span class="lineNum">   10663 </span>            :     the callback shall be kept or not.
<span class="lineNum">   10664 </span>            : 
<span class="lineNum">   10665 </span>            :     We distinguish six scenarios (determined by the event type) in which the
<span class="lineNum">   10666 </span>            :     callback function can be called. The following table describes the values
<span class="lineNum">   10667 </span>            :     of the parameters @a depth, @a event, and @a parsed.
<span class="lineNum">   10668 </span>            : 
<span class="lineNum">   10669 </span>            :     parameter @a event | description | parameter @a depth | parameter @a parsed
<span class="lineNum">   10670 </span>            :     ------------------ | ----------- | ------------------ | -------------------
<span class="lineNum">   10671 </span>            :     parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
<span class="lineNum">   10672 </span>            :     parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
<span class="lineNum">   10673 </span>            :     parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
<span class="lineNum">   10674 </span>            :     parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
<span class="lineNum">   10675 </span>            :     parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
<span class="lineNum">   10676 </span>            :     parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value
<span class="lineNum">   10677 </span>            : 
<span class="lineNum">   10678 </span>            :     @image html callback_events.png &quot;Example when certain parse events are triggered&quot;
<span class="lineNum">   10679 </span>            : 
<span class="lineNum">   10680 </span>            :     Discarding a value (i.e., returning `false`) has different effects
<span class="lineNum">   10681 </span>            :     depending on the context in which function was called:
<span class="lineNum">   10682 </span>            : 
<span class="lineNum">   10683 </span>            :     - Discarded values in structured types are skipped. That is, the parser
<span class="lineNum">   10684 </span>            :       will behave as if the discarded value was never read.
<span class="lineNum">   10685 </span>            :     - In case a value outside a structured type is skipped, it is replaced
<span class="lineNum">   10686 </span>            :       with `null`. This case happens if the top-level element is skipped.
<span class="lineNum">   10687 </span>            : 
<span class="lineNum">   10688 </span>            :     @param[in] depth  the depth of the recursion during parsing
<span class="lineNum">   10689 </span>            : 
<span class="lineNum">   10690 </span>            :     @param[in] event  an event of type parse_event_t indicating the context in
<span class="lineNum">   10691 </span>            :     the callback function has been called
<span class="lineNum">   10692 </span>            : 
<span class="lineNum">   10693 </span>            :     @param[in,out] parsed  the current intermediate parse result; note that
<span class="lineNum">   10694 </span>            :     writing to this value has no effect for parse_event_t::key events
<span class="lineNum">   10695 </span>            : 
<span class="lineNum">   10696 </span>            :     @return Whether the JSON value which called the function during parsing
<span class="lineNum">   10697 </span>            :     should be kept (`true`) or not (`false`). In the latter case, it is either
<span class="lineNum">   10698 </span>            :     skipped completely or replaced by an empty discarded object.
<span class="lineNum">   10699 </span>            : 
<span class="lineNum">   10700 </span>            :     @sa @ref parse for examples
<span class="lineNum">   10701 </span>            : 
<span class="lineNum">   10702 </span>            :     @since version 1.0.0
<span class="lineNum">   10703 </span>            :     */
<span class="lineNum">   10704 </span>            :     using parser_callback_t = typename parser::parser_callback_t;
<span class="lineNum">   10705 </span>            : 
<span class="lineNum">   10706 </span>            : 
<span class="lineNum">   10707 </span>            :     //////////////////
<span class="lineNum">   10708 </span>            :     // constructors //
<span class="lineNum">   10709 </span>            :     //////////////////
<span class="lineNum">   10710 </span>            : 
<span class="lineNum">   10711 </span>            :     /// @name constructors and destructors
<span class="lineNum">   10712 </span>            :     /// Constructors of class @ref basic_json, copy/move constructor, copy
<span class="lineNum">   10713 </span>            :     /// assignment, static functions creating objects, and the destructor.
<span class="lineNum">   10714 </span>            :     /// @{
<span class="lineNum">   10715 </span>            : 
<span class="lineNum">   10716 </span>            :     /*!
<span class="lineNum">   10717 </span>            :     @brief create an empty value with a given type
<span class="lineNum">   10718 </span>            : 
<span class="lineNum">   10719 </span>            :     Create an empty JSON value with a given type. The value will be default
<span class="lineNum">   10720 </span>            :     initialized with an empty value which depends on the type:
<span class="lineNum">   10721 </span>            : 
<span class="lineNum">   10722 </span>            :     Value type  | initial value
<span class="lineNum">   10723 </span>            :     ----------- | -------------
<span class="lineNum">   10724 </span>            :     null        | `null`
<span class="lineNum">   10725 </span>            :     boolean     | `false`
<span class="lineNum">   10726 </span>            :     string      | `&quot;&quot;`
<span class="lineNum">   10727 </span>            :     number      | `0`
<span class="lineNum">   10728 </span>            :     object      | `{}`
<span class="lineNum">   10729 </span>            :     array       | `[]`
<span class="lineNum">   10730 </span>            : 
<span class="lineNum">   10731 </span>            :     @param[in] v  the type of the value to create
<span class="lineNum">   10732 </span>            : 
<span class="lineNum">   10733 </span>            :     @complexity Constant.
<span class="lineNum">   10734 </span>            : 
<span class="lineNum">   10735 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   10736 </span>            :     changes to any JSON value.
<span class="lineNum">   10737 </span>            : 
<span class="lineNum">   10738 </span>            :     @liveexample{The following code shows the constructor for different @ref
<span class="lineNum">   10739 </span>            :     value_t values,basic_json__value_t}
<span class="lineNum">   10740 </span>            : 
<span class="lineNum">   10741 </span>            :     @sa @ref clear() -- restores the postcondition of this constructor
<span class="lineNum">   10742 </span>            : 
<a name="10743"><span class="lineNum">   10743 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   10744 </span>            :     */
<span class="lineNum">   10745 </span><span class="lineCov">        503 :     basic_json(const value_t v)</span>
<span class="lineNum">   10746 </span><span class="lineCov">        503 :         : m_type(v), m_value(v)</span>
<span class="lineNum">   10747 </span>            :     {
<span class="lineNum">   10748 </span><span class="lineCov">        503 :         assert_invariant();</span>
<span class="lineNum">   10749 </span><span class="lineCov">        503 :     }</span>
<span class="lineNum">   10750 </span>            : 
<span class="lineNum">   10751 </span>            :     /*!
<span class="lineNum">   10752 </span>            :     @brief create a null object
<span class="lineNum">   10753 </span>            : 
<span class="lineNum">   10754 </span>            :     Create a `null` JSON value. It either takes a null pointer as parameter
<span class="lineNum">   10755 </span>            :     (explicitly creating `null`) or no parameter (implicitly creating `null`).
<span class="lineNum">   10756 </span>            :     The passed null pointer itself is not read -- it is only used to choose
<span class="lineNum">   10757 </span>            :     the right constructor.
<span class="lineNum">   10758 </span>            : 
<span class="lineNum">   10759 </span>            :     @complexity Constant.
<span class="lineNum">   10760 </span>            : 
<span class="lineNum">   10761 </span>            :     @exceptionsafety No-throw guarantee: this constructor never throws
<span class="lineNum">   10762 </span>            :     exceptions.
<span class="lineNum">   10763 </span>            : 
<span class="lineNum">   10764 </span>            :     @liveexample{The following code shows the constructor with and without a
<span class="lineNum">   10765 </span>            :     null pointer parameter.,basic_json__nullptr_t}
<span class="lineNum">   10766 </span>            : 
<a name="10767"><span class="lineNum">   10767 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   10768 </span>            :     */
<span class="lineNum">   10769 </span><span class="lineCov">        500 :     basic_json(std::nullptr_t = nullptr) noexcept</span>
<span class="lineNum">   10770 </span><span class="lineCov">        500 :         : basic_json(value_t::null)</span>
<span class="lineNum">   10771 </span>            :     {
<span class="lineNum">   10772 </span><span class="lineCov">        500 :         assert_invariant();</span>
<span class="lineNum">   10773 </span><span class="lineCov">        500 :     }</span>
<span class="lineNum">   10774 </span>            : 
<span class="lineNum">   10775 </span>            :     /*!
<span class="lineNum">   10776 </span>            :     @brief create a JSON value
<span class="lineNum">   10777 </span>            : 
<span class="lineNum">   10778 </span>            :     This is a &quot;catch all&quot; constructor for all compatible JSON types; that is,
<span class="lineNum">   10779 </span>            :     types for which a `to_json()` method exists. The constructor forwards the
<span class="lineNum">   10780 </span>            :     parameter @a val to that method (to `json_serializer&lt;U&gt;::to_json` method
<span class="lineNum">   10781 </span>            :     with `U = uncvref_t&lt;CompatibleType&gt;`, to be exact).
<span class="lineNum">   10782 </span>            : 
<span class="lineNum">   10783 </span>            :     Template type @a CompatibleType includes, but is not limited to, the
<span class="lineNum">   10784 </span>            :     following types:
<span class="lineNum">   10785 </span>            :     - **arrays**: @ref array_t and all kinds of compatible containers such as
<span class="lineNum">   10786 </span>            :       `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
<span class="lineNum">   10787 </span>            :       `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
<span class="lineNum">   10788 </span>            :       `std::multiset`, and `std::unordered_multiset` with a `value_type` from
<span class="lineNum">   10789 </span>            :       which a @ref basic_json value can be constructed.
<span class="lineNum">   10790 </span>            :     - **objects**: @ref object_t and all kinds of compatible associative
<span class="lineNum">   10791 </span>            :       containers such as `std::map`, `std::unordered_map`, `std::multimap`,
<span class="lineNum">   10792 </span>            :       and `std::unordered_multimap` with a `key_type` compatible to
<span class="lineNum">   10793 </span>            :       @ref string_t and a `value_type` from which a @ref basic_json value can
<span class="lineNum">   10794 </span>            :       be constructed.
<span class="lineNum">   10795 </span>            :     - **strings**: @ref string_t, string literals, and all compatible string
<span class="lineNum">   10796 </span>            :       containers can be used.
<span class="lineNum">   10797 </span>            :     - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
<span class="lineNum">   10798 </span>            :       @ref number_float_t, and all convertible number types such as `int`,
<span class="lineNum">   10799 </span>            :       `size_t`, `int64_t`, `float` or `double` can be used.
<span class="lineNum">   10800 </span>            :     - **boolean**: @ref boolean_t / `bool` can be used.
<span class="lineNum">   10801 </span>            : 
<span class="lineNum">   10802 </span>            :     See the examples below.
<span class="lineNum">   10803 </span>            : 
<span class="lineNum">   10804 </span>            :     @tparam CompatibleType a type such that:
<span class="lineNum">   10805 </span>            :     - @a CompatibleType is not derived from `std::istream`,
<span class="lineNum">   10806 </span>            :     - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
<span class="lineNum">   10807 </span>            :          constructors),
<span class="lineNum">   10808 </span>            :     - @a CompatibleType is not a @ref basic_json nested type (e.g.,
<span class="lineNum">   10809 </span>            :          @ref json_pointer, @ref iterator, etc ...)
<span class="lineNum">   10810 </span>            :     - @ref @ref json_serializer&lt;U&gt; has a
<span class="lineNum">   10811 </span>            :          `to_json(basic_json_t&amp;, CompatibleType&amp;&amp;)` method
<span class="lineNum">   10812 </span>            : 
<span class="lineNum">   10813 </span>            :     @tparam U = `uncvref_t&lt;CompatibleType&gt;`
<span class="lineNum">   10814 </span>            : 
<span class="lineNum">   10815 </span>            :     @param[in] val the value to be forwarded to the respective constructor
<span class="lineNum">   10816 </span>            : 
<span class="lineNum">   10817 </span>            :     @complexity Usually linear in the size of the passed @a val, also
<span class="lineNum">   10818 </span>            :                 depending on the implementation of the called `to_json()`
<span class="lineNum">   10819 </span>            :                 method.
<span class="lineNum">   10820 </span>            : 
<span class="lineNum">   10821 </span>            :     @exceptionsafety Depends on the called constructor. For types directly
<span class="lineNum">   10822 </span>            :     supported by the library (i.e., all types for which no `to_json()` function
<span class="lineNum">   10823 </span>            :     was provided), strong guarantee holds: if an exception is thrown, there are
<span class="lineNum">   10824 </span>            :     no changes to any JSON value.
<span class="lineNum">   10825 </span>            : 
<span class="lineNum">   10826 </span>            :     @liveexample{The following code shows the constructor with several
<span class="lineNum">   10827 </span>            :     compatible types.,basic_json__CompatibleType}
<span class="lineNum">   10828 </span>            : 
<span class="lineNum">   10829 </span>            :     @since version 2.1.0
<span class="lineNum">   10830 </span>            :     */
<span class="lineNum">   10831 </span>            :     template &lt;typename CompatibleType,
<span class="lineNum">   10832 </span>            :               typename U = detail::uncvref_t&lt;CompatibleType&gt;,
<a name="10833"><span class="lineNum">   10833 </span>            :               detail::enable_if_t&lt;</a>
<span class="lineNum">   10834 </span>            :                   detail::is_compatible_type&lt;basic_json_t, U&gt;::value, int&gt; = 0&gt;
<span class="lineNum">   10835 </span><span class="lineCov">        386 :     basic_json(CompatibleType &amp;&amp; val) noexcept(noexcept(</span>
<span class="lineNum">   10836 </span>            :                 JSONSerializer&lt;U&gt;::to_json(std::declval&lt;basic_json_t&amp;&gt;(),
<span class="lineNum">   10837 </span>            :                                            std::forward&lt;CompatibleType&gt;(val))))
<span class="lineNum">   10838 </span><span class="lineCov">        386 :     {</span>
<span class="lineNum">   10839 </span><span class="lineCov">        386 :         JSONSerializer&lt;U&gt;::to_json(*this, std::forward&lt;CompatibleType&gt;(val));</span>
<span class="lineNum">   10840 </span><span class="lineCov">        386 :         assert_invariant();</span>
<span class="lineNum">   10841 </span><span class="lineCov">        386 :     }</span>
<span class="lineNum">   10842 </span>            : 
<span class="lineNum">   10843 </span>            :     /*!
<span class="lineNum">   10844 </span>            :     @brief create a container (array or object) from an initializer list
<span class="lineNum">   10845 </span>            : 
<span class="lineNum">   10846 </span>            :     Creates a JSON value of type array or object from the passed initializer
<span class="lineNum">   10847 </span>            :     list @a init. In case @a type_deduction is `true` (default), the type of
<span class="lineNum">   10848 </span>            :     the JSON value to be created is deducted from the initializer list @a init
<span class="lineNum">   10849 </span>            :     according to the following rules:
<span class="lineNum">   10850 </span>            : 
<span class="lineNum">   10851 </span>            :     1. If the list is empty, an empty JSON object value `{}` is created.
<span class="lineNum">   10852 </span>            :     2. If the list consists of pairs whose first element is a string, a JSON
<span class="lineNum">   10853 </span>            :        object value is created where the first elements of the pairs are
<span class="lineNum">   10854 </span>            :        treated as keys and the second elements are as values.
<span class="lineNum">   10855 </span>            :     3. In all other cases, an array is created.
<span class="lineNum">   10856 </span>            : 
<span class="lineNum">   10857 </span>            :     The rules aim to create the best fit between a C++ initializer list and
<span class="lineNum">   10858 </span>            :     JSON values. The rationale is as follows:
<span class="lineNum">   10859 </span>            : 
<span class="lineNum">   10860 </span>            :     1. The empty initializer list is written as `{}` which is exactly an empty
<span class="lineNum">   10861 </span>            :        JSON object.
<span class="lineNum">   10862 </span>            :     2. C++ has no way of describing mapped types other than to list a list of
<span class="lineNum">   10863 </span>            :        pairs. As JSON requires that keys must be of type string, rule 2 is the
<span class="lineNum">   10864 </span>            :        weakest constraint one can pose on initializer lists to interpret them
<span class="lineNum">   10865 </span>            :        as an object.
<span class="lineNum">   10866 </span>            :     3. In all other cases, the initializer list could not be interpreted as
<span class="lineNum">   10867 </span>            :        JSON object type, so interpreting it as JSON array type is safe.
<span class="lineNum">   10868 </span>            : 
<span class="lineNum">   10869 </span>            :     With the rules described above, the following JSON values cannot be
<span class="lineNum">   10870 </span>            :     expressed by an initializer list:
<span class="lineNum">   10871 </span>            : 
<span class="lineNum">   10872 </span>            :     - the empty array (`[]`): use @ref array(initializer_list_t)
<span class="lineNum">   10873 </span>            :       with an empty initializer list in this case
<span class="lineNum">   10874 </span>            :     - arrays whose elements satisfy rule 2: use @ref
<span class="lineNum">   10875 </span>            :       array(initializer_list_t) with the same initializer list
<span class="lineNum">   10876 </span>            :       in this case
<span class="lineNum">   10877 </span>            : 
<span class="lineNum">   10878 </span>            :     @note When used without parentheses around an empty initializer list, @ref
<span class="lineNum">   10879 </span>            :     basic_json() is called instead of this function, yielding the JSON null
<span class="lineNum">   10880 </span>            :     value.
<span class="lineNum">   10881 </span>            : 
<span class="lineNum">   10882 </span>            :     @param[in] init  initializer list with JSON values
<span class="lineNum">   10883 </span>            : 
<span class="lineNum">   10884 </span>            :     @param[in] type_deduction internal parameter; when set to `true`, the type
<span class="lineNum">   10885 </span>            :     of the JSON value is deducted from the initializer list @a init; when set
<span class="lineNum">   10886 </span>            :     to `false`, the type provided via @a manual_type is forced. This mode is
<span class="lineNum">   10887 </span>            :     used by the functions @ref array(initializer_list_t) and
<span class="lineNum">   10888 </span>            :     @ref object(initializer_list_t).
<span class="lineNum">   10889 </span>            : 
<span class="lineNum">   10890 </span>            :     @param[in] manual_type internal parameter; when @a type_deduction is set
<span class="lineNum">   10891 </span>            :     to `false`, the created JSON value will use the provided type (only @ref
<span class="lineNum">   10892 </span>            :     value_t::array and @ref value_t::object are valid); when @a type_deduction
<span class="lineNum">   10893 </span>            :     is set to `true`, this parameter has no effect
<span class="lineNum">   10894 </span>            : 
<span class="lineNum">   10895 </span>            :     @throw type_error.301 if @a type_deduction is `false`, @a manual_type is
<span class="lineNum">   10896 </span>            :     `value_t::object`, but @a init contains an element which is not a pair
<span class="lineNum">   10897 </span>            :     whose first element is a string. In this case, the constructor could not
<span class="lineNum">   10898 </span>            :     create an object. If @a type_deduction would have be `true`, an array
<span class="lineNum">   10899 </span>            :     would have been created. See @ref object(initializer_list_t)
<span class="lineNum">   10900 </span>            :     for an example.
<span class="lineNum">   10901 </span>            : 
<span class="lineNum">   10902 </span>            :     @complexity Linear in the size of the initializer list @a init.
<span class="lineNum">   10903 </span>            : 
<span class="lineNum">   10904 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   10905 </span>            :     changes to any JSON value.
<span class="lineNum">   10906 </span>            : 
<span class="lineNum">   10907 </span>            :     @liveexample{The example below shows how JSON values are created from
<span class="lineNum">   10908 </span>            :     initializer lists.,basic_json__list_init_t}
<span class="lineNum">   10909 </span>            : 
<span class="lineNum">   10910 </span>            :     @sa @ref array(initializer_list_t) -- create a JSON array
<span class="lineNum">   10911 </span>            :     value from an initializer list
<span class="lineNum">   10912 </span>            :     @sa @ref object(initializer_list_t) -- create a JSON object
<span class="lineNum">   10913 </span>            :     value from an initializer list
<span class="lineNum">   10914 </span>            : 
<a name="10915"><span class="lineNum">   10915 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   10916 </span>            :     */
<span class="lineNum">   10917 </span><span class="lineCov">        317 :     basic_json(initializer_list_t init,</span>
<span class="lineNum">   10918 </span>            :                bool type_deduction = true,
<span class="lineNum">   10919 </span>            :                value_t manual_type = value_t::array)
<span class="lineNum">   10920 </span><span class="lineCov">        317 :     {</span>
<span class="lineNum">   10921 </span>            :         // check if each element is an array with two elements whose first
<a name="10922"><span class="lineNum">   10922 </span>            :         // element is a string</a>
<span class="lineNum">   10923 </span><span class="lineCov">        634 :         bool is_an_object = std::all_of(init.begin(), init.end(),</span>
<span class="lineNum">   10924 </span><span class="lineCov">        462 :                                         [](const detail::json_ref&lt;basic_json&gt;&amp; element_ref)</span>
<span class="lineNum">   10925 </span>            :         {
<span class="lineNum">   10926 </span><span class="lineCov">        462 :             return (element_ref-&gt;is_array() and element_ref-&gt;size() == 2 and (*element_ref)[0].is_string());</span>
<span class="lineNum">   10927 </span><span class="lineCov">        779 :         });</span>
<span class="lineNum">   10928 </span>            : 
<span class="lineNum">   10929 </span>            :         // adjust type if type deduction is not wanted
<span class="lineNum">   10930 </span><span class="lineCov">        317 :         if (not type_deduction)</span>
<span class="lineNum">   10931 </span>            :         {
<span class="lineNum">   10932 </span>            :             // if array is wanted, do not create an object though possible
<span class="lineNum">   10933 </span><span class="lineCov">         12 :             if (manual_type == value_t::array)</span>
<span class="lineNum">   10934 </span>            :             {
<span class="lineNum">   10935 </span><span class="lineCov">         12 :                 is_an_object = false;</span>
<span class="lineNum">   10936 </span>            :             }
<span class="lineNum">   10937 </span>            : 
<span class="lineNum">   10938 </span>            :             // if object is wanted but impossible, throw an exception
<span class="lineNum">   10939 </span><span class="lineCov">         12 :             if (JSON_UNLIKELY(manual_type == value_t::object and not is_an_object))</span>
<span class="lineNum">   10940 </span>            :             {
<span class="lineNum">   10941 </span><span class="lineNoCov">          0 :                 JSON_THROW(type_error::create(301, &quot;cannot create object from initializer list&quot;));</span>
<span class="lineNum">   10942 </span>            :             }
<span class="lineNum">   10943 </span>            :         }
<span class="lineNum">   10944 </span>            : 
<span class="lineNum">   10945 </span><span class="lineCov">        317 :         if (is_an_object)</span>
<span class="lineNum">   10946 </span>            :         {
<span class="lineNum">   10947 </span>            :             // the initializer list is a list of pairs -&gt; create object
<span class="lineNum">   10948 </span><span class="lineCov">         80 :             m_type = value_t::object;</span>
<a name="10949"><span class="lineNum">   10949 </span><span class="lineCov">         80 :             m_value = value_t::object;</span></a>
<span class="lineNum">   10950 </span>            : 
<span class="lineNum">   10951 </span><span class="lineCov">        305 :             std::for_each(init.begin(), init.end(), [this](const detail::json_ref&lt;basic_json&gt;&amp; element_ref)</span>
<span class="lineNum">   10952 </span><span class="lineCov">        225 :             {</span>
<span class="lineNum">   10953 </span><span class="lineCov">        450 :                 auto element = element_ref.moved_or_copied();</span>
<span class="lineNum">   10954 </span><span class="lineCov">        225 :                 m_value.object-&gt;emplace(</span>
<span class="lineNum">   10955 </span><span class="lineCov">        225 :                     std::move(*((*element.m_value.array)[0].m_value.string)),</span>
<span class="lineNum">   10956 </span><span class="lineCov">        225 :                     std::move((*element.m_value.array)[1]));</span>
<span class="lineNum">   10957 </span><span class="lineCov">        225 :             });</span>
<span class="lineNum">   10958 </span>            :         }
<span class="lineNum">   10959 </span>            :         else
<span class="lineNum">   10960 </span>            :         {
<span class="lineNum">   10961 </span>            :             // the initializer list describes an array -&gt; create array
<span class="lineNum">   10962 </span><span class="lineCov">        237 :             m_type = value_t::array;</span>
<span class="lineNum">   10963 </span><span class="lineCov">        237 :             m_value.array = create&lt;array_t&gt;(init.begin(), init.end());</span>
<span class="lineNum">   10964 </span>            :         }
<span class="lineNum">   10965 </span>            : 
<span class="lineNum">   10966 </span><span class="lineCov">        317 :         assert_invariant();</span>
<span class="lineNum">   10967 </span><span class="lineCov">        317 :     }</span>
<span class="lineNum">   10968 </span>            : 
<span class="lineNum">   10969 </span>            :     /*!
<span class="lineNum">   10970 </span>            :     @brief explicitly create an array from an initializer list
<span class="lineNum">   10971 </span>            : 
<span class="lineNum">   10972 </span>            :     Creates a JSON array value from a given initializer list. That is, given a
<span class="lineNum">   10973 </span>            :     list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
<span class="lineNum">   10974 </span>            :     initializer list is empty, the empty array `[]` is created.
<span class="lineNum">   10975 </span>            : 
<span class="lineNum">   10976 </span>            :     @note This function is only needed to express two edge cases that cannot
<span class="lineNum">   10977 </span>            :     be realized with the initializer list constructor (@ref
<span class="lineNum">   10978 </span>            :     basic_json(initializer_list_t, bool, value_t)). These cases
<span class="lineNum">   10979 </span>            :     are:
<span class="lineNum">   10980 </span>            :     1. creating an array whose elements are all pairs whose first element is a
<span class="lineNum">   10981 </span>            :     string -- in this case, the initializer list constructor would create an
<span class="lineNum">   10982 </span>            :     object, taking the first elements as keys
<span class="lineNum">   10983 </span>            :     2. creating an empty array -- passing the empty initializer list to the
<span class="lineNum">   10984 </span>            :     initializer list constructor yields an empty object
<span class="lineNum">   10985 </span>            : 
<span class="lineNum">   10986 </span>            :     @param[in] init  initializer list with JSON values to create an array from
<span class="lineNum">   10987 </span>            :     (optional)
<span class="lineNum">   10988 </span>            : 
<span class="lineNum">   10989 </span>            :     @return JSON array value
<span class="lineNum">   10990 </span>            : 
<span class="lineNum">   10991 </span>            :     @complexity Linear in the size of @a init.
<span class="lineNum">   10992 </span>            : 
<span class="lineNum">   10993 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   10994 </span>            :     changes to any JSON value.
<span class="lineNum">   10995 </span>            : 
<span class="lineNum">   10996 </span>            :     @liveexample{The following code shows an example for the `array`
<span class="lineNum">   10997 </span>            :     function.,array}
<span class="lineNum">   10998 </span>            : 
<span class="lineNum">   10999 </span>            :     @sa @ref basic_json(initializer_list_t, bool, value_t) --
<span class="lineNum">   11000 </span>            :     create a JSON value from an initializer list
<span class="lineNum">   11001 </span>            :     @sa @ref object(initializer_list_t) -- create a JSON object
<span class="lineNum">   11002 </span>            :     value from an initializer list
<span class="lineNum">   11003 </span>            : 
<a name="11004"><span class="lineNum">   11004 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11005 </span>            :     */
<span class="lineNum">   11006 </span><span class="lineCov">         12 :     static basic_json array(initializer_list_t init = {})</span>
<span class="lineNum">   11007 </span>            :     {
<span class="lineNum">   11008 </span><span class="lineCov">         12 :         return basic_json(init, false, value_t::array);</span>
<span class="lineNum">   11009 </span>            :     }
<span class="lineNum">   11010 </span>            : 
<span class="lineNum">   11011 </span>            :     /*!
<span class="lineNum">   11012 </span>            :     @brief explicitly create an object from an initializer list
<span class="lineNum">   11013 </span>            : 
<span class="lineNum">   11014 </span>            :     Creates a JSON object value from a given initializer list. The initializer
<span class="lineNum">   11015 </span>            :     lists elements must be pairs, and their first elements must be strings. If
<span class="lineNum">   11016 </span>            :     the initializer list is empty, the empty object `{}` is created.
<span class="lineNum">   11017 </span>            : 
<span class="lineNum">   11018 </span>            :     @note This function is only added for symmetry reasons. In contrast to the
<span class="lineNum">   11019 </span>            :     related function @ref array(initializer_list_t), there are
<span class="lineNum">   11020 </span>            :     no cases which can only be expressed by this function. That is, any
<span class="lineNum">   11021 </span>            :     initializer list @a init can also be passed to the initializer list
<span class="lineNum">   11022 </span>            :     constructor @ref basic_json(initializer_list_t, bool, value_t).
<span class="lineNum">   11023 </span>            : 
<span class="lineNum">   11024 </span>            :     @param[in] init  initializer list to create an object from (optional)
<span class="lineNum">   11025 </span>            : 
<span class="lineNum">   11026 </span>            :     @return JSON object value
<span class="lineNum">   11027 </span>            : 
<span class="lineNum">   11028 </span>            :     @throw type_error.301 if @a init is not a list of pairs whose first
<span class="lineNum">   11029 </span>            :     elements are strings. In this case, no object can be created. When such a
<span class="lineNum">   11030 </span>            :     value is passed to @ref basic_json(initializer_list_t, bool, value_t),
<span class="lineNum">   11031 </span>            :     an array would have been created from the passed initializer list @a init.
<span class="lineNum">   11032 </span>            :     See example below.
<span class="lineNum">   11033 </span>            : 
<span class="lineNum">   11034 </span>            :     @complexity Linear in the size of @a init.
<span class="lineNum">   11035 </span>            : 
<span class="lineNum">   11036 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   11037 </span>            :     changes to any JSON value.
<span class="lineNum">   11038 </span>            : 
<span class="lineNum">   11039 </span>            :     @liveexample{The following code shows an example for the `object`
<span class="lineNum">   11040 </span>            :     function.,object}
<span class="lineNum">   11041 </span>            : 
<span class="lineNum">   11042 </span>            :     @sa @ref basic_json(initializer_list_t, bool, value_t) --
<span class="lineNum">   11043 </span>            :     create a JSON value from an initializer list
<span class="lineNum">   11044 </span>            :     @sa @ref array(initializer_list_t) -- create a JSON array
<span class="lineNum">   11045 </span>            :     value from an initializer list
<span class="lineNum">   11046 </span>            : 
<span class="lineNum">   11047 </span>            :     @since version 1.0.0
<span class="lineNum">   11048 </span>            :     */
<span class="lineNum">   11049 </span>            :     static basic_json object(initializer_list_t init = {})
<span class="lineNum">   11050 </span>            :     {
<span class="lineNum">   11051 </span>            :         return basic_json(init, false, value_t::object);
<span class="lineNum">   11052 </span>            :     }
<span class="lineNum">   11053 </span>            : 
<span class="lineNum">   11054 </span>            :     /*!
<span class="lineNum">   11055 </span>            :     @brief construct an array with count copies of given value
<span class="lineNum">   11056 </span>            : 
<span class="lineNum">   11057 </span>            :     Constructs a JSON array value by creating @a cnt copies of a passed value.
<span class="lineNum">   11058 </span>            :     In case @a cnt is `0`, an empty array is created.
<span class="lineNum">   11059 </span>            : 
<span class="lineNum">   11060 </span>            :     @param[in] cnt  the number of JSON copies of @a val to create
<span class="lineNum">   11061 </span>            :     @param[in] val  the JSON value to copy
<span class="lineNum">   11062 </span>            : 
<span class="lineNum">   11063 </span>            :     @post `std::distance(begin(),end()) == cnt` holds.
<span class="lineNum">   11064 </span>            : 
<span class="lineNum">   11065 </span>            :     @complexity Linear in @a cnt.
<span class="lineNum">   11066 </span>            : 
<span class="lineNum">   11067 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   11068 </span>            :     changes to any JSON value.
<span class="lineNum">   11069 </span>            : 
<span class="lineNum">   11070 </span>            :     @liveexample{The following code shows examples for the @ref
<span class="lineNum">   11071 </span>            :     basic_json(size_type\, const basic_json&amp;)
<span class="lineNum">   11072 </span>            :     constructor.,basic_json__size_type_basic_json}
<span class="lineNum">   11073 </span>            : 
<span class="lineNum">   11074 </span>            :     @since version 1.0.0
<span class="lineNum">   11075 </span>            :     */
<span class="lineNum">   11076 </span>            :     basic_json(size_type cnt, const basic_json&amp; val)
<span class="lineNum">   11077 </span>            :         : m_type(value_t::array)
<span class="lineNum">   11078 </span>            :     {
<span class="lineNum">   11079 </span>            :         m_value.array = create&lt;array_t&gt;(cnt, val);
<span class="lineNum">   11080 </span>            :         assert_invariant();
<span class="lineNum">   11081 </span>            :     }
<span class="lineNum">   11082 </span>            : 
<span class="lineNum">   11083 </span>            :     /*!
<span class="lineNum">   11084 </span>            :     @brief construct a JSON container given an iterator range
<span class="lineNum">   11085 </span>            : 
<span class="lineNum">   11086 </span>            :     Constructs the JSON value with the contents of the range `[first, last)`.
<span class="lineNum">   11087 </span>            :     The semantics depends on the different types a JSON value can have:
<span class="lineNum">   11088 </span>            :     - In case of a null type, invalid_iterator.206 is thrown.
<span class="lineNum">   11089 </span>            :     - In case of other primitive types (number, boolean, or string), @a first
<span class="lineNum">   11090 </span>            :       must be `begin()` and @a last must be `end()`. In this case, the value is
<span class="lineNum">   11091 </span>            :       copied. Otherwise, invalid_iterator.204 is thrown.
<span class="lineNum">   11092 </span>            :     - In case of structured types (array, object), the constructor behaves as
<span class="lineNum">   11093 </span>            :       similar versions for `std::vector` or `std::map`; that is, a JSON array
<span class="lineNum">   11094 </span>            :       or object is constructed from the values in the range.
<span class="lineNum">   11095 </span>            : 
<span class="lineNum">   11096 </span>            :     @tparam InputIT an input iterator type (@ref iterator or @ref
<span class="lineNum">   11097 </span>            :     const_iterator)
<span class="lineNum">   11098 </span>            : 
<span class="lineNum">   11099 </span>            :     @param[in] first begin of the range to copy from (included)
<span class="lineNum">   11100 </span>            :     @param[in] last end of the range to copy from (excluded)
<span class="lineNum">   11101 </span>            : 
<span class="lineNum">   11102 </span>            :     @pre Iterators @a first and @a last must be initialized. **This
<span class="lineNum">   11103 </span>            :          precondition is enforced with an assertion (see warning).** If
<span class="lineNum">   11104 </span>            :          assertions are switched off, a violation of this precondition yields
<span class="lineNum">   11105 </span>            :          undefined behavior.
<span class="lineNum">   11106 </span>            : 
<span class="lineNum">   11107 </span>            :     @pre Range `[first, last)` is valid. Usually, this precondition cannot be
<span class="lineNum">   11108 </span>            :          checked efficiently. Only certain edge cases are detected; see the
<span class="lineNum">   11109 </span>            :          description of the exceptions below. A violation of this precondition
<span class="lineNum">   11110 </span>            :          yields undefined behavior.
<span class="lineNum">   11111 </span>            : 
<span class="lineNum">   11112 </span>            :     @warning A precondition is enforced with a runtime assertion that will
<span class="lineNum">   11113 </span>            :              result in calling `std::abort` if this precondition is not met.
<span class="lineNum">   11114 </span>            :              Assertions can be disabled by defining `NDEBUG` at compile time.
<span class="lineNum">   11115 </span>            :              See http://en.cppreference.com/w/cpp/error/assert for more
<span class="lineNum">   11116 </span>            :              information.
<span class="lineNum">   11117 </span>            : 
<span class="lineNum">   11118 </span>            :     @throw invalid_iterator.201 if iterators @a first and @a last are not
<span class="lineNum">   11119 </span>            :     compatible (i.e., do not belong to the same JSON value). In this case,
<span class="lineNum">   11120 </span>            :     the range `[first, last)` is undefined.
<span class="lineNum">   11121 </span>            :     @throw invalid_iterator.204 if iterators @a first and @a last belong to a
<span class="lineNum">   11122 </span>            :     primitive type (number, boolean, or string), but @a first does not point
<span class="lineNum">   11123 </span>            :     to the first element any more. In this case, the range `[first, last)` is
<span class="lineNum">   11124 </span>            :     undefined. See example code below.
<span class="lineNum">   11125 </span>            :     @throw invalid_iterator.206 if iterators @a first and @a last belong to a
<span class="lineNum">   11126 </span>            :     null value. In this case, the range `[first, last)` is undefined.
<span class="lineNum">   11127 </span>            : 
<span class="lineNum">   11128 </span>            :     @complexity Linear in distance between @a first and @a last.
<span class="lineNum">   11129 </span>            : 
<span class="lineNum">   11130 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   11131 </span>            :     changes to any JSON value.
<span class="lineNum">   11132 </span>            : 
<span class="lineNum">   11133 </span>            :     @liveexample{The example below shows several ways to create JSON values by
<span class="lineNum">   11134 </span>            :     specifying a subrange with iterators.,basic_json__InputIt_InputIt}
<span class="lineNum">   11135 </span>            : 
<span class="lineNum">   11136 </span>            :     @since version 1.0.0
<span class="lineNum">   11137 </span>            :     */
<span class="lineNum">   11138 </span>            :     template&lt;class InputIT, typename std::enable_if&lt;
<span class="lineNum">   11139 </span>            :                  std::is_same&lt;InputIT, typename basic_json_t::iterator&gt;::value or
<span class="lineNum">   11140 </span>            :                  std::is_same&lt;InputIT, typename basic_json_t::const_iterator&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   11141 </span>            :     basic_json(InputIT first, InputIT last)
<span class="lineNum">   11142 </span>            :     {
<span class="lineNum">   11143 </span>            :         assert(first.m_object != nullptr);
<span class="lineNum">   11144 </span>            :         assert(last.m_object != nullptr);
<span class="lineNum">   11145 </span>            : 
<span class="lineNum">   11146 </span>            :         // make sure iterator fits the current value
<span class="lineNum">   11147 </span>            :         if (JSON_UNLIKELY(first.m_object != last.m_object))
<span class="lineNum">   11148 </span>            :         {
<span class="lineNum">   11149 </span>            :             JSON_THROW(invalid_iterator::create(201, &quot;iterators are not compatible&quot;));
<span class="lineNum">   11150 </span>            :         }
<span class="lineNum">   11151 </span>            : 
<span class="lineNum">   11152 </span>            :         // copy type from first iterator
<span class="lineNum">   11153 </span>            :         m_type = first.m_object-&gt;m_type;
<span class="lineNum">   11154 </span>            : 
<span class="lineNum">   11155 </span>            :         // check if iterator range is complete for primitive values
<span class="lineNum">   11156 </span>            :         switch (m_type)
<span class="lineNum">   11157 </span>            :         {
<span class="lineNum">   11158 </span>            :             case value_t::boolean:
<span class="lineNum">   11159 </span>            :             case value_t::number_float:
<span class="lineNum">   11160 </span>            :             case value_t::number_integer:
<span class="lineNum">   11161 </span>            :             case value_t::number_unsigned:
<span class="lineNum">   11162 </span>            :             case value_t::string:
<span class="lineNum">   11163 </span>            :             {
<span class="lineNum">   11164 </span>            :                 if (JSON_UNLIKELY(not first.m_it.primitive_iterator.is_begin()
<span class="lineNum">   11165 </span>            :                                   or not last.m_it.primitive_iterator.is_end()))
<span class="lineNum">   11166 </span>            :                 {
<span class="lineNum">   11167 </span>            :                     JSON_THROW(invalid_iterator::create(204, &quot;iterators out of range&quot;));
<span class="lineNum">   11168 </span>            :                 }
<span class="lineNum">   11169 </span>            :                 break;
<span class="lineNum">   11170 </span>            :             }
<span class="lineNum">   11171 </span>            : 
<span class="lineNum">   11172 </span>            :             default:
<span class="lineNum">   11173 </span>            :                 break;
<span class="lineNum">   11174 </span>            :         }
<span class="lineNum">   11175 </span>            : 
<span class="lineNum">   11176 </span>            :         switch (m_type)
<span class="lineNum">   11177 </span>            :         {
<span class="lineNum">   11178 </span>            :             case value_t::number_integer:
<span class="lineNum">   11179 </span>            :             {
<span class="lineNum">   11180 </span>            :                 m_value.number_integer = first.m_object-&gt;m_value.number_integer;
<span class="lineNum">   11181 </span>            :                 break;
<span class="lineNum">   11182 </span>            :             }
<span class="lineNum">   11183 </span>            : 
<span class="lineNum">   11184 </span>            :             case value_t::number_unsigned:
<span class="lineNum">   11185 </span>            :             {
<span class="lineNum">   11186 </span>            :                 m_value.number_unsigned = first.m_object-&gt;m_value.number_unsigned;
<span class="lineNum">   11187 </span>            :                 break;
<span class="lineNum">   11188 </span>            :             }
<span class="lineNum">   11189 </span>            : 
<span class="lineNum">   11190 </span>            :             case value_t::number_float:
<span class="lineNum">   11191 </span>            :             {
<span class="lineNum">   11192 </span>            :                 m_value.number_float = first.m_object-&gt;m_value.number_float;
<span class="lineNum">   11193 </span>            :                 break;
<span class="lineNum">   11194 </span>            :             }
<span class="lineNum">   11195 </span>            : 
<span class="lineNum">   11196 </span>            :             case value_t::boolean:
<span class="lineNum">   11197 </span>            :             {
<span class="lineNum">   11198 </span>            :                 m_value.boolean = first.m_object-&gt;m_value.boolean;
<span class="lineNum">   11199 </span>            :                 break;
<span class="lineNum">   11200 </span>            :             }
<span class="lineNum">   11201 </span>            : 
<span class="lineNum">   11202 </span>            :             case value_t::string:
<span class="lineNum">   11203 </span>            :             {
<span class="lineNum">   11204 </span>            :                 m_value = *first.m_object-&gt;m_value.string;
<span class="lineNum">   11205 </span>            :                 break;
<span class="lineNum">   11206 </span>            :             }
<span class="lineNum">   11207 </span>            : 
<span class="lineNum">   11208 </span>            :             case value_t::object:
<span class="lineNum">   11209 </span>            :             {
<span class="lineNum">   11210 </span>            :                 m_value.object = create&lt;object_t&gt;(first.m_it.object_iterator,
<span class="lineNum">   11211 </span>            :                                                   last.m_it.object_iterator);
<span class="lineNum">   11212 </span>            :                 break;
<span class="lineNum">   11213 </span>            :             }
<span class="lineNum">   11214 </span>            : 
<span class="lineNum">   11215 </span>            :             case value_t::array:
<span class="lineNum">   11216 </span>            :             {
<span class="lineNum">   11217 </span>            :                 m_value.array = create&lt;array_t&gt;(first.m_it.array_iterator,
<span class="lineNum">   11218 </span>            :                                                 last.m_it.array_iterator);
<span class="lineNum">   11219 </span>            :                 break;
<span class="lineNum">   11220 </span>            :             }
<span class="lineNum">   11221 </span>            : 
<span class="lineNum">   11222 </span>            :             default:
<span class="lineNum">   11223 </span>            :                 JSON_THROW(invalid_iterator::create(206, &quot;cannot construct with iterators from &quot; +
<span class="lineNum">   11224 </span>            :                                                     std::string(first.m_object-&gt;type_name())));
<span class="lineNum">   11225 </span>            :         }
<span class="lineNum">   11226 </span>            : 
<span class="lineNum">   11227 </span>            :         assert_invariant();
<span class="lineNum">   11228 </span>            :     }
<span class="lineNum">   11229 </span>            : 
<span class="lineNum">   11230 </span>            : 
<span class="lineNum">   11231 </span>            :     ///////////////////////////////////////
<span class="lineNum">   11232 </span>            :     // other constructors and destructor //
<span class="lineNum">   11233 </span>            :     ///////////////////////////////////////
<a name="11234"><span class="lineNum">   11234 </span>            : </a>
<span class="lineNum">   11235 </span>            :     /// @private
<span class="lineNum">   11236 </span><span class="lineCov">        462 :     basic_json(const detail::json_ref&lt;basic_json&gt;&amp; ref)</span>
<span class="lineNum">   11237 </span><span class="lineCov">        462 :         : basic_json(ref.moved_or_copied())</span>
<span class="lineNum">   11238 </span><span class="lineCov">        462 :     {}</span>
<span class="lineNum">   11239 </span>            : 
<span class="lineNum">   11240 </span>            :     /*!
<span class="lineNum">   11241 </span>            :     @brief copy constructor
<span class="lineNum">   11242 </span>            : 
<span class="lineNum">   11243 </span>            :     Creates a copy of a given JSON value.
<span class="lineNum">   11244 </span>            : 
<span class="lineNum">   11245 </span>            :     @param[in] other  the JSON value to copy
<span class="lineNum">   11246 </span>            : 
<span class="lineNum">   11247 </span>            :     @post `*this == other`
<span class="lineNum">   11248 </span>            : 
<span class="lineNum">   11249 </span>            :     @complexity Linear in the size of @a other.
<span class="lineNum">   11250 </span>            : 
<span class="lineNum">   11251 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   11252 </span>            :     changes to any JSON value.
<span class="lineNum">   11253 </span>            : 
<span class="lineNum">   11254 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   11255 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   11256 </span>            :     requirements:
<span class="lineNum">   11257 </span>            :     - The complexity is linear.
<span class="lineNum">   11258 </span>            :     - As postcondition, it holds: `other == basic_json(other)`.
<span class="lineNum">   11259 </span>            : 
<span class="lineNum">   11260 </span>            :     @liveexample{The following code shows an example for the copy
<span class="lineNum">   11261 </span>            :     constructor.,basic_json__basic_json}
<span class="lineNum">   11262 </span>            : 
<a name="11263"><span class="lineNum">   11263 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11264 </span>            :     */
<span class="lineNum">   11265 </span><span class="lineCov">        304 :     basic_json(const basic_json&amp; other)</span>
<span class="lineNum">   11266 </span><span class="lineCov">        304 :         : m_type(other.m_type)</span>
<span class="lineNum">   11267 </span>            :     {
<span class="lineNum">   11268 </span>            :         // check of passed value is valid
<span class="lineNum">   11269 </span><span class="lineCov">        304 :         other.assert_invariant();</span>
<span class="lineNum">   11270 </span>            : 
<span class="lineNum">   11271 </span><span class="lineCov">        304 :         switch (m_type)</span>
<span class="lineNum">   11272 </span>            :         {
<span class="lineNum">   11273 </span>            :             case value_t::object:
<span class="lineNum">   11274 </span>            :             {
<span class="lineNum">   11275 </span><span class="lineCov">         26 :                 m_value = *other.m_value.object;</span>
<span class="lineNum">   11276 </span><span class="lineCov">         26 :                 break;</span>
<span class="lineNum">   11277 </span>            :             }
<span class="lineNum">   11278 </span>            : 
<span class="lineNum">   11279 </span>            :             case value_t::array:
<span class="lineNum">   11280 </span>            :             {
<span class="lineNum">   11281 </span><span class="lineNoCov">          0 :                 m_value = *other.m_value.array;</span>
<span class="lineNum">   11282 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">   11283 </span>            :             }
<span class="lineNum">   11284 </span>            : 
<span class="lineNum">   11285 </span>            :             case value_t::string:
<span class="lineNum">   11286 </span>            :             {
<span class="lineNum">   11287 </span><span class="lineCov">         31 :                 m_value = *other.m_value.string;</span>
<span class="lineNum">   11288 </span><span class="lineCov">         31 :                 break;</span>
<span class="lineNum">   11289 </span>            :             }
<span class="lineNum">   11290 </span>            : 
<span class="lineNum">   11291 </span>            :             case value_t::boolean:
<span class="lineNum">   11292 </span>            :             {
<span class="lineNum">   11293 </span><span class="lineCov">          1 :                 m_value = other.m_value.boolean;</span>
<span class="lineNum">   11294 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">   11295 </span>            :             }
<span class="lineNum">   11296 </span>            : 
<span class="lineNum">   11297 </span>            :             case value_t::number_integer:
<span class="lineNum">   11298 </span>            :             {
<span class="lineNum">   11299 </span><span class="lineCov">         21 :                 m_value = other.m_value.number_integer;</span>
<span class="lineNum">   11300 </span><span class="lineCov">         21 :                 break;</span>
<span class="lineNum">   11301 </span>            :             }
<span class="lineNum">   11302 </span>            : 
<span class="lineNum">   11303 </span>            :             case value_t::number_unsigned:
<span class="lineNum">   11304 </span>            :             {
<span class="lineNum">   11305 </span><span class="lineCov">        219 :                 m_value = other.m_value.number_unsigned;</span>
<span class="lineNum">   11306 </span><span class="lineCov">        219 :                 break;</span>
<span class="lineNum">   11307 </span>            :             }
<span class="lineNum">   11308 </span>            : 
<span class="lineNum">   11309 </span>            :             case value_t::number_float:
<span class="lineNum">   11310 </span>            :             {
<span class="lineNum">   11311 </span><span class="lineNoCov">          0 :                 m_value = other.m_value.number_float;</span>
<span class="lineNum">   11312 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">   11313 </span>            :             }
<span class="lineNum">   11314 </span>            : 
<span class="lineNum">   11315 </span>            :             default:
<span class="lineNum">   11316 </span><span class="lineCov">          6 :                 break;</span>
<span class="lineNum">   11317 </span>            :         }
<span class="lineNum">   11318 </span>            : 
<span class="lineNum">   11319 </span><span class="lineCov">        304 :         assert_invariant();</span>
<span class="lineNum">   11320 </span><span class="lineCov">        304 :     }</span>
<span class="lineNum">   11321 </span>            : 
<span class="lineNum">   11322 </span>            :     /*!
<span class="lineNum">   11323 </span>            :     @brief move constructor
<span class="lineNum">   11324 </span>            : 
<span class="lineNum">   11325 </span>            :     Move constructor. Constructs a JSON value with the contents of the given
<span class="lineNum">   11326 </span>            :     value @a other using move semantics. It &quot;steals&quot; the resources from @a
<span class="lineNum">   11327 </span>            :     other and leaves it as JSON null value.
<span class="lineNum">   11328 </span>            : 
<span class="lineNum">   11329 </span>            :     @param[in,out] other  value to move to this object
<span class="lineNum">   11330 </span>            : 
<span class="lineNum">   11331 </span>            :     @post `*this` has the same value as @a other before the call.
<span class="lineNum">   11332 </span>            :     @post @a other is a JSON null value.
<span class="lineNum">   11333 </span>            : 
<span class="lineNum">   11334 </span>            :     @complexity Constant.
<span class="lineNum">   11335 </span>            : 
<span class="lineNum">   11336 </span>            :     @exceptionsafety No-throw guarantee: this constructor never throws
<span class="lineNum">   11337 </span>            :     exceptions.
<span class="lineNum">   11338 </span>            : 
<span class="lineNum">   11339 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   11340 </span>            :     [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible)
<span class="lineNum">   11341 </span>            :     requirements.
<span class="lineNum">   11342 </span>            : 
<span class="lineNum">   11343 </span>            :     @liveexample{The code below shows the move constructor explicitly called
<span class="lineNum">   11344 </span>            :     via std::move.,basic_json__moveconstructor}
<span class="lineNum">   11345 </span>            : 
<a name="11346"><span class="lineNum">   11346 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11347 </span>            :     */
<span class="lineNum">   11348 </span><span class="lineCov">       1481 :     basic_json(basic_json&amp;&amp; other) noexcept</span>
<span class="lineNum">   11349 </span><span class="lineCov">       1481 :         : m_type(std::move(other.m_type)),</span>
<span class="lineNum">   11350 </span><span class="lineCov">       1481 :           m_value(std::move(other.m_value))</span>
<span class="lineNum">   11351 </span>            :     {
<span class="lineNum">   11352 </span>            :         // check that passed value is valid
<span class="lineNum">   11353 </span><span class="lineCov">       1481 :         other.assert_invariant();</span>
<span class="lineNum">   11354 </span>            : 
<span class="lineNum">   11355 </span>            :         // invalidate payload
<span class="lineNum">   11356 </span><span class="lineCov">       1481 :         other.m_type = value_t::null;</span>
<span class="lineNum">   11357 </span><span class="lineCov">       1481 :         other.m_value = {};</span>
<span class="lineNum">   11358 </span>            : 
<span class="lineNum">   11359 </span><span class="lineCov">       1481 :         assert_invariant();</span>
<span class="lineNum">   11360 </span><span class="lineCov">       1481 :     }</span>
<span class="lineNum">   11361 </span>            : 
<span class="lineNum">   11362 </span>            :     /*!
<span class="lineNum">   11363 </span>            :     @brief copy assignment
<span class="lineNum">   11364 </span>            : 
<span class="lineNum">   11365 </span>            :     Copy assignment operator. Copies a JSON value via the &quot;copy and swap&quot;
<span class="lineNum">   11366 </span>            :     strategy: It is expressed in terms of the copy constructor, destructor,
<span class="lineNum">   11367 </span>            :     and the `swap()` member function.
<span class="lineNum">   11368 </span>            : 
<span class="lineNum">   11369 </span>            :     @param[in] other  value to copy from
<span class="lineNum">   11370 </span>            : 
<span class="lineNum">   11371 </span>            :     @complexity Linear.
<span class="lineNum">   11372 </span>            : 
<span class="lineNum">   11373 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   11374 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   11375 </span>            :     requirements:
<span class="lineNum">   11376 </span>            :     - The complexity is linear.
<span class="lineNum">   11377 </span>            : 
<span class="lineNum">   11378 </span>            :     @liveexample{The code below shows and example for the copy assignment. It
<span class="lineNum">   11379 </span>            :     creates a copy of value `a` which is then swapped with `b`. Finally\, the
<span class="lineNum">   11380 </span>            :     copy of `a` (which is the null value after the swap) is
<span class="lineNum">   11381 </span>            :     destroyed.,basic_json__copyassignment}
<span class="lineNum">   11382 </span>            : 
<a name="11383"><span class="lineNum">   11383 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11384 </span>            :     */
<span class="lineNum">   11385 </span><span class="lineCov">         18 :     reference&amp; operator=(basic_json other) noexcept (</span>
<span class="lineNum">   11386 </span>            :         std::is_nothrow_move_constructible&lt;value_t&gt;::value and
<span class="lineNum">   11387 </span>            :         std::is_nothrow_move_assignable&lt;value_t&gt;::value and
<span class="lineNum">   11388 </span>            :         std::is_nothrow_move_constructible&lt;json_value&gt;::value and
<span class="lineNum">   11389 </span>            :         std::is_nothrow_move_assignable&lt;json_value&gt;::value
<span class="lineNum">   11390 </span>            :     )
<span class="lineNum">   11391 </span>            :     {
<span class="lineNum">   11392 </span>            :         // check that passed value is valid
<span class="lineNum">   11393 </span><span class="lineCov">         18 :         other.assert_invariant();</span>
<span class="lineNum">   11394 </span>            : 
<span class="lineNum">   11395 </span>            :         using std::swap;
<span class="lineNum">   11396 </span><span class="lineCov">         18 :         swap(m_type, other.m_type);</span>
<span class="lineNum">   11397 </span><span class="lineCov">         18 :         swap(m_value, other.m_value);</span>
<span class="lineNum">   11398 </span>            : 
<span class="lineNum">   11399 </span><span class="lineCov">         18 :         assert_invariant();</span>
<span class="lineNum">   11400 </span><span class="lineCov">         18 :         return *this;</span>
<span class="lineNum">   11401 </span>            :     }
<span class="lineNum">   11402 </span>            : 
<span class="lineNum">   11403 </span>            :     /*!
<span class="lineNum">   11404 </span>            :     @brief destructor
<span class="lineNum">   11405 </span>            : 
<span class="lineNum">   11406 </span>            :     Destroys the JSON value and frees all allocated memory.
<span class="lineNum">   11407 </span>            : 
<span class="lineNum">   11408 </span>            :     @complexity Linear.
<span class="lineNum">   11409 </span>            : 
<span class="lineNum">   11410 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   11411 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   11412 </span>            :     requirements:
<span class="lineNum">   11413 </span>            :     - The complexity is linear.
<span class="lineNum">   11414 </span>            :     - All stored elements are destroyed and all memory is freed.
<span class="lineNum">   11415 </span>            : 
<a name="11416"><span class="lineNum">   11416 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11417 </span>            :     */
<span class="lineNum">   11418 </span><span class="lineCov">       2991 :     ~basic_json() noexcept</span>
<span class="lineNum">   11419 </span>            :     {
<span class="lineNum">   11420 </span><span class="lineCov">       2991 :         assert_invariant();</span>
<span class="lineNum">   11421 </span><span class="lineCov">       2991 :         m_value.destroy(m_type);</span>
<span class="lineNum">   11422 </span><span class="lineCov">       2991 :     }</span>
<span class="lineNum">   11423 </span>            : 
<span class="lineNum">   11424 </span>            :     /// @}
<span class="lineNum">   11425 </span>            : 
<span class="lineNum">   11426 </span>            :   public:
<span class="lineNum">   11427 </span>            :     ///////////////////////
<span class="lineNum">   11428 </span>            :     // object inspection //
<span class="lineNum">   11429 </span>            :     ///////////////////////
<span class="lineNum">   11430 </span>            : 
<span class="lineNum">   11431 </span>            :     /// @name object inspection
<span class="lineNum">   11432 </span>            :     /// Functions to inspect the type of a JSON value.
<span class="lineNum">   11433 </span>            :     /// @{
<span class="lineNum">   11434 </span>            : 
<span class="lineNum">   11435 </span>            :     /*!
<span class="lineNum">   11436 </span>            :     @brief serialization
<span class="lineNum">   11437 </span>            : 
<span class="lineNum">   11438 </span>            :     Serialization function for JSON values. The function tries to mimic
<span class="lineNum">   11439 </span>            :     Python's `json.dumps()` function, and currently supports its @a indent
<span class="lineNum">   11440 </span>            :     and @a ensure_ascii parameters.
<span class="lineNum">   11441 </span>            : 
<span class="lineNum">   11442 </span>            :     @param[in] indent If indent is nonnegative, then array elements and object
<span class="lineNum">   11443 </span>            :     members will be pretty-printed with that indent level. An indent level of
<span class="lineNum">   11444 </span>            :     `0` will only insert newlines. `-1` (the default) selects the most compact
<span class="lineNum">   11445 </span>            :     representation.
<span class="lineNum">   11446 </span>            :     @param[in] indent_char The character to use for indentation if @a indent is
<span class="lineNum">   11447 </span>            :     greater than `0`. The default is ` ` (space).
<span class="lineNum">   11448 </span>            :     @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
<span class="lineNum">   11449 </span>            :     in the output are escaped with `\uXXXX` sequences, and the result consists
<span class="lineNum">   11450 </span>            :     of ASCII characters only.
<span class="lineNum">   11451 </span>            : 
<span class="lineNum">   11452 </span>            :     @return string containing the serialization of the JSON value
<span class="lineNum">   11453 </span>            : 
<span class="lineNum">   11454 </span>            :     @throw type_error.316 if a string stored inside the JSON value is not
<span class="lineNum">   11455 </span>            :                           UTF-8 encoded
<span class="lineNum">   11456 </span>            : 
<span class="lineNum">   11457 </span>            :     @complexity Linear.
<span class="lineNum">   11458 </span>            : 
<span class="lineNum">   11459 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   11460 </span>            :     changes in the JSON value.
<span class="lineNum">   11461 </span>            : 
<span class="lineNum">   11462 </span>            :     @liveexample{The following example shows the effect of different @a indent\,
<span class="lineNum">   11463 </span>            :     @a indent_char\, and @a ensure_ascii parameters to the result of the
<span class="lineNum">   11464 </span>            :     serialization.,dump}
<span class="lineNum">   11465 </span>            : 
<span class="lineNum">   11466 </span>            :     @see https://docs.python.org/2/library/json.html#json.dump
<span class="lineNum">   11467 </span>            : 
<span class="lineNum">   11468 </span>            :     @since version 1.0.0; indentation character @a indent_char, option
<a name="11469"><span class="lineNum">   11469 </span>            :            @a ensure_ascii and exceptions added in version 3.0.0</a>
<span class="lineNum">   11470 </span>            :     */
<span class="lineNum">   11471 </span><span class="lineCov">        123 :     string_t dump(const int indent = -1, const char indent_char = ' ',</span>
<span class="lineNum">   11472 </span>            :                   const bool ensure_ascii = false) const
<span class="lineNum">   11473 </span>            :     {
<span class="lineNum">   11474 </span><span class="lineCov">        123 :         string_t result;</span>
<span class="lineNum">   11475 </span><span class="lineCov">        246 :         serializer s(detail::output_adapter&lt;char&gt;(result), indent_char);</span>
<span class="lineNum">   11476 </span>            : 
<span class="lineNum">   11477 </span><span class="lineCov">        123 :         if (indent &gt;= 0)</span>
<span class="lineNum">   11478 </span>            :         {
<span class="lineNum">   11479 </span><span class="lineCov">        122 :             s.dump(*this, true, ensure_ascii, static_cast&lt;unsigned int&gt;(indent));</span>
<span class="lineNum">   11480 </span>            :         }
<span class="lineNum">   11481 </span>            :         else
<span class="lineNum">   11482 </span>            :         {
<span class="lineNum">   11483 </span><span class="lineCov">          1 :             s.dump(*this, false, ensure_ascii, 0);</span>
<span class="lineNum">   11484 </span>            :         }
<span class="lineNum">   11485 </span>            : 
<span class="lineNum">   11486 </span><span class="lineCov">        246 :         return result;</span>
<span class="lineNum">   11487 </span>            :     }
<span class="lineNum">   11488 </span>            : 
<span class="lineNum">   11489 </span>            :     /*!
<span class="lineNum">   11490 </span>            :     @brief return the type of the JSON value (explicit)
<span class="lineNum">   11491 </span>            : 
<span class="lineNum">   11492 </span>            :     Return the type of the JSON value as a value from the @ref value_t
<span class="lineNum">   11493 </span>            :     enumeration.
<span class="lineNum">   11494 </span>            : 
<span class="lineNum">   11495 </span>            :     @return the type of the JSON value
<span class="lineNum">   11496 </span>            :             Value type                | return value
<span class="lineNum">   11497 </span>            :             ------------------------- | -------------------------
<span class="lineNum">   11498 </span>            :             null                      | value_t::null
<span class="lineNum">   11499 </span>            :             boolean                   | value_t::boolean
<span class="lineNum">   11500 </span>            :             string                    | value_t::string
<span class="lineNum">   11501 </span>            :             number (integer)          | value_t::number_integer
<span class="lineNum">   11502 </span>            :             number (unsigned integer) | value_t::number_unsigned
<span class="lineNum">   11503 </span>            :             number (floating-point)   | value_t::number_float
<span class="lineNum">   11504 </span>            :             object                    | value_t::object
<span class="lineNum">   11505 </span>            :             array                     | value_t::array
<span class="lineNum">   11506 </span>            :             discarded                 | value_t::discarded
<span class="lineNum">   11507 </span>            : 
<span class="lineNum">   11508 </span>            :     @complexity Constant.
<span class="lineNum">   11509 </span>            : 
<span class="lineNum">   11510 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11511 </span>            :     exceptions.
<span class="lineNum">   11512 </span>            : 
<span class="lineNum">   11513 </span>            :     @liveexample{The following code exemplifies `type()` for all JSON
<span class="lineNum">   11514 </span>            :     types.,type}
<span class="lineNum">   11515 </span>            : 
<span class="lineNum">   11516 </span>            :     @sa @ref operator value_t() -- return the type of the JSON value (implicit)
<span class="lineNum">   11517 </span>            :     @sa @ref type_name() -- return the type as string
<span class="lineNum">   11518 </span>            : 
<a name="11519"><span class="lineNum">   11519 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11520 </span>            :     */
<span class="lineNum">   11521 </span><span class="lineCov">         60 :     constexpr value_t type() const noexcept</span>
<span class="lineNum">   11522 </span>            :     {
<span class="lineNum">   11523 </span><span class="lineCov">         60 :         return m_type;</span>
<span class="lineNum">   11524 </span>            :     }
<span class="lineNum">   11525 </span>            : 
<span class="lineNum">   11526 </span>            :     /*!
<span class="lineNum">   11527 </span>            :     @brief return whether type is primitive
<span class="lineNum">   11528 </span>            : 
<span class="lineNum">   11529 </span>            :     This function returns true if and only if the JSON type is primitive
<span class="lineNum">   11530 </span>            :     (string, number, boolean, or null).
<span class="lineNum">   11531 </span>            : 
<span class="lineNum">   11532 </span>            :     @return `true` if type is primitive (string, number, boolean, or null),
<span class="lineNum">   11533 </span>            :     `false` otherwise.
<span class="lineNum">   11534 </span>            : 
<span class="lineNum">   11535 </span>            :     @complexity Constant.
<span class="lineNum">   11536 </span>            : 
<span class="lineNum">   11537 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11538 </span>            :     exceptions.
<span class="lineNum">   11539 </span>            : 
<span class="lineNum">   11540 </span>            :     @liveexample{The following code exemplifies `is_primitive()` for all JSON
<span class="lineNum">   11541 </span>            :     types.,is_primitive}
<span class="lineNum">   11542 </span>            : 
<span class="lineNum">   11543 </span>            :     @sa @ref is_structured() -- returns whether JSON value is structured
<span class="lineNum">   11544 </span>            :     @sa @ref is_null() -- returns whether JSON value is `null`
<span class="lineNum">   11545 </span>            :     @sa @ref is_string() -- returns whether JSON value is a string
<span class="lineNum">   11546 </span>            :     @sa @ref is_boolean() -- returns whether JSON value is a boolean
<span class="lineNum">   11547 </span>            :     @sa @ref is_number() -- returns whether JSON value is a number
<span class="lineNum">   11548 </span>            : 
<span class="lineNum">   11549 </span>            :     @since version 1.0.0
<span class="lineNum">   11550 </span>            :     */
<span class="lineNum">   11551 </span>            :     constexpr bool is_primitive() const noexcept
<span class="lineNum">   11552 </span>            :     {
<span class="lineNum">   11553 </span>            :         return is_null() or is_string() or is_boolean() or is_number();
<span class="lineNum">   11554 </span>            :     }
<span class="lineNum">   11555 </span>            : 
<span class="lineNum">   11556 </span>            :     /*!
<span class="lineNum">   11557 </span>            :     @brief return whether type is structured
<span class="lineNum">   11558 </span>            : 
<span class="lineNum">   11559 </span>            :     This function returns true if and only if the JSON type is structured
<span class="lineNum">   11560 </span>            :     (array or object).
<span class="lineNum">   11561 </span>            : 
<span class="lineNum">   11562 </span>            :     @return `true` if type is structured (array or object), `false` otherwise.
<span class="lineNum">   11563 </span>            : 
<span class="lineNum">   11564 </span>            :     @complexity Constant.
<span class="lineNum">   11565 </span>            : 
<span class="lineNum">   11566 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11567 </span>            :     exceptions.
<span class="lineNum">   11568 </span>            : 
<span class="lineNum">   11569 </span>            :     @liveexample{The following code exemplifies `is_structured()` for all JSON
<span class="lineNum">   11570 </span>            :     types.,is_structured}
<span class="lineNum">   11571 </span>            : 
<span class="lineNum">   11572 </span>            :     @sa @ref is_primitive() -- returns whether value is primitive
<span class="lineNum">   11573 </span>            :     @sa @ref is_array() -- returns whether value is an array
<span class="lineNum">   11574 </span>            :     @sa @ref is_object() -- returns whether value is an object
<span class="lineNum">   11575 </span>            : 
<span class="lineNum">   11576 </span>            :     @since version 1.0.0
<span class="lineNum">   11577 </span>            :     */
<span class="lineNum">   11578 </span>            :     constexpr bool is_structured() const noexcept
<span class="lineNum">   11579 </span>            :     {
<span class="lineNum">   11580 </span>            :         return is_array() or is_object();
<span class="lineNum">   11581 </span>            :     }
<span class="lineNum">   11582 </span>            : 
<span class="lineNum">   11583 </span>            :     /*!
<span class="lineNum">   11584 </span>            :     @brief return whether value is null
<span class="lineNum">   11585 </span>            : 
<span class="lineNum">   11586 </span>            :     This function returns true if and only if the JSON value is null.
<span class="lineNum">   11587 </span>            : 
<span class="lineNum">   11588 </span>            :     @return `true` if type is null, `false` otherwise.
<span class="lineNum">   11589 </span>            : 
<span class="lineNum">   11590 </span>            :     @complexity Constant.
<span class="lineNum">   11591 </span>            : 
<span class="lineNum">   11592 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11593 </span>            :     exceptions.
<span class="lineNum">   11594 </span>            : 
<span class="lineNum">   11595 </span>            :     @liveexample{The following code exemplifies `is_null()` for all JSON
<span class="lineNum">   11596 </span>            :     types.,is_null}
<span class="lineNum">   11597 </span>            : 
<a name="11598"><span class="lineNum">   11598 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11599 </span>            :     */
<span class="lineNum">   11600 </span><span class="lineCov">        328 :     constexpr bool is_null() const noexcept</span>
<span class="lineNum">   11601 </span>            :     {
<span class="lineNum">   11602 </span><span class="lineCov">        328 :         return (m_type == value_t::null);</span>
<span class="lineNum">   11603 </span>            :     }
<span class="lineNum">   11604 </span>            : 
<span class="lineNum">   11605 </span>            :     /*!
<span class="lineNum">   11606 </span>            :     @brief return whether value is a boolean
<span class="lineNum">   11607 </span>            : 
<span class="lineNum">   11608 </span>            :     This function returns true if and only if the JSON value is a boolean.
<span class="lineNum">   11609 </span>            : 
<span class="lineNum">   11610 </span>            :     @return `true` if type is boolean, `false` otherwise.
<span class="lineNum">   11611 </span>            : 
<span class="lineNum">   11612 </span>            :     @complexity Constant.
<span class="lineNum">   11613 </span>            : 
<span class="lineNum">   11614 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11615 </span>            :     exceptions.
<span class="lineNum">   11616 </span>            : 
<span class="lineNum">   11617 </span>            :     @liveexample{The following code exemplifies `is_boolean()` for all JSON
<span class="lineNum">   11618 </span>            :     types.,is_boolean}
<span class="lineNum">   11619 </span>            : 
<a name="11620"><span class="lineNum">   11620 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11621 </span>            :     */
<span class="lineNum">   11622 </span><span class="lineNoCov">          0 :     constexpr bool is_boolean() const noexcept</span>
<span class="lineNum">   11623 </span>            :     {
<span class="lineNum">   11624 </span><span class="lineNoCov">          0 :         return (m_type == value_t::boolean);</span>
<span class="lineNum">   11625 </span>            :     }
<span class="lineNum">   11626 </span>            : 
<span class="lineNum">   11627 </span>            :     /*!
<span class="lineNum">   11628 </span>            :     @brief return whether value is a number
<span class="lineNum">   11629 </span>            : 
<span class="lineNum">   11630 </span>            :     This function returns true if and only if the JSON value is a number. This
<span class="lineNum">   11631 </span>            :     includes both integer (signed and unsigned) and floating-point values.
<span class="lineNum">   11632 </span>            : 
<span class="lineNum">   11633 </span>            :     @return `true` if type is number (regardless whether integer, unsigned
<span class="lineNum">   11634 </span>            :     integer or floating-type), `false` otherwise.
<span class="lineNum">   11635 </span>            : 
<span class="lineNum">   11636 </span>            :     @complexity Constant.
<span class="lineNum">   11637 </span>            : 
<span class="lineNum">   11638 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11639 </span>            :     exceptions.
<span class="lineNum">   11640 </span>            : 
<span class="lineNum">   11641 </span>            :     @liveexample{The following code exemplifies `is_number()` for all JSON
<span class="lineNum">   11642 </span>            :     types.,is_number}
<span class="lineNum">   11643 </span>            : 
<span class="lineNum">   11644 </span>            :     @sa @ref is_number_integer() -- check if value is an integer or unsigned
<span class="lineNum">   11645 </span>            :     integer number
<span class="lineNum">   11646 </span>            :     @sa @ref is_number_unsigned() -- check if value is an unsigned integer
<span class="lineNum">   11647 </span>            :     number
<span class="lineNum">   11648 </span>            :     @sa @ref is_number_float() -- check if value is a floating-point number
<span class="lineNum">   11649 </span>            : 
<a name="11650"><span class="lineNum">   11650 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11651 </span>            :     */
<span class="lineNum">   11652 </span><span class="lineCov">         75 :     constexpr bool is_number() const noexcept</span>
<span class="lineNum">   11653 </span>            :     {
<span class="lineNum">   11654 </span><span class="lineCov">         75 :         return is_number_integer() or is_number_float();</span>
<span class="lineNum">   11655 </span>            :     }
<span class="lineNum">   11656 </span>            : 
<span class="lineNum">   11657 </span>            :     /*!
<span class="lineNum">   11658 </span>            :     @brief return whether value is an integer number
<span class="lineNum">   11659 </span>            : 
<span class="lineNum">   11660 </span>            :     This function returns true if and only if the JSON value is a signed or
<span class="lineNum">   11661 </span>            :     unsigned integer number. This excludes floating-point values.
<span class="lineNum">   11662 </span>            : 
<span class="lineNum">   11663 </span>            :     @return `true` if type is an integer or unsigned integer number, `false`
<span class="lineNum">   11664 </span>            :     otherwise.
<span class="lineNum">   11665 </span>            : 
<span class="lineNum">   11666 </span>            :     @complexity Constant.
<span class="lineNum">   11667 </span>            : 
<span class="lineNum">   11668 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11669 </span>            :     exceptions.
<span class="lineNum">   11670 </span>            : 
<span class="lineNum">   11671 </span>            :     @liveexample{The following code exemplifies `is_number_integer()` for all
<span class="lineNum">   11672 </span>            :     JSON types.,is_number_integer}
<span class="lineNum">   11673 </span>            : 
<span class="lineNum">   11674 </span>            :     @sa @ref is_number() -- check if value is a number
<span class="lineNum">   11675 </span>            :     @sa @ref is_number_unsigned() -- check if value is an unsigned integer
<span class="lineNum">   11676 </span>            :     number
<span class="lineNum">   11677 </span>            :     @sa @ref is_number_float() -- check if value is a floating-point number
<span class="lineNum">   11678 </span>            : 
<a name="11679"><span class="lineNum">   11679 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11680 </span>            :     */
<span class="lineNum">   11681 </span><span class="lineCov">         87 :     constexpr bool is_number_integer() const noexcept</span>
<span class="lineNum">   11682 </span>            :     {
<span class="lineNum">   11683 </span><span class="lineCov">         87 :         return (m_type == value_t::number_integer or m_type == value_t::number_unsigned);</span>
<span class="lineNum">   11684 </span>            :     }
<span class="lineNum">   11685 </span>            : 
<span class="lineNum">   11686 </span>            :     /*!
<span class="lineNum">   11687 </span>            :     @brief return whether value is an unsigned integer number
<span class="lineNum">   11688 </span>            : 
<span class="lineNum">   11689 </span>            :     This function returns true if and only if the JSON value is an unsigned
<span class="lineNum">   11690 </span>            :     integer number. This excludes floating-point and signed integer values.
<span class="lineNum">   11691 </span>            : 
<span class="lineNum">   11692 </span>            :     @return `true` if type is an unsigned integer number, `false` otherwise.
<span class="lineNum">   11693 </span>            : 
<span class="lineNum">   11694 </span>            :     @complexity Constant.
<span class="lineNum">   11695 </span>            : 
<span class="lineNum">   11696 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11697 </span>            :     exceptions.
<span class="lineNum">   11698 </span>            : 
<span class="lineNum">   11699 </span>            :     @liveexample{The following code exemplifies `is_number_unsigned()` for all
<span class="lineNum">   11700 </span>            :     JSON types.,is_number_unsigned}
<span class="lineNum">   11701 </span>            : 
<span class="lineNum">   11702 </span>            :     @sa @ref is_number() -- check if value is a number
<span class="lineNum">   11703 </span>            :     @sa @ref is_number_integer() -- check if value is an integer or unsigned
<span class="lineNum">   11704 </span>            :     integer number
<span class="lineNum">   11705 </span>            :     @sa @ref is_number_float() -- check if value is a floating-point number
<span class="lineNum">   11706 </span>            : 
<a name="11707"><span class="lineNum">   11707 </span>            :     @since version 2.0.0</a>
<span class="lineNum">   11708 </span>            :     */
<span class="lineNum">   11709 </span><span class="lineCov">         60 :     constexpr bool is_number_unsigned() const noexcept</span>
<span class="lineNum">   11710 </span>            :     {
<span class="lineNum">   11711 </span><span class="lineCov">         60 :         return (m_type == value_t::number_unsigned);</span>
<span class="lineNum">   11712 </span>            :     }
<span class="lineNum">   11713 </span>            : 
<span class="lineNum">   11714 </span>            :     /*!
<span class="lineNum">   11715 </span>            :     @brief return whether value is a floating-point number
<span class="lineNum">   11716 </span>            : 
<span class="lineNum">   11717 </span>            :     This function returns true if and only if the JSON value is a
<span class="lineNum">   11718 </span>            :     floating-point number. This excludes signed and unsigned integer values.
<span class="lineNum">   11719 </span>            : 
<span class="lineNum">   11720 </span>            :     @return `true` if type is a floating-point number, `false` otherwise.
<span class="lineNum">   11721 </span>            : 
<span class="lineNum">   11722 </span>            :     @complexity Constant.
<span class="lineNum">   11723 </span>            : 
<span class="lineNum">   11724 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11725 </span>            :     exceptions.
<span class="lineNum">   11726 </span>            : 
<span class="lineNum">   11727 </span>            :     @liveexample{The following code exemplifies `is_number_float()` for all
<span class="lineNum">   11728 </span>            :     JSON types.,is_number_float}
<span class="lineNum">   11729 </span>            : 
<span class="lineNum">   11730 </span>            :     @sa @ref is_number() -- check if value is number
<span class="lineNum">   11731 </span>            :     @sa @ref is_number_integer() -- check if value is an integer number
<span class="lineNum">   11732 </span>            :     @sa @ref is_number_unsigned() -- check if value is an unsigned integer
<span class="lineNum">   11733 </span>            :     number
<span class="lineNum">   11734 </span>            : 
<a name="11735"><span class="lineNum">   11735 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11736 </span>            :     */
<span class="lineNum">   11737 </span><span class="lineCov">          1 :     constexpr bool is_number_float() const noexcept</span>
<span class="lineNum">   11738 </span>            :     {
<span class="lineNum">   11739 </span><span class="lineCov">          1 :         return (m_type == value_t::number_float);</span>
<span class="lineNum">   11740 </span>            :     }
<span class="lineNum">   11741 </span>            : 
<span class="lineNum">   11742 </span>            :     /*!
<span class="lineNum">   11743 </span>            :     @brief return whether value is an object
<span class="lineNum">   11744 </span>            : 
<span class="lineNum">   11745 </span>            :     This function returns true if and only if the JSON value is an object.
<span class="lineNum">   11746 </span>            : 
<span class="lineNum">   11747 </span>            :     @return `true` if type is object, `false` otherwise.
<span class="lineNum">   11748 </span>            : 
<span class="lineNum">   11749 </span>            :     @complexity Constant.
<span class="lineNum">   11750 </span>            : 
<span class="lineNum">   11751 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11752 </span>            :     exceptions.
<span class="lineNum">   11753 </span>            : 
<span class="lineNum">   11754 </span>            :     @liveexample{The following code exemplifies `is_object()` for all JSON
<span class="lineNum">   11755 </span>            :     types.,is_object}
<span class="lineNum">   11756 </span>            : 
<a name="11757"><span class="lineNum">   11757 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11758 </span>            :     */
<span class="lineNum">   11759 </span><span class="lineCov">        954 :     constexpr bool is_object() const noexcept</span>
<span class="lineNum">   11760 </span>            :     {
<span class="lineNum">   11761 </span><span class="lineCov">        954 :         return (m_type == value_t::object);</span>
<span class="lineNum">   11762 </span>            :     }
<span class="lineNum">   11763 </span>            : 
<span class="lineNum">   11764 </span>            :     /*!
<span class="lineNum">   11765 </span>            :     @brief return whether value is an array
<span class="lineNum">   11766 </span>            : 
<span class="lineNum">   11767 </span>            :     This function returns true if and only if the JSON value is an array.
<span class="lineNum">   11768 </span>            : 
<span class="lineNum">   11769 </span>            :     @return `true` if type is array, `false` otherwise.
<span class="lineNum">   11770 </span>            : 
<span class="lineNum">   11771 </span>            :     @complexity Constant.
<span class="lineNum">   11772 </span>            : 
<span class="lineNum">   11773 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11774 </span>            :     exceptions.
<span class="lineNum">   11775 </span>            : 
<span class="lineNum">   11776 </span>            :     @liveexample{The following code exemplifies `is_array()` for all JSON
<span class="lineNum">   11777 </span>            :     types.,is_array}
<span class="lineNum">   11778 </span>            : 
<a name="11779"><span class="lineNum">   11779 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11780 </span>            :     */
<span class="lineNum">   11781 </span><span class="lineCov">        793 :     constexpr bool is_array() const noexcept</span>
<span class="lineNum">   11782 </span>            :     {
<span class="lineNum">   11783 </span><span class="lineCov">        793 :         return (m_type == value_t::array);</span>
<span class="lineNum">   11784 </span>            :     }
<span class="lineNum">   11785 </span>            : 
<span class="lineNum">   11786 </span>            :     /*!
<span class="lineNum">   11787 </span>            :     @brief return whether value is a string
<span class="lineNum">   11788 </span>            : 
<span class="lineNum">   11789 </span>            :     This function returns true if and only if the JSON value is a string.
<span class="lineNum">   11790 </span>            : 
<span class="lineNum">   11791 </span>            :     @return `true` if type is string, `false` otherwise.
<span class="lineNum">   11792 </span>            : 
<span class="lineNum">   11793 </span>            :     @complexity Constant.
<span class="lineNum">   11794 </span>            : 
<span class="lineNum">   11795 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11796 </span>            :     exceptions.
<span class="lineNum">   11797 </span>            : 
<span class="lineNum">   11798 </span>            :     @liveexample{The following code exemplifies `is_string()` for all JSON
<span class="lineNum">   11799 </span>            :     types.,is_string}
<span class="lineNum">   11800 </span>            : 
<a name="11801"><span class="lineNum">   11801 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11802 </span>            :     */
<span class="lineNum">   11803 </span><span class="lineCov">        510 :     constexpr bool is_string() const noexcept</span>
<span class="lineNum">   11804 </span>            :     {
<span class="lineNum">   11805 </span><span class="lineCov">        510 :         return (m_type == value_t::string);</span>
<span class="lineNum">   11806 </span>            :     }
<span class="lineNum">   11807 </span>            : 
<span class="lineNum">   11808 </span>            :     /*!
<span class="lineNum">   11809 </span>            :     @brief return whether value is discarded
<span class="lineNum">   11810 </span>            : 
<span class="lineNum">   11811 </span>            :     This function returns true if and only if the JSON value was discarded
<span class="lineNum">   11812 </span>            :     during parsing with a callback function (see @ref parser_callback_t).
<span class="lineNum">   11813 </span>            : 
<span class="lineNum">   11814 </span>            :     @note This function will always be `false` for JSON values after parsing.
<span class="lineNum">   11815 </span>            :     That is, discarded values can only occur during parsing, but will be
<span class="lineNum">   11816 </span>            :     removed when inside a structured value or replaced by null in other cases.
<span class="lineNum">   11817 </span>            : 
<span class="lineNum">   11818 </span>            :     @return `true` if type is discarded, `false` otherwise.
<span class="lineNum">   11819 </span>            : 
<span class="lineNum">   11820 </span>            :     @complexity Constant.
<span class="lineNum">   11821 </span>            : 
<span class="lineNum">   11822 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11823 </span>            :     exceptions.
<span class="lineNum">   11824 </span>            : 
<span class="lineNum">   11825 </span>            :     @liveexample{The following code exemplifies `is_discarded()` for all JSON
<span class="lineNum">   11826 </span>            :     types.,is_discarded}
<span class="lineNum">   11827 </span>            : 
<a name="11828"><span class="lineNum">   11828 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11829 </span>            :     */
<span class="lineNum">   11830 </span><span class="lineCov">       1205 :     constexpr bool is_discarded() const noexcept</span>
<span class="lineNum">   11831 </span>            :     {
<span class="lineNum">   11832 </span><span class="lineCov">       1205 :         return (m_type == value_t::discarded);</span>
<span class="lineNum">   11833 </span>            :     }
<span class="lineNum">   11834 </span>            : 
<span class="lineNum">   11835 </span>            :     /*!
<span class="lineNum">   11836 </span>            :     @brief return the type of the JSON value (implicit)
<span class="lineNum">   11837 </span>            : 
<span class="lineNum">   11838 </span>            :     Implicitly return the type of the JSON value as a value from the @ref
<span class="lineNum">   11839 </span>            :     value_t enumeration.
<span class="lineNum">   11840 </span>            : 
<span class="lineNum">   11841 </span>            :     @return the type of the JSON value
<span class="lineNum">   11842 </span>            : 
<span class="lineNum">   11843 </span>            :     @complexity Constant.
<span class="lineNum">   11844 </span>            : 
<span class="lineNum">   11845 </span>            :     @exceptionsafety No-throw guarantee: this member function never throws
<span class="lineNum">   11846 </span>            :     exceptions.
<span class="lineNum">   11847 </span>            : 
<span class="lineNum">   11848 </span>            :     @liveexample{The following code exemplifies the @ref value_t operator for
<span class="lineNum">   11849 </span>            :     all JSON types.,operator__value_t}
<span class="lineNum">   11850 </span>            : 
<span class="lineNum">   11851 </span>            :     @sa @ref type() -- return the type of the JSON value (explicit)
<span class="lineNum">   11852 </span>            :     @sa @ref type_name() -- return the type as string
<span class="lineNum">   11853 </span>            : 
<a name="11854"><span class="lineNum">   11854 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   11855 </span>            :     */
<span class="lineNum">   11856 </span><span class="lineCov">         54 :     constexpr operator value_t() const noexcept</span>
<span class="lineNum">   11857 </span>            :     {
<span class="lineNum">   11858 </span><span class="lineCov">         54 :         return m_type;</span>
<span class="lineNum">   11859 </span>            :     }
<span class="lineNum">   11860 </span>            : 
<span class="lineNum">   11861 </span>            :     /// @}
<span class="lineNum">   11862 </span>            : 
<span class="lineNum">   11863 </span>            :   private:
<span class="lineNum">   11864 </span>            :     //////////////////
<span class="lineNum">   11865 </span>            :     // value access //
<span class="lineNum">   11866 </span>            :     //////////////////
<span class="lineNum">   11867 </span>            : 
<span class="lineNum">   11868 </span>            :     /// get a boolean (explicit)
<span class="lineNum">   11869 </span>            :     boolean_t get_impl(boolean_t* /*unused*/) const
<span class="lineNum">   11870 </span>            :     {
<span class="lineNum">   11871 </span>            :         if (JSON_LIKELY(is_boolean()))
<span class="lineNum">   11872 </span>            :         {
<span class="lineNum">   11873 </span>            :             return m_value.boolean;
<span class="lineNum">   11874 </span>            :         }
<span class="lineNum">   11875 </span>            : 
<span class="lineNum">   11876 </span>            :         JSON_THROW(type_error::create(302, &quot;type must be boolean, but is &quot; + std::string(type_name())));
<span class="lineNum">   11877 </span>            :     }
<span class="lineNum">   11878 </span>            : 
<span class="lineNum">   11879 </span>            :     /// get a pointer to the value (object)
<span class="lineNum">   11880 </span>            :     object_t* get_impl_ptr(object_t* /*unused*/) noexcept
<span class="lineNum">   11881 </span>            :     {
<span class="lineNum">   11882 </span>            :         return is_object() ? m_value.object : nullptr;
<span class="lineNum">   11883 </span>            :     }
<span class="lineNum">   11884 </span>            : 
<span class="lineNum">   11885 </span>            :     /// get a pointer to the value (object)
<span class="lineNum">   11886 </span>            :     constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
<span class="lineNum">   11887 </span>            :     {
<span class="lineNum">   11888 </span>            :         return is_object() ? m_value.object : nullptr;
<span class="lineNum">   11889 </span>            :     }
<span class="lineNum">   11890 </span>            : 
<span class="lineNum">   11891 </span>            :     /// get a pointer to the value (array)
<span class="lineNum">   11892 </span>            :     array_t* get_impl_ptr(array_t* /*unused*/) noexcept
<span class="lineNum">   11893 </span>            :     {
<span class="lineNum">   11894 </span>            :         return is_array() ? m_value.array : nullptr;
<span class="lineNum">   11895 </span>            :     }
<span class="lineNum">   11896 </span>            : 
<span class="lineNum">   11897 </span>            :     /// get a pointer to the value (array)
<span class="lineNum">   11898 </span>            :     constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
<span class="lineNum">   11899 </span>            :     {
<span class="lineNum">   11900 </span>            :         return is_array() ? m_value.array : nullptr;
<span class="lineNum">   11901 </span>            :     }
<span class="lineNum">   11902 </span>            : 
<span class="lineNum">   11903 </span>            :     /// get a pointer to the value (string)
<span class="lineNum">   11904 </span>            :     string_t* get_impl_ptr(string_t* /*unused*/) noexcept
<span class="lineNum">   11905 </span>            :     {
<span class="lineNum">   11906 </span>            :         return is_string() ? m_value.string : nullptr;
<span class="lineNum">   11907 </span>            :     }
<a name="11908"><span class="lineNum">   11908 </span>            : </a>
<span class="lineNum">   11909 </span>            :     /// get a pointer to the value (string)
<span class="lineNum">   11910 </span><span class="lineCov">        115 :     constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept</span>
<span class="lineNum">   11911 </span>            :     {
<span class="lineNum">   11912 </span><span class="lineCov">        115 :         return is_string() ? m_value.string : nullptr;</span>
<span class="lineNum">   11913 </span>            :     }
<span class="lineNum">   11914 </span>            : 
<span class="lineNum">   11915 </span>            :     /// get a pointer to the value (boolean)
<span class="lineNum">   11916 </span>            :     boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
<span class="lineNum">   11917 </span>            :     {
<span class="lineNum">   11918 </span>            :         return is_boolean() ? &amp;m_value.boolean : nullptr;
<span class="lineNum">   11919 </span>            :     }
<a name="11920"><span class="lineNum">   11920 </span>            : </a>
<span class="lineNum">   11921 </span>            :     /// get a pointer to the value (boolean)
<span class="lineNum">   11922 </span><span class="lineNoCov">          0 :     constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept</span>
<span class="lineNum">   11923 </span>            :     {
<span class="lineNum">   11924 </span><span class="lineNoCov">          0 :         return is_boolean() ? &amp;m_value.boolean : nullptr;</span>
<span class="lineNum">   11925 </span>            :     }
<span class="lineNum">   11926 </span>            : 
<span class="lineNum">   11927 </span>            :     /// get a pointer to the value (integer number)
<span class="lineNum">   11928 </span>            :     number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
<span class="lineNum">   11929 </span>            :     {
<span class="lineNum">   11930 </span>            :         return is_number_integer() ? &amp;m_value.number_integer : nullptr;
<span class="lineNum">   11931 </span>            :     }
<a name="11932"><span class="lineNum">   11932 </span>            : </a>
<span class="lineNum">   11933 </span>            :     /// get a pointer to the value (integer number)
<span class="lineNum">   11934 </span><span class="lineCov">          2 :     constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept</span>
<span class="lineNum">   11935 </span>            :     {
<span class="lineNum">   11936 </span><span class="lineCov">          2 :         return is_number_integer() ? &amp;m_value.number_integer : nullptr;</span>
<span class="lineNum">   11937 </span>            :     }
<span class="lineNum">   11938 </span>            : 
<span class="lineNum">   11939 </span>            :     /// get a pointer to the value (unsigned number)
<span class="lineNum">   11940 </span>            :     number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
<span class="lineNum">   11941 </span>            :     {
<span class="lineNum">   11942 </span>            :         return is_number_unsigned() ? &amp;m_value.number_unsigned : nullptr;
<span class="lineNum">   11943 </span>            :     }
<a name="11944"><span class="lineNum">   11944 </span>            : </a>
<span class="lineNum">   11945 </span>            :     /// get a pointer to the value (unsigned number)
<span class="lineNum">   11946 </span><span class="lineCov">         52 :     constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept</span>
<span class="lineNum">   11947 </span>            :     {
<span class="lineNum">   11948 </span><span class="lineCov">         52 :         return is_number_unsigned() ? &amp;m_value.number_unsigned : nullptr;</span>
<span class="lineNum">   11949 </span>            :     }
<span class="lineNum">   11950 </span>            : 
<span class="lineNum">   11951 </span>            :     /// get a pointer to the value (floating-point number)
<span class="lineNum">   11952 </span>            :     number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
<span class="lineNum">   11953 </span>            :     {
<span class="lineNum">   11954 </span>            :         return is_number_float() ? &amp;m_value.number_float : nullptr;
<span class="lineNum">   11955 </span>            :     }
<a name="11956"><span class="lineNum">   11956 </span>            : </a>
<span class="lineNum">   11957 </span>            :     /// get a pointer to the value (floating-point number)
<span class="lineNum">   11958 </span><span class="lineNoCov">          0 :     constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept</span>
<span class="lineNum">   11959 </span>            :     {
<span class="lineNum">   11960 </span><span class="lineNoCov">          0 :         return is_number_float() ? &amp;m_value.number_float : nullptr;</span>
<span class="lineNum">   11961 </span>            :     }
<span class="lineNum">   11962 </span>            : 
<span class="lineNum">   11963 </span>            :     /*!
<span class="lineNum">   11964 </span>            :     @brief helper function to implement get_ref()
<span class="lineNum">   11965 </span>            : 
<span class="lineNum">   11966 </span>            :     This function helps to implement get_ref() without code duplication for
<span class="lineNum">   11967 </span>            :     const and non-const overloads
<span class="lineNum">   11968 </span>            : 
<span class="lineNum">   11969 </span>            :     @tparam ThisType will be deduced as `basic_json` or `const basic_json`
<span class="lineNum">   11970 </span>            : 
<span class="lineNum">   11971 </span>            :     @throw type_error.303 if ReferenceType does not match underlying value
<span class="lineNum">   11972 </span>            :     type of the current JSON
<span class="lineNum">   11973 </span>            :     */
<span class="lineNum">   11974 </span>            :     template&lt;typename ReferenceType, typename ThisType&gt;
<span class="lineNum">   11975 </span>            :     static ReferenceType get_ref_impl(ThisType&amp; obj)
<span class="lineNum">   11976 </span>            :     {
<span class="lineNum">   11977 </span>            :         // delegate the call to get_ptr&lt;&gt;()
<span class="lineNum">   11978 </span>            :         auto ptr = obj.template get_ptr&lt;typename std::add_pointer&lt;ReferenceType&gt;::type&gt;();
<span class="lineNum">   11979 </span>            : 
<span class="lineNum">   11980 </span>            :         if (JSON_LIKELY(ptr != nullptr))
<span class="lineNum">   11981 </span>            :         {
<span class="lineNum">   11982 </span>            :             return *ptr;
<span class="lineNum">   11983 </span>            :         }
<span class="lineNum">   11984 </span>            : 
<span class="lineNum">   11985 </span>            :         JSON_THROW(type_error::create(303, &quot;incompatible ReferenceType for get_ref, actual type is &quot; + std::string(obj.type_name())));
<span class="lineNum">   11986 </span>            :     }
<span class="lineNum">   11987 </span>            : 
<span class="lineNum">   11988 </span>            :   public:
<span class="lineNum">   11989 </span>            :     /// @name value access
<span class="lineNum">   11990 </span>            :     /// Direct access to the stored value of a JSON value.
<span class="lineNum">   11991 </span>            :     /// @{
<span class="lineNum">   11992 </span>            : 
<span class="lineNum">   11993 </span>            :     /*!
<span class="lineNum">   11994 </span>            :     @brief get special-case overload
<span class="lineNum">   11995 </span>            : 
<span class="lineNum">   11996 </span>            :     This overloads avoids a lot of template boilerplate, it can be seen as the
<span class="lineNum">   11997 </span>            :     identity method
<span class="lineNum">   11998 </span>            : 
<span class="lineNum">   11999 </span>            :     @tparam BasicJsonType == @ref basic_json
<span class="lineNum">   12000 </span>            : 
<span class="lineNum">   12001 </span>            :     @return a copy of *this
<span class="lineNum">   12002 </span>            : 
<span class="lineNum">   12003 </span>            :     @complexity Constant.
<span class="lineNum">   12004 </span>            : 
<span class="lineNum">   12005 </span>            :     @since version 2.1.0
<span class="lineNum">   12006 </span>            :     */
<span class="lineNum">   12007 </span>            :     template&lt;typename BasicJsonType, detail::enable_if_t&lt;
<span class="lineNum">   12008 </span>            :                  std::is_same&lt;typename std::remove_const&lt;BasicJsonType&gt;::type, basic_json_t&gt;::value,
<span class="lineNum">   12009 </span>            :                  int&gt; = 0&gt;
<span class="lineNum">   12010 </span>            :     basic_json get() const
<span class="lineNum">   12011 </span>            :     {
<span class="lineNum">   12012 </span>            :         return *this;
<span class="lineNum">   12013 </span>            :     }
<span class="lineNum">   12014 </span>            : 
<span class="lineNum">   12015 </span>            :     /*!
<span class="lineNum">   12016 </span>            :     @brief get a value (explicit)
<span class="lineNum">   12017 </span>            : 
<span class="lineNum">   12018 </span>            :     Explicit type conversion between the JSON value and a compatible value
<span class="lineNum">   12019 </span>            :     which is [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible)
<span class="lineNum">   12020 </span>            :     and [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible).
<span class="lineNum">   12021 </span>            :     The value is converted by calling the @ref json_serializer&lt;ValueType&gt;
<span class="lineNum">   12022 </span>            :     `from_json()` method.
<span class="lineNum">   12023 </span>            : 
<span class="lineNum">   12024 </span>            :     The function is equivalent to executing
<span class="lineNum">   12025 </span>            :     @code {.cpp}
<span class="lineNum">   12026 </span>            :     ValueType ret;
<span class="lineNum">   12027 </span>            :     JSONSerializer&lt;ValueType&gt;::from_json(*this, ret);
<span class="lineNum">   12028 </span>            :     return ret;
<span class="lineNum">   12029 </span>            :     @endcode
<span class="lineNum">   12030 </span>            : 
<span class="lineNum">   12031 </span>            :     This overloads is chosen if:
<span class="lineNum">   12032 </span>            :     - @a ValueType is not @ref basic_json,
<span class="lineNum">   12033 </span>            :     - @ref json_serializer&lt;ValueType&gt; has a `from_json()` method of the form
<span class="lineNum">   12034 </span>            :       `void from_json(const basic_json&amp;, ValueType&amp;)`, and
<span class="lineNum">   12035 </span>            :     - @ref json_serializer&lt;ValueType&gt; does not have a `from_json()` method of
<span class="lineNum">   12036 </span>            :       the form `ValueType from_json(const basic_json&amp;)`
<span class="lineNum">   12037 </span>            : 
<span class="lineNum">   12038 </span>            :     @tparam ValueTypeCV the provided value type
<span class="lineNum">   12039 </span>            :     @tparam ValueType the returned value type
<span class="lineNum">   12040 </span>            : 
<span class="lineNum">   12041 </span>            :     @return copy of the JSON value, converted to @a ValueType
<span class="lineNum">   12042 </span>            : 
<span class="lineNum">   12043 </span>            :     @throw what @ref json_serializer&lt;ValueType&gt; `from_json()` method throws
<span class="lineNum">   12044 </span>            : 
<span class="lineNum">   12045 </span>            :     @liveexample{The example below shows several conversions from JSON values
<span class="lineNum">   12046 </span>            :     to other types. There a few things to note: (1) Floating-point numbers can
<span class="lineNum">   12047 </span>            :     be converted to integers\, (2) A JSON array can be converted to a standard
<span class="lineNum">   12048 </span>            :     `std::vector&lt;short&gt;`\, (3) A JSON object can be converted to C++
<span class="lineNum">   12049 </span>            :     associative containers such as `std::unordered_map&lt;std::string\,
<span class="lineNum">   12050 </span>            :     json&gt;`.,get__ValueType_const}
<span class="lineNum">   12051 </span>            : 
<span class="lineNum">   12052 </span>            :     @since version 2.1.0
<span class="lineNum">   12053 </span>            :     */
<span class="lineNum">   12054 </span>            :     template&lt;typename ValueTypeCV, typename ValueType = detail::uncvref_t&lt;ValueTypeCV&gt;,
<span class="lineNum">   12055 </span>            :              detail::enable_if_t &lt;
<span class="lineNum">   12056 </span>            :                  not std::is_same&lt;basic_json_t, ValueType&gt;::value and
<span class="lineNum">   12057 </span>            :                  detail::has_from_json&lt;basic_json_t, ValueType&gt;::value and
<a name="12058"><span class="lineNum">   12058 </span>            :                  not detail::has_non_default_from_json&lt;basic_json_t, ValueType&gt;::value,</a>
<span class="lineNum">   12059 </span>            :                  int&gt; = 0&gt;
<span class="lineNum">   12060 </span><span class="lineCov">        169 :     ValueType get() const noexcept(noexcept(</span>
<span class="lineNum">   12061 </span>            :                                        JSONSerializer&lt;ValueType&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;(), std::declval&lt;ValueType&amp;&gt;())))
<span class="lineNum">   12062 </span>            :     {
<span class="lineNum">   12063 </span>            :         // we cannot static_assert on ValueTypeCV being non-const, because
<span class="lineNum">   12064 </span>            :         // there is support for get&lt;const basic_json_t&gt;(), which is why we
<span class="lineNum">   12065 </span>            :         // still need the uncvref
<span class="lineNum">   12066 </span>            :         static_assert(not std::is_reference&lt;ValueTypeCV&gt;::value,
<span class="lineNum">   12067 </span>            :                       &quot;get() cannot be used with reference types, you might want to use get_ref()&quot;);
<span class="lineNum">   12068 </span>            :         static_assert(std::is_default_constructible&lt;ValueType&gt;::value,
<span class="lineNum">   12069 </span>            :                       &quot;types must be DefaultConstructible when used with get()&quot;);
<span class="lineNum">   12070 </span>            : 
<span class="lineNum">   12071 </span><span class="lineCov">        115 :         ValueType ret;</span>
<span class="lineNum">   12072 </span><span class="lineCov">        169 :         JSONSerializer&lt;ValueType&gt;::from_json(*this, ret);</span>
<span class="lineNum">   12073 </span><span class="lineCov">        169 :         return ret;</span>
<span class="lineNum">   12074 </span>            :     }
<span class="lineNum">   12075 </span>            : 
<span class="lineNum">   12076 </span>            :     /*!
<span class="lineNum">   12077 </span>            :     @brief get a value (explicit); special case
<span class="lineNum">   12078 </span>            : 
<span class="lineNum">   12079 </span>            :     Explicit type conversion between the JSON value and a compatible value
<span class="lineNum">   12080 </span>            :     which is **not** [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible)
<span class="lineNum">   12081 </span>            :     and **not** [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible).
<span class="lineNum">   12082 </span>            :     The value is converted by calling the @ref json_serializer&lt;ValueType&gt;
<span class="lineNum">   12083 </span>            :     `from_json()` method.
<span class="lineNum">   12084 </span>            : 
<span class="lineNum">   12085 </span>            :     The function is equivalent to executing
<span class="lineNum">   12086 </span>            :     @code {.cpp}
<span class="lineNum">   12087 </span>            :     return JSONSerializer&lt;ValueTypeCV&gt;::from_json(*this);
<span class="lineNum">   12088 </span>            :     @endcode
<span class="lineNum">   12089 </span>            : 
<span class="lineNum">   12090 </span>            :     This overloads is chosen if:
<span class="lineNum">   12091 </span>            :     - @a ValueType is not @ref basic_json and
<span class="lineNum">   12092 </span>            :     - @ref json_serializer&lt;ValueType&gt; has a `from_json()` method of the form
<span class="lineNum">   12093 </span>            :       `ValueType from_json(const basic_json&amp;)`
<span class="lineNum">   12094 </span>            : 
<span class="lineNum">   12095 </span>            :     @note If @ref json_serializer&lt;ValueType&gt; has both overloads of
<span class="lineNum">   12096 </span>            :     `from_json()`, this one is chosen.
<span class="lineNum">   12097 </span>            : 
<span class="lineNum">   12098 </span>            :     @tparam ValueTypeCV the provided value type
<span class="lineNum">   12099 </span>            :     @tparam ValueType the returned value type
<span class="lineNum">   12100 </span>            : 
<span class="lineNum">   12101 </span>            :     @return copy of the JSON value, converted to @a ValueType
<span class="lineNum">   12102 </span>            : 
<span class="lineNum">   12103 </span>            :     @throw what @ref json_serializer&lt;ValueType&gt; `from_json()` method throws
<span class="lineNum">   12104 </span>            : 
<span class="lineNum">   12105 </span>            :     @since version 2.1.0
<span class="lineNum">   12106 </span>            :     */
<span class="lineNum">   12107 </span>            :     template&lt;typename ValueTypeCV, typename ValueType = detail::uncvref_t&lt;ValueTypeCV&gt;,
<span class="lineNum">   12108 </span>            :              detail::enable_if_t&lt;not std::is_same&lt;basic_json_t, ValueType&gt;::value and
<span class="lineNum">   12109 </span>            :                                  detail::has_non_default_from_json&lt;basic_json_t, ValueType&gt;::value,
<span class="lineNum">   12110 </span>            :                                  int&gt; = 0&gt;
<span class="lineNum">   12111 </span>            :     ValueType get() const noexcept(noexcept(
<span class="lineNum">   12112 </span>            :                                        JSONSerializer&lt;ValueTypeCV&gt;::from_json(std::declval&lt;const basic_json_t&amp;&gt;())))
<span class="lineNum">   12113 </span>            :     {
<span class="lineNum">   12114 </span>            :         static_assert(not std::is_reference&lt;ValueTypeCV&gt;::value,
<span class="lineNum">   12115 </span>            :                       &quot;get() cannot be used with reference types, you might want to use get_ref()&quot;);
<span class="lineNum">   12116 </span>            :         return JSONSerializer&lt;ValueTypeCV&gt;::from_json(*this);
<span class="lineNum">   12117 </span>            :     }
<span class="lineNum">   12118 </span>            : 
<span class="lineNum">   12119 </span>            :     /*!
<span class="lineNum">   12120 </span>            :     @brief get a pointer value (explicit)
<span class="lineNum">   12121 </span>            : 
<span class="lineNum">   12122 </span>            :     Explicit pointer access to the internally stored JSON value. No copies are
<span class="lineNum">   12123 </span>            :     made.
<span class="lineNum">   12124 </span>            : 
<span class="lineNum">   12125 </span>            :     @warning The pointer becomes invalid if the underlying JSON object
<span class="lineNum">   12126 </span>            :     changes.
<span class="lineNum">   12127 </span>            : 
<span class="lineNum">   12128 </span>            :     @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
<span class="lineNum">   12129 </span>            :     object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
<span class="lineNum">   12130 </span>            :     @ref number_unsigned_t, or @ref number_float_t.
<span class="lineNum">   12131 </span>            : 
<span class="lineNum">   12132 </span>            :     @return pointer to the internally stored JSON value if the requested
<span class="lineNum">   12133 </span>            :     pointer type @a PointerType fits to the JSON value; `nullptr` otherwise
<span class="lineNum">   12134 </span>            : 
<span class="lineNum">   12135 </span>            :     @complexity Constant.
<span class="lineNum">   12136 </span>            : 
<span class="lineNum">   12137 </span>            :     @liveexample{The example below shows how pointers to internal values of a
<span class="lineNum">   12138 </span>            :     JSON value can be requested. Note that no type conversions are made and a
<span class="lineNum">   12139 </span>            :     `nullptr` is returned if the value and the requested pointer type does not
<span class="lineNum">   12140 </span>            :     match.,get__PointerType}
<span class="lineNum">   12141 </span>            : 
<span class="lineNum">   12142 </span>            :     @sa @ref get_ptr() for explicit pointer-member access
<span class="lineNum">   12143 </span>            : 
<span class="lineNum">   12144 </span>            :     @since version 1.0.0
<span class="lineNum">   12145 </span>            :     */
<span class="lineNum">   12146 </span>            :     template&lt;typename PointerType, typename std::enable_if&lt;
<span class="lineNum">   12147 </span>            :                  std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12148 </span>            :     PointerType get() noexcept
<span class="lineNum">   12149 </span>            :     {
<span class="lineNum">   12150 </span>            :         // delegate the call to get_ptr
<span class="lineNum">   12151 </span>            :         return get_ptr&lt;PointerType&gt;();
<span class="lineNum">   12152 </span>            :     }
<span class="lineNum">   12153 </span>            : 
<span class="lineNum">   12154 </span>            :     /*!
<span class="lineNum">   12155 </span>            :     @brief get a pointer value (explicit)
<span class="lineNum">   12156 </span>            :     @copydoc get()
<span class="lineNum">   12157 </span>            :     */
<span class="lineNum">   12158 </span>            :     template&lt;typename PointerType, typename std::enable_if&lt;
<span class="lineNum">   12159 </span>            :                  std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12160 </span>            :     constexpr const PointerType get() const noexcept
<span class="lineNum">   12161 </span>            :     {
<span class="lineNum">   12162 </span>            :         // delegate the call to get_ptr
<span class="lineNum">   12163 </span>            :         return get_ptr&lt;PointerType&gt;();
<span class="lineNum">   12164 </span>            :     }
<span class="lineNum">   12165 </span>            : 
<span class="lineNum">   12166 </span>            :     /*!
<span class="lineNum">   12167 </span>            :     @brief get a pointer value (implicit)
<span class="lineNum">   12168 </span>            : 
<span class="lineNum">   12169 </span>            :     Implicit pointer access to the internally stored JSON value. No copies are
<span class="lineNum">   12170 </span>            :     made.
<span class="lineNum">   12171 </span>            : 
<span class="lineNum">   12172 </span>            :     @warning Writing data to the pointee of the result yields an undefined
<span class="lineNum">   12173 </span>            :     state.
<span class="lineNum">   12174 </span>            : 
<span class="lineNum">   12175 </span>            :     @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
<span class="lineNum">   12176 </span>            :     object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
<span class="lineNum">   12177 </span>            :     @ref number_unsigned_t, or @ref number_float_t. Enforced by a static
<span class="lineNum">   12178 </span>            :     assertion.
<span class="lineNum">   12179 </span>            : 
<span class="lineNum">   12180 </span>            :     @return pointer to the internally stored JSON value if the requested
<span class="lineNum">   12181 </span>            :     pointer type @a PointerType fits to the JSON value; `nullptr` otherwise
<span class="lineNum">   12182 </span>            : 
<span class="lineNum">   12183 </span>            :     @complexity Constant.
<span class="lineNum">   12184 </span>            : 
<span class="lineNum">   12185 </span>            :     @liveexample{The example below shows how pointers to internal values of a
<span class="lineNum">   12186 </span>            :     JSON value can be requested. Note that no type conversions are made and a
<span class="lineNum">   12187 </span>            :     `nullptr` is returned if the value and the requested pointer type does not
<span class="lineNum">   12188 </span>            :     match.,get_ptr}
<span class="lineNum">   12189 </span>            : 
<span class="lineNum">   12190 </span>            :     @since version 1.0.0
<span class="lineNum">   12191 </span>            :     */
<span class="lineNum">   12192 </span>            :     template&lt;typename PointerType, typename std::enable_if&lt;
<span class="lineNum">   12193 </span>            :                  std::is_pointer&lt;PointerType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12194 </span>            :     PointerType get_ptr() noexcept
<span class="lineNum">   12195 </span>            :     {
<span class="lineNum">   12196 </span>            :         // get the type of the PointerType (remove pointer and const)
<span class="lineNum">   12197 </span>            :         using pointee_t = typename std::remove_const&lt;typename
<span class="lineNum">   12198 </span>            :                           std::remove_pointer&lt;typename
<span class="lineNum">   12199 </span>            :                           std::remove_const&lt;PointerType&gt;::type&gt;::type&gt;::type;
<span class="lineNum">   12200 </span>            :         // make sure the type matches the allowed types
<span class="lineNum">   12201 </span>            :         static_assert(
<span class="lineNum">   12202 </span>            :             std::is_same&lt;object_t, pointee_t&gt;::value
<span class="lineNum">   12203 </span>            :             or std::is_same&lt;array_t, pointee_t&gt;::value
<span class="lineNum">   12204 </span>            :             or std::is_same&lt;string_t, pointee_t&gt;::value
<span class="lineNum">   12205 </span>            :             or std::is_same&lt;boolean_t, pointee_t&gt;::value
<span class="lineNum">   12206 </span>            :             or std::is_same&lt;number_integer_t, pointee_t&gt;::value
<span class="lineNum">   12207 </span>            :             or std::is_same&lt;number_unsigned_t, pointee_t&gt;::value
<span class="lineNum">   12208 </span>            :             or std::is_same&lt;number_float_t, pointee_t&gt;::value
<span class="lineNum">   12209 </span>            :             , &quot;incompatible pointer type&quot;);
<span class="lineNum">   12210 </span>            : 
<span class="lineNum">   12211 </span>            :         // delegate the call to get_impl_ptr&lt;&gt;()
<span class="lineNum">   12212 </span>            :         return get_impl_ptr(static_cast&lt;PointerType&gt;(nullptr));
<span class="lineNum">   12213 </span>            :     }
<span class="lineNum">   12214 </span>            : 
<span class="lineNum">   12215 </span>            :     /*!
<span class="lineNum">   12216 </span>            :     @brief get a pointer value (implicit)
<span class="lineNum">   12217 </span>            :     @copydoc get_ptr()
<span class="lineNum">   12218 </span>            :     */
<span class="lineNum">   12219 </span>            :     template&lt;typename PointerType, typename std::enable_if&lt;
<a name="12220"><span class="lineNum">   12220 </span>            :                  std::is_pointer&lt;PointerType&gt;::value and</a>
<span class="lineNum">   12221 </span>            :                  std::is_const&lt;typename std::remove_pointer&lt;PointerType&gt;::type&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12222 </span><span class="lineCov">        169 :     constexpr const PointerType get_ptr() const noexcept</span>
<span class="lineNum">   12223 </span>            :     {
<span class="lineNum">   12224 </span>            :         // get the type of the PointerType (remove pointer and const)
<span class="lineNum">   12225 </span>            :         using pointee_t = typename std::remove_const&lt;typename
<span class="lineNum">   12226 </span>            :                           std::remove_pointer&lt;typename
<span class="lineNum">   12227 </span>            :                           std::remove_const&lt;PointerType&gt;::type&gt;::type&gt;::type;
<span class="lineNum">   12228 </span>            :         // make sure the type matches the allowed types
<span class="lineNum">   12229 </span>            :         static_assert(
<span class="lineNum">   12230 </span>            :             std::is_same&lt;object_t, pointee_t&gt;::value
<span class="lineNum">   12231 </span>            :             or std::is_same&lt;array_t, pointee_t&gt;::value
<span class="lineNum">   12232 </span>            :             or std::is_same&lt;string_t, pointee_t&gt;::value
<span class="lineNum">   12233 </span>            :             or std::is_same&lt;boolean_t, pointee_t&gt;::value
<span class="lineNum">   12234 </span>            :             or std::is_same&lt;number_integer_t, pointee_t&gt;::value
<span class="lineNum">   12235 </span>            :             or std::is_same&lt;number_unsigned_t, pointee_t&gt;::value
<span class="lineNum">   12236 </span>            :             or std::is_same&lt;number_float_t, pointee_t&gt;::value
<span class="lineNum">   12237 </span>            :             , &quot;incompatible pointer type&quot;);
<span class="lineNum">   12238 </span>            : 
<span class="lineNum">   12239 </span>            :         // delegate the call to get_impl_ptr&lt;&gt;() const
<span class="lineNum">   12240 </span><span class="lineCov">        169 :         return get_impl_ptr(static_cast&lt;PointerType&gt;(nullptr));</span>
<span class="lineNum">   12241 </span>            :     }
<span class="lineNum">   12242 </span>            : 
<span class="lineNum">   12243 </span>            :     /*!
<span class="lineNum">   12244 </span>            :     @brief get a reference value (implicit)
<span class="lineNum">   12245 </span>            : 
<span class="lineNum">   12246 </span>            :     Implicit reference access to the internally stored JSON value. No copies
<span class="lineNum">   12247 </span>            :     are made.
<span class="lineNum">   12248 </span>            : 
<span class="lineNum">   12249 </span>            :     @warning Writing data to the referee of the result yields an undefined
<span class="lineNum">   12250 </span>            :     state.
<span class="lineNum">   12251 </span>            : 
<span class="lineNum">   12252 </span>            :     @tparam ReferenceType reference type; must be a reference to @ref array_t,
<span class="lineNum">   12253 </span>            :     @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
<span class="lineNum">   12254 </span>            :     @ref number_float_t. Enforced by static assertion.
<span class="lineNum">   12255 </span>            : 
<span class="lineNum">   12256 </span>            :     @return reference to the internally stored JSON value if the requested
<span class="lineNum">   12257 </span>            :     reference type @a ReferenceType fits to the JSON value; throws
<span class="lineNum">   12258 </span>            :     type_error.303 otherwise
<span class="lineNum">   12259 </span>            : 
<span class="lineNum">   12260 </span>            :     @throw type_error.303 in case passed type @a ReferenceType is incompatible
<span class="lineNum">   12261 </span>            :     with the stored JSON value; see example below
<span class="lineNum">   12262 </span>            : 
<span class="lineNum">   12263 </span>            :     @complexity Constant.
<span class="lineNum">   12264 </span>            : 
<span class="lineNum">   12265 </span>            :     @liveexample{The example shows several calls to `get_ref()`.,get_ref}
<span class="lineNum">   12266 </span>            : 
<span class="lineNum">   12267 </span>            :     @since version 1.1.0
<span class="lineNum">   12268 </span>            :     */
<span class="lineNum">   12269 </span>            :     template&lt;typename ReferenceType, typename std::enable_if&lt;
<span class="lineNum">   12270 </span>            :                  std::is_reference&lt;ReferenceType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12271 </span>            :     ReferenceType get_ref()
<span class="lineNum">   12272 </span>            :     {
<span class="lineNum">   12273 </span>            :         // delegate call to get_ref_impl
<span class="lineNum">   12274 </span>            :         return get_ref_impl&lt;ReferenceType&gt;(*this);
<span class="lineNum">   12275 </span>            :     }
<span class="lineNum">   12276 </span>            : 
<span class="lineNum">   12277 </span>            :     /*!
<span class="lineNum">   12278 </span>            :     @brief get a reference value (implicit)
<span class="lineNum">   12279 </span>            :     @copydoc get_ref()
<span class="lineNum">   12280 </span>            :     */
<span class="lineNum">   12281 </span>            :     template&lt;typename ReferenceType, typename std::enable_if&lt;
<span class="lineNum">   12282 </span>            :                  std::is_reference&lt;ReferenceType&gt;::value and
<span class="lineNum">   12283 </span>            :                  std::is_const&lt;typename std::remove_reference&lt;ReferenceType&gt;::type&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12284 </span>            :     ReferenceType get_ref() const
<span class="lineNum">   12285 </span>            :     {
<span class="lineNum">   12286 </span>            :         // delegate call to get_ref_impl
<span class="lineNum">   12287 </span>            :         return get_ref_impl&lt;ReferenceType&gt;(*this);
<span class="lineNum">   12288 </span>            :     }
<span class="lineNum">   12289 </span>            : 
<span class="lineNum">   12290 </span>            :     /*!
<span class="lineNum">   12291 </span>            :     @brief get a value (implicit)
<span class="lineNum">   12292 </span>            : 
<span class="lineNum">   12293 </span>            :     Implicit type conversion between the JSON value and a compatible value.
<span class="lineNum">   12294 </span>            :     The call is realized by calling @ref get() const.
<span class="lineNum">   12295 </span>            : 
<span class="lineNum">   12296 </span>            :     @tparam ValueType non-pointer type compatible to the JSON value, for
<span class="lineNum">   12297 </span>            :     instance `int` for JSON integer numbers, `bool` for JSON booleans, or
<span class="lineNum">   12298 </span>            :     `std::vector` types for JSON arrays. The character type of @ref string_t
<span class="lineNum">   12299 </span>            :     as well as an initializer list of this type is excluded to avoid
<span class="lineNum">   12300 </span>            :     ambiguities as these types implicitly convert to `std::string`.
<span class="lineNum">   12301 </span>            : 
<span class="lineNum">   12302 </span>            :     @return copy of the JSON value, converted to type @a ValueType
<span class="lineNum">   12303 </span>            : 
<span class="lineNum">   12304 </span>            :     @throw type_error.302 in case passed type @a ValueType is incompatible
<span class="lineNum">   12305 </span>            :     to the JSON value type (e.g., the JSON value is of type boolean, but a
<span class="lineNum">   12306 </span>            :     string is requested); see example below
<span class="lineNum">   12307 </span>            : 
<span class="lineNum">   12308 </span>            :     @complexity Linear in the size of the JSON value.
<span class="lineNum">   12309 </span>            : 
<span class="lineNum">   12310 </span>            :     @liveexample{The example below shows several conversions from JSON values
<span class="lineNum">   12311 </span>            :     to other types. There a few things to note: (1) Floating-point numbers can
<span class="lineNum">   12312 </span>            :     be converted to integers\, (2) A JSON array can be converted to a standard
<span class="lineNum">   12313 </span>            :     `std::vector&lt;short&gt;`\, (3) A JSON object can be converted to C++
<span class="lineNum">   12314 </span>            :     associative containers such as `std::unordered_map&lt;std::string\,
<span class="lineNum">   12315 </span>            :     json&gt;`.,operator__ValueType}
<span class="lineNum">   12316 </span>            : 
<span class="lineNum">   12317 </span>            :     @since version 1.0.0
<span class="lineNum">   12318 </span>            :     */
<span class="lineNum">   12319 </span>            :     template &lt; typename ValueType, typename std::enable_if &lt;
<span class="lineNum">   12320 </span>            :                    not std::is_pointer&lt;ValueType&gt;::value and
<span class="lineNum">   12321 </span>            :                    not std::is_same&lt;ValueType, detail::json_ref&lt;basic_json&gt;&gt;::value and
<span class="lineNum">   12322 </span>            :                    not std::is_same&lt;ValueType, typename string_t::value_type&gt;::value
<span class="lineNum">   12323 </span>            : #ifndef _MSC_VER  // fix for issue #167 operator&lt;&lt; ambiguity under VS2015
<span class="lineNum">   12324 </span>            :                    and not std::is_same&lt;ValueType, std::initializer_list&lt;typename string_t::value_type&gt;&gt;::value
<span class="lineNum">   12325 </span>            : #endif
<span class="lineNum">   12326 </span>            : #if defined(JSON_HAS_CPP_17)
<span class="lineNum">   12327 </span>            :                    and not std::is_same&lt;ValueType, typename std::string_view&gt;::value
<a name="12328"><span class="lineNum">   12328 </span>            : #endif</a>
<span class="lineNum">   12329 </span>            :                    , int &gt;::type = 0 &gt;
<span class="lineNum">   12330 </span><span class="lineCov">          3 :     operator ValueType() const</span>
<span class="lineNum">   12331 </span>            :     {
<span class="lineNum">   12332 </span>            :         // delegate the call to get&lt;&gt;() const
<span class="lineNum">   12333 </span><span class="lineCov">          3 :         return get&lt;ValueType&gt;();</span>
<span class="lineNum">   12334 </span>            :     }
<span class="lineNum">   12335 </span>            : 
<span class="lineNum">   12336 </span>            :     /// @}
<span class="lineNum">   12337 </span>            : 
<span class="lineNum">   12338 </span>            : 
<span class="lineNum">   12339 </span>            :     ////////////////////
<span class="lineNum">   12340 </span>            :     // element access //
<span class="lineNum">   12341 </span>            :     ////////////////////
<span class="lineNum">   12342 </span>            : 
<span class="lineNum">   12343 </span>            :     /// @name element access
<span class="lineNum">   12344 </span>            :     /// Access to the JSON value.
<span class="lineNum">   12345 </span>            :     /// @{
<span class="lineNum">   12346 </span>            : 
<span class="lineNum">   12347 </span>            :     /*!
<span class="lineNum">   12348 </span>            :     @brief access specified array element with bounds checking
<span class="lineNum">   12349 </span>            : 
<span class="lineNum">   12350 </span>            :     Returns a reference to the element at specified location @a idx, with
<span class="lineNum">   12351 </span>            :     bounds checking.
<span class="lineNum">   12352 </span>            : 
<span class="lineNum">   12353 </span>            :     @param[in] idx  index of the element to access
<span class="lineNum">   12354 </span>            : 
<span class="lineNum">   12355 </span>            :     @return reference to the element at index @a idx
<span class="lineNum">   12356 </span>            : 
<span class="lineNum">   12357 </span>            :     @throw type_error.304 if the JSON value is not an array; in this case,
<span class="lineNum">   12358 </span>            :     calling `at` with an index makes no sense. See example below.
<span class="lineNum">   12359 </span>            :     @throw out_of_range.401 if the index @a idx is out of range of the array;
<span class="lineNum">   12360 </span>            :     that is, `idx &gt;= size()`. See example below.
<span class="lineNum">   12361 </span>            : 
<span class="lineNum">   12362 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   12363 </span>            :     changes in the JSON value.
<span class="lineNum">   12364 </span>            : 
<span class="lineNum">   12365 </span>            :     @complexity Constant.
<span class="lineNum">   12366 </span>            : 
<span class="lineNum">   12367 </span>            :     @since version 1.0.0
<span class="lineNum">   12368 </span>            : 
<span class="lineNum">   12369 </span>            :     @liveexample{The example below shows how array elements can be read and
<span class="lineNum">   12370 </span>            :     written using `at()`. It also demonstrates the different exceptions that
<span class="lineNum">   12371 </span>            :     can be thrown.,at__size_type}
<span class="lineNum">   12372 </span>            :     */
<span class="lineNum">   12373 </span>            :     reference at(size_type idx)
<span class="lineNum">   12374 </span>            :     {
<span class="lineNum">   12375 </span>            :         // at only works for arrays
<span class="lineNum">   12376 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   12377 </span>            :         {
<span class="lineNum">   12378 </span>            :             JSON_TRY
<span class="lineNum">   12379 </span>            :             {
<span class="lineNum">   12380 </span>            :                 return m_value.array-&gt;at(idx);
<span class="lineNum">   12381 </span>            :             }
<span class="lineNum">   12382 </span>            :             JSON_CATCH (std::out_of_range&amp;)
<span class="lineNum">   12383 </span>            :             {
<span class="lineNum">   12384 </span>            :                 // create better exception explanation
<span class="lineNum">   12385 </span>            :                 JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;));
<span class="lineNum">   12386 </span>            :             }
<span class="lineNum">   12387 </span>            :         }
<span class="lineNum">   12388 </span>            :         else
<span class="lineNum">   12389 </span>            :         {
<span class="lineNum">   12390 </span>            :             JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name())));
<span class="lineNum">   12391 </span>            :         }
<span class="lineNum">   12392 </span>            :     }
<span class="lineNum">   12393 </span>            : 
<span class="lineNum">   12394 </span>            :     /*!
<span class="lineNum">   12395 </span>            :     @brief access specified array element with bounds checking
<span class="lineNum">   12396 </span>            : 
<span class="lineNum">   12397 </span>            :     Returns a const reference to the element at specified location @a idx,
<span class="lineNum">   12398 </span>            :     with bounds checking.
<span class="lineNum">   12399 </span>            : 
<span class="lineNum">   12400 </span>            :     @param[in] idx  index of the element to access
<span class="lineNum">   12401 </span>            : 
<span class="lineNum">   12402 </span>            :     @return const reference to the element at index @a idx
<span class="lineNum">   12403 </span>            : 
<span class="lineNum">   12404 </span>            :     @throw type_error.304 if the JSON value is not an array; in this case,
<span class="lineNum">   12405 </span>            :     calling `at` with an index makes no sense. See example below.
<span class="lineNum">   12406 </span>            :     @throw out_of_range.401 if the index @a idx is out of range of the array;
<span class="lineNum">   12407 </span>            :     that is, `idx &gt;= size()`. See example below.
<span class="lineNum">   12408 </span>            : 
<span class="lineNum">   12409 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   12410 </span>            :     changes in the JSON value.
<span class="lineNum">   12411 </span>            : 
<span class="lineNum">   12412 </span>            :     @complexity Constant.
<span class="lineNum">   12413 </span>            : 
<span class="lineNum">   12414 </span>            :     @since version 1.0.0
<span class="lineNum">   12415 </span>            : 
<span class="lineNum">   12416 </span>            :     @liveexample{The example below shows how array elements can be read using
<span class="lineNum">   12417 </span>            :     `at()`. It also demonstrates the different exceptions that can be thrown.,
<span class="lineNum">   12418 </span>            :     at__size_type_const}
<span class="lineNum">   12419 </span>            :     */
<span class="lineNum">   12420 </span>            :     const_reference at(size_type idx) const
<span class="lineNum">   12421 </span>            :     {
<span class="lineNum">   12422 </span>            :         // at only works for arrays
<span class="lineNum">   12423 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   12424 </span>            :         {
<span class="lineNum">   12425 </span>            :             JSON_TRY
<span class="lineNum">   12426 </span>            :             {
<span class="lineNum">   12427 </span>            :                 return m_value.array-&gt;at(idx);
<span class="lineNum">   12428 </span>            :             }
<span class="lineNum">   12429 </span>            :             JSON_CATCH (std::out_of_range&amp;)
<span class="lineNum">   12430 </span>            :             {
<span class="lineNum">   12431 </span>            :                 // create better exception explanation
<span class="lineNum">   12432 </span>            :                 JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;));
<span class="lineNum">   12433 </span>            :             }
<span class="lineNum">   12434 </span>            :         }
<span class="lineNum">   12435 </span>            :         else
<span class="lineNum">   12436 </span>            :         {
<span class="lineNum">   12437 </span>            :             JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name())));
<span class="lineNum">   12438 </span>            :         }
<span class="lineNum">   12439 </span>            :     }
<span class="lineNum">   12440 </span>            : 
<span class="lineNum">   12441 </span>            :     /*!
<span class="lineNum">   12442 </span>            :     @brief access specified object element with bounds checking
<span class="lineNum">   12443 </span>            : 
<span class="lineNum">   12444 </span>            :     Returns a reference to the element at with specified key @a key, with
<span class="lineNum">   12445 </span>            :     bounds checking.
<span class="lineNum">   12446 </span>            : 
<span class="lineNum">   12447 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12448 </span>            : 
<span class="lineNum">   12449 </span>            :     @return reference to the element at key @a key
<span class="lineNum">   12450 </span>            : 
<span class="lineNum">   12451 </span>            :     @throw type_error.304 if the JSON value is not an object; in this case,
<span class="lineNum">   12452 </span>            :     calling `at` with a key makes no sense. See example below.
<span class="lineNum">   12453 </span>            :     @throw out_of_range.403 if the key @a key is is not stored in the object;
<span class="lineNum">   12454 </span>            :     that is, `find(key) == end()`. See example below.
<span class="lineNum">   12455 </span>            : 
<span class="lineNum">   12456 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   12457 </span>            :     changes in the JSON value.
<span class="lineNum">   12458 </span>            : 
<span class="lineNum">   12459 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12460 </span>            : 
<span class="lineNum">   12461 </span>            :     @sa @ref operator[](const typename object_t::key_type&amp;) for unchecked
<span class="lineNum">   12462 </span>            :     access by reference
<span class="lineNum">   12463 </span>            :     @sa @ref value() for access by value with a default value
<span class="lineNum">   12464 </span>            : 
<span class="lineNum">   12465 </span>            :     @since version 1.0.0
<span class="lineNum">   12466 </span>            : 
<span class="lineNum">   12467 </span>            :     @liveexample{The example below shows how object elements can be read and
<span class="lineNum">   12468 </span>            :     written using `at()`. It also demonstrates the different exceptions that
<span class="lineNum">   12469 </span>            :     can be thrown.,at__object_t_key_type}
<span class="lineNum">   12470 </span>            :     */
<span class="lineNum">   12471 </span>            :     reference at(const typename object_t::key_type&amp; key)
<span class="lineNum">   12472 </span>            :     {
<span class="lineNum">   12473 </span>            :         // at only works for objects
<span class="lineNum">   12474 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   12475 </span>            :         {
<span class="lineNum">   12476 </span>            :             JSON_TRY
<span class="lineNum">   12477 </span>            :             {
<span class="lineNum">   12478 </span>            :                 return m_value.object-&gt;at(key);
<span class="lineNum">   12479 </span>            :             }
<span class="lineNum">   12480 </span>            :             JSON_CATCH (std::out_of_range&amp;)
<span class="lineNum">   12481 </span>            :             {
<span class="lineNum">   12482 </span>            :                 // create better exception explanation
<span class="lineNum">   12483 </span>            :                 JSON_THROW(out_of_range::create(403, &quot;key '&quot; + key + &quot;' not found&quot;));
<span class="lineNum">   12484 </span>            :             }
<span class="lineNum">   12485 </span>            :         }
<span class="lineNum">   12486 </span>            :         else
<span class="lineNum">   12487 </span>            :         {
<span class="lineNum">   12488 </span>            :             JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name())));
<span class="lineNum">   12489 </span>            :         }
<span class="lineNum">   12490 </span>            :     }
<span class="lineNum">   12491 </span>            : 
<span class="lineNum">   12492 </span>            :     /*!
<span class="lineNum">   12493 </span>            :     @brief access specified object element with bounds checking
<span class="lineNum">   12494 </span>            : 
<span class="lineNum">   12495 </span>            :     Returns a const reference to the element at with specified key @a key,
<span class="lineNum">   12496 </span>            :     with bounds checking.
<span class="lineNum">   12497 </span>            : 
<span class="lineNum">   12498 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12499 </span>            : 
<span class="lineNum">   12500 </span>            :     @return const reference to the element at key @a key
<span class="lineNum">   12501 </span>            : 
<span class="lineNum">   12502 </span>            :     @throw type_error.304 if the JSON value is not an object; in this case,
<span class="lineNum">   12503 </span>            :     calling `at` with a key makes no sense. See example below.
<span class="lineNum">   12504 </span>            :     @throw out_of_range.403 if the key @a key is is not stored in the object;
<span class="lineNum">   12505 </span>            :     that is, `find(key) == end()`. See example below.
<span class="lineNum">   12506 </span>            : 
<span class="lineNum">   12507 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   12508 </span>            :     changes in the JSON value.
<span class="lineNum">   12509 </span>            : 
<span class="lineNum">   12510 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12511 </span>            : 
<span class="lineNum">   12512 </span>            :     @sa @ref operator[](const typename object_t::key_type&amp;) for unchecked
<span class="lineNum">   12513 </span>            :     access by reference
<span class="lineNum">   12514 </span>            :     @sa @ref value() for access by value with a default value
<span class="lineNum">   12515 </span>            : 
<span class="lineNum">   12516 </span>            :     @since version 1.0.0
<span class="lineNum">   12517 </span>            : 
<span class="lineNum">   12518 </span>            :     @liveexample{The example below shows how object elements can be read using
<span class="lineNum">   12519 </span>            :     `at()`. It also demonstrates the different exceptions that can be thrown.,
<span class="lineNum">   12520 </span>            :     at__object_t_key_type_const}
<span class="lineNum">   12521 </span>            :     */
<span class="lineNum">   12522 </span>            :     const_reference at(const typename object_t::key_type&amp; key) const
<span class="lineNum">   12523 </span>            :     {
<span class="lineNum">   12524 </span>            :         // at only works for objects
<span class="lineNum">   12525 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   12526 </span>            :         {
<span class="lineNum">   12527 </span>            :             JSON_TRY
<span class="lineNum">   12528 </span>            :             {
<span class="lineNum">   12529 </span>            :                 return m_value.object-&gt;at(key);
<span class="lineNum">   12530 </span>            :             }
<span class="lineNum">   12531 </span>            :             JSON_CATCH (std::out_of_range&amp;)
<span class="lineNum">   12532 </span>            :             {
<span class="lineNum">   12533 </span>            :                 // create better exception explanation
<span class="lineNum">   12534 </span>            :                 JSON_THROW(out_of_range::create(403, &quot;key '&quot; + key + &quot;' not found&quot;));
<span class="lineNum">   12535 </span>            :             }
<span class="lineNum">   12536 </span>            :         }
<span class="lineNum">   12537 </span>            :         else
<span class="lineNum">   12538 </span>            :         {
<span class="lineNum">   12539 </span>            :             JSON_THROW(type_error::create(304, &quot;cannot use at() with &quot; + std::string(type_name())));
<span class="lineNum">   12540 </span>            :         }
<span class="lineNum">   12541 </span>            :     }
<span class="lineNum">   12542 </span>            : 
<span class="lineNum">   12543 </span>            :     /*!
<span class="lineNum">   12544 </span>            :     @brief access specified array element
<span class="lineNum">   12545 </span>            : 
<span class="lineNum">   12546 </span>            :     Returns a reference to the element at specified location @a idx.
<span class="lineNum">   12547 </span>            : 
<span class="lineNum">   12548 </span>            :     @note If @a idx is beyond the range of the array (i.e., `idx &gt;= size()`),
<span class="lineNum">   12549 </span>            :     then the array is silently filled up with `null` values to make `idx` a
<span class="lineNum">   12550 </span>            :     valid reference to the last stored element.
<span class="lineNum">   12551 </span>            : 
<span class="lineNum">   12552 </span>            :     @param[in] idx  index of the element to access
<span class="lineNum">   12553 </span>            : 
<span class="lineNum">   12554 </span>            :     @return reference to the element at index @a idx
<span class="lineNum">   12555 </span>            : 
<span class="lineNum">   12556 </span>            :     @throw type_error.305 if the JSON value is not an array or null; in that
<span class="lineNum">   12557 </span>            :     cases, using the [] operator with an index makes no sense.
<span class="lineNum">   12558 </span>            : 
<span class="lineNum">   12559 </span>            :     @complexity Constant if @a idx is in the range of the array. Otherwise
<span class="lineNum">   12560 </span>            :     linear in `idx - size()`.
<span class="lineNum">   12561 </span>            : 
<span class="lineNum">   12562 </span>            :     @liveexample{The example below shows how array elements can be read and
<span class="lineNum">   12563 </span>            :     written using `[]` operator. Note the addition of `null`
<span class="lineNum">   12564 </span>            :     values.,operatorarray__size_type}
<span class="lineNum">   12565 </span>            : 
<span class="lineNum">   12566 </span>            :     @since version 1.0.0
<span class="lineNum">   12567 </span>            :     */
<span class="lineNum">   12568 </span>            :     reference operator[](size_type idx)
<span class="lineNum">   12569 </span>            :     {
<span class="lineNum">   12570 </span>            :         // implicitly convert null value to an empty array
<span class="lineNum">   12571 </span>            :         if (is_null())
<span class="lineNum">   12572 </span>            :         {
<span class="lineNum">   12573 </span>            :             m_type = value_t::array;
<span class="lineNum">   12574 </span>            :             m_value.array = create&lt;array_t&gt;();
<span class="lineNum">   12575 </span>            :             assert_invariant();
<span class="lineNum">   12576 </span>            :         }
<span class="lineNum">   12577 </span>            : 
<span class="lineNum">   12578 </span>            :         // operator[] only works for arrays
<span class="lineNum">   12579 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   12580 </span>            :         {
<span class="lineNum">   12581 </span>            :             // fill up array with null values if given idx is outside range
<span class="lineNum">   12582 </span>            :             if (idx &gt;= m_value.array-&gt;size())
<span class="lineNum">   12583 </span>            :             {
<span class="lineNum">   12584 </span>            :                 m_value.array-&gt;insert(m_value.array-&gt;end(),
<span class="lineNum">   12585 </span>            :                                       idx - m_value.array-&gt;size() + 1,
<span class="lineNum">   12586 </span>            :                                       basic_json());
<span class="lineNum">   12587 </span>            :             }
<span class="lineNum">   12588 </span>            : 
<span class="lineNum">   12589 </span>            :             return m_value.array-&gt;operator[](idx);
<span class="lineNum">   12590 </span>            :         }
<span class="lineNum">   12591 </span>            : 
<span class="lineNum">   12592 </span>            :         JSON_THROW(type_error::create(305, &quot;cannot use operator[] with &quot; + std::string(type_name())));
<span class="lineNum">   12593 </span>            :     }
<span class="lineNum">   12594 </span>            : 
<span class="lineNum">   12595 </span>            :     /*!
<span class="lineNum">   12596 </span>            :     @brief access specified array element
<span class="lineNum">   12597 </span>            : 
<span class="lineNum">   12598 </span>            :     Returns a const reference to the element at specified location @a idx.
<span class="lineNum">   12599 </span>            : 
<span class="lineNum">   12600 </span>            :     @param[in] idx  index of the element to access
<span class="lineNum">   12601 </span>            : 
<span class="lineNum">   12602 </span>            :     @return const reference to the element at index @a idx
<span class="lineNum">   12603 </span>            : 
<span class="lineNum">   12604 </span>            :     @throw type_error.305 if the JSON value is not an array; in that case,
<span class="lineNum">   12605 </span>            :     using the [] operator with an index makes no sense.
<span class="lineNum">   12606 </span>            : 
<span class="lineNum">   12607 </span>            :     @complexity Constant.
<span class="lineNum">   12608 </span>            : 
<span class="lineNum">   12609 </span>            :     @liveexample{The example below shows how array elements can be read using
<span class="lineNum">   12610 </span>            :     the `[]` operator.,operatorarray__size_type_const}
<span class="lineNum">   12611 </span>            : 
<a name="12612"><span class="lineNum">   12612 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   12613 </span>            :     */
<span class="lineNum">   12614 </span><span class="lineCov">        277 :     const_reference operator[](size_type idx) const</span>
<span class="lineNum">   12615 </span>            :     {
<span class="lineNum">   12616 </span>            :         // const operator[] only works for arrays
<span class="lineNum">   12617 </span><span class="lineCov">        277 :         if (JSON_LIKELY(is_array()))</span>
<span class="lineNum">   12618 </span>            :         {
<span class="lineNum">   12619 </span><span class="lineCov">        554 :             return m_value.array-&gt;operator[](idx);</span>
<span class="lineNum">   12620 </span>            :         }
<span class="lineNum">   12621 </span>            : 
<span class="lineNum">   12622 </span><span class="lineNoCov">          0 :         JSON_THROW(type_error::create(305, &quot;cannot use operator[] with &quot; + std::string(type_name())));</span>
<span class="lineNum">   12623 </span>            :     }
<span class="lineNum">   12624 </span>            : 
<span class="lineNum">   12625 </span>            :     /*!
<span class="lineNum">   12626 </span>            :     @brief access specified object element
<span class="lineNum">   12627 </span>            : 
<span class="lineNum">   12628 </span>            :     Returns a reference to the element at with specified key @a key.
<span class="lineNum">   12629 </span>            : 
<span class="lineNum">   12630 </span>            :     @note If @a key is not found in the object, then it is silently added to
<span class="lineNum">   12631 </span>            :     the object and filled with a `null` value to make `key` a valid reference.
<span class="lineNum">   12632 </span>            :     In case the value was `null` before, it is converted to an object.
<span class="lineNum">   12633 </span>            : 
<span class="lineNum">   12634 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12635 </span>            : 
<span class="lineNum">   12636 </span>            :     @return reference to the element at key @a key
<span class="lineNum">   12637 </span>            : 
<span class="lineNum">   12638 </span>            :     @throw type_error.305 if the JSON value is not an object or null; in that
<span class="lineNum">   12639 </span>            :     cases, using the [] operator with a key makes no sense.
<span class="lineNum">   12640 </span>            : 
<span class="lineNum">   12641 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12642 </span>            : 
<span class="lineNum">   12643 </span>            :     @liveexample{The example below shows how object elements can be read and
<span class="lineNum">   12644 </span>            :     written using the `[]` operator.,operatorarray__key_type}
<span class="lineNum">   12645 </span>            : 
<span class="lineNum">   12646 </span>            :     @sa @ref at(const typename object_t::key_type&amp;) for access by reference
<span class="lineNum">   12647 </span>            :     with range checking
<span class="lineNum">   12648 </span>            :     @sa @ref value() for access by value with a default value
<span class="lineNum">   12649 </span>            : 
<a name="12650"><span class="lineNum">   12650 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   12651 </span>            :     */
<span class="lineNum">   12652 </span><span class="lineCov">         30 :     reference operator[](const typename object_t::key_type&amp; key)</span>
<span class="lineNum">   12653 </span>            :     {
<span class="lineNum">   12654 </span>            :         // implicitly convert null value to an empty object
<span class="lineNum">   12655 </span><span class="lineCov">         30 :         if (is_null())</span>
<span class="lineNum">   12656 </span>            :         {
<span class="lineNum">   12657 </span><span class="lineCov">          6 :             m_type = value_t::object;</span>
<span class="lineNum">   12658 </span><span class="lineCov">          6 :             m_value.object = create&lt;object_t&gt;();</span>
<span class="lineNum">   12659 </span><span class="lineCov">          6 :             assert_invariant();</span>
<span class="lineNum">   12660 </span>            :         }
<span class="lineNum">   12661 </span>            : 
<span class="lineNum">   12662 </span>            :         // operator[] only works for objects
<span class="lineNum">   12663 </span><span class="lineCov">         30 :         if (JSON_LIKELY(is_object()))</span>
<span class="lineNum">   12664 </span>            :         {
<span class="lineNum">   12665 </span><span class="lineCov">         60 :             return m_value.object-&gt;operator[](key);</span>
<span class="lineNum">   12666 </span>            :         }
<span class="lineNum">   12667 </span>            : 
<span class="lineNum">   12668 </span><span class="lineNoCov">          0 :         JSON_THROW(type_error::create(305, &quot;cannot use operator[] with &quot; + std::string(type_name())));</span>
<span class="lineNum">   12669 </span>            :     }
<span class="lineNum">   12670 </span>            : 
<span class="lineNum">   12671 </span>            :     /*!
<span class="lineNum">   12672 </span>            :     @brief read-only access specified object element
<span class="lineNum">   12673 </span>            : 
<span class="lineNum">   12674 </span>            :     Returns a const reference to the element at with specified key @a key. No
<span class="lineNum">   12675 </span>            :     bounds checking is performed.
<span class="lineNum">   12676 </span>            : 
<span class="lineNum">   12677 </span>            :     @warning If the element with key @a key does not exist, the behavior is
<span class="lineNum">   12678 </span>            :     undefined.
<span class="lineNum">   12679 </span>            : 
<span class="lineNum">   12680 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12681 </span>            : 
<span class="lineNum">   12682 </span>            :     @return const reference to the element at key @a key
<span class="lineNum">   12683 </span>            : 
<span class="lineNum">   12684 </span>            :     @pre The element with key @a key must exist. **This precondition is
<span class="lineNum">   12685 </span>            :          enforced with an assertion.**
<span class="lineNum">   12686 </span>            : 
<span class="lineNum">   12687 </span>            :     @throw type_error.305 if the JSON value is not an object; in that case,
<span class="lineNum">   12688 </span>            :     using the [] operator with a key makes no sense.
<span class="lineNum">   12689 </span>            : 
<span class="lineNum">   12690 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12691 </span>            : 
<span class="lineNum">   12692 </span>            :     @liveexample{The example below shows how object elements can be read using
<span class="lineNum">   12693 </span>            :     the `[]` operator.,operatorarray__key_type_const}
<span class="lineNum">   12694 </span>            : 
<span class="lineNum">   12695 </span>            :     @sa @ref at(const typename object_t::key_type&amp;) for access by reference
<span class="lineNum">   12696 </span>            :     with range checking
<span class="lineNum">   12697 </span>            :     @sa @ref value() for access by value with a default value
<span class="lineNum">   12698 </span>            : 
<span class="lineNum">   12699 </span>            :     @since version 1.0.0
<span class="lineNum">   12700 </span>            :     */
<span class="lineNum">   12701 </span>            :     const_reference operator[](const typename object_t::key_type&amp; key) const
<span class="lineNum">   12702 </span>            :     {
<span class="lineNum">   12703 </span>            :         // const operator[] only works for objects
<span class="lineNum">   12704 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   12705 </span>            :         {
<span class="lineNum">   12706 </span>            :             assert(m_value.object-&gt;find(key) != m_value.object-&gt;end());
<span class="lineNum">   12707 </span>            :             return m_value.object-&gt;find(key)-&gt;second;
<span class="lineNum">   12708 </span>            :         }
<span class="lineNum">   12709 </span>            : 
<span class="lineNum">   12710 </span>            :         JSON_THROW(type_error::create(305, &quot;cannot use operator[] with &quot; + std::string(type_name())));
<span class="lineNum">   12711 </span>            :     }
<span class="lineNum">   12712 </span>            : 
<span class="lineNum">   12713 </span>            :     /*!
<span class="lineNum">   12714 </span>            :     @brief access specified object element
<span class="lineNum">   12715 </span>            : 
<span class="lineNum">   12716 </span>            :     Returns a reference to the element at with specified key @a key.
<span class="lineNum">   12717 </span>            : 
<span class="lineNum">   12718 </span>            :     @note If @a key is not found in the object, then it is silently added to
<span class="lineNum">   12719 </span>            :     the object and filled with a `null` value to make `key` a valid reference.
<span class="lineNum">   12720 </span>            :     In case the value was `null` before, it is converted to an object.
<span class="lineNum">   12721 </span>            : 
<span class="lineNum">   12722 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12723 </span>            : 
<span class="lineNum">   12724 </span>            :     @return reference to the element at key @a key
<span class="lineNum">   12725 </span>            : 
<span class="lineNum">   12726 </span>            :     @throw type_error.305 if the JSON value is not an object or null; in that
<span class="lineNum">   12727 </span>            :     cases, using the [] operator with a key makes no sense.
<span class="lineNum">   12728 </span>            : 
<span class="lineNum">   12729 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12730 </span>            : 
<span class="lineNum">   12731 </span>            :     @liveexample{The example below shows how object elements can be read and
<span class="lineNum">   12732 </span>            :     written using the `[]` operator.,operatorarray__key_type}
<span class="lineNum">   12733 </span>            : 
<span class="lineNum">   12734 </span>            :     @sa @ref at(const typename object_t::key_type&amp;) for access by reference
<span class="lineNum">   12735 </span>            :     with range checking
<span class="lineNum">   12736 </span>            :     @sa @ref value() for access by value with a default value
<span class="lineNum">   12737 </span>            : 
<span class="lineNum">   12738 </span>            :     @since version 1.1.0
<a name="12739"><span class="lineNum">   12739 </span>            :     */</a>
<span class="lineNum">   12740 </span>            :     template&lt;typename T&gt;
<span class="lineNum">   12741 </span><span class="lineCov">         16 :     reference operator[](T* key)</span>
<span class="lineNum">   12742 </span>            :     {
<span class="lineNum">   12743 </span>            :         // implicitly convert null to object
<span class="lineNum">   12744 </span><span class="lineCov">         16 :         if (is_null())</span>
<span class="lineNum">   12745 </span>            :         {
<span class="lineNum">   12746 </span><span class="lineCov">          3 :             m_type = value_t::object;</span>
<span class="lineNum">   12747 </span><span class="lineCov">          3 :             m_value = value_t::object;</span>
<span class="lineNum">   12748 </span><span class="lineCov">          3 :             assert_invariant();</span>
<span class="lineNum">   12749 </span>            :         }
<span class="lineNum">   12750 </span>            : 
<span class="lineNum">   12751 </span>            :         // at only works for objects
<span class="lineNum">   12752 </span><span class="lineCov">         16 :         if (JSON_LIKELY(is_object()))</span>
<span class="lineNum">   12753 </span>            :         {
<span class="lineNum">   12754 </span><span class="lineCov">         32 :             return m_value.object-&gt;operator[](key);</span>
<span class="lineNum">   12755 </span>            :         }
<span class="lineNum">   12756 </span>            : 
<span class="lineNum">   12757 </span><span class="lineNoCov">          0 :         JSON_THROW(type_error::create(305, &quot;cannot use operator[] with &quot; + std::string(type_name())));</span>
<span class="lineNum">   12758 </span>            :     }
<span class="lineNum">   12759 </span>            : 
<span class="lineNum">   12760 </span>            :     /*!
<span class="lineNum">   12761 </span>            :     @brief read-only access specified object element
<span class="lineNum">   12762 </span>            : 
<span class="lineNum">   12763 </span>            :     Returns a const reference to the element at with specified key @a key. No
<span class="lineNum">   12764 </span>            :     bounds checking is performed.
<span class="lineNum">   12765 </span>            : 
<span class="lineNum">   12766 </span>            :     @warning If the element with key @a key does not exist, the behavior is
<span class="lineNum">   12767 </span>            :     undefined.
<span class="lineNum">   12768 </span>            : 
<span class="lineNum">   12769 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12770 </span>            : 
<span class="lineNum">   12771 </span>            :     @return const reference to the element at key @a key
<span class="lineNum">   12772 </span>            : 
<span class="lineNum">   12773 </span>            :     @pre The element with key @a key must exist. **This precondition is
<span class="lineNum">   12774 </span>            :          enforced with an assertion.**
<span class="lineNum">   12775 </span>            : 
<span class="lineNum">   12776 </span>            :     @throw type_error.305 if the JSON value is not an object; in that case,
<span class="lineNum">   12777 </span>            :     using the [] operator with a key makes no sense.
<span class="lineNum">   12778 </span>            : 
<span class="lineNum">   12779 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12780 </span>            : 
<span class="lineNum">   12781 </span>            :     @liveexample{The example below shows how object elements can be read using
<span class="lineNum">   12782 </span>            :     the `[]` operator.,operatorarray__key_type_const}
<span class="lineNum">   12783 </span>            : 
<span class="lineNum">   12784 </span>            :     @sa @ref at(const typename object_t::key_type&amp;) for access by reference
<span class="lineNum">   12785 </span>            :     with range checking
<span class="lineNum">   12786 </span>            :     @sa @ref value() for access by value with a default value
<span class="lineNum">   12787 </span>            : 
<span class="lineNum">   12788 </span>            :     @since version 1.1.0
<a name="12789"><span class="lineNum">   12789 </span>            :     */</a>
<span class="lineNum">   12790 </span>            :     template&lt;typename T&gt;
<span class="lineNum">   12791 </span><span class="lineCov">        411 :     const_reference operator[](T* key) const</span>
<span class="lineNum">   12792 </span>            :     {
<span class="lineNum">   12793 </span>            :         // at only works for objects
<span class="lineNum">   12794 </span><span class="lineCov">        411 :         if (JSON_LIKELY(is_object()))</span>
<span class="lineNum">   12795 </span>            :         {
<span class="lineNum">   12796 </span><span class="lineCov">        411 :             assert(m_value.object-&gt;find(key) != m_value.object-&gt;end());</span>
<span class="lineNum">   12797 </span><span class="lineCov">        822 :             return m_value.object-&gt;find(key)-&gt;second;</span>
<span class="lineNum">   12798 </span>            :         }
<span class="lineNum">   12799 </span>            : 
<span class="lineNum">   12800 </span><span class="lineNoCov">          0 :         JSON_THROW(type_error::create(305, &quot;cannot use operator[] with &quot; + std::string(type_name())));</span>
<span class="lineNum">   12801 </span>            :     }
<span class="lineNum">   12802 </span>            : 
<span class="lineNum">   12803 </span>            :     /*!
<span class="lineNum">   12804 </span>            :     @brief access specified object element with default value
<span class="lineNum">   12805 </span>            : 
<span class="lineNum">   12806 </span>            :     Returns either a copy of an object's element at the specified key @a key
<span class="lineNum">   12807 </span>            :     or a given default value if no element with key @a key exists.
<span class="lineNum">   12808 </span>            : 
<span class="lineNum">   12809 </span>            :     The function is basically equivalent to executing
<span class="lineNum">   12810 </span>            :     @code {.cpp}
<span class="lineNum">   12811 </span>            :     try {
<span class="lineNum">   12812 </span>            :         return at(key);
<span class="lineNum">   12813 </span>            :     } catch(out_of_range) {
<span class="lineNum">   12814 </span>            :         return default_value;
<span class="lineNum">   12815 </span>            :     }
<span class="lineNum">   12816 </span>            :     @endcode
<span class="lineNum">   12817 </span>            : 
<span class="lineNum">   12818 </span>            :     @note Unlike @ref at(const typename object_t::key_type&amp;), this function
<span class="lineNum">   12819 </span>            :     does not throw if the given key @a key was not found.
<span class="lineNum">   12820 </span>            : 
<span class="lineNum">   12821 </span>            :     @note Unlike @ref operator[](const typename object_t::key_type&amp; key), this
<span class="lineNum">   12822 </span>            :     function does not implicitly add an element to the position defined by @a
<span class="lineNum">   12823 </span>            :     key. This function is furthermore also applicable to const objects.
<span class="lineNum">   12824 </span>            : 
<span class="lineNum">   12825 </span>            :     @param[in] key  key of the element to access
<span class="lineNum">   12826 </span>            :     @param[in] default_value  the value to return if @a key is not found
<span class="lineNum">   12827 </span>            : 
<span class="lineNum">   12828 </span>            :     @tparam ValueType type compatible to JSON values, for instance `int` for
<span class="lineNum">   12829 </span>            :     JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
<span class="lineNum">   12830 </span>            :     JSON arrays. Note the type of the expected value at @a key and the default
<span class="lineNum">   12831 </span>            :     value @a default_value must be compatible.
<span class="lineNum">   12832 </span>            : 
<span class="lineNum">   12833 </span>            :     @return copy of the element at key @a key or @a default_value if @a key
<span class="lineNum">   12834 </span>            :     is not found
<span class="lineNum">   12835 </span>            : 
<span class="lineNum">   12836 </span>            :     @throw type_error.306 if the JSON value is not an object; in that case,
<span class="lineNum">   12837 </span>            :     using `value()` with a key makes no sense.
<span class="lineNum">   12838 </span>            : 
<span class="lineNum">   12839 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12840 </span>            : 
<span class="lineNum">   12841 </span>            :     @liveexample{The example below shows how object elements can be queried
<span class="lineNum">   12842 </span>            :     with a default value.,basic_json__value}
<span class="lineNum">   12843 </span>            : 
<span class="lineNum">   12844 </span>            :     @sa @ref at(const typename object_t::key_type&amp;) for access by reference
<span class="lineNum">   12845 </span>            :     with range checking
<span class="lineNum">   12846 </span>            :     @sa @ref operator[](const typename object_t::key_type&amp;) for unchecked
<span class="lineNum">   12847 </span>            :     access by reference
<span class="lineNum">   12848 </span>            : 
<span class="lineNum">   12849 </span>            :     @since version 1.0.0
<span class="lineNum">   12850 </span>            :     */
<span class="lineNum">   12851 </span>            :     template&lt;class ValueType, typename std::enable_if&lt;
<span class="lineNum">   12852 </span>            :                  std::is_convertible&lt;basic_json_t, ValueType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12853 </span>            :     ValueType value(const typename object_t::key_type&amp; key, const ValueType&amp; default_value) const
<span class="lineNum">   12854 </span>            :     {
<span class="lineNum">   12855 </span>            :         // at only works for objects
<span class="lineNum">   12856 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   12857 </span>            :         {
<span class="lineNum">   12858 </span>            :             // if key is found, return value and given default value otherwise
<span class="lineNum">   12859 </span>            :             const auto it = find(key);
<span class="lineNum">   12860 </span>            :             if (it != end())
<span class="lineNum">   12861 </span>            :             {
<span class="lineNum">   12862 </span>            :                 return *it;
<span class="lineNum">   12863 </span>            :             }
<span class="lineNum">   12864 </span>            : 
<span class="lineNum">   12865 </span>            :             return default_value;
<span class="lineNum">   12866 </span>            :         }
<span class="lineNum">   12867 </span>            : 
<span class="lineNum">   12868 </span>            :         JSON_THROW(type_error::create(306, &quot;cannot use value() with &quot; + std::string(type_name())));
<span class="lineNum">   12869 </span>            :     }
<span class="lineNum">   12870 </span>            : 
<span class="lineNum">   12871 </span>            :     /*!
<span class="lineNum">   12872 </span>            :     @brief overload for a default value of type const char*
<span class="lineNum">   12873 </span>            :     @copydoc basic_json::value(const typename object_t::key_type&amp;, ValueType) const
<span class="lineNum">   12874 </span>            :     */
<span class="lineNum">   12875 </span>            :     string_t value(const typename object_t::key_type&amp; key, const char* default_value) const
<span class="lineNum">   12876 </span>            :     {
<span class="lineNum">   12877 </span>            :         return value(key, string_t(default_value));
<span class="lineNum">   12878 </span>            :     }
<span class="lineNum">   12879 </span>            : 
<span class="lineNum">   12880 </span>            :     /*!
<span class="lineNum">   12881 </span>            :     @brief access specified object element via JSON Pointer with default value
<span class="lineNum">   12882 </span>            : 
<span class="lineNum">   12883 </span>            :     Returns either a copy of an object's element at the specified key @a key
<span class="lineNum">   12884 </span>            :     or a given default value if no element with key @a key exists.
<span class="lineNum">   12885 </span>            : 
<span class="lineNum">   12886 </span>            :     The function is basically equivalent to executing
<span class="lineNum">   12887 </span>            :     @code {.cpp}
<span class="lineNum">   12888 </span>            :     try {
<span class="lineNum">   12889 </span>            :         return at(ptr);
<span class="lineNum">   12890 </span>            :     } catch(out_of_range) {
<span class="lineNum">   12891 </span>            :         return default_value;
<span class="lineNum">   12892 </span>            :     }
<span class="lineNum">   12893 </span>            :     @endcode
<span class="lineNum">   12894 </span>            : 
<span class="lineNum">   12895 </span>            :     @note Unlike @ref at(const json_pointer&amp;), this function does not throw
<span class="lineNum">   12896 </span>            :     if the given key @a key was not found.
<span class="lineNum">   12897 </span>            : 
<span class="lineNum">   12898 </span>            :     @param[in] ptr  a JSON pointer to the element to access
<span class="lineNum">   12899 </span>            :     @param[in] default_value  the value to return if @a ptr found no value
<span class="lineNum">   12900 </span>            : 
<span class="lineNum">   12901 </span>            :     @tparam ValueType type compatible to JSON values, for instance `int` for
<span class="lineNum">   12902 </span>            :     JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
<span class="lineNum">   12903 </span>            :     JSON arrays. Note the type of the expected value at @a key and the default
<span class="lineNum">   12904 </span>            :     value @a default_value must be compatible.
<span class="lineNum">   12905 </span>            : 
<span class="lineNum">   12906 </span>            :     @return copy of the element at key @a key or @a default_value if @a key
<span class="lineNum">   12907 </span>            :     is not found
<span class="lineNum">   12908 </span>            : 
<span class="lineNum">   12909 </span>            :     @throw type_error.306 if the JSON value is not an objec; in that case,
<span class="lineNum">   12910 </span>            :     using `value()` with a key makes no sense.
<span class="lineNum">   12911 </span>            : 
<span class="lineNum">   12912 </span>            :     @complexity Logarithmic in the size of the container.
<span class="lineNum">   12913 </span>            : 
<span class="lineNum">   12914 </span>            :     @liveexample{The example below shows how object elements can be queried
<span class="lineNum">   12915 </span>            :     with a default value.,basic_json__value_ptr}
<span class="lineNum">   12916 </span>            : 
<span class="lineNum">   12917 </span>            :     @sa @ref operator[](const json_pointer&amp;) for unchecked access by reference
<span class="lineNum">   12918 </span>            : 
<span class="lineNum">   12919 </span>            :     @since version 2.0.2
<span class="lineNum">   12920 </span>            :     */
<span class="lineNum">   12921 </span>            :     template&lt;class ValueType, typename std::enable_if&lt;
<span class="lineNum">   12922 </span>            :                  std::is_convertible&lt;basic_json_t, ValueType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   12923 </span>            :     ValueType value(const json_pointer&amp; ptr, const ValueType&amp; default_value) const
<span class="lineNum">   12924 </span>            :     {
<span class="lineNum">   12925 </span>            :         // at only works for objects
<span class="lineNum">   12926 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   12927 </span>            :         {
<span class="lineNum">   12928 </span>            :             // if pointer resolves a value, return it or use default value
<span class="lineNum">   12929 </span>            :             JSON_TRY
<span class="lineNum">   12930 </span>            :             {
<span class="lineNum">   12931 </span>            :                 return ptr.get_checked(this);
<span class="lineNum">   12932 </span>            :             }
<span class="lineNum">   12933 </span>            :             JSON_CATCH (out_of_range&amp;)
<span class="lineNum">   12934 </span>            :             {
<span class="lineNum">   12935 </span>            :                 return default_value;
<span class="lineNum">   12936 </span>            :             }
<span class="lineNum">   12937 </span>            :         }
<span class="lineNum">   12938 </span>            : 
<span class="lineNum">   12939 </span>            :         JSON_THROW(type_error::create(306, &quot;cannot use value() with &quot; + std::string(type_name())));
<span class="lineNum">   12940 </span>            :     }
<span class="lineNum">   12941 </span>            : 
<span class="lineNum">   12942 </span>            :     /*!
<span class="lineNum">   12943 </span>            :     @brief overload for a default value of type const char*
<span class="lineNum">   12944 </span>            :     @copydoc basic_json::value(const json_pointer&amp;, ValueType) const
<span class="lineNum">   12945 </span>            :     */
<span class="lineNum">   12946 </span>            :     string_t value(const json_pointer&amp; ptr, const char* default_value) const
<span class="lineNum">   12947 </span>            :     {
<span class="lineNum">   12948 </span>            :         return value(ptr, string_t(default_value));
<span class="lineNum">   12949 </span>            :     }
<span class="lineNum">   12950 </span>            : 
<span class="lineNum">   12951 </span>            :     /*!
<span class="lineNum">   12952 </span>            :     @brief access the first element
<span class="lineNum">   12953 </span>            : 
<span class="lineNum">   12954 </span>            :     Returns a reference to the first element in the container. For a JSON
<span class="lineNum">   12955 </span>            :     container `c`, the expression `c.front()` is equivalent to `*c.begin()`.
<span class="lineNum">   12956 </span>            : 
<span class="lineNum">   12957 </span>            :     @return In case of a structured type (array or object), a reference to the
<span class="lineNum">   12958 </span>            :     first element is returned. In case of number, string, or boolean values, a
<span class="lineNum">   12959 </span>            :     reference to the value is returned.
<span class="lineNum">   12960 </span>            : 
<span class="lineNum">   12961 </span>            :     @complexity Constant.
<span class="lineNum">   12962 </span>            : 
<span class="lineNum">   12963 </span>            :     @pre The JSON value must not be `null` (would throw `std::out_of_range`)
<span class="lineNum">   12964 </span>            :     or an empty array or object (undefined behavior, **guarded by
<span class="lineNum">   12965 </span>            :     assertions**).
<span class="lineNum">   12966 </span>            :     @post The JSON value remains unchanged.
<span class="lineNum">   12967 </span>            : 
<span class="lineNum">   12968 </span>            :     @throw invalid_iterator.214 when called on `null` value
<span class="lineNum">   12969 </span>            : 
<span class="lineNum">   12970 </span>            :     @liveexample{The following code shows an example for `front()`.,front}
<span class="lineNum">   12971 </span>            : 
<span class="lineNum">   12972 </span>            :     @sa @ref back() -- access the last element
<span class="lineNum">   12973 </span>            : 
<span class="lineNum">   12974 </span>            :     @since version 1.0.0
<span class="lineNum">   12975 </span>            :     */
<span class="lineNum">   12976 </span>            :     reference front()
<span class="lineNum">   12977 </span>            :     {
<span class="lineNum">   12978 </span>            :         return *begin();
<span class="lineNum">   12979 </span>            :     }
<span class="lineNum">   12980 </span>            : 
<span class="lineNum">   12981 </span>            :     /*!
<span class="lineNum">   12982 </span>            :     @copydoc basic_json::front()
<span class="lineNum">   12983 </span>            :     */
<span class="lineNum">   12984 </span>            :     const_reference front() const
<span class="lineNum">   12985 </span>            :     {
<span class="lineNum">   12986 </span>            :         return *cbegin();
<span class="lineNum">   12987 </span>            :     }
<span class="lineNum">   12988 </span>            : 
<span class="lineNum">   12989 </span>            :     /*!
<span class="lineNum">   12990 </span>            :     @brief access the last element
<span class="lineNum">   12991 </span>            : 
<span class="lineNum">   12992 </span>            :     Returns a reference to the last element in the container. For a JSON
<span class="lineNum">   12993 </span>            :     container `c`, the expression `c.back()` is equivalent to
<span class="lineNum">   12994 </span>            :     @code {.cpp}
<span class="lineNum">   12995 </span>            :     auto tmp = c.end();
<span class="lineNum">   12996 </span>            :     --tmp;
<span class="lineNum">   12997 </span>            :     return *tmp;
<span class="lineNum">   12998 </span>            :     @endcode
<span class="lineNum">   12999 </span>            : 
<span class="lineNum">   13000 </span>            :     @return In case of a structured type (array or object), a reference to the
<span class="lineNum">   13001 </span>            :     last element is returned. In case of number, string, or boolean values, a
<span class="lineNum">   13002 </span>            :     reference to the value is returned.
<span class="lineNum">   13003 </span>            : 
<span class="lineNum">   13004 </span>            :     @complexity Constant.
<span class="lineNum">   13005 </span>            : 
<span class="lineNum">   13006 </span>            :     @pre The JSON value must not be `null` (would throw `std::out_of_range`)
<span class="lineNum">   13007 </span>            :     or an empty array or object (undefined behavior, **guarded by
<span class="lineNum">   13008 </span>            :     assertions**).
<span class="lineNum">   13009 </span>            :     @post The JSON value remains unchanged.
<span class="lineNum">   13010 </span>            : 
<span class="lineNum">   13011 </span>            :     @throw invalid_iterator.214 when called on a `null` value. See example
<span class="lineNum">   13012 </span>            :     below.
<span class="lineNum">   13013 </span>            : 
<span class="lineNum">   13014 </span>            :     @liveexample{The following code shows an example for `back()`.,back}
<span class="lineNum">   13015 </span>            : 
<span class="lineNum">   13016 </span>            :     @sa @ref front() -- access the first element
<span class="lineNum">   13017 </span>            : 
<span class="lineNum">   13018 </span>            :     @since version 1.0.0
<span class="lineNum">   13019 </span>            :     */
<span class="lineNum">   13020 </span>            :     reference back()
<span class="lineNum">   13021 </span>            :     {
<span class="lineNum">   13022 </span>            :         auto tmp = end();
<span class="lineNum">   13023 </span>            :         --tmp;
<span class="lineNum">   13024 </span>            :         return *tmp;
<span class="lineNum">   13025 </span>            :     }
<span class="lineNum">   13026 </span>            : 
<span class="lineNum">   13027 </span>            :     /*!
<span class="lineNum">   13028 </span>            :     @copydoc basic_json::back()
<span class="lineNum">   13029 </span>            :     */
<span class="lineNum">   13030 </span>            :     const_reference back() const
<span class="lineNum">   13031 </span>            :     {
<span class="lineNum">   13032 </span>            :         auto tmp = cend();
<span class="lineNum">   13033 </span>            :         --tmp;
<span class="lineNum">   13034 </span>            :         return *tmp;
<span class="lineNum">   13035 </span>            :     }
<span class="lineNum">   13036 </span>            : 
<span class="lineNum">   13037 </span>            :     /*!
<span class="lineNum">   13038 </span>            :     @brief remove element given an iterator
<span class="lineNum">   13039 </span>            : 
<span class="lineNum">   13040 </span>            :     Removes the element specified by iterator @a pos. The iterator @a pos must
<span class="lineNum">   13041 </span>            :     be valid and dereferenceable. Thus the `end()` iterator (which is valid,
<span class="lineNum">   13042 </span>            :     but is not dereferenceable) cannot be used as a value for @a pos.
<span class="lineNum">   13043 </span>            : 
<span class="lineNum">   13044 </span>            :     If called on a primitive type other than `null`, the resulting JSON value
<span class="lineNum">   13045 </span>            :     will be `null`.
<span class="lineNum">   13046 </span>            : 
<span class="lineNum">   13047 </span>            :     @param[in] pos iterator to the element to remove
<span class="lineNum">   13048 </span>            :     @return Iterator following the last removed element. If the iterator @a
<span class="lineNum">   13049 </span>            :     pos refers to the last element, the `end()` iterator is returned.
<span class="lineNum">   13050 </span>            : 
<span class="lineNum">   13051 </span>            :     @tparam IteratorType an @ref iterator or @ref const_iterator
<span class="lineNum">   13052 </span>            : 
<span class="lineNum">   13053 </span>            :     @post Invalidates iterators and references at or after the point of the
<span class="lineNum">   13054 </span>            :     erase, including the `end()` iterator.
<span class="lineNum">   13055 </span>            : 
<span class="lineNum">   13056 </span>            :     @throw type_error.307 if called on a `null` value; example: `&quot;cannot use
<span class="lineNum">   13057 </span>            :     erase() with null&quot;`
<span class="lineNum">   13058 </span>            :     @throw invalid_iterator.202 if called on an iterator which does not belong
<span class="lineNum">   13059 </span>            :     to the current JSON value; example: `&quot;iterator does not fit current
<span class="lineNum">   13060 </span>            :     value&quot;`
<span class="lineNum">   13061 </span>            :     @throw invalid_iterator.205 if called on a primitive type with invalid
<span class="lineNum">   13062 </span>            :     iterator (i.e., any iterator which is not `begin()`); example: `&quot;iterator
<span class="lineNum">   13063 </span>            :     out of range&quot;`
<span class="lineNum">   13064 </span>            : 
<span class="lineNum">   13065 </span>            :     @complexity The complexity depends on the type:
<span class="lineNum">   13066 </span>            :     - objects: amortized constant
<span class="lineNum">   13067 </span>            :     - arrays: linear in distance between @a pos and the end of the container
<span class="lineNum">   13068 </span>            :     - strings: linear in the length of the string
<span class="lineNum">   13069 </span>            :     - other types: constant
<span class="lineNum">   13070 </span>            : 
<span class="lineNum">   13071 </span>            :     @liveexample{The example shows the result of `erase()` for different JSON
<span class="lineNum">   13072 </span>            :     types.,erase__IteratorType}
<span class="lineNum">   13073 </span>            : 
<span class="lineNum">   13074 </span>            :     @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
<span class="lineNum">   13075 </span>            :     the given range
<span class="lineNum">   13076 </span>            :     @sa @ref erase(const typename object_t::key_type&amp;) -- removes the element
<span class="lineNum">   13077 </span>            :     from an object at the given key
<span class="lineNum">   13078 </span>            :     @sa @ref erase(const size_type) -- removes the element from an array at
<span class="lineNum">   13079 </span>            :     the given index
<span class="lineNum">   13080 </span>            : 
<span class="lineNum">   13081 </span>            :     @since version 1.0.0
<span class="lineNum">   13082 </span>            :     */
<span class="lineNum">   13083 </span>            :     template&lt;class IteratorType, typename std::enable_if&lt;
<span class="lineNum">   13084 </span>            :                  std::is_same&lt;IteratorType, typename basic_json_t::iterator&gt;::value or
<span class="lineNum">   13085 </span>            :                  std::is_same&lt;IteratorType, typename basic_json_t::const_iterator&gt;::value, int&gt;::type
<span class="lineNum">   13086 </span>            :              = 0&gt;
<span class="lineNum">   13087 </span>            :     IteratorType erase(IteratorType pos)
<span class="lineNum">   13088 </span>            :     {
<span class="lineNum">   13089 </span>            :         // make sure iterator fits the current value
<span class="lineNum">   13090 </span>            :         if (JSON_UNLIKELY(this != pos.m_object))
<span class="lineNum">   13091 </span>            :         {
<span class="lineNum">   13092 </span>            :             JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;));
<span class="lineNum">   13093 </span>            :         }
<span class="lineNum">   13094 </span>            : 
<span class="lineNum">   13095 </span>            :         IteratorType result = end();
<span class="lineNum">   13096 </span>            : 
<span class="lineNum">   13097 </span>            :         switch (m_type)
<span class="lineNum">   13098 </span>            :         {
<span class="lineNum">   13099 </span>            :             case value_t::boolean:
<span class="lineNum">   13100 </span>            :             case value_t::number_float:
<span class="lineNum">   13101 </span>            :             case value_t::number_integer:
<span class="lineNum">   13102 </span>            :             case value_t::number_unsigned:
<span class="lineNum">   13103 </span>            :             case value_t::string:
<span class="lineNum">   13104 </span>            :             {
<span class="lineNum">   13105 </span>            :                 if (JSON_UNLIKELY(not pos.m_it.primitive_iterator.is_begin()))
<span class="lineNum">   13106 </span>            :                 {
<span class="lineNum">   13107 </span>            :                     JSON_THROW(invalid_iterator::create(205, &quot;iterator out of range&quot;));
<span class="lineNum">   13108 </span>            :                 }
<span class="lineNum">   13109 </span>            : 
<span class="lineNum">   13110 </span>            :                 if (is_string())
<span class="lineNum">   13111 </span>            :                 {
<span class="lineNum">   13112 </span>            :                     AllocatorType&lt;string_t&gt; alloc;
<span class="lineNum">   13113 </span>            :                     std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);
<span class="lineNum">   13114 </span>            :                     std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);
<span class="lineNum">   13115 </span>            :                     m_value.string = nullptr;
<span class="lineNum">   13116 </span>            :                 }
<span class="lineNum">   13117 </span>            : 
<span class="lineNum">   13118 </span>            :                 m_type = value_t::null;
<span class="lineNum">   13119 </span>            :                 assert_invariant();
<span class="lineNum">   13120 </span>            :                 break;
<span class="lineNum">   13121 </span>            :             }
<span class="lineNum">   13122 </span>            : 
<span class="lineNum">   13123 </span>            :             case value_t::object:
<span class="lineNum">   13124 </span>            :             {
<span class="lineNum">   13125 </span>            :                 result.m_it.object_iterator = m_value.object-&gt;erase(pos.m_it.object_iterator);
<span class="lineNum">   13126 </span>            :                 break;
<span class="lineNum">   13127 </span>            :             }
<span class="lineNum">   13128 </span>            : 
<span class="lineNum">   13129 </span>            :             case value_t::array:
<span class="lineNum">   13130 </span>            :             {
<span class="lineNum">   13131 </span>            :                 result.m_it.array_iterator = m_value.array-&gt;erase(pos.m_it.array_iterator);
<span class="lineNum">   13132 </span>            :                 break;
<span class="lineNum">   13133 </span>            :             }
<span class="lineNum">   13134 </span>            : 
<span class="lineNum">   13135 </span>            :             default:
<span class="lineNum">   13136 </span>            :                 JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name())));
<span class="lineNum">   13137 </span>            :         }
<span class="lineNum">   13138 </span>            : 
<span class="lineNum">   13139 </span>            :         return result;
<span class="lineNum">   13140 </span>            :     }
<span class="lineNum">   13141 </span>            : 
<span class="lineNum">   13142 </span>            :     /*!
<span class="lineNum">   13143 </span>            :     @brief remove elements given an iterator range
<span class="lineNum">   13144 </span>            : 
<span class="lineNum">   13145 </span>            :     Removes the element specified by the range `[first; last)`. The iterator
<span class="lineNum">   13146 </span>            :     @a first does not need to be dereferenceable if `first == last`: erasing
<span class="lineNum">   13147 </span>            :     an empty range is a no-op.
<span class="lineNum">   13148 </span>            : 
<span class="lineNum">   13149 </span>            :     If called on a primitive type other than `null`, the resulting JSON value
<span class="lineNum">   13150 </span>            :     will be `null`.
<span class="lineNum">   13151 </span>            : 
<span class="lineNum">   13152 </span>            :     @param[in] first iterator to the beginning of the range to remove
<span class="lineNum">   13153 </span>            :     @param[in] last iterator past the end of the range to remove
<span class="lineNum">   13154 </span>            :     @return Iterator following the last removed element. If the iterator @a
<span class="lineNum">   13155 </span>            :     second refers to the last element, the `end()` iterator is returned.
<span class="lineNum">   13156 </span>            : 
<span class="lineNum">   13157 </span>            :     @tparam IteratorType an @ref iterator or @ref const_iterator
<span class="lineNum">   13158 </span>            : 
<span class="lineNum">   13159 </span>            :     @post Invalidates iterators and references at or after the point of the
<span class="lineNum">   13160 </span>            :     erase, including the `end()` iterator.
<span class="lineNum">   13161 </span>            : 
<span class="lineNum">   13162 </span>            :     @throw type_error.307 if called on a `null` value; example: `&quot;cannot use
<span class="lineNum">   13163 </span>            :     erase() with null&quot;`
<span class="lineNum">   13164 </span>            :     @throw invalid_iterator.203 if called on iterators which does not belong
<span class="lineNum">   13165 </span>            :     to the current JSON value; example: `&quot;iterators do not fit current value&quot;`
<span class="lineNum">   13166 </span>            :     @throw invalid_iterator.204 if called on a primitive type with invalid
<span class="lineNum">   13167 </span>            :     iterators (i.e., if `first != begin()` and `last != end()`); example:
<span class="lineNum">   13168 </span>            :     `&quot;iterators out of range&quot;`
<span class="lineNum">   13169 </span>            : 
<span class="lineNum">   13170 </span>            :     @complexity The complexity depends on the type:
<span class="lineNum">   13171 </span>            :     - objects: `log(size()) + std::distance(first, last)`
<span class="lineNum">   13172 </span>            :     - arrays: linear in the distance between @a first and @a last, plus linear
<span class="lineNum">   13173 </span>            :       in the distance between @a last and end of the container
<span class="lineNum">   13174 </span>            :     - strings: linear in the length of the string
<span class="lineNum">   13175 </span>            :     - other types: constant
<span class="lineNum">   13176 </span>            : 
<span class="lineNum">   13177 </span>            :     @liveexample{The example shows the result of `erase()` for different JSON
<span class="lineNum">   13178 </span>            :     types.,erase__IteratorType_IteratorType}
<span class="lineNum">   13179 </span>            : 
<span class="lineNum">   13180 </span>            :     @sa @ref erase(IteratorType) -- removes the element at a given position
<span class="lineNum">   13181 </span>            :     @sa @ref erase(const typename object_t::key_type&amp;) -- removes the element
<span class="lineNum">   13182 </span>            :     from an object at the given key
<span class="lineNum">   13183 </span>            :     @sa @ref erase(const size_type) -- removes the element from an array at
<span class="lineNum">   13184 </span>            :     the given index
<span class="lineNum">   13185 </span>            : 
<span class="lineNum">   13186 </span>            :     @since version 1.0.0
<span class="lineNum">   13187 </span>            :     */
<span class="lineNum">   13188 </span>            :     template&lt;class IteratorType, typename std::enable_if&lt;
<span class="lineNum">   13189 </span>            :                  std::is_same&lt;IteratorType, typename basic_json_t::iterator&gt;::value or
<span class="lineNum">   13190 </span>            :                  std::is_same&lt;IteratorType, typename basic_json_t::const_iterator&gt;::value, int&gt;::type
<span class="lineNum">   13191 </span>            :              = 0&gt;
<span class="lineNum">   13192 </span>            :     IteratorType erase(IteratorType first, IteratorType last)
<span class="lineNum">   13193 </span>            :     {
<span class="lineNum">   13194 </span>            :         // make sure iterator fits the current value
<span class="lineNum">   13195 </span>            :         if (JSON_UNLIKELY(this != first.m_object or this != last.m_object))
<span class="lineNum">   13196 </span>            :         {
<span class="lineNum">   13197 </span>            :             JSON_THROW(invalid_iterator::create(203, &quot;iterators do not fit current value&quot;));
<span class="lineNum">   13198 </span>            :         }
<span class="lineNum">   13199 </span>            : 
<span class="lineNum">   13200 </span>            :         IteratorType result = end();
<span class="lineNum">   13201 </span>            : 
<span class="lineNum">   13202 </span>            :         switch (m_type)
<span class="lineNum">   13203 </span>            :         {
<span class="lineNum">   13204 </span>            :             case value_t::boolean:
<span class="lineNum">   13205 </span>            :             case value_t::number_float:
<span class="lineNum">   13206 </span>            :             case value_t::number_integer:
<span class="lineNum">   13207 </span>            :             case value_t::number_unsigned:
<span class="lineNum">   13208 </span>            :             case value_t::string:
<span class="lineNum">   13209 </span>            :             {
<span class="lineNum">   13210 </span>            :                 if (JSON_LIKELY(not first.m_it.primitive_iterator.is_begin()
<span class="lineNum">   13211 </span>            :                                 or not last.m_it.primitive_iterator.is_end()))
<span class="lineNum">   13212 </span>            :                 {
<span class="lineNum">   13213 </span>            :                     JSON_THROW(invalid_iterator::create(204, &quot;iterators out of range&quot;));
<span class="lineNum">   13214 </span>            :                 }
<span class="lineNum">   13215 </span>            : 
<span class="lineNum">   13216 </span>            :                 if (is_string())
<span class="lineNum">   13217 </span>            :                 {
<span class="lineNum">   13218 </span>            :                     AllocatorType&lt;string_t&gt; alloc;
<span class="lineNum">   13219 </span>            :                     std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);
<span class="lineNum">   13220 </span>            :                     std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);
<span class="lineNum">   13221 </span>            :                     m_value.string = nullptr;
<span class="lineNum">   13222 </span>            :                 }
<span class="lineNum">   13223 </span>            : 
<span class="lineNum">   13224 </span>            :                 m_type = value_t::null;
<span class="lineNum">   13225 </span>            :                 assert_invariant();
<span class="lineNum">   13226 </span>            :                 break;
<span class="lineNum">   13227 </span>            :             }
<span class="lineNum">   13228 </span>            : 
<span class="lineNum">   13229 </span>            :             case value_t::object:
<span class="lineNum">   13230 </span>            :             {
<span class="lineNum">   13231 </span>            :                 result.m_it.object_iterator = m_value.object-&gt;erase(first.m_it.object_iterator,
<span class="lineNum">   13232 </span>            :                                               last.m_it.object_iterator);
<span class="lineNum">   13233 </span>            :                 break;
<span class="lineNum">   13234 </span>            :             }
<span class="lineNum">   13235 </span>            : 
<span class="lineNum">   13236 </span>            :             case value_t::array:
<span class="lineNum">   13237 </span>            :             {
<span class="lineNum">   13238 </span>            :                 result.m_it.array_iterator = m_value.array-&gt;erase(first.m_it.array_iterator,
<span class="lineNum">   13239 </span>            :                                              last.m_it.array_iterator);
<span class="lineNum">   13240 </span>            :                 break;
<span class="lineNum">   13241 </span>            :             }
<span class="lineNum">   13242 </span>            : 
<span class="lineNum">   13243 </span>            :             default:
<span class="lineNum">   13244 </span>            :                 JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name())));
<span class="lineNum">   13245 </span>            :         }
<span class="lineNum">   13246 </span>            : 
<span class="lineNum">   13247 </span>            :         return result;
<span class="lineNum">   13248 </span>            :     }
<span class="lineNum">   13249 </span>            : 
<span class="lineNum">   13250 </span>            :     /*!
<span class="lineNum">   13251 </span>            :     @brief remove element from a JSON object given a key
<span class="lineNum">   13252 </span>            : 
<span class="lineNum">   13253 </span>            :     Removes elements from a JSON object with the key value @a key.
<span class="lineNum">   13254 </span>            : 
<span class="lineNum">   13255 </span>            :     @param[in] key value of the elements to remove
<span class="lineNum">   13256 </span>            : 
<span class="lineNum">   13257 </span>            :     @return Number of elements removed. If @a ObjectType is the default
<span class="lineNum">   13258 </span>            :     `std::map` type, the return value will always be `0` (@a key was not
<span class="lineNum">   13259 </span>            :     found) or `1` (@a key was found).
<span class="lineNum">   13260 </span>            : 
<span class="lineNum">   13261 </span>            :     @post References and iterators to the erased elements are invalidated.
<span class="lineNum">   13262 </span>            :     Other references and iterators are not affected.
<span class="lineNum">   13263 </span>            : 
<span class="lineNum">   13264 </span>            :     @throw type_error.307 when called on a type other than JSON object;
<span class="lineNum">   13265 </span>            :     example: `&quot;cannot use erase() with null&quot;`
<span class="lineNum">   13266 </span>            : 
<span class="lineNum">   13267 </span>            :     @complexity `log(size()) + count(key)`
<span class="lineNum">   13268 </span>            : 
<span class="lineNum">   13269 </span>            :     @liveexample{The example shows the effect of `erase()`.,erase__key_type}
<span class="lineNum">   13270 </span>            : 
<span class="lineNum">   13271 </span>            :     @sa @ref erase(IteratorType) -- removes the element at a given position
<span class="lineNum">   13272 </span>            :     @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
<span class="lineNum">   13273 </span>            :     the given range
<span class="lineNum">   13274 </span>            :     @sa @ref erase(const size_type) -- removes the element from an array at
<span class="lineNum">   13275 </span>            :     the given index
<span class="lineNum">   13276 </span>            : 
<span class="lineNum">   13277 </span>            :     @since version 1.0.0
<span class="lineNum">   13278 </span>            :     */
<span class="lineNum">   13279 </span>            :     size_type erase(const typename object_t::key_type&amp; key)
<span class="lineNum">   13280 </span>            :     {
<span class="lineNum">   13281 </span>            :         // this erase only works for objects
<span class="lineNum">   13282 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   13283 </span>            :         {
<span class="lineNum">   13284 </span>            :             return m_value.object-&gt;erase(key);
<span class="lineNum">   13285 </span>            :         }
<span class="lineNum">   13286 </span>            : 
<span class="lineNum">   13287 </span>            :         JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name())));
<span class="lineNum">   13288 </span>            :     }
<span class="lineNum">   13289 </span>            : 
<span class="lineNum">   13290 </span>            :     /*!
<span class="lineNum">   13291 </span>            :     @brief remove element from a JSON array given an index
<span class="lineNum">   13292 </span>            : 
<span class="lineNum">   13293 </span>            :     Removes element from a JSON array at the index @a idx.
<span class="lineNum">   13294 </span>            : 
<span class="lineNum">   13295 </span>            :     @param[in] idx index of the element to remove
<span class="lineNum">   13296 </span>            : 
<span class="lineNum">   13297 </span>            :     @throw type_error.307 when called on a type other than JSON object;
<span class="lineNum">   13298 </span>            :     example: `&quot;cannot use erase() with null&quot;`
<span class="lineNum">   13299 </span>            :     @throw out_of_range.401 when `idx &gt;= size()`; example: `&quot;array index 17
<span class="lineNum">   13300 </span>            :     is out of range&quot;`
<span class="lineNum">   13301 </span>            : 
<span class="lineNum">   13302 </span>            :     @complexity Linear in distance between @a idx and the end of the container.
<span class="lineNum">   13303 </span>            : 
<span class="lineNum">   13304 </span>            :     @liveexample{The example shows the effect of `erase()`.,erase__size_type}
<span class="lineNum">   13305 </span>            : 
<span class="lineNum">   13306 </span>            :     @sa @ref erase(IteratorType) -- removes the element at a given position
<span class="lineNum">   13307 </span>            :     @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
<span class="lineNum">   13308 </span>            :     the given range
<span class="lineNum">   13309 </span>            :     @sa @ref erase(const typename object_t::key_type&amp;) -- removes the element
<span class="lineNum">   13310 </span>            :     from an object at the given key
<span class="lineNum">   13311 </span>            : 
<span class="lineNum">   13312 </span>            :     @since version 1.0.0
<span class="lineNum">   13313 </span>            :     */
<span class="lineNum">   13314 </span>            :     void erase(const size_type idx)
<span class="lineNum">   13315 </span>            :     {
<span class="lineNum">   13316 </span>            :         // this erase only works for arrays
<span class="lineNum">   13317 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   13318 </span>            :         {
<span class="lineNum">   13319 </span>            :             if (JSON_UNLIKELY(idx &gt;= size()))
<span class="lineNum">   13320 </span>            :             {
<span class="lineNum">   13321 </span>            :                 JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;));
<span class="lineNum">   13322 </span>            :             }
<span class="lineNum">   13323 </span>            : 
<span class="lineNum">   13324 </span>            :             m_value.array-&gt;erase(m_value.array-&gt;begin() + static_cast&lt;difference_type&gt;(idx));
<span class="lineNum">   13325 </span>            :         }
<span class="lineNum">   13326 </span>            :         else
<span class="lineNum">   13327 </span>            :         {
<span class="lineNum">   13328 </span>            :             JSON_THROW(type_error::create(307, &quot;cannot use erase() with &quot; + std::string(type_name())));
<span class="lineNum">   13329 </span>            :         }
<span class="lineNum">   13330 </span>            :     }
<span class="lineNum">   13331 </span>            : 
<span class="lineNum">   13332 </span>            :     /// @}
<span class="lineNum">   13333 </span>            : 
<span class="lineNum">   13334 </span>            : 
<span class="lineNum">   13335 </span>            :     ////////////
<span class="lineNum">   13336 </span>            :     // lookup //
<span class="lineNum">   13337 </span>            :     ////////////
<span class="lineNum">   13338 </span>            : 
<span class="lineNum">   13339 </span>            :     /// @name lookup
<span class="lineNum">   13340 </span>            :     /// @{
<span class="lineNum">   13341 </span>            : 
<span class="lineNum">   13342 </span>            :     /*!
<span class="lineNum">   13343 </span>            :     @brief find an element in a JSON object
<span class="lineNum">   13344 </span>            : 
<span class="lineNum">   13345 </span>            :     Finds an element in a JSON object with key equivalent to @a key. If the
<span class="lineNum">   13346 </span>            :     element is not found or the JSON value is not an object, end() is
<span class="lineNum">   13347 </span>            :     returned.
<span class="lineNum">   13348 </span>            : 
<span class="lineNum">   13349 </span>            :     @note This method always returns @ref end() when executed on a JSON type
<span class="lineNum">   13350 </span>            :           that is not an object.
<span class="lineNum">   13351 </span>            : 
<span class="lineNum">   13352 </span>            :     @param[in] key key value of the element to search for.
<span class="lineNum">   13353 </span>            : 
<span class="lineNum">   13354 </span>            :     @return Iterator to an element with key equivalent to @a key. If no such
<span class="lineNum">   13355 </span>            :     element is found or the JSON value is not an object, past-the-end (see
<span class="lineNum">   13356 </span>            :     @ref end()) iterator is returned.
<span class="lineNum">   13357 </span>            : 
<span class="lineNum">   13358 </span>            :     @complexity Logarithmic in the size of the JSON object.
<span class="lineNum">   13359 </span>            : 
<span class="lineNum">   13360 </span>            :     @liveexample{The example shows how `find()` is used.,find__key_type}
<span class="lineNum">   13361 </span>            : 
<span class="lineNum">   13362 </span>            :     @since version 1.0.0
<span class="lineNum">   13363 </span>            :     */
<span class="lineNum">   13364 </span>            :     template&lt;typename KeyT&gt;
<span class="lineNum">   13365 </span>            :     iterator find(KeyT&amp;&amp; key)
<span class="lineNum">   13366 </span>            :     {
<span class="lineNum">   13367 </span>            :         auto result = end();
<span class="lineNum">   13368 </span>            : 
<span class="lineNum">   13369 </span>            :         if (is_object())
<span class="lineNum">   13370 </span>            :         {
<span class="lineNum">   13371 </span>            :             result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key));
<span class="lineNum">   13372 </span>            :         }
<span class="lineNum">   13373 </span>            : 
<span class="lineNum">   13374 </span>            :         return result;
<span class="lineNum">   13375 </span>            :     }
<span class="lineNum">   13376 </span>            : 
<span class="lineNum">   13377 </span>            :     /*!
<span class="lineNum">   13378 </span>            :     @brief find an element in a JSON object
<span class="lineNum">   13379 </span>            :     @copydoc find(KeyT&amp;&amp;)
<a name="13380"><span class="lineNum">   13380 </span>            :     */</a>
<span class="lineNum">   13381 </span>            :     template&lt;typename KeyT&gt;
<span class="lineNum">   13382 </span><span class="lineCov">         48 :     const_iterator find(KeyT&amp;&amp; key) const</span>
<span class="lineNum">   13383 </span>            :     {
<span class="lineNum">   13384 </span><span class="lineCov">         48 :         auto result = cend();</span>
<span class="lineNum">   13385 </span>            : 
<span class="lineNum">   13386 </span><span class="lineCov">         48 :         if (is_object())</span>
<span class="lineNum">   13387 </span>            :         {
<span class="lineNum">   13388 </span><span class="lineCov">         48 :             result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key));</span>
<span class="lineNum">   13389 </span>            :         }
<span class="lineNum">   13390 </span>            : 
<span class="lineNum">   13391 </span><span class="lineCov">         48 :         return result;</span>
<span class="lineNum">   13392 </span>            :     }
<span class="lineNum">   13393 </span>            : 
<span class="lineNum">   13394 </span>            :     /*!
<span class="lineNum">   13395 </span>            :     @brief returns the number of occurrences of a key in a JSON object
<span class="lineNum">   13396 </span>            : 
<span class="lineNum">   13397 </span>            :     Returns the number of elements with key @a key. If ObjectType is the
<span class="lineNum">   13398 </span>            :     default `std::map` type, the return value will always be `0` (@a key was
<span class="lineNum">   13399 </span>            :     not found) or `1` (@a key was found).
<span class="lineNum">   13400 </span>            : 
<span class="lineNum">   13401 </span>            :     @note This method always returns `0` when executed on a JSON type that is
<span class="lineNum">   13402 </span>            :           not an object.
<span class="lineNum">   13403 </span>            : 
<span class="lineNum">   13404 </span>            :     @param[in] key key value of the element to count
<span class="lineNum">   13405 </span>            : 
<span class="lineNum">   13406 </span>            :     @return Number of elements with key @a key. If the JSON value is not an
<span class="lineNum">   13407 </span>            :     object, the return value will be `0`.
<span class="lineNum">   13408 </span>            : 
<span class="lineNum">   13409 </span>            :     @complexity Logarithmic in the size of the JSON object.
<span class="lineNum">   13410 </span>            : 
<span class="lineNum">   13411 </span>            :     @liveexample{The example shows how `count()` is used.,count}
<span class="lineNum">   13412 </span>            : 
<span class="lineNum">   13413 </span>            :     @since version 1.0.0
<a name="13414"><span class="lineNum">   13414 </span>            :     */</a>
<span class="lineNum">   13415 </span>            :     template&lt;typename KeyT&gt;
<span class="lineNum">   13416 </span><span class="lineCov">        337 :     size_type count(KeyT&amp;&amp; key) const</span>
<span class="lineNum">   13417 </span>            :     {
<span class="lineNum">   13418 </span>            :         // return 0 for all nonobject types
<span class="lineNum">   13419 </span><span class="lineCov">        337 :         return is_object() ? m_value.object-&gt;count(std::forward&lt;KeyT&gt;(key)) : 0;</span>
<span class="lineNum">   13420 </span>            :     }
<span class="lineNum">   13421 </span>            : 
<span class="lineNum">   13422 </span>            :     /// @}
<span class="lineNum">   13423 </span>            : 
<span class="lineNum">   13424 </span>            : 
<span class="lineNum">   13425 </span>            :     ///////////////
<span class="lineNum">   13426 </span>            :     // iterators //
<span class="lineNum">   13427 </span>            :     ///////////////
<span class="lineNum">   13428 </span>            : 
<span class="lineNum">   13429 </span>            :     /// @name iterators
<span class="lineNum">   13430 </span>            :     /// @{
<span class="lineNum">   13431 </span>            : 
<span class="lineNum">   13432 </span>            :     /*!
<span class="lineNum">   13433 </span>            :     @brief returns an iterator to the first element
<span class="lineNum">   13434 </span>            : 
<span class="lineNum">   13435 </span>            :     Returns an iterator to the first element.
<span class="lineNum">   13436 </span>            : 
<span class="lineNum">   13437 </span>            :     @image html range-begin-end.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13438 </span>            : 
<span class="lineNum">   13439 </span>            :     @return iterator to the first element
<span class="lineNum">   13440 </span>            : 
<span class="lineNum">   13441 </span>            :     @complexity Constant.
<span class="lineNum">   13442 </span>            : 
<span class="lineNum">   13443 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13444 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   13445 </span>            :     requirements:
<span class="lineNum">   13446 </span>            :     - The complexity is constant.
<span class="lineNum">   13447 </span>            : 
<span class="lineNum">   13448 </span>            :     @liveexample{The following code shows an example for `begin()`.,begin}
<span class="lineNum">   13449 </span>            : 
<span class="lineNum">   13450 </span>            :     @sa @ref cbegin() -- returns a const iterator to the beginning
<span class="lineNum">   13451 </span>            :     @sa @ref end() -- returns an iterator to the end
<span class="lineNum">   13452 </span>            :     @sa @ref cend() -- returns a const iterator to the end
<span class="lineNum">   13453 </span>            : 
<span class="lineNum">   13454 </span>            :     @since version 1.0.0
<span class="lineNum">   13455 </span>            :     */
<span class="lineNum">   13456 </span>            :     iterator begin() noexcept
<span class="lineNum">   13457 </span>            :     {
<span class="lineNum">   13458 </span>            :         iterator result(this);
<span class="lineNum">   13459 </span>            :         result.set_begin();
<span class="lineNum">   13460 </span>            :         return result;
<span class="lineNum">   13461 </span>            :     }
<span class="lineNum">   13462 </span>            : 
<span class="lineNum">   13463 </span>            :     /*!
<a name="13464"><span class="lineNum">   13464 </span>            :     @copydoc basic_json::cbegin()</a>
<span class="lineNum">   13465 </span>            :     */
<span class="lineNum">   13466 </span><span class="lineCov">          5 :     const_iterator begin() const noexcept</span>
<span class="lineNum">   13467 </span>            :     {
<span class="lineNum">   13468 </span><span class="lineCov">          5 :         return cbegin();</span>
<span class="lineNum">   13469 </span>            :     }
<span class="lineNum">   13470 </span>            : 
<span class="lineNum">   13471 </span>            :     /*!
<span class="lineNum">   13472 </span>            :     @brief returns a const iterator to the first element
<span class="lineNum">   13473 </span>            : 
<span class="lineNum">   13474 </span>            :     Returns a const iterator to the first element.
<span class="lineNum">   13475 </span>            : 
<span class="lineNum">   13476 </span>            :     @image html range-begin-end.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13477 </span>            : 
<span class="lineNum">   13478 </span>            :     @return const iterator to the first element
<span class="lineNum">   13479 </span>            : 
<span class="lineNum">   13480 </span>            :     @complexity Constant.
<span class="lineNum">   13481 </span>            : 
<span class="lineNum">   13482 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13483 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   13484 </span>            :     requirements:
<span class="lineNum">   13485 </span>            :     - The complexity is constant.
<span class="lineNum">   13486 </span>            :     - Has the semantics of `const_cast&lt;const basic_json&amp;&gt;(*this).begin()`.
<span class="lineNum">   13487 </span>            : 
<span class="lineNum">   13488 </span>            :     @liveexample{The following code shows an example for `cbegin()`.,cbegin}
<span class="lineNum">   13489 </span>            : 
<span class="lineNum">   13490 </span>            :     @sa @ref begin() -- returns an iterator to the beginning
<span class="lineNum">   13491 </span>            :     @sa @ref end() -- returns an iterator to the end
<span class="lineNum">   13492 </span>            :     @sa @ref cend() -- returns a const iterator to the end
<span class="lineNum">   13493 </span>            : 
<a name="13494"><span class="lineNum">   13494 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   13495 </span>            :     */
<span class="lineNum">   13496 </span><span class="lineCov">          5 :     const_iterator cbegin() const noexcept</span>
<span class="lineNum">   13497 </span>            :     {
<span class="lineNum">   13498 </span><span class="lineCov">          5 :         const_iterator result(this);</span>
<span class="lineNum">   13499 </span><span class="lineCov">          5 :         result.set_begin();</span>
<span class="lineNum">   13500 </span><span class="lineCov">          5 :         return result;</span>
<span class="lineNum">   13501 </span>            :     }
<span class="lineNum">   13502 </span>            : 
<span class="lineNum">   13503 </span>            :     /*!
<span class="lineNum">   13504 </span>            :     @brief returns an iterator to one past the last element
<span class="lineNum">   13505 </span>            : 
<span class="lineNum">   13506 </span>            :     Returns an iterator to one past the last element.
<span class="lineNum">   13507 </span>            : 
<span class="lineNum">   13508 </span>            :     @image html range-begin-end.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13509 </span>            : 
<span class="lineNum">   13510 </span>            :     @return iterator one past the last element
<span class="lineNum">   13511 </span>            : 
<span class="lineNum">   13512 </span>            :     @complexity Constant.
<span class="lineNum">   13513 </span>            : 
<span class="lineNum">   13514 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13515 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   13516 </span>            :     requirements:
<span class="lineNum">   13517 </span>            :     - The complexity is constant.
<span class="lineNum">   13518 </span>            : 
<span class="lineNum">   13519 </span>            :     @liveexample{The following code shows an example for `end()`.,end}
<span class="lineNum">   13520 </span>            : 
<span class="lineNum">   13521 </span>            :     @sa @ref cend() -- returns a const iterator to the end
<span class="lineNum">   13522 </span>            :     @sa @ref begin() -- returns an iterator to the beginning
<span class="lineNum">   13523 </span>            :     @sa @ref cbegin() -- returns a const iterator to the beginning
<span class="lineNum">   13524 </span>            : 
<span class="lineNum">   13525 </span>            :     @since version 1.0.0
<span class="lineNum">   13526 </span>            :     */
<span class="lineNum">   13527 </span>            :     iterator end() noexcept
<span class="lineNum">   13528 </span>            :     {
<span class="lineNum">   13529 </span>            :         iterator result(this);
<span class="lineNum">   13530 </span>            :         result.set_end();
<span class="lineNum">   13531 </span>            :         return result;
<span class="lineNum">   13532 </span>            :     }
<span class="lineNum">   13533 </span>            : 
<span class="lineNum">   13534 </span>            :     /*!
<a name="13535"><span class="lineNum">   13535 </span>            :     @copydoc basic_json::cend()</a>
<span class="lineNum">   13536 </span>            :     */
<span class="lineNum">   13537 </span><span class="lineCov">         53 :     const_iterator end() const noexcept</span>
<span class="lineNum">   13538 </span>            :     {
<span class="lineNum">   13539 </span><span class="lineCov">         53 :         return cend();</span>
<span class="lineNum">   13540 </span>            :     }
<span class="lineNum">   13541 </span>            : 
<span class="lineNum">   13542 </span>            :     /*!
<span class="lineNum">   13543 </span>            :     @brief returns a const iterator to one past the last element
<span class="lineNum">   13544 </span>            : 
<span class="lineNum">   13545 </span>            :     Returns a const iterator to one past the last element.
<span class="lineNum">   13546 </span>            : 
<span class="lineNum">   13547 </span>            :     @image html range-begin-end.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13548 </span>            : 
<span class="lineNum">   13549 </span>            :     @return const iterator one past the last element
<span class="lineNum">   13550 </span>            : 
<span class="lineNum">   13551 </span>            :     @complexity Constant.
<span class="lineNum">   13552 </span>            : 
<span class="lineNum">   13553 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13554 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   13555 </span>            :     requirements:
<span class="lineNum">   13556 </span>            :     - The complexity is constant.
<span class="lineNum">   13557 </span>            :     - Has the semantics of `const_cast&lt;const basic_json&amp;&gt;(*this).end()`.
<span class="lineNum">   13558 </span>            : 
<span class="lineNum">   13559 </span>            :     @liveexample{The following code shows an example for `cend()`.,cend}
<span class="lineNum">   13560 </span>            : 
<span class="lineNum">   13561 </span>            :     @sa @ref end() -- returns an iterator to the end
<span class="lineNum">   13562 </span>            :     @sa @ref begin() -- returns an iterator to the beginning
<span class="lineNum">   13563 </span>            :     @sa @ref cbegin() -- returns a const iterator to the beginning
<span class="lineNum">   13564 </span>            : 
<a name="13565"><span class="lineNum">   13565 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   13566 </span>            :     */
<span class="lineNum">   13567 </span><span class="lineCov">        101 :     const_iterator cend() const noexcept</span>
<span class="lineNum">   13568 </span>            :     {
<span class="lineNum">   13569 </span><span class="lineCov">        101 :         const_iterator result(this);</span>
<span class="lineNum">   13570 </span><span class="lineCov">        101 :         result.set_end();</span>
<span class="lineNum">   13571 </span><span class="lineCov">        101 :         return result;</span>
<span class="lineNum">   13572 </span>            :     }
<span class="lineNum">   13573 </span>            : 
<span class="lineNum">   13574 </span>            :     /*!
<span class="lineNum">   13575 </span>            :     @brief returns an iterator to the reverse-beginning
<span class="lineNum">   13576 </span>            : 
<span class="lineNum">   13577 </span>            :     Returns an iterator to the reverse-beginning; that is, the last element.
<span class="lineNum">   13578 </span>            : 
<span class="lineNum">   13579 </span>            :     @image html range-rbegin-rend.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13580 </span>            : 
<span class="lineNum">   13581 </span>            :     @complexity Constant.
<span class="lineNum">   13582 </span>            : 
<span class="lineNum">   13583 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13584 </span>            :     [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
<span class="lineNum">   13585 </span>            :     requirements:
<span class="lineNum">   13586 </span>            :     - The complexity is constant.
<span class="lineNum">   13587 </span>            :     - Has the semantics of `reverse_iterator(end())`.
<span class="lineNum">   13588 </span>            : 
<span class="lineNum">   13589 </span>            :     @liveexample{The following code shows an example for `rbegin()`.,rbegin}
<span class="lineNum">   13590 </span>            : 
<span class="lineNum">   13591 </span>            :     @sa @ref crbegin() -- returns a const reverse iterator to the beginning
<span class="lineNum">   13592 </span>            :     @sa @ref rend() -- returns a reverse iterator to the end
<span class="lineNum">   13593 </span>            :     @sa @ref crend() -- returns a const reverse iterator to the end
<span class="lineNum">   13594 </span>            : 
<span class="lineNum">   13595 </span>            :     @since version 1.0.0
<span class="lineNum">   13596 </span>            :     */
<span class="lineNum">   13597 </span>            :     reverse_iterator rbegin() noexcept
<span class="lineNum">   13598 </span>            :     {
<span class="lineNum">   13599 </span>            :         return reverse_iterator(end());
<span class="lineNum">   13600 </span>            :     }
<span class="lineNum">   13601 </span>            : 
<span class="lineNum">   13602 </span>            :     /*!
<span class="lineNum">   13603 </span>            :     @copydoc basic_json::crbegin()
<span class="lineNum">   13604 </span>            :     */
<span class="lineNum">   13605 </span>            :     const_reverse_iterator rbegin() const noexcept
<span class="lineNum">   13606 </span>            :     {
<span class="lineNum">   13607 </span>            :         return crbegin();
<span class="lineNum">   13608 </span>            :     }
<span class="lineNum">   13609 </span>            : 
<span class="lineNum">   13610 </span>            :     /*!
<span class="lineNum">   13611 </span>            :     @brief returns an iterator to the reverse-end
<span class="lineNum">   13612 </span>            : 
<span class="lineNum">   13613 </span>            :     Returns an iterator to the reverse-end; that is, one before the first
<span class="lineNum">   13614 </span>            :     element.
<span class="lineNum">   13615 </span>            : 
<span class="lineNum">   13616 </span>            :     @image html range-rbegin-rend.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13617 </span>            : 
<span class="lineNum">   13618 </span>            :     @complexity Constant.
<span class="lineNum">   13619 </span>            : 
<span class="lineNum">   13620 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13621 </span>            :     [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
<span class="lineNum">   13622 </span>            :     requirements:
<span class="lineNum">   13623 </span>            :     - The complexity is constant.
<span class="lineNum">   13624 </span>            :     - Has the semantics of `reverse_iterator(begin())`.
<span class="lineNum">   13625 </span>            : 
<span class="lineNum">   13626 </span>            :     @liveexample{The following code shows an example for `rend()`.,rend}
<span class="lineNum">   13627 </span>            : 
<span class="lineNum">   13628 </span>            :     @sa @ref crend() -- returns a const reverse iterator to the end
<span class="lineNum">   13629 </span>            :     @sa @ref rbegin() -- returns a reverse iterator to the beginning
<span class="lineNum">   13630 </span>            :     @sa @ref crbegin() -- returns a const reverse iterator to the beginning
<span class="lineNum">   13631 </span>            : 
<span class="lineNum">   13632 </span>            :     @since version 1.0.0
<span class="lineNum">   13633 </span>            :     */
<span class="lineNum">   13634 </span>            :     reverse_iterator rend() noexcept
<span class="lineNum">   13635 </span>            :     {
<span class="lineNum">   13636 </span>            :         return reverse_iterator(begin());
<span class="lineNum">   13637 </span>            :     }
<span class="lineNum">   13638 </span>            : 
<span class="lineNum">   13639 </span>            :     /*!
<span class="lineNum">   13640 </span>            :     @copydoc basic_json::crend()
<span class="lineNum">   13641 </span>            :     */
<span class="lineNum">   13642 </span>            :     const_reverse_iterator rend() const noexcept
<span class="lineNum">   13643 </span>            :     {
<span class="lineNum">   13644 </span>            :         return crend();
<span class="lineNum">   13645 </span>            :     }
<span class="lineNum">   13646 </span>            : 
<span class="lineNum">   13647 </span>            :     /*!
<span class="lineNum">   13648 </span>            :     @brief returns a const reverse iterator to the last element
<span class="lineNum">   13649 </span>            : 
<span class="lineNum">   13650 </span>            :     Returns a const iterator to the reverse-beginning; that is, the last
<span class="lineNum">   13651 </span>            :     element.
<span class="lineNum">   13652 </span>            : 
<span class="lineNum">   13653 </span>            :     @image html range-rbegin-rend.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13654 </span>            : 
<span class="lineNum">   13655 </span>            :     @complexity Constant.
<span class="lineNum">   13656 </span>            : 
<span class="lineNum">   13657 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13658 </span>            :     [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
<span class="lineNum">   13659 </span>            :     requirements:
<span class="lineNum">   13660 </span>            :     - The complexity is constant.
<span class="lineNum">   13661 </span>            :     - Has the semantics of `const_cast&lt;const basic_json&amp;&gt;(*this).rbegin()`.
<span class="lineNum">   13662 </span>            : 
<span class="lineNum">   13663 </span>            :     @liveexample{The following code shows an example for `crbegin()`.,crbegin}
<span class="lineNum">   13664 </span>            : 
<span class="lineNum">   13665 </span>            :     @sa @ref rbegin() -- returns a reverse iterator to the beginning
<span class="lineNum">   13666 </span>            :     @sa @ref rend() -- returns a reverse iterator to the end
<span class="lineNum">   13667 </span>            :     @sa @ref crend() -- returns a const reverse iterator to the end
<span class="lineNum">   13668 </span>            : 
<span class="lineNum">   13669 </span>            :     @since version 1.0.0
<span class="lineNum">   13670 </span>            :     */
<span class="lineNum">   13671 </span>            :     const_reverse_iterator crbegin() const noexcept
<span class="lineNum">   13672 </span>            :     {
<span class="lineNum">   13673 </span>            :         return const_reverse_iterator(cend());
<span class="lineNum">   13674 </span>            :     }
<span class="lineNum">   13675 </span>            : 
<span class="lineNum">   13676 </span>            :     /*!
<span class="lineNum">   13677 </span>            :     @brief returns a const reverse iterator to one before the first
<span class="lineNum">   13678 </span>            : 
<span class="lineNum">   13679 </span>            :     Returns a const reverse iterator to the reverse-end; that is, one before
<span class="lineNum">   13680 </span>            :     the first element.
<span class="lineNum">   13681 </span>            : 
<span class="lineNum">   13682 </span>            :     @image html range-rbegin-rend.svg &quot;Illustration from cppreference.com&quot;
<span class="lineNum">   13683 </span>            : 
<span class="lineNum">   13684 </span>            :     @complexity Constant.
<span class="lineNum">   13685 </span>            : 
<span class="lineNum">   13686 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13687 </span>            :     [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer)
<span class="lineNum">   13688 </span>            :     requirements:
<span class="lineNum">   13689 </span>            :     - The complexity is constant.
<span class="lineNum">   13690 </span>            :     - Has the semantics of `const_cast&lt;const basic_json&amp;&gt;(*this).rend()`.
<span class="lineNum">   13691 </span>            : 
<span class="lineNum">   13692 </span>            :     @liveexample{The following code shows an example for `crend()`.,crend}
<span class="lineNum">   13693 </span>            : 
<span class="lineNum">   13694 </span>            :     @sa @ref rend() -- returns a reverse iterator to the end
<span class="lineNum">   13695 </span>            :     @sa @ref rbegin() -- returns a reverse iterator to the beginning
<span class="lineNum">   13696 </span>            :     @sa @ref crbegin() -- returns a const reverse iterator to the beginning
<span class="lineNum">   13697 </span>            : 
<span class="lineNum">   13698 </span>            :     @since version 1.0.0
<span class="lineNum">   13699 </span>            :     */
<span class="lineNum">   13700 </span>            :     const_reverse_iterator crend() const noexcept
<span class="lineNum">   13701 </span>            :     {
<span class="lineNum">   13702 </span>            :         return const_reverse_iterator(cbegin());
<span class="lineNum">   13703 </span>            :     }
<span class="lineNum">   13704 </span>            : 
<span class="lineNum">   13705 </span>            :   public:
<span class="lineNum">   13706 </span>            :     /*!
<span class="lineNum">   13707 </span>            :     @brief wrapper to access iterator member functions in range-based for
<span class="lineNum">   13708 </span>            : 
<span class="lineNum">   13709 </span>            :     This function allows to access @ref iterator::key() and @ref
<span class="lineNum">   13710 </span>            :     iterator::value() during range-based for loops. In these loops, a
<span class="lineNum">   13711 </span>            :     reference to the JSON values is returned, so there is no access to the
<span class="lineNum">   13712 </span>            :     underlying iterator.
<span class="lineNum">   13713 </span>            : 
<span class="lineNum">   13714 </span>            :     For loop without iterator_wrapper:
<span class="lineNum">   13715 </span>            : 
<span class="lineNum">   13716 </span>            :     @code{cpp}
<span class="lineNum">   13717 </span>            :     for (auto it = j_object.begin(); it != j_object.end(); ++it)
<span class="lineNum">   13718 </span>            :     {
<span class="lineNum">   13719 </span>            :         std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; it.key() &lt;&lt; &quot;, value:&quot; &lt;&lt; it.value() &lt;&lt; '\n';
<span class="lineNum">   13720 </span>            :     }
<span class="lineNum">   13721 </span>            :     @endcode
<span class="lineNum">   13722 </span>            : 
<span class="lineNum">   13723 </span>            :     Range-based for loop without iterator proxy:
<span class="lineNum">   13724 </span>            : 
<span class="lineNum">   13725 </span>            :     @code{cpp}
<span class="lineNum">   13726 </span>            :     for (auto it : j_object)
<span class="lineNum">   13727 </span>            :     {
<span class="lineNum">   13728 </span>            :         // &quot;it&quot; is of type json::reference and has no key() member
<span class="lineNum">   13729 </span>            :         std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; it &lt;&lt; '\n';
<span class="lineNum">   13730 </span>            :     }
<span class="lineNum">   13731 </span>            :     @endcode
<span class="lineNum">   13732 </span>            : 
<span class="lineNum">   13733 </span>            :     Range-based for loop with iterator proxy:
<span class="lineNum">   13734 </span>            : 
<span class="lineNum">   13735 </span>            :     @code{cpp}
<span class="lineNum">   13736 </span>            :     for (auto it : json::iterator_wrapper(j_object))
<span class="lineNum">   13737 </span>            :     {
<span class="lineNum">   13738 </span>            :         std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; it.key() &lt;&lt; &quot;, value:&quot; &lt;&lt; it.value() &lt;&lt; '\n';
<span class="lineNum">   13739 </span>            :     }
<span class="lineNum">   13740 </span>            :     @endcode
<span class="lineNum">   13741 </span>            : 
<span class="lineNum">   13742 </span>            :     @note When iterating over an array, `key()` will return the index of the
<span class="lineNum">   13743 </span>            :           element as string (see example).
<span class="lineNum">   13744 </span>            : 
<span class="lineNum">   13745 </span>            :     @param[in] ref  reference to a JSON value
<span class="lineNum">   13746 </span>            :     @return iteration proxy object wrapping @a ref with an interface to use in
<span class="lineNum">   13747 </span>            :             range-based for loops
<span class="lineNum">   13748 </span>            : 
<span class="lineNum">   13749 </span>            :     @liveexample{The following code shows how the wrapper is used,iterator_wrapper}
<span class="lineNum">   13750 </span>            : 
<span class="lineNum">   13751 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   13752 </span>            :     changes in the JSON value.
<span class="lineNum">   13753 </span>            : 
<span class="lineNum">   13754 </span>            :     @complexity Constant.
<span class="lineNum">   13755 </span>            : 
<span class="lineNum">   13756 </span>            :     @note The name of this function is not yet final and may change in the
<span class="lineNum">   13757 </span>            :     future.
<span class="lineNum">   13758 </span>            : 
<span class="lineNum">   13759 </span>            :     @deprecated This stream operator is deprecated and will be removed in
<span class="lineNum">   13760 </span>            :                 future 4.0.0 of the library. Please use @ref items() instead;
<span class="lineNum">   13761 </span>            :                 that is, replace `json::iterator_wrapper(j)` with `j.items()`.
<span class="lineNum">   13762 </span>            :     */
<span class="lineNum">   13763 </span>            :     JSON_DEPRECATED
<span class="lineNum">   13764 </span>            :     static iteration_proxy&lt;iterator&gt; iterator_wrapper(reference ref) noexcept
<span class="lineNum">   13765 </span>            :     {
<span class="lineNum">   13766 </span>            :         return ref.items();
<span class="lineNum">   13767 </span>            :     }
<span class="lineNum">   13768 </span>            : 
<span class="lineNum">   13769 </span>            :     /*!
<span class="lineNum">   13770 </span>            :     @copydoc iterator_wrapper(reference)
<span class="lineNum">   13771 </span>            :     */
<span class="lineNum">   13772 </span>            :     JSON_DEPRECATED
<span class="lineNum">   13773 </span>            :     static iteration_proxy&lt;const_iterator&gt; iterator_wrapper(const_reference ref) noexcept
<span class="lineNum">   13774 </span>            :     {
<span class="lineNum">   13775 </span>            :         return ref.items();
<span class="lineNum">   13776 </span>            :     }
<span class="lineNum">   13777 </span>            : 
<span class="lineNum">   13778 </span>            :     /*!
<span class="lineNum">   13779 </span>            :     @brief helper to access iterator member functions in range-based for
<span class="lineNum">   13780 </span>            : 
<span class="lineNum">   13781 </span>            :     This function allows to access @ref iterator::key() and @ref
<span class="lineNum">   13782 </span>            :     iterator::value() during range-based for loops. In these loops, a
<span class="lineNum">   13783 </span>            :     reference to the JSON values is returned, so there is no access to the
<span class="lineNum">   13784 </span>            :     underlying iterator.
<span class="lineNum">   13785 </span>            : 
<span class="lineNum">   13786 </span>            :     For loop without `items()` function:
<span class="lineNum">   13787 </span>            : 
<span class="lineNum">   13788 </span>            :     @code{cpp}
<span class="lineNum">   13789 </span>            :     for (auto it = j_object.begin(); it != j_object.end(); ++it)
<span class="lineNum">   13790 </span>            :     {
<span class="lineNum">   13791 </span>            :         std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; it.key() &lt;&lt; &quot;, value:&quot; &lt;&lt; it.value() &lt;&lt; '\n';
<span class="lineNum">   13792 </span>            :     }
<span class="lineNum">   13793 </span>            :     @endcode
<span class="lineNum">   13794 </span>            : 
<span class="lineNum">   13795 </span>            :     Range-based for loop without `items()` function:
<span class="lineNum">   13796 </span>            : 
<span class="lineNum">   13797 </span>            :     @code{cpp}
<span class="lineNum">   13798 </span>            :     for (auto it : j_object)
<span class="lineNum">   13799 </span>            :     {
<span class="lineNum">   13800 </span>            :         // &quot;it&quot; is of type json::reference and has no key() member
<span class="lineNum">   13801 </span>            :         std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; it &lt;&lt; '\n';
<span class="lineNum">   13802 </span>            :     }
<span class="lineNum">   13803 </span>            :     @endcode
<span class="lineNum">   13804 </span>            : 
<span class="lineNum">   13805 </span>            :     Range-based for loop with `items()` function:
<span class="lineNum">   13806 </span>            : 
<span class="lineNum">   13807 </span>            :     @code{cpp}
<span class="lineNum">   13808 </span>            :     for (auto it : j_object.items())
<span class="lineNum">   13809 </span>            :     {
<span class="lineNum">   13810 </span>            :         std::cout &lt;&lt; &quot;key: &quot; &lt;&lt; it.key() &lt;&lt; &quot;, value:&quot; &lt;&lt; it.value() &lt;&lt; '\n';
<span class="lineNum">   13811 </span>            :     }
<span class="lineNum">   13812 </span>            :     @endcode
<span class="lineNum">   13813 </span>            : 
<span class="lineNum">   13814 </span>            :     @note When iterating over an array, `key()` will return the index of the
<span class="lineNum">   13815 </span>            :           element as string (see example). For primitive types (e.g., numbers),
<span class="lineNum">   13816 </span>            :           `key()` returns an empty string.
<span class="lineNum">   13817 </span>            : 
<span class="lineNum">   13818 </span>            :     @return iteration proxy object wrapping @a ref with an interface to use in
<span class="lineNum">   13819 </span>            :             range-based for loops
<span class="lineNum">   13820 </span>            : 
<span class="lineNum">   13821 </span>            :     @liveexample{The following code shows how the function is used.,items}
<span class="lineNum">   13822 </span>            : 
<span class="lineNum">   13823 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   13824 </span>            :     changes in the JSON value.
<span class="lineNum">   13825 </span>            : 
<span class="lineNum">   13826 </span>            :     @complexity Constant.
<span class="lineNum">   13827 </span>            : 
<span class="lineNum">   13828 </span>            :     @since version 3.x.x.
<span class="lineNum">   13829 </span>            :     */
<span class="lineNum">   13830 </span>            :     iteration_proxy&lt;iterator&gt; items() noexcept
<span class="lineNum">   13831 </span>            :     {
<span class="lineNum">   13832 </span>            :         return iteration_proxy&lt;iterator&gt;(*this);
<span class="lineNum">   13833 </span>            :     }
<span class="lineNum">   13834 </span>            : 
<span class="lineNum">   13835 </span>            :     /*!
<span class="lineNum">   13836 </span>            :     @copydoc items()
<span class="lineNum">   13837 </span>            :     */
<span class="lineNum">   13838 </span>            :     iteration_proxy&lt;const_iterator&gt; items() const noexcept
<span class="lineNum">   13839 </span>            :     {
<span class="lineNum">   13840 </span>            :         return iteration_proxy&lt;const_iterator&gt;(*this);
<span class="lineNum">   13841 </span>            :     }
<span class="lineNum">   13842 </span>            : 
<span class="lineNum">   13843 </span>            :     /// @}
<span class="lineNum">   13844 </span>            : 
<span class="lineNum">   13845 </span>            : 
<span class="lineNum">   13846 </span>            :     //////////////
<span class="lineNum">   13847 </span>            :     // capacity //
<span class="lineNum">   13848 </span>            :     //////////////
<span class="lineNum">   13849 </span>            : 
<span class="lineNum">   13850 </span>            :     /// @name capacity
<span class="lineNum">   13851 </span>            :     /// @{
<span class="lineNum">   13852 </span>            : 
<span class="lineNum">   13853 </span>            :     /*!
<span class="lineNum">   13854 </span>            :     @brief checks whether the container is empty.
<span class="lineNum">   13855 </span>            : 
<span class="lineNum">   13856 </span>            :     Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).
<span class="lineNum">   13857 </span>            : 
<span class="lineNum">   13858 </span>            :     @return The return value depends on the different types and is
<span class="lineNum">   13859 </span>            :             defined as follows:
<span class="lineNum">   13860 </span>            :             Value type  | return value
<span class="lineNum">   13861 </span>            :             ----------- | -------------
<span class="lineNum">   13862 </span>            :             null        | `true`
<span class="lineNum">   13863 </span>            :             boolean     | `false`
<span class="lineNum">   13864 </span>            :             string      | `false`
<span class="lineNum">   13865 </span>            :             number      | `false`
<span class="lineNum">   13866 </span>            :             object      | result of function `object_t::empty()`
<span class="lineNum">   13867 </span>            :             array       | result of function `array_t::empty()`
<span class="lineNum">   13868 </span>            : 
<span class="lineNum">   13869 </span>            :     @liveexample{The following code uses `empty()` to check if a JSON
<span class="lineNum">   13870 </span>            :     object contains any elements.,empty}
<span class="lineNum">   13871 </span>            : 
<span class="lineNum">   13872 </span>            :     @complexity Constant, as long as @ref array_t and @ref object_t satisfy
<span class="lineNum">   13873 </span>            :     the Container concept; that is, their `empty()` functions have constant
<span class="lineNum">   13874 </span>            :     complexity.
<span class="lineNum">   13875 </span>            : 
<span class="lineNum">   13876 </span>            :     @iterators No changes.
<span class="lineNum">   13877 </span>            : 
<span class="lineNum">   13878 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   13879 </span>            : 
<span class="lineNum">   13880 </span>            :     @note This function does not return whether a string stored as JSON value
<span class="lineNum">   13881 </span>            :     is empty - it returns whether the JSON container itself is empty which is
<span class="lineNum">   13882 </span>            :     false in the case of a string.
<span class="lineNum">   13883 </span>            : 
<span class="lineNum">   13884 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13885 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   13886 </span>            :     requirements:
<span class="lineNum">   13887 </span>            :     - The complexity is constant.
<span class="lineNum">   13888 </span>            :     - Has the semantics of `begin() == end()`.
<span class="lineNum">   13889 </span>            : 
<span class="lineNum">   13890 </span>            :     @sa @ref size() -- returns the number of elements
<span class="lineNum">   13891 </span>            : 
<a name="13892"><span class="lineNum">   13892 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   13893 </span>            :     */
<span class="lineNum">   13894 </span><span class="lineCov">          6 :     bool empty() const noexcept</span>
<span class="lineNum">   13895 </span>            :     {
<span class="lineNum">   13896 </span><span class="lineCov">          6 :         switch (m_type)</span>
<span class="lineNum">   13897 </span>            :         {
<span class="lineNum">   13898 </span>            :             case value_t::null:
<span class="lineNum">   13899 </span>            :             {
<span class="lineNum">   13900 </span>            :                 // null values are empty
<span class="lineNum">   13901 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">   13902 </span>            :             }
<span class="lineNum">   13903 </span>            : 
<span class="lineNum">   13904 </span>            :             case value_t::array:
<span class="lineNum">   13905 </span>            :             {
<span class="lineNum">   13906 </span>            :                 // delegate call to array_t::empty()
<span class="lineNum">   13907 </span><span class="lineCov">          6 :                 return m_value.array-&gt;empty();</span>
<span class="lineNum">   13908 </span>            :             }
<span class="lineNum">   13909 </span>            : 
<span class="lineNum">   13910 </span>            :             case value_t::object:
<span class="lineNum">   13911 </span>            :             {
<span class="lineNum">   13912 </span>            :                 // delegate call to object_t::empty()
<span class="lineNum">   13913 </span><span class="lineNoCov">          0 :                 return m_value.object-&gt;empty();</span>
<span class="lineNum">   13914 </span>            :             }
<span class="lineNum">   13915 </span>            : 
<span class="lineNum">   13916 </span>            :             default:
<span class="lineNum">   13917 </span>            :             {
<span class="lineNum">   13918 </span>            :                 // all other types are nonempty
<span class="lineNum">   13919 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">   13920 </span>            :             }
<span class="lineNum">   13921 </span>            :         }
<span class="lineNum">   13922 </span>            :     }
<span class="lineNum">   13923 </span>            : 
<span class="lineNum">   13924 </span>            :     /*!
<span class="lineNum">   13925 </span>            :     @brief returns the number of elements
<span class="lineNum">   13926 </span>            : 
<span class="lineNum">   13927 </span>            :     Returns the number of elements in a JSON value.
<span class="lineNum">   13928 </span>            : 
<span class="lineNum">   13929 </span>            :     @return The return value depends on the different types and is
<span class="lineNum">   13930 </span>            :             defined as follows:
<span class="lineNum">   13931 </span>            :             Value type  | return value
<span class="lineNum">   13932 </span>            :             ----------- | -------------
<span class="lineNum">   13933 </span>            :             null        | `0`
<span class="lineNum">   13934 </span>            :             boolean     | `1`
<span class="lineNum">   13935 </span>            :             string      | `1`
<span class="lineNum">   13936 </span>            :             number      | `1`
<span class="lineNum">   13937 </span>            :             object      | result of function object_t::size()
<span class="lineNum">   13938 </span>            :             array       | result of function array_t::size()
<span class="lineNum">   13939 </span>            : 
<span class="lineNum">   13940 </span>            :     @liveexample{The following code calls `size()` on the different value
<span class="lineNum">   13941 </span>            :     types.,size}
<span class="lineNum">   13942 </span>            : 
<span class="lineNum">   13943 </span>            :     @complexity Constant, as long as @ref array_t and @ref object_t satisfy
<span class="lineNum">   13944 </span>            :     the Container concept; that is, their size() functions have constant
<span class="lineNum">   13945 </span>            :     complexity.
<span class="lineNum">   13946 </span>            : 
<span class="lineNum">   13947 </span>            :     @iterators No changes.
<span class="lineNum">   13948 </span>            : 
<span class="lineNum">   13949 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   13950 </span>            : 
<span class="lineNum">   13951 </span>            :     @note This function does not return the length of a string stored as JSON
<span class="lineNum">   13952 </span>            :     value - it returns the number of elements in the JSON value which is 1 in
<span class="lineNum">   13953 </span>            :     the case of a string.
<span class="lineNum">   13954 </span>            : 
<span class="lineNum">   13955 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   13956 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   13957 </span>            :     requirements:
<span class="lineNum">   13958 </span>            :     - The complexity is constant.
<span class="lineNum">   13959 </span>            :     - Has the semantics of `std::distance(begin(), end())`.
<span class="lineNum">   13960 </span>            : 
<span class="lineNum">   13961 </span>            :     @sa @ref empty() -- checks whether the container is empty
<span class="lineNum">   13962 </span>            :     @sa @ref max_size() -- returns the maximal number of elements
<span class="lineNum">   13963 </span>            : 
<a name="13964"><span class="lineNum">   13964 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   13965 </span>            :     */
<span class="lineNum">   13966 </span><span class="lineCov">        239 :     size_type size() const noexcept</span>
<span class="lineNum">   13967 </span>            :     {
<span class="lineNum">   13968 </span><span class="lineCov">        239 :         switch (m_type)</span>
<span class="lineNum">   13969 </span>            :         {
<span class="lineNum">   13970 </span>            :             case value_t::null:
<span class="lineNum">   13971 </span>            :             {
<span class="lineNum">   13972 </span>            :                 // null values are empty
<span class="lineNum">   13973 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">   13974 </span>            :             }
<span class="lineNum">   13975 </span>            : 
<span class="lineNum">   13976 </span>            :             case value_t::array:
<span class="lineNum">   13977 </span>            :             {
<span class="lineNum">   13978 </span>            :                 // delegate call to array_t::size()
<span class="lineNum">   13979 </span><span class="lineCov">        239 :                 return m_value.array-&gt;size();</span>
<span class="lineNum">   13980 </span>            :             }
<span class="lineNum">   13981 </span>            : 
<span class="lineNum">   13982 </span>            :             case value_t::object:
<span class="lineNum">   13983 </span>            :             {
<span class="lineNum">   13984 </span>            :                 // delegate call to object_t::size()
<span class="lineNum">   13985 </span><span class="lineNoCov">          0 :                 return m_value.object-&gt;size();</span>
<span class="lineNum">   13986 </span>            :             }
<span class="lineNum">   13987 </span>            : 
<span class="lineNum">   13988 </span>            :             default:
<span class="lineNum">   13989 </span>            :             {
<span class="lineNum">   13990 </span>            :                 // all other types have size 1
<span class="lineNum">   13991 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">   13992 </span>            :             }
<span class="lineNum">   13993 </span>            :         }
<span class="lineNum">   13994 </span>            :     }
<span class="lineNum">   13995 </span>            : 
<span class="lineNum">   13996 </span>            :     /*!
<span class="lineNum">   13997 </span>            :     @brief returns the maximum possible number of elements
<span class="lineNum">   13998 </span>            : 
<span class="lineNum">   13999 </span>            :     Returns the maximum number of elements a JSON value is able to hold due to
<span class="lineNum">   14000 </span>            :     system or library implementation limitations, i.e. `std::distance(begin(),
<span class="lineNum">   14001 </span>            :     end())` for the JSON value.
<span class="lineNum">   14002 </span>            : 
<span class="lineNum">   14003 </span>            :     @return The return value depends on the different types and is
<span class="lineNum">   14004 </span>            :             defined as follows:
<span class="lineNum">   14005 </span>            :             Value type  | return value
<span class="lineNum">   14006 </span>            :             ----------- | -------------
<span class="lineNum">   14007 </span>            :             null        | `0` (same as `size()`)
<span class="lineNum">   14008 </span>            :             boolean     | `1` (same as `size()`)
<span class="lineNum">   14009 </span>            :             string      | `1` (same as `size()`)
<span class="lineNum">   14010 </span>            :             number      | `1` (same as `size()`)
<span class="lineNum">   14011 </span>            :             object      | result of function `object_t::max_size()`
<span class="lineNum">   14012 </span>            :             array       | result of function `array_t::max_size()`
<span class="lineNum">   14013 </span>            : 
<span class="lineNum">   14014 </span>            :     @liveexample{The following code calls `max_size()` on the different value
<span class="lineNum">   14015 </span>            :     types. Note the output is implementation specific.,max_size}
<span class="lineNum">   14016 </span>            : 
<span class="lineNum">   14017 </span>            :     @complexity Constant, as long as @ref array_t and @ref object_t satisfy
<span class="lineNum">   14018 </span>            :     the Container concept; that is, their `max_size()` functions have constant
<span class="lineNum">   14019 </span>            :     complexity.
<span class="lineNum">   14020 </span>            : 
<span class="lineNum">   14021 </span>            :     @iterators No changes.
<span class="lineNum">   14022 </span>            : 
<span class="lineNum">   14023 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   14024 </span>            : 
<span class="lineNum">   14025 </span>            :     @requirement This function helps `basic_json` satisfying the
<span class="lineNum">   14026 </span>            :     [Container](http://en.cppreference.com/w/cpp/concept/Container)
<span class="lineNum">   14027 </span>            :     requirements:
<span class="lineNum">   14028 </span>            :     - The complexity is constant.
<span class="lineNum">   14029 </span>            :     - Has the semantics of returning `b.size()` where `b` is the largest
<span class="lineNum">   14030 </span>            :       possible JSON value.
<span class="lineNum">   14031 </span>            : 
<span class="lineNum">   14032 </span>            :     @sa @ref size() -- returns the number of elements
<span class="lineNum">   14033 </span>            : 
<span class="lineNum">   14034 </span>            :     @since version 1.0.0
<span class="lineNum">   14035 </span>            :     */
<span class="lineNum">   14036 </span>            :     size_type max_size() const noexcept
<span class="lineNum">   14037 </span>            :     {
<span class="lineNum">   14038 </span>            :         switch (m_type)
<span class="lineNum">   14039 </span>            :         {
<span class="lineNum">   14040 </span>            :             case value_t::array:
<span class="lineNum">   14041 </span>            :             {
<span class="lineNum">   14042 </span>            :                 // delegate call to array_t::max_size()
<span class="lineNum">   14043 </span>            :                 return m_value.array-&gt;max_size();
<span class="lineNum">   14044 </span>            :             }
<span class="lineNum">   14045 </span>            : 
<span class="lineNum">   14046 </span>            :             case value_t::object:
<span class="lineNum">   14047 </span>            :             {
<span class="lineNum">   14048 </span>            :                 // delegate call to object_t::max_size()
<span class="lineNum">   14049 </span>            :                 return m_value.object-&gt;max_size();
<span class="lineNum">   14050 </span>            :             }
<span class="lineNum">   14051 </span>            : 
<span class="lineNum">   14052 </span>            :             default:
<span class="lineNum">   14053 </span>            :             {
<span class="lineNum">   14054 </span>            :                 // all other types have max_size() == size()
<span class="lineNum">   14055 </span>            :                 return size();
<span class="lineNum">   14056 </span>            :             }
<span class="lineNum">   14057 </span>            :         }
<span class="lineNum">   14058 </span>            :     }
<span class="lineNum">   14059 </span>            : 
<span class="lineNum">   14060 </span>            :     /// @}
<span class="lineNum">   14061 </span>            : 
<span class="lineNum">   14062 </span>            : 
<span class="lineNum">   14063 </span>            :     ///////////////
<span class="lineNum">   14064 </span>            :     // modifiers //
<span class="lineNum">   14065 </span>            :     ///////////////
<span class="lineNum">   14066 </span>            : 
<span class="lineNum">   14067 </span>            :     /// @name modifiers
<span class="lineNum">   14068 </span>            :     /// @{
<span class="lineNum">   14069 </span>            : 
<span class="lineNum">   14070 </span>            :     /*!
<span class="lineNum">   14071 </span>            :     @brief clears the contents
<span class="lineNum">   14072 </span>            : 
<span class="lineNum">   14073 </span>            :     Clears the content of a JSON value and resets it to the default value as
<span class="lineNum">   14074 </span>            :     if @ref basic_json(value_t) would have been called with the current value
<span class="lineNum">   14075 </span>            :     type from @ref type():
<span class="lineNum">   14076 </span>            : 
<span class="lineNum">   14077 </span>            :     Value type  | initial value
<span class="lineNum">   14078 </span>            :     ----------- | -------------
<span class="lineNum">   14079 </span>            :     null        | `null`
<span class="lineNum">   14080 </span>            :     boolean     | `false`
<span class="lineNum">   14081 </span>            :     string      | `&quot;&quot;`
<span class="lineNum">   14082 </span>            :     number      | `0`
<span class="lineNum">   14083 </span>            :     object      | `{}`
<span class="lineNum">   14084 </span>            :     array       | `[]`
<span class="lineNum">   14085 </span>            : 
<span class="lineNum">   14086 </span>            :     @post Has the same effect as calling
<span class="lineNum">   14087 </span>            :     @code {.cpp}
<span class="lineNum">   14088 </span>            :     *this = basic_json(type());
<span class="lineNum">   14089 </span>            :     @endcode
<span class="lineNum">   14090 </span>            : 
<span class="lineNum">   14091 </span>            :     @liveexample{The example below shows the effect of `clear()` to different
<span class="lineNum">   14092 </span>            :     JSON types.,clear}
<span class="lineNum">   14093 </span>            : 
<span class="lineNum">   14094 </span>            :     @complexity Linear in the size of the JSON value.
<span class="lineNum">   14095 </span>            : 
<span class="lineNum">   14096 </span>            :     @iterators All iterators, pointers and references related to this container
<span class="lineNum">   14097 </span>            :                are invalidated.
<span class="lineNum">   14098 </span>            : 
<span class="lineNum">   14099 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   14100 </span>            : 
<span class="lineNum">   14101 </span>            :     @sa @ref basic_json(value_t) -- constructor that creates an object with the
<span class="lineNum">   14102 </span>            :         same value than calling `clear()`
<span class="lineNum">   14103 </span>            : 
<span class="lineNum">   14104 </span>            :     @since version 1.0.0
<span class="lineNum">   14105 </span>            :     */
<span class="lineNum">   14106 </span>            :     void clear() noexcept
<span class="lineNum">   14107 </span>            :     {
<span class="lineNum">   14108 </span>            :         switch (m_type)
<span class="lineNum">   14109 </span>            :         {
<span class="lineNum">   14110 </span>            :             case value_t::number_integer:
<span class="lineNum">   14111 </span>            :             {
<span class="lineNum">   14112 </span>            :                 m_value.number_integer = 0;
<span class="lineNum">   14113 </span>            :                 break;
<span class="lineNum">   14114 </span>            :             }
<span class="lineNum">   14115 </span>            : 
<span class="lineNum">   14116 </span>            :             case value_t::number_unsigned:
<span class="lineNum">   14117 </span>            :             {
<span class="lineNum">   14118 </span>            :                 m_value.number_unsigned = 0;
<span class="lineNum">   14119 </span>            :                 break;
<span class="lineNum">   14120 </span>            :             }
<span class="lineNum">   14121 </span>            : 
<span class="lineNum">   14122 </span>            :             case value_t::number_float:
<span class="lineNum">   14123 </span>            :             {
<span class="lineNum">   14124 </span>            :                 m_value.number_float = 0.0;
<span class="lineNum">   14125 </span>            :                 break;
<span class="lineNum">   14126 </span>            :             }
<span class="lineNum">   14127 </span>            : 
<span class="lineNum">   14128 </span>            :             case value_t::boolean:
<span class="lineNum">   14129 </span>            :             {
<span class="lineNum">   14130 </span>            :                 m_value.boolean = false;
<span class="lineNum">   14131 </span>            :                 break;
<span class="lineNum">   14132 </span>            :             }
<span class="lineNum">   14133 </span>            : 
<span class="lineNum">   14134 </span>            :             case value_t::string:
<span class="lineNum">   14135 </span>            :             {
<span class="lineNum">   14136 </span>            :                 m_value.string-&gt;clear();
<span class="lineNum">   14137 </span>            :                 break;
<span class="lineNum">   14138 </span>            :             }
<span class="lineNum">   14139 </span>            : 
<span class="lineNum">   14140 </span>            :             case value_t::array:
<span class="lineNum">   14141 </span>            :             {
<span class="lineNum">   14142 </span>            :                 m_value.array-&gt;clear();
<span class="lineNum">   14143 </span>            :                 break;
<span class="lineNum">   14144 </span>            :             }
<span class="lineNum">   14145 </span>            : 
<span class="lineNum">   14146 </span>            :             case value_t::object:
<span class="lineNum">   14147 </span>            :             {
<span class="lineNum">   14148 </span>            :                 m_value.object-&gt;clear();
<span class="lineNum">   14149 </span>            :                 break;
<span class="lineNum">   14150 </span>            :             }
<span class="lineNum">   14151 </span>            : 
<span class="lineNum">   14152 </span>            :             default:
<span class="lineNum">   14153 </span>            :                 break;
<span class="lineNum">   14154 </span>            :         }
<span class="lineNum">   14155 </span>            :     }
<span class="lineNum">   14156 </span>            : 
<span class="lineNum">   14157 </span>            :     /*!
<span class="lineNum">   14158 </span>            :     @brief add an object to an array
<span class="lineNum">   14159 </span>            : 
<span class="lineNum">   14160 </span>            :     Appends the given element @a val to the end of the JSON value. If the
<span class="lineNum">   14161 </span>            :     function is called on a JSON null value, an empty array is created before
<span class="lineNum">   14162 </span>            :     appending @a val.
<span class="lineNum">   14163 </span>            : 
<span class="lineNum">   14164 </span>            :     @param[in] val the value to add to the JSON array
<span class="lineNum">   14165 </span>            : 
<span class="lineNum">   14166 </span>            :     @throw type_error.308 when called on a type other than JSON array or
<span class="lineNum">   14167 </span>            :     null; example: `&quot;cannot use push_back() with number&quot;`
<span class="lineNum">   14168 </span>            : 
<span class="lineNum">   14169 </span>            :     @complexity Amortized constant.
<span class="lineNum">   14170 </span>            : 
<span class="lineNum">   14171 </span>            :     @liveexample{The example shows how `push_back()` and `+=` can be used to
<span class="lineNum">   14172 </span>            :     add elements to a JSON array. Note how the `null` value was silently
<span class="lineNum">   14173 </span>            :     converted to a JSON array.,push_back}
<span class="lineNum">   14174 </span>            : 
<a name="14175"><span class="lineNum">   14175 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   14176 </span>            :     */
<span class="lineNum">   14177 </span><span class="lineCov">          4 :     void push_back(basic_json&amp;&amp; val)</span>
<span class="lineNum">   14178 </span>            :     {
<span class="lineNum">   14179 </span>            :         // push_back only works for null objects or arrays
<span class="lineNum">   14180 </span><span class="lineCov">          4 :         if (JSON_UNLIKELY(not(is_null() or is_array())))</span>
<span class="lineNum">   14181 </span>            :         {
<span class="lineNum">   14182 </span><span class="lineNoCov">          0 :             JSON_THROW(type_error::create(308, &quot;cannot use push_back() with &quot; + std::string(type_name())));</span>
<span class="lineNum">   14183 </span>            :         }
<span class="lineNum">   14184 </span>            : 
<span class="lineNum">   14185 </span>            :         // transform null object into an array
<span class="lineNum">   14186 </span><span class="lineCov">          4 :         if (is_null())</span>
<span class="lineNum">   14187 </span>            :         {
<span class="lineNum">   14188 </span><span class="lineCov">          2 :             m_type = value_t::array;</span>
<span class="lineNum">   14189 </span><span class="lineCov">          2 :             m_value = value_t::array;</span>
<span class="lineNum">   14190 </span><span class="lineCov">          2 :             assert_invariant();</span>
<span class="lineNum">   14191 </span>            :         }
<span class="lineNum">   14192 </span>            : 
<span class="lineNum">   14193 </span>            :         // add element to array (move semantics)
<span class="lineNum">   14194 </span><span class="lineCov">          4 :         m_value.array-&gt;push_back(std::move(val));</span>
<span class="lineNum">   14195 </span>            :         // invalidate object
<span class="lineNum">   14196 </span><span class="lineCov">          4 :         val.m_type = value_t::null;</span>
<span class="lineNum">   14197 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">   14198 </span>            : 
<span class="lineNum">   14199 </span>            :     /*!
<span class="lineNum">   14200 </span>            :     @brief add an object to an array
<span class="lineNum">   14201 </span>            :     @copydoc push_back(basic_json&amp;&amp;)
<span class="lineNum">   14202 </span>            :     */
<span class="lineNum">   14203 </span>            :     reference operator+=(basic_json&amp;&amp; val)
<span class="lineNum">   14204 </span>            :     {
<span class="lineNum">   14205 </span>            :         push_back(std::move(val));
<span class="lineNum">   14206 </span>            :         return *this;
<span class="lineNum">   14207 </span>            :     }
<span class="lineNum">   14208 </span>            : 
<span class="lineNum">   14209 </span>            :     /*!
<span class="lineNum">   14210 </span>            :     @brief add an object to an array
<a name="14211"><span class="lineNum">   14211 </span>            :     @copydoc push_back(basic_json&amp;&amp;)</a>
<span class="lineNum">   14212 </span>            :     */
<span class="lineNum">   14213 </span><span class="lineCov">          4 :     void push_back(const basic_json&amp; val)</span>
<span class="lineNum">   14214 </span>            :     {
<span class="lineNum">   14215 </span>            :         // push_back only works for null objects or arrays
<span class="lineNum">   14216 </span><span class="lineCov">          4 :         if (JSON_UNLIKELY(not(is_null() or is_array())))</span>
<span class="lineNum">   14217 </span>            :         {
<span class="lineNum">   14218 </span><span class="lineNoCov">          0 :             JSON_THROW(type_error::create(308, &quot;cannot use push_back() with &quot; + std::string(type_name())));</span>
<span class="lineNum">   14219 </span>            :         }
<span class="lineNum">   14220 </span>            : 
<span class="lineNum">   14221 </span>            :         // transform null object into an array
<span class="lineNum">   14222 </span><span class="lineCov">          4 :         if (is_null())</span>
<span class="lineNum">   14223 </span>            :         {
<span class="lineNum">   14224 </span><span class="lineCov">          2 :             m_type = value_t::array;</span>
<span class="lineNum">   14225 </span><span class="lineCov">          2 :             m_value = value_t::array;</span>
<span class="lineNum">   14226 </span><span class="lineCov">          2 :             assert_invariant();</span>
<span class="lineNum">   14227 </span>            :         }
<span class="lineNum">   14228 </span>            : 
<span class="lineNum">   14229 </span>            :         // add element to array
<span class="lineNum">   14230 </span><span class="lineCov">          4 :         m_value.array-&gt;push_back(val);</span>
<span class="lineNum">   14231 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">   14232 </span>            : 
<span class="lineNum">   14233 </span>            :     /*!
<span class="lineNum">   14234 </span>            :     @brief add an object to an array
<span class="lineNum">   14235 </span>            :     @copydoc push_back(basic_json&amp;&amp;)
<span class="lineNum">   14236 </span>            :     */
<span class="lineNum">   14237 </span>            :     reference operator+=(const basic_json&amp; val)
<span class="lineNum">   14238 </span>            :     {
<span class="lineNum">   14239 </span>            :         push_back(val);
<span class="lineNum">   14240 </span>            :         return *this;
<span class="lineNum">   14241 </span>            :     }
<span class="lineNum">   14242 </span>            : 
<span class="lineNum">   14243 </span>            :     /*!
<span class="lineNum">   14244 </span>            :     @brief add an object to an object
<span class="lineNum">   14245 </span>            : 
<span class="lineNum">   14246 </span>            :     Inserts the given element @a val to the JSON object. If the function is
<span class="lineNum">   14247 </span>            :     called on a JSON null value, an empty object is created before inserting
<span class="lineNum">   14248 </span>            :     @a val.
<span class="lineNum">   14249 </span>            : 
<span class="lineNum">   14250 </span>            :     @param[in] val the value to add to the JSON object
<span class="lineNum">   14251 </span>            : 
<span class="lineNum">   14252 </span>            :     @throw type_error.308 when called on a type other than JSON object or
<span class="lineNum">   14253 </span>            :     null; example: `&quot;cannot use push_back() with number&quot;`
<span class="lineNum">   14254 </span>            : 
<span class="lineNum">   14255 </span>            :     @complexity Logarithmic in the size of the container, O(log(`size()`)).
<span class="lineNum">   14256 </span>            : 
<span class="lineNum">   14257 </span>            :     @liveexample{The example shows how `push_back()` and `+=` can be used to
<span class="lineNum">   14258 </span>            :     add elements to a JSON object. Note how the `null` value was silently
<span class="lineNum">   14259 </span>            :     converted to a JSON object.,push_back__object_t__value}
<span class="lineNum">   14260 </span>            : 
<span class="lineNum">   14261 </span>            :     @since version 1.0.0
<span class="lineNum">   14262 </span>            :     */
<span class="lineNum">   14263 </span>            :     void push_back(const typename object_t::value_type&amp; val)
<span class="lineNum">   14264 </span>            :     {
<span class="lineNum">   14265 </span>            :         // push_back only works for null objects or objects
<span class="lineNum">   14266 </span>            :         if (JSON_UNLIKELY(not(is_null() or is_object())))
<span class="lineNum">   14267 </span>            :         {
<span class="lineNum">   14268 </span>            :             JSON_THROW(type_error::create(308, &quot;cannot use push_back() with &quot; + std::string(type_name())));
<span class="lineNum">   14269 </span>            :         }
<span class="lineNum">   14270 </span>            : 
<span class="lineNum">   14271 </span>            :         // transform null object into an object
<span class="lineNum">   14272 </span>            :         if (is_null())
<span class="lineNum">   14273 </span>            :         {
<span class="lineNum">   14274 </span>            :             m_type = value_t::object;
<span class="lineNum">   14275 </span>            :             m_value = value_t::object;
<span class="lineNum">   14276 </span>            :             assert_invariant();
<span class="lineNum">   14277 </span>            :         }
<span class="lineNum">   14278 </span>            : 
<span class="lineNum">   14279 </span>            :         // add element to array
<span class="lineNum">   14280 </span>            :         m_value.object-&gt;insert(val);
<span class="lineNum">   14281 </span>            :     }
<span class="lineNum">   14282 </span>            : 
<span class="lineNum">   14283 </span>            :     /*!
<span class="lineNum">   14284 </span>            :     @brief add an object to an object
<span class="lineNum">   14285 </span>            :     @copydoc push_back(const typename object_t::value_type&amp;)
<span class="lineNum">   14286 </span>            :     */
<span class="lineNum">   14287 </span>            :     reference operator+=(const typename object_t::value_type&amp; val)
<span class="lineNum">   14288 </span>            :     {
<span class="lineNum">   14289 </span>            :         push_back(val);
<span class="lineNum">   14290 </span>            :         return *this;
<span class="lineNum">   14291 </span>            :     }
<span class="lineNum">   14292 </span>            : 
<span class="lineNum">   14293 </span>            :     /*!
<span class="lineNum">   14294 </span>            :     @brief add an object to an object
<span class="lineNum">   14295 </span>            : 
<span class="lineNum">   14296 </span>            :     This function allows to use `push_back` with an initializer list. In case
<span class="lineNum">   14297 </span>            : 
<span class="lineNum">   14298 </span>            :     1. the current value is an object,
<span class="lineNum">   14299 </span>            :     2. the initializer list @a init contains only two elements, and
<span class="lineNum">   14300 </span>            :     3. the first element of @a init is a string,
<span class="lineNum">   14301 </span>            : 
<span class="lineNum">   14302 </span>            :     @a init is converted into an object element and added using
<span class="lineNum">   14303 </span>            :     @ref push_back(const typename object_t::value_type&amp;). Otherwise, @a init
<span class="lineNum">   14304 </span>            :     is converted to a JSON value and added using @ref push_back(basic_json&amp;&amp;).
<span class="lineNum">   14305 </span>            : 
<span class="lineNum">   14306 </span>            :     @param[in] init  an initializer list
<span class="lineNum">   14307 </span>            : 
<span class="lineNum">   14308 </span>            :     @complexity Linear in the size of the initializer list @a init.
<span class="lineNum">   14309 </span>            : 
<span class="lineNum">   14310 </span>            :     @note This function is required to resolve an ambiguous overload error,
<span class="lineNum">   14311 </span>            :           because pairs like `{&quot;key&quot;, &quot;value&quot;}` can be both interpreted as
<span class="lineNum">   14312 </span>            :           `object_t::value_type` or `std::initializer_list&lt;basic_json&gt;`, see
<span class="lineNum">   14313 </span>            :           https://github.com/nlohmann/json/issues/235 for more information.
<span class="lineNum">   14314 </span>            : 
<span class="lineNum">   14315 </span>            :     @liveexample{The example shows how initializer lists are treated as
<span class="lineNum">   14316 </span>            :     objects when possible.,push_back__initializer_list}
<span class="lineNum">   14317 </span>            :     */
<span class="lineNum">   14318 </span>            :     void push_back(initializer_list_t init)
<span class="lineNum">   14319 </span>            :     {
<span class="lineNum">   14320 </span>            :         if (is_object() and init.size() == 2 and (*init.begin())-&gt;is_string())
<span class="lineNum">   14321 </span>            :         {
<span class="lineNum">   14322 </span>            :             basic_json&amp;&amp; key = init.begin()-&gt;moved_or_copied();
<span class="lineNum">   14323 </span>            :             push_back(typename object_t::value_type(
<span class="lineNum">   14324 </span>            :                           std::move(key.get_ref&lt;string_t&amp;&gt;()), (init.begin() + 1)-&gt;moved_or_copied()));
<span class="lineNum">   14325 </span>            :         }
<span class="lineNum">   14326 </span>            :         else
<span class="lineNum">   14327 </span>            :         {
<span class="lineNum">   14328 </span>            :             push_back(basic_json(init));
<span class="lineNum">   14329 </span>            :         }
<span class="lineNum">   14330 </span>            :     }
<span class="lineNum">   14331 </span>            : 
<span class="lineNum">   14332 </span>            :     /*!
<span class="lineNum">   14333 </span>            :     @brief add an object to an object
<span class="lineNum">   14334 </span>            :     @copydoc push_back(initializer_list_t)
<span class="lineNum">   14335 </span>            :     */
<span class="lineNum">   14336 </span>            :     reference operator+=(initializer_list_t init)
<span class="lineNum">   14337 </span>            :     {
<span class="lineNum">   14338 </span>            :         push_back(init);
<span class="lineNum">   14339 </span>            :         return *this;
<span class="lineNum">   14340 </span>            :     }
<span class="lineNum">   14341 </span>            : 
<span class="lineNum">   14342 </span>            :     /*!
<span class="lineNum">   14343 </span>            :     @brief add an object to an array
<span class="lineNum">   14344 </span>            : 
<span class="lineNum">   14345 </span>            :     Creates a JSON value from the passed parameters @a args to the end of the
<span class="lineNum">   14346 </span>            :     JSON value. If the function is called on a JSON null value, an empty array
<span class="lineNum">   14347 </span>            :     is created before appending the value created from @a args.
<span class="lineNum">   14348 </span>            : 
<span class="lineNum">   14349 </span>            :     @param[in] args arguments to forward to a constructor of @ref basic_json
<span class="lineNum">   14350 </span>            :     @tparam Args compatible types to create a @ref basic_json object
<span class="lineNum">   14351 </span>            : 
<span class="lineNum">   14352 </span>            :     @throw type_error.311 when called on a type other than JSON array or
<span class="lineNum">   14353 </span>            :     null; example: `&quot;cannot use emplace_back() with number&quot;`
<span class="lineNum">   14354 </span>            : 
<span class="lineNum">   14355 </span>            :     @complexity Amortized constant.
<span class="lineNum">   14356 </span>            : 
<span class="lineNum">   14357 </span>            :     @liveexample{The example shows how `push_back()` can be used to add
<span class="lineNum">   14358 </span>            :     elements to a JSON array. Note how the `null` value was silently converted
<span class="lineNum">   14359 </span>            :     to a JSON array.,emplace_back}
<span class="lineNum">   14360 </span>            : 
<span class="lineNum">   14361 </span>            :     @since version 2.0.8
<a name="14362"><span class="lineNum">   14362 </span>            :     */</a>
<span class="lineNum">   14363 </span>            :     template&lt;class... Args&gt;
<span class="lineNum">   14364 </span><span class="lineCov">         18 :     void emplace_back(Args&amp;&amp; ... args)</span>
<span class="lineNum">   14365 </span>            :     {
<span class="lineNum">   14366 </span>            :         // emplace_back only works for null objects or arrays
<span class="lineNum">   14367 </span><span class="lineCov">         18 :         if (JSON_UNLIKELY(not(is_null() or is_array())))</span>
<span class="lineNum">   14368 </span>            :         {
<span class="lineNum">   14369 </span><span class="lineNoCov">          0 :             JSON_THROW(type_error::create(311, &quot;cannot use emplace_back() with &quot; + std::string(type_name())));</span>
<span class="lineNum">   14370 </span>            :         }
<span class="lineNum">   14371 </span>            : 
<span class="lineNum">   14372 </span>            :         // transform null object into an array
<span class="lineNum">   14373 </span><span class="lineCov">         18 :         if (is_null())</span>
<span class="lineNum">   14374 </span>            :         {
<span class="lineNum">   14375 </span><span class="lineNoCov">          0 :             m_type = value_t::array;</span>
<span class="lineNum">   14376 </span><span class="lineNoCov">          0 :             m_value = value_t::array;</span>
<span class="lineNum">   14377 </span><span class="lineNoCov">          0 :             assert_invariant();</span>
<span class="lineNum">   14378 </span>            :         }
<span class="lineNum">   14379 </span>            : 
<span class="lineNum">   14380 </span>            :         // add element to array (perfect forwarding)
<span class="lineNum">   14381 </span><span class="lineCov">         18 :         m_value.array-&gt;emplace_back(std::forward&lt;Args&gt;(args)...);</span>
<span class="lineNum">   14382 </span><span class="lineCov">         18 :     }</span>
<span class="lineNum">   14383 </span>            : 
<span class="lineNum">   14384 </span>            :     /*!
<span class="lineNum">   14385 </span>            :     @brief add an object to an object if key does not exist
<span class="lineNum">   14386 </span>            : 
<span class="lineNum">   14387 </span>            :     Inserts a new element into a JSON object constructed in-place with the
<span class="lineNum">   14388 </span>            :     given @a args if there is no element with the key in the container. If the
<span class="lineNum">   14389 </span>            :     function is called on a JSON null value, an empty object is created before
<span class="lineNum">   14390 </span>            :     appending the value created from @a args.
<span class="lineNum">   14391 </span>            : 
<span class="lineNum">   14392 </span>            :     @param[in] args arguments to forward to a constructor of @ref basic_json
<span class="lineNum">   14393 </span>            :     @tparam Args compatible types to create a @ref basic_json object
<span class="lineNum">   14394 </span>            : 
<span class="lineNum">   14395 </span>            :     @return a pair consisting of an iterator to the inserted element, or the
<span class="lineNum">   14396 </span>            :             already-existing element if no insertion happened, and a bool
<span class="lineNum">   14397 </span>            :             denoting whether the insertion took place.
<span class="lineNum">   14398 </span>            : 
<span class="lineNum">   14399 </span>            :     @throw type_error.311 when called on a type other than JSON object or
<span class="lineNum">   14400 </span>            :     null; example: `&quot;cannot use emplace() with number&quot;`
<span class="lineNum">   14401 </span>            : 
<span class="lineNum">   14402 </span>            :     @complexity Logarithmic in the size of the container, O(log(`size()`)).
<span class="lineNum">   14403 </span>            : 
<span class="lineNum">   14404 </span>            :     @liveexample{The example shows how `emplace()` can be used to add elements
<span class="lineNum">   14405 </span>            :     to a JSON object. Note how the `null` value was silently converted to a
<span class="lineNum">   14406 </span>            :     JSON object. Further note how no value is added if there was already one
<span class="lineNum">   14407 </span>            :     value stored with the same key.,emplace}
<span class="lineNum">   14408 </span>            : 
<span class="lineNum">   14409 </span>            :     @since version 2.0.8
<span class="lineNum">   14410 </span>            :     */
<span class="lineNum">   14411 </span>            :     template&lt;class... Args&gt;
<span class="lineNum">   14412 </span>            :     std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp; ... args)
<span class="lineNum">   14413 </span>            :     {
<span class="lineNum">   14414 </span>            :         // emplace only works for null objects or arrays
<span class="lineNum">   14415 </span>            :         if (JSON_UNLIKELY(not(is_null() or is_object())))
<span class="lineNum">   14416 </span>            :         {
<span class="lineNum">   14417 </span>            :             JSON_THROW(type_error::create(311, &quot;cannot use emplace() with &quot; + std::string(type_name())));
<span class="lineNum">   14418 </span>            :         }
<span class="lineNum">   14419 </span>            : 
<span class="lineNum">   14420 </span>            :         // transform null object into an object
<span class="lineNum">   14421 </span>            :         if (is_null())
<span class="lineNum">   14422 </span>            :         {
<span class="lineNum">   14423 </span>            :             m_type = value_t::object;
<span class="lineNum">   14424 </span>            :             m_value = value_t::object;
<span class="lineNum">   14425 </span>            :             assert_invariant();
<span class="lineNum">   14426 </span>            :         }
<span class="lineNum">   14427 </span>            : 
<span class="lineNum">   14428 </span>            :         // add element to array (perfect forwarding)
<span class="lineNum">   14429 </span>            :         auto res = m_value.object-&gt;emplace(std::forward&lt;Args&gt;(args)...);
<span class="lineNum">   14430 </span>            :         // create result iterator and set iterator to the result of emplace
<span class="lineNum">   14431 </span>            :         auto it = begin();
<span class="lineNum">   14432 </span>            :         it.m_it.object_iterator = res.first;
<span class="lineNum">   14433 </span>            : 
<span class="lineNum">   14434 </span>            :         // return pair of iterator and boolean
<span class="lineNum">   14435 </span>            :         return {it, res.second};
<span class="lineNum">   14436 </span>            :     }
<span class="lineNum">   14437 </span>            : 
<span class="lineNum">   14438 </span>            :     /*!
<span class="lineNum">   14439 </span>            :     @brief inserts element
<span class="lineNum">   14440 </span>            : 
<span class="lineNum">   14441 </span>            :     Inserts element @a val before iterator @a pos.
<span class="lineNum">   14442 </span>            : 
<span class="lineNum">   14443 </span>            :     @param[in] pos iterator before which the content will be inserted; may be
<span class="lineNum">   14444 </span>            :     the end() iterator
<span class="lineNum">   14445 </span>            :     @param[in] val element to insert
<span class="lineNum">   14446 </span>            :     @return iterator pointing to the inserted @a val.
<span class="lineNum">   14447 </span>            : 
<span class="lineNum">   14448 </span>            :     @throw type_error.309 if called on JSON values other than arrays;
<span class="lineNum">   14449 </span>            :     example: `&quot;cannot use insert() with string&quot;`
<span class="lineNum">   14450 </span>            :     @throw invalid_iterator.202 if @a pos is not an iterator of *this;
<span class="lineNum">   14451 </span>            :     example: `&quot;iterator does not fit current value&quot;`
<span class="lineNum">   14452 </span>            : 
<span class="lineNum">   14453 </span>            :     @complexity Constant plus linear in the distance between @a pos and end of
<span class="lineNum">   14454 </span>            :     the container.
<span class="lineNum">   14455 </span>            : 
<span class="lineNum">   14456 </span>            :     @liveexample{The example shows how `insert()` is used.,insert}
<span class="lineNum">   14457 </span>            : 
<span class="lineNum">   14458 </span>            :     @since version 1.0.0
<span class="lineNum">   14459 </span>            :     */
<span class="lineNum">   14460 </span>            :     iterator insert(const_iterator pos, const basic_json&amp; val)
<span class="lineNum">   14461 </span>            :     {
<span class="lineNum">   14462 </span>            :         // insert only works for arrays
<span class="lineNum">   14463 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   14464 </span>            :         {
<span class="lineNum">   14465 </span>            :             // check if iterator pos fits to this JSON value
<span class="lineNum">   14466 </span>            :             if (JSON_UNLIKELY(pos.m_object != this))
<span class="lineNum">   14467 </span>            :             {
<span class="lineNum">   14468 </span>            :                 JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;));
<span class="lineNum">   14469 </span>            :             }
<span class="lineNum">   14470 </span>            : 
<span class="lineNum">   14471 </span>            :             // insert to array and return iterator
<span class="lineNum">   14472 </span>            :             iterator result(this);
<span class="lineNum">   14473 </span>            :             result.m_it.array_iterator = m_value.array-&gt;insert(pos.m_it.array_iterator, val);
<span class="lineNum">   14474 </span>            :             return result;
<span class="lineNum">   14475 </span>            :         }
<span class="lineNum">   14476 </span>            : 
<span class="lineNum">   14477 </span>            :         JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name())));
<span class="lineNum">   14478 </span>            :     }
<span class="lineNum">   14479 </span>            : 
<span class="lineNum">   14480 </span>            :     /*!
<span class="lineNum">   14481 </span>            :     @brief inserts element
<span class="lineNum">   14482 </span>            :     @copydoc insert(const_iterator, const basic_json&amp;)
<span class="lineNum">   14483 </span>            :     */
<span class="lineNum">   14484 </span>            :     iterator insert(const_iterator pos, basic_json&amp;&amp; val)
<span class="lineNum">   14485 </span>            :     {
<span class="lineNum">   14486 </span>            :         return insert(pos, val);
<span class="lineNum">   14487 </span>            :     }
<span class="lineNum">   14488 </span>            : 
<span class="lineNum">   14489 </span>            :     /*!
<span class="lineNum">   14490 </span>            :     @brief inserts elements
<span class="lineNum">   14491 </span>            : 
<span class="lineNum">   14492 </span>            :     Inserts @a cnt copies of @a val before iterator @a pos.
<span class="lineNum">   14493 </span>            : 
<span class="lineNum">   14494 </span>            :     @param[in] pos iterator before which the content will be inserted; may be
<span class="lineNum">   14495 </span>            :     the end() iterator
<span class="lineNum">   14496 </span>            :     @param[in] cnt number of copies of @a val to insert
<span class="lineNum">   14497 </span>            :     @param[in] val element to insert
<span class="lineNum">   14498 </span>            :     @return iterator pointing to the first element inserted, or @a pos if
<span class="lineNum">   14499 </span>            :     `cnt==0`
<span class="lineNum">   14500 </span>            : 
<span class="lineNum">   14501 </span>            :     @throw type_error.309 if called on JSON values other than arrays; example:
<span class="lineNum">   14502 </span>            :     `&quot;cannot use insert() with string&quot;`
<span class="lineNum">   14503 </span>            :     @throw invalid_iterator.202 if @a pos is not an iterator of *this;
<span class="lineNum">   14504 </span>            :     example: `&quot;iterator does not fit current value&quot;`
<span class="lineNum">   14505 </span>            : 
<span class="lineNum">   14506 </span>            :     @complexity Linear in @a cnt plus linear in the distance between @a pos
<span class="lineNum">   14507 </span>            :     and end of the container.
<span class="lineNum">   14508 </span>            : 
<span class="lineNum">   14509 </span>            :     @liveexample{The example shows how `insert()` is used.,insert__count}
<span class="lineNum">   14510 </span>            : 
<span class="lineNum">   14511 </span>            :     @since version 1.0.0
<span class="lineNum">   14512 </span>            :     */
<span class="lineNum">   14513 </span>            :     iterator insert(const_iterator pos, size_type cnt, const basic_json&amp; val)
<span class="lineNum">   14514 </span>            :     {
<span class="lineNum">   14515 </span>            :         // insert only works for arrays
<span class="lineNum">   14516 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   14517 </span>            :         {
<span class="lineNum">   14518 </span>            :             // check if iterator pos fits to this JSON value
<span class="lineNum">   14519 </span>            :             if (JSON_UNLIKELY(pos.m_object != this))
<span class="lineNum">   14520 </span>            :             {
<span class="lineNum">   14521 </span>            :                 JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;));
<span class="lineNum">   14522 </span>            :             }
<span class="lineNum">   14523 </span>            : 
<span class="lineNum">   14524 </span>            :             // insert to array and return iterator
<span class="lineNum">   14525 </span>            :             iterator result(this);
<span class="lineNum">   14526 </span>            :             result.m_it.array_iterator = m_value.array-&gt;insert(pos.m_it.array_iterator, cnt, val);
<span class="lineNum">   14527 </span>            :             return result;
<span class="lineNum">   14528 </span>            :         }
<span class="lineNum">   14529 </span>            : 
<span class="lineNum">   14530 </span>            :         JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name())));
<span class="lineNum">   14531 </span>            :     }
<span class="lineNum">   14532 </span>            : 
<span class="lineNum">   14533 </span>            :     /*!
<span class="lineNum">   14534 </span>            :     @brief inserts elements
<span class="lineNum">   14535 </span>            : 
<span class="lineNum">   14536 </span>            :     Inserts elements from range `[first, last)` before iterator @a pos.
<span class="lineNum">   14537 </span>            : 
<span class="lineNum">   14538 </span>            :     @param[in] pos iterator before which the content will be inserted; may be
<span class="lineNum">   14539 </span>            :     the end() iterator
<span class="lineNum">   14540 </span>            :     @param[in] first begin of the range of elements to insert
<span class="lineNum">   14541 </span>            :     @param[in] last end of the range of elements to insert
<span class="lineNum">   14542 </span>            : 
<span class="lineNum">   14543 </span>            :     @throw type_error.309 if called on JSON values other than arrays; example:
<span class="lineNum">   14544 </span>            :     `&quot;cannot use insert() with string&quot;`
<span class="lineNum">   14545 </span>            :     @throw invalid_iterator.202 if @a pos is not an iterator of *this;
<span class="lineNum">   14546 </span>            :     example: `&quot;iterator does not fit current value&quot;`
<span class="lineNum">   14547 </span>            :     @throw invalid_iterator.210 if @a first and @a last do not belong to the
<span class="lineNum">   14548 </span>            :     same JSON value; example: `&quot;iterators do not fit&quot;`
<span class="lineNum">   14549 </span>            :     @throw invalid_iterator.211 if @a first or @a last are iterators into
<span class="lineNum">   14550 </span>            :     container for which insert is called; example: `&quot;passed iterators may not
<span class="lineNum">   14551 </span>            :     belong to container&quot;`
<span class="lineNum">   14552 </span>            : 
<span class="lineNum">   14553 </span>            :     @return iterator pointing to the first element inserted, or @a pos if
<span class="lineNum">   14554 </span>            :     `first==last`
<span class="lineNum">   14555 </span>            : 
<span class="lineNum">   14556 </span>            :     @complexity Linear in `std::distance(first, last)` plus linear in the
<span class="lineNum">   14557 </span>            :     distance between @a pos and end of the container.
<span class="lineNum">   14558 </span>            : 
<span class="lineNum">   14559 </span>            :     @liveexample{The example shows how `insert()` is used.,insert__range}
<span class="lineNum">   14560 </span>            : 
<span class="lineNum">   14561 </span>            :     @since version 1.0.0
<span class="lineNum">   14562 </span>            :     */
<span class="lineNum">   14563 </span>            :     iterator insert(const_iterator pos, const_iterator first, const_iterator last)
<span class="lineNum">   14564 </span>            :     {
<span class="lineNum">   14565 </span>            :         // insert only works for arrays
<span class="lineNum">   14566 </span>            :         if (JSON_UNLIKELY(not is_array()))
<span class="lineNum">   14567 </span>            :         {
<span class="lineNum">   14568 </span>            :             JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name())));
<span class="lineNum">   14569 </span>            :         }
<span class="lineNum">   14570 </span>            : 
<span class="lineNum">   14571 </span>            :         // check if iterator pos fits to this JSON value
<span class="lineNum">   14572 </span>            :         if (JSON_UNLIKELY(pos.m_object != this))
<span class="lineNum">   14573 </span>            :         {
<span class="lineNum">   14574 </span>            :             JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;));
<span class="lineNum">   14575 </span>            :         }
<span class="lineNum">   14576 </span>            : 
<span class="lineNum">   14577 </span>            :         // check if range iterators belong to the same JSON object
<span class="lineNum">   14578 </span>            :         if (JSON_UNLIKELY(first.m_object != last.m_object))
<span class="lineNum">   14579 </span>            :         {
<span class="lineNum">   14580 </span>            :             JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;));
<span class="lineNum">   14581 </span>            :         }
<span class="lineNum">   14582 </span>            : 
<span class="lineNum">   14583 </span>            :         if (JSON_UNLIKELY(first.m_object == this))
<span class="lineNum">   14584 </span>            :         {
<span class="lineNum">   14585 </span>            :             JSON_THROW(invalid_iterator::create(211, &quot;passed iterators may not belong to container&quot;));
<span class="lineNum">   14586 </span>            :         }
<span class="lineNum">   14587 </span>            : 
<span class="lineNum">   14588 </span>            :         // insert to array and return iterator
<span class="lineNum">   14589 </span>            :         iterator result(this);
<span class="lineNum">   14590 </span>            :         result.m_it.array_iterator = m_value.array-&gt;insert(
<span class="lineNum">   14591 </span>            :                                          pos.m_it.array_iterator,
<span class="lineNum">   14592 </span>            :                                          first.m_it.array_iterator,
<span class="lineNum">   14593 </span>            :                                          last.m_it.array_iterator);
<span class="lineNum">   14594 </span>            :         return result;
<span class="lineNum">   14595 </span>            :     }
<span class="lineNum">   14596 </span>            : 
<span class="lineNum">   14597 </span>            :     /*!
<span class="lineNum">   14598 </span>            :     @brief inserts elements
<span class="lineNum">   14599 </span>            : 
<span class="lineNum">   14600 </span>            :     Inserts elements from initializer list @a ilist before iterator @a pos.
<span class="lineNum">   14601 </span>            : 
<span class="lineNum">   14602 </span>            :     @param[in] pos iterator before which the content will be inserted; may be
<span class="lineNum">   14603 </span>            :     the end() iterator
<span class="lineNum">   14604 </span>            :     @param[in] ilist initializer list to insert the values from
<span class="lineNum">   14605 </span>            : 
<span class="lineNum">   14606 </span>            :     @throw type_error.309 if called on JSON values other than arrays; example:
<span class="lineNum">   14607 </span>            :     `&quot;cannot use insert() with string&quot;`
<span class="lineNum">   14608 </span>            :     @throw invalid_iterator.202 if @a pos is not an iterator of *this;
<span class="lineNum">   14609 </span>            :     example: `&quot;iterator does not fit current value&quot;`
<span class="lineNum">   14610 </span>            : 
<span class="lineNum">   14611 </span>            :     @return iterator pointing to the first element inserted, or @a pos if
<span class="lineNum">   14612 </span>            :     `ilist` is empty
<span class="lineNum">   14613 </span>            : 
<span class="lineNum">   14614 </span>            :     @complexity Linear in `ilist.size()` plus linear in the distance between
<span class="lineNum">   14615 </span>            :     @a pos and end of the container.
<span class="lineNum">   14616 </span>            : 
<span class="lineNum">   14617 </span>            :     @liveexample{The example shows how `insert()` is used.,insert__ilist}
<span class="lineNum">   14618 </span>            : 
<span class="lineNum">   14619 </span>            :     @since version 1.0.0
<span class="lineNum">   14620 </span>            :     */
<span class="lineNum">   14621 </span>            :     iterator insert(const_iterator pos, initializer_list_t ilist)
<span class="lineNum">   14622 </span>            :     {
<span class="lineNum">   14623 </span>            :         // insert only works for arrays
<span class="lineNum">   14624 </span>            :         if (JSON_UNLIKELY(not is_array()))
<span class="lineNum">   14625 </span>            :         {
<span class="lineNum">   14626 </span>            :             JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name())));
<span class="lineNum">   14627 </span>            :         }
<span class="lineNum">   14628 </span>            : 
<span class="lineNum">   14629 </span>            :         // check if iterator pos fits to this JSON value
<span class="lineNum">   14630 </span>            :         if (JSON_UNLIKELY(pos.m_object != this))
<span class="lineNum">   14631 </span>            :         {
<span class="lineNum">   14632 </span>            :             JSON_THROW(invalid_iterator::create(202, &quot;iterator does not fit current value&quot;));
<span class="lineNum">   14633 </span>            :         }
<span class="lineNum">   14634 </span>            : 
<span class="lineNum">   14635 </span>            :         // insert to array and return iterator
<span class="lineNum">   14636 </span>            :         iterator result(this);
<span class="lineNum">   14637 </span>            :         result.m_it.array_iterator = m_value.array-&gt;insert(pos.m_it.array_iterator, ilist.begin(), ilist.end());
<span class="lineNum">   14638 </span>            :         return result;
<span class="lineNum">   14639 </span>            :     }
<span class="lineNum">   14640 </span>            : 
<span class="lineNum">   14641 </span>            :     /*!
<span class="lineNum">   14642 </span>            :     @brief inserts elements
<span class="lineNum">   14643 </span>            : 
<span class="lineNum">   14644 </span>            :     Inserts elements from range `[first, last)`.
<span class="lineNum">   14645 </span>            : 
<span class="lineNum">   14646 </span>            :     @param[in] first begin of the range of elements to insert
<span class="lineNum">   14647 </span>            :     @param[in] last end of the range of elements to insert
<span class="lineNum">   14648 </span>            : 
<span class="lineNum">   14649 </span>            :     @throw type_error.309 if called on JSON values other than objects; example:
<span class="lineNum">   14650 </span>            :     `&quot;cannot use insert() with string&quot;`
<span class="lineNum">   14651 </span>            :     @throw invalid_iterator.202 if iterator @a first or @a last does does not
<span class="lineNum">   14652 </span>            :     point to an object; example: `&quot;iterators first and last must point to
<span class="lineNum">   14653 </span>            :     objects&quot;`
<span class="lineNum">   14654 </span>            :     @throw invalid_iterator.210 if @a first and @a last do not belong to the
<span class="lineNum">   14655 </span>            :     same JSON value; example: `&quot;iterators do not fit&quot;`
<span class="lineNum">   14656 </span>            : 
<span class="lineNum">   14657 </span>            :     @complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
<span class="lineNum">   14658 </span>            :     of elements to insert.
<span class="lineNum">   14659 </span>            : 
<span class="lineNum">   14660 </span>            :     @liveexample{The example shows how `insert()` is used.,insert__range_object}
<span class="lineNum">   14661 </span>            : 
<span class="lineNum">   14662 </span>            :     @since version 3.0.0
<span class="lineNum">   14663 </span>            :     */
<span class="lineNum">   14664 </span>            :     void insert(const_iterator first, const_iterator last)
<span class="lineNum">   14665 </span>            :     {
<span class="lineNum">   14666 </span>            :         // insert only works for objects
<span class="lineNum">   14667 </span>            :         if (JSON_UNLIKELY(not is_object()))
<span class="lineNum">   14668 </span>            :         {
<span class="lineNum">   14669 </span>            :             JSON_THROW(type_error::create(309, &quot;cannot use insert() with &quot; + std::string(type_name())));
<span class="lineNum">   14670 </span>            :         }
<span class="lineNum">   14671 </span>            : 
<span class="lineNum">   14672 </span>            :         // check if range iterators belong to the same JSON object
<span class="lineNum">   14673 </span>            :         if (JSON_UNLIKELY(first.m_object != last.m_object))
<span class="lineNum">   14674 </span>            :         {
<span class="lineNum">   14675 </span>            :             JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;));
<span class="lineNum">   14676 </span>            :         }
<span class="lineNum">   14677 </span>            : 
<span class="lineNum">   14678 </span>            :         // passed iterators must belong to objects
<span class="lineNum">   14679 </span>            :         if (JSON_UNLIKELY(not first.m_object-&gt;is_object()))
<span class="lineNum">   14680 </span>            :         {
<span class="lineNum">   14681 </span>            :             JSON_THROW(invalid_iterator::create(202, &quot;iterators first and last must point to objects&quot;));
<span class="lineNum">   14682 </span>            :         }
<span class="lineNum">   14683 </span>            : 
<span class="lineNum">   14684 </span>            :         m_value.object-&gt;insert(first.m_it.object_iterator, last.m_it.object_iterator);
<span class="lineNum">   14685 </span>            :     }
<span class="lineNum">   14686 </span>            : 
<span class="lineNum">   14687 </span>            :     /*!
<span class="lineNum">   14688 </span>            :     @brief updates a JSON object from another object, overwriting existing keys
<span class="lineNum">   14689 </span>            : 
<span class="lineNum">   14690 </span>            :     Inserts all values from JSON object @a j and overwrites existing keys.
<span class="lineNum">   14691 </span>            : 
<span class="lineNum">   14692 </span>            :     @param[in] j  JSON object to read values from
<span class="lineNum">   14693 </span>            : 
<span class="lineNum">   14694 </span>            :     @throw type_error.312 if called on JSON values other than objects; example:
<span class="lineNum">   14695 </span>            :     `&quot;cannot use update() with string&quot;`
<span class="lineNum">   14696 </span>            : 
<span class="lineNum">   14697 </span>            :     @complexity O(N*log(size() + N)), where N is the number of elements to
<span class="lineNum">   14698 </span>            :                 insert.
<span class="lineNum">   14699 </span>            : 
<span class="lineNum">   14700 </span>            :     @liveexample{The example shows how `update()` is used.,update}
<span class="lineNum">   14701 </span>            : 
<span class="lineNum">   14702 </span>            :     @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update
<span class="lineNum">   14703 </span>            : 
<span class="lineNum">   14704 </span>            :     @since version 3.0.0
<span class="lineNum">   14705 </span>            :     */
<span class="lineNum">   14706 </span>            :     void update(const_reference j)
<span class="lineNum">   14707 </span>            :     {
<span class="lineNum">   14708 </span>            :         // implicitly convert null value to an empty object
<span class="lineNum">   14709 </span>            :         if (is_null())
<span class="lineNum">   14710 </span>            :         {
<span class="lineNum">   14711 </span>            :             m_type = value_t::object;
<span class="lineNum">   14712 </span>            :             m_value.object = create&lt;object_t&gt;();
<span class="lineNum">   14713 </span>            :             assert_invariant();
<span class="lineNum">   14714 </span>            :         }
<span class="lineNum">   14715 </span>            : 
<span class="lineNum">   14716 </span>            :         if (JSON_UNLIKELY(not is_object()))
<span class="lineNum">   14717 </span>            :         {
<span class="lineNum">   14718 </span>            :             JSON_THROW(type_error::create(312, &quot;cannot use update() with &quot; + std::string(type_name())));
<span class="lineNum">   14719 </span>            :         }
<span class="lineNum">   14720 </span>            :         if (JSON_UNLIKELY(not j.is_object()))
<span class="lineNum">   14721 </span>            :         {
<span class="lineNum">   14722 </span>            :             JSON_THROW(type_error::create(312, &quot;cannot use update() with &quot; + std::string(j.type_name())));
<span class="lineNum">   14723 </span>            :         }
<span class="lineNum">   14724 </span>            : 
<span class="lineNum">   14725 </span>            :         for (auto it = j.cbegin(); it != j.cend(); ++it)
<span class="lineNum">   14726 </span>            :         {
<span class="lineNum">   14727 </span>            :             m_value.object-&gt;operator[](it.key()) = it.value();
<span class="lineNum">   14728 </span>            :         }
<span class="lineNum">   14729 </span>            :     }
<span class="lineNum">   14730 </span>            : 
<span class="lineNum">   14731 </span>            :     /*!
<span class="lineNum">   14732 </span>            :     @brief updates a JSON object from another object, overwriting existing keys
<span class="lineNum">   14733 </span>            : 
<span class="lineNum">   14734 </span>            :     Inserts all values from from range `[first, last)` and overwrites existing
<span class="lineNum">   14735 </span>            :     keys.
<span class="lineNum">   14736 </span>            : 
<span class="lineNum">   14737 </span>            :     @param[in] first begin of the range of elements to insert
<span class="lineNum">   14738 </span>            :     @param[in] last end of the range of elements to insert
<span class="lineNum">   14739 </span>            : 
<span class="lineNum">   14740 </span>            :     @throw type_error.312 if called on JSON values other than objects; example:
<span class="lineNum">   14741 </span>            :     `&quot;cannot use update() with string&quot;`
<span class="lineNum">   14742 </span>            :     @throw invalid_iterator.202 if iterator @a first or @a last does does not
<span class="lineNum">   14743 </span>            :     point to an object; example: `&quot;iterators first and last must point to
<span class="lineNum">   14744 </span>            :     objects&quot;`
<span class="lineNum">   14745 </span>            :     @throw invalid_iterator.210 if @a first and @a last do not belong to the
<span class="lineNum">   14746 </span>            :     same JSON value; example: `&quot;iterators do not fit&quot;`
<span class="lineNum">   14747 </span>            : 
<span class="lineNum">   14748 </span>            :     @complexity O(N*log(size() + N)), where N is the number of elements to
<span class="lineNum">   14749 </span>            :                 insert.
<span class="lineNum">   14750 </span>            : 
<span class="lineNum">   14751 </span>            :     @liveexample{The example shows how `update()` is used__range.,update}
<span class="lineNum">   14752 </span>            : 
<span class="lineNum">   14753 </span>            :     @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update
<span class="lineNum">   14754 </span>            : 
<span class="lineNum">   14755 </span>            :     @since version 3.0.0
<span class="lineNum">   14756 </span>            :     */
<span class="lineNum">   14757 </span>            :     void update(const_iterator first, const_iterator last)
<span class="lineNum">   14758 </span>            :     {
<span class="lineNum">   14759 </span>            :         // implicitly convert null value to an empty object
<span class="lineNum">   14760 </span>            :         if (is_null())
<span class="lineNum">   14761 </span>            :         {
<span class="lineNum">   14762 </span>            :             m_type = value_t::object;
<span class="lineNum">   14763 </span>            :             m_value.object = create&lt;object_t&gt;();
<span class="lineNum">   14764 </span>            :             assert_invariant();
<span class="lineNum">   14765 </span>            :         }
<span class="lineNum">   14766 </span>            : 
<span class="lineNum">   14767 </span>            :         if (JSON_UNLIKELY(not is_object()))
<span class="lineNum">   14768 </span>            :         {
<span class="lineNum">   14769 </span>            :             JSON_THROW(type_error::create(312, &quot;cannot use update() with &quot; + std::string(type_name())));
<span class="lineNum">   14770 </span>            :         }
<span class="lineNum">   14771 </span>            : 
<span class="lineNum">   14772 </span>            :         // check if range iterators belong to the same JSON object
<span class="lineNum">   14773 </span>            :         if (JSON_UNLIKELY(first.m_object != last.m_object))
<span class="lineNum">   14774 </span>            :         {
<span class="lineNum">   14775 </span>            :             JSON_THROW(invalid_iterator::create(210, &quot;iterators do not fit&quot;));
<span class="lineNum">   14776 </span>            :         }
<span class="lineNum">   14777 </span>            : 
<span class="lineNum">   14778 </span>            :         // passed iterators must belong to objects
<span class="lineNum">   14779 </span>            :         if (JSON_UNLIKELY(not first.m_object-&gt;is_object()
<span class="lineNum">   14780 </span>            :                           or not first.m_object-&gt;is_object()))
<span class="lineNum">   14781 </span>            :         {
<span class="lineNum">   14782 </span>            :             JSON_THROW(invalid_iterator::create(202, &quot;iterators first and last must point to objects&quot;));
<span class="lineNum">   14783 </span>            :         }
<span class="lineNum">   14784 </span>            : 
<span class="lineNum">   14785 </span>            :         for (auto it = first; it != last; ++it)
<span class="lineNum">   14786 </span>            :         {
<span class="lineNum">   14787 </span>            :             m_value.object-&gt;operator[](it.key()) = it.value();
<span class="lineNum">   14788 </span>            :         }
<span class="lineNum">   14789 </span>            :     }
<span class="lineNum">   14790 </span>            : 
<span class="lineNum">   14791 </span>            :     /*!
<span class="lineNum">   14792 </span>            :     @brief exchanges the values
<span class="lineNum">   14793 </span>            : 
<span class="lineNum">   14794 </span>            :     Exchanges the contents of the JSON value with those of @a other. Does not
<span class="lineNum">   14795 </span>            :     invoke any move, copy, or swap operations on individual elements. All
<span class="lineNum">   14796 </span>            :     iterators and references remain valid. The past-the-end iterator is
<span class="lineNum">   14797 </span>            :     invalidated.
<span class="lineNum">   14798 </span>            : 
<span class="lineNum">   14799 </span>            :     @param[in,out] other JSON value to exchange the contents with
<span class="lineNum">   14800 </span>            : 
<span class="lineNum">   14801 </span>            :     @complexity Constant.
<span class="lineNum">   14802 </span>            : 
<span class="lineNum">   14803 </span>            :     @liveexample{The example below shows how JSON values can be swapped with
<span class="lineNum">   14804 </span>            :     `swap()`.,swap__reference}
<span class="lineNum">   14805 </span>            : 
<span class="lineNum">   14806 </span>            :     @since version 1.0.0
<span class="lineNum">   14807 </span>            :     */
<span class="lineNum">   14808 </span>            :     void swap(reference other) noexcept (
<span class="lineNum">   14809 </span>            :         std::is_nothrow_move_constructible&lt;value_t&gt;::value and
<span class="lineNum">   14810 </span>            :         std::is_nothrow_move_assignable&lt;value_t&gt;::value and
<span class="lineNum">   14811 </span>            :         std::is_nothrow_move_constructible&lt;json_value&gt;::value and
<span class="lineNum">   14812 </span>            :         std::is_nothrow_move_assignable&lt;json_value&gt;::value
<span class="lineNum">   14813 </span>            :     )
<span class="lineNum">   14814 </span>            :     {
<span class="lineNum">   14815 </span>            :         std::swap(m_type, other.m_type);
<span class="lineNum">   14816 </span>            :         std::swap(m_value, other.m_value);
<span class="lineNum">   14817 </span>            :         assert_invariant();
<span class="lineNum">   14818 </span>            :     }
<span class="lineNum">   14819 </span>            : 
<span class="lineNum">   14820 </span>            :     /*!
<span class="lineNum">   14821 </span>            :     @brief exchanges the values
<span class="lineNum">   14822 </span>            : 
<span class="lineNum">   14823 </span>            :     Exchanges the contents of a JSON array with those of @a other. Does not
<span class="lineNum">   14824 </span>            :     invoke any move, copy, or swap operations on individual elements. All
<span class="lineNum">   14825 </span>            :     iterators and references remain valid. The past-the-end iterator is
<span class="lineNum">   14826 </span>            :     invalidated.
<span class="lineNum">   14827 </span>            : 
<span class="lineNum">   14828 </span>            :     @param[in,out] other array to exchange the contents with
<span class="lineNum">   14829 </span>            : 
<span class="lineNum">   14830 </span>            :     @throw type_error.310 when JSON value is not an array; example: `&quot;cannot
<span class="lineNum">   14831 </span>            :     use swap() with string&quot;`
<span class="lineNum">   14832 </span>            : 
<span class="lineNum">   14833 </span>            :     @complexity Constant.
<span class="lineNum">   14834 </span>            : 
<span class="lineNum">   14835 </span>            :     @liveexample{The example below shows how arrays can be swapped with
<span class="lineNum">   14836 </span>            :     `swap()`.,swap__array_t}
<span class="lineNum">   14837 </span>            : 
<span class="lineNum">   14838 </span>            :     @since version 1.0.0
<span class="lineNum">   14839 </span>            :     */
<span class="lineNum">   14840 </span>            :     void swap(array_t&amp; other)
<span class="lineNum">   14841 </span>            :     {
<span class="lineNum">   14842 </span>            :         // swap only works for arrays
<span class="lineNum">   14843 </span>            :         if (JSON_LIKELY(is_array()))
<span class="lineNum">   14844 </span>            :         {
<span class="lineNum">   14845 </span>            :             std::swap(*(m_value.array), other);
<span class="lineNum">   14846 </span>            :         }
<span class="lineNum">   14847 </span>            :         else
<span class="lineNum">   14848 </span>            :         {
<span class="lineNum">   14849 </span>            :             JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name())));
<span class="lineNum">   14850 </span>            :         }
<span class="lineNum">   14851 </span>            :     }
<span class="lineNum">   14852 </span>            : 
<span class="lineNum">   14853 </span>            :     /*!
<span class="lineNum">   14854 </span>            :     @brief exchanges the values
<span class="lineNum">   14855 </span>            : 
<span class="lineNum">   14856 </span>            :     Exchanges the contents of a JSON object with those of @a other. Does not
<span class="lineNum">   14857 </span>            :     invoke any move, copy, or swap operations on individual elements. All
<span class="lineNum">   14858 </span>            :     iterators and references remain valid. The past-the-end iterator is
<span class="lineNum">   14859 </span>            :     invalidated.
<span class="lineNum">   14860 </span>            : 
<span class="lineNum">   14861 </span>            :     @param[in,out] other object to exchange the contents with
<span class="lineNum">   14862 </span>            : 
<span class="lineNum">   14863 </span>            :     @throw type_error.310 when JSON value is not an object; example:
<span class="lineNum">   14864 </span>            :     `&quot;cannot use swap() with string&quot;`
<span class="lineNum">   14865 </span>            : 
<span class="lineNum">   14866 </span>            :     @complexity Constant.
<span class="lineNum">   14867 </span>            : 
<span class="lineNum">   14868 </span>            :     @liveexample{The example below shows how objects can be swapped with
<span class="lineNum">   14869 </span>            :     `swap()`.,swap__object_t}
<span class="lineNum">   14870 </span>            : 
<span class="lineNum">   14871 </span>            :     @since version 1.0.0
<span class="lineNum">   14872 </span>            :     */
<span class="lineNum">   14873 </span>            :     void swap(object_t&amp; other)
<span class="lineNum">   14874 </span>            :     {
<span class="lineNum">   14875 </span>            :         // swap only works for objects
<span class="lineNum">   14876 </span>            :         if (JSON_LIKELY(is_object()))
<span class="lineNum">   14877 </span>            :         {
<span class="lineNum">   14878 </span>            :             std::swap(*(m_value.object), other);
<span class="lineNum">   14879 </span>            :         }
<span class="lineNum">   14880 </span>            :         else
<span class="lineNum">   14881 </span>            :         {
<span class="lineNum">   14882 </span>            :             JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name())));
<span class="lineNum">   14883 </span>            :         }
<span class="lineNum">   14884 </span>            :     }
<span class="lineNum">   14885 </span>            : 
<span class="lineNum">   14886 </span>            :     /*!
<span class="lineNum">   14887 </span>            :     @brief exchanges the values
<span class="lineNum">   14888 </span>            : 
<span class="lineNum">   14889 </span>            :     Exchanges the contents of a JSON string with those of @a other. Does not
<span class="lineNum">   14890 </span>            :     invoke any move, copy, or swap operations on individual elements. All
<span class="lineNum">   14891 </span>            :     iterators and references remain valid. The past-the-end iterator is
<span class="lineNum">   14892 </span>            :     invalidated.
<span class="lineNum">   14893 </span>            : 
<span class="lineNum">   14894 </span>            :     @param[in,out] other string to exchange the contents with
<span class="lineNum">   14895 </span>            : 
<span class="lineNum">   14896 </span>            :     @throw type_error.310 when JSON value is not a string; example: `&quot;cannot
<span class="lineNum">   14897 </span>            :     use swap() with boolean&quot;`
<span class="lineNum">   14898 </span>            : 
<span class="lineNum">   14899 </span>            :     @complexity Constant.
<span class="lineNum">   14900 </span>            : 
<span class="lineNum">   14901 </span>            :     @liveexample{The example below shows how strings can be swapped with
<span class="lineNum">   14902 </span>            :     `swap()`.,swap__string_t}
<span class="lineNum">   14903 </span>            : 
<span class="lineNum">   14904 </span>            :     @since version 1.0.0
<span class="lineNum">   14905 </span>            :     */
<span class="lineNum">   14906 </span>            :     void swap(string_t&amp; other)
<span class="lineNum">   14907 </span>            :     {
<span class="lineNum">   14908 </span>            :         // swap only works for strings
<span class="lineNum">   14909 </span>            :         if (JSON_LIKELY(is_string()))
<span class="lineNum">   14910 </span>            :         {
<span class="lineNum">   14911 </span>            :             std::swap(*(m_value.string), other);
<span class="lineNum">   14912 </span>            :         }
<span class="lineNum">   14913 </span>            :         else
<span class="lineNum">   14914 </span>            :         {
<span class="lineNum">   14915 </span>            :             JSON_THROW(type_error::create(310, &quot;cannot use swap() with &quot; + std::string(type_name())));
<span class="lineNum">   14916 </span>            :         }
<span class="lineNum">   14917 </span>            :     }
<span class="lineNum">   14918 </span>            : 
<span class="lineNum">   14919 </span>            :     /// @}
<span class="lineNum">   14920 </span>            : 
<span class="lineNum">   14921 </span>            :   public:
<span class="lineNum">   14922 </span>            :     //////////////////////////////////////////
<span class="lineNum">   14923 </span>            :     // lexicographical comparison operators //
<span class="lineNum">   14924 </span>            :     //////////////////////////////////////////
<span class="lineNum">   14925 </span>            : 
<span class="lineNum">   14926 </span>            :     /// @name lexicographical comparison operators
<span class="lineNum">   14927 </span>            :     /// @{
<span class="lineNum">   14928 </span>            : 
<span class="lineNum">   14929 </span>            :     /*!
<span class="lineNum">   14930 </span>            :     @brief comparison: equal
<span class="lineNum">   14931 </span>            : 
<span class="lineNum">   14932 </span>            :     Compares two JSON values for equality according to the following rules:
<span class="lineNum">   14933 </span>            :     - Two JSON values are equal if (1) they are from the same type and (2)
<span class="lineNum">   14934 </span>            :       their stored values are the same according to their respective
<span class="lineNum">   14935 </span>            :       `operator==`.
<span class="lineNum">   14936 </span>            :     - Integer and floating-point numbers are automatically converted before
<span class="lineNum">   14937 </span>            :       comparison. Note than two NaN values are always treated as unequal.
<span class="lineNum">   14938 </span>            :     - Two JSON null values are equal.
<span class="lineNum">   14939 </span>            : 
<span class="lineNum">   14940 </span>            :     @note Floating-point inside JSON values numbers are compared with
<span class="lineNum">   14941 </span>            :     `json::number_float_t::operator==` which is `double::operator==` by
<span class="lineNum">   14942 </span>            :     default. To compare floating-point while respecting an epsilon, an alternative
<span class="lineNum">   14943 </span>            :     [comparison function](https://github.com/mariokonrad/marnav/blob/master/src/marnav/math/floatingpoint.hpp#L34-#L39)
<span class="lineNum">   14944 </span>            :     could be used, for instance
<span class="lineNum">   14945 </span>            :     @code {.cpp}
<span class="lineNum">   14946 </span>            :     template&lt;typename T, typename = typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::type&gt;
<span class="lineNum">   14947 </span>            :     inline bool is_same(T a, T b, T epsilon = std::numeric_limits&lt;T&gt;::epsilon()) noexcept
<span class="lineNum">   14948 </span>            :     {
<span class="lineNum">   14949 </span>            :         return std::abs(a - b) &lt;= epsilon;
<span class="lineNum">   14950 </span>            :     }
<span class="lineNum">   14951 </span>            :     @endcode
<span class="lineNum">   14952 </span>            : 
<span class="lineNum">   14953 </span>            :     @note NaN values never compare equal to themselves or to other NaN values.
<span class="lineNum">   14954 </span>            : 
<span class="lineNum">   14955 </span>            :     @param[in] lhs  first JSON value to consider
<span class="lineNum">   14956 </span>            :     @param[in] rhs  second JSON value to consider
<span class="lineNum">   14957 </span>            :     @return whether the values @a lhs and @a rhs are equal
<span class="lineNum">   14958 </span>            : 
<span class="lineNum">   14959 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   14960 </span>            : 
<span class="lineNum">   14961 </span>            :     @complexity Linear.
<span class="lineNum">   14962 </span>            : 
<span class="lineNum">   14963 </span>            :     @liveexample{The example demonstrates comparing several JSON
<span class="lineNum">   14964 </span>            :     types.,operator__equal}
<span class="lineNum">   14965 </span>            : 
<span class="lineNum">   14966 </span>            :     @since version 1.0.0
<span class="lineNum">   14967 </span>            :     */
<span class="lineNum">   14968 </span>            :     friend bool operator==(const_reference lhs, const_reference rhs) noexcept
<span class="lineNum">   14969 </span>            :     {
<span class="lineNum">   14970 </span>            :         const auto lhs_type = lhs.type();
<span class="lineNum">   14971 </span>            :         const auto rhs_type = rhs.type();
<span class="lineNum">   14972 </span>            : 
<span class="lineNum">   14973 </span>            :         if (lhs_type == rhs_type)
<span class="lineNum">   14974 </span>            :         {
<span class="lineNum">   14975 </span>            :             switch (lhs_type)
<span class="lineNum">   14976 </span>            :             {
<span class="lineNum">   14977 </span>            :                 case value_t::array:
<span class="lineNum">   14978 </span>            :                     return (*lhs.m_value.array == *rhs.m_value.array);
<span class="lineNum">   14979 </span>            : 
<span class="lineNum">   14980 </span>            :                 case value_t::object:
<span class="lineNum">   14981 </span>            :                     return (*lhs.m_value.object == *rhs.m_value.object);
<span class="lineNum">   14982 </span>            : 
<span class="lineNum">   14983 </span>            :                 case value_t::null:
<span class="lineNum">   14984 </span>            :                     return true;
<span class="lineNum">   14985 </span>            : 
<span class="lineNum">   14986 </span>            :                 case value_t::string:
<span class="lineNum">   14987 </span>            :                     return (*lhs.m_value.string == *rhs.m_value.string);
<span class="lineNum">   14988 </span>            : 
<span class="lineNum">   14989 </span>            :                 case value_t::boolean:
<span class="lineNum">   14990 </span>            :                     return (lhs.m_value.boolean == rhs.m_value.boolean);
<span class="lineNum">   14991 </span>            : 
<span class="lineNum">   14992 </span>            :                 case value_t::number_integer:
<span class="lineNum">   14993 </span>            :                     return (lhs.m_value.number_integer == rhs.m_value.number_integer);
<span class="lineNum">   14994 </span>            : 
<span class="lineNum">   14995 </span>            :                 case value_t::number_unsigned:
<span class="lineNum">   14996 </span>            :                     return (lhs.m_value.number_unsigned == rhs.m_value.number_unsigned);
<span class="lineNum">   14997 </span>            : 
<span class="lineNum">   14998 </span>            :                 case value_t::number_float:
<span class="lineNum">   14999 </span>            :                     return (lhs.m_value.number_float == rhs.m_value.number_float);
<span class="lineNum">   15000 </span>            : 
<span class="lineNum">   15001 </span>            :                 default:
<span class="lineNum">   15002 </span>            :                     return false;
<span class="lineNum">   15003 </span>            :             }
<span class="lineNum">   15004 </span>            :         }
<span class="lineNum">   15005 </span>            :         else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
<span class="lineNum">   15006 </span>            :         {
<span class="lineNum">   15007 </span>            :             return (static_cast&lt;number_float_t&gt;(lhs.m_value.number_integer) == rhs.m_value.number_float);
<span class="lineNum">   15008 </span>            :         }
<span class="lineNum">   15009 </span>            :         else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
<span class="lineNum">   15010 </span>            :         {
<span class="lineNum">   15011 </span>            :             return (lhs.m_value.number_float == static_cast&lt;number_float_t&gt;(rhs.m_value.number_integer));
<span class="lineNum">   15012 </span>            :         }
<span class="lineNum">   15013 </span>            :         else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
<span class="lineNum">   15014 </span>            :         {
<span class="lineNum">   15015 </span>            :             return (static_cast&lt;number_float_t&gt;(lhs.m_value.number_unsigned) == rhs.m_value.number_float);
<span class="lineNum">   15016 </span>            :         }
<span class="lineNum">   15017 </span>            :         else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
<span class="lineNum">   15018 </span>            :         {
<span class="lineNum">   15019 </span>            :             return (lhs.m_value.number_float == static_cast&lt;number_float_t&gt;(rhs.m_value.number_unsigned));
<span class="lineNum">   15020 </span>            :         }
<span class="lineNum">   15021 </span>            :         else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
<span class="lineNum">   15022 </span>            :         {
<span class="lineNum">   15023 </span>            :             return (static_cast&lt;number_integer_t&gt;(lhs.m_value.number_unsigned) == rhs.m_value.number_integer);
<span class="lineNum">   15024 </span>            :         }
<span class="lineNum">   15025 </span>            :         else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
<span class="lineNum">   15026 </span>            :         {
<span class="lineNum">   15027 </span>            :             return (lhs.m_value.number_integer == static_cast&lt;number_integer_t&gt;(rhs.m_value.number_unsigned));
<span class="lineNum">   15028 </span>            :         }
<span class="lineNum">   15029 </span>            : 
<span class="lineNum">   15030 </span>            :         return false;
<span class="lineNum">   15031 </span>            :     }
<span class="lineNum">   15032 </span>            : 
<span class="lineNum">   15033 </span>            :     /*!
<span class="lineNum">   15034 </span>            :     @brief comparison: equal
<span class="lineNum">   15035 </span>            :     @copydoc operator==(const_reference, const_reference)
<span class="lineNum">   15036 </span>            :     */
<span class="lineNum">   15037 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15038 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15039 </span>            :     friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
<span class="lineNum">   15040 </span>            :     {
<span class="lineNum">   15041 </span>            :         return (lhs == basic_json(rhs));
<span class="lineNum">   15042 </span>            :     }
<span class="lineNum">   15043 </span>            : 
<span class="lineNum">   15044 </span>            :     /*!
<span class="lineNum">   15045 </span>            :     @brief comparison: equal
<span class="lineNum">   15046 </span>            :     @copydoc operator==(const_reference, const_reference)
<span class="lineNum">   15047 </span>            :     */
<span class="lineNum">   15048 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15049 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15050 </span>            :     friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
<span class="lineNum">   15051 </span>            :     {
<span class="lineNum">   15052 </span>            :         return (basic_json(lhs) == rhs);
<span class="lineNum">   15053 </span>            :     }
<span class="lineNum">   15054 </span>            : 
<span class="lineNum">   15055 </span>            :     /*!
<span class="lineNum">   15056 </span>            :     @brief comparison: not equal
<span class="lineNum">   15057 </span>            : 
<span class="lineNum">   15058 </span>            :     Compares two JSON values for inequality by calculating `not (lhs == rhs)`.
<span class="lineNum">   15059 </span>            : 
<span class="lineNum">   15060 </span>            :     @param[in] lhs  first JSON value to consider
<span class="lineNum">   15061 </span>            :     @param[in] rhs  second JSON value to consider
<span class="lineNum">   15062 </span>            :     @return whether the values @a lhs and @a rhs are not equal
<span class="lineNum">   15063 </span>            : 
<span class="lineNum">   15064 </span>            :     @complexity Linear.
<span class="lineNum">   15065 </span>            : 
<span class="lineNum">   15066 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   15067 </span>            : 
<span class="lineNum">   15068 </span>            :     @liveexample{The example demonstrates comparing several JSON
<span class="lineNum">   15069 </span>            :     types.,operator__notequal}
<span class="lineNum">   15070 </span>            : 
<span class="lineNum">   15071 </span>            :     @since version 1.0.0
<span class="lineNum">   15072 </span>            :     */
<span class="lineNum">   15073 </span>            :     friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
<span class="lineNum">   15074 </span>            :     {
<span class="lineNum">   15075 </span>            :         return not (lhs == rhs);
<span class="lineNum">   15076 </span>            :     }
<span class="lineNum">   15077 </span>            : 
<span class="lineNum">   15078 </span>            :     /*!
<span class="lineNum">   15079 </span>            :     @brief comparison: not equal
<span class="lineNum">   15080 </span>            :     @copydoc operator!=(const_reference, const_reference)
<span class="lineNum">   15081 </span>            :     */
<span class="lineNum">   15082 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15083 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15084 </span>            :     friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
<span class="lineNum">   15085 </span>            :     {
<span class="lineNum">   15086 </span>            :         return (lhs != basic_json(rhs));
<span class="lineNum">   15087 </span>            :     }
<span class="lineNum">   15088 </span>            : 
<span class="lineNum">   15089 </span>            :     /*!
<span class="lineNum">   15090 </span>            :     @brief comparison: not equal
<span class="lineNum">   15091 </span>            :     @copydoc operator!=(const_reference, const_reference)
<span class="lineNum">   15092 </span>            :     */
<span class="lineNum">   15093 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15094 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15095 </span>            :     friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
<span class="lineNum">   15096 </span>            :     {
<span class="lineNum">   15097 </span>            :         return (basic_json(lhs) != rhs);
<span class="lineNum">   15098 </span>            :     }
<span class="lineNum">   15099 </span>            : 
<span class="lineNum">   15100 </span>            :     /*!
<span class="lineNum">   15101 </span>            :     @brief comparison: less than
<span class="lineNum">   15102 </span>            : 
<span class="lineNum">   15103 </span>            :     Compares whether one JSON value @a lhs is less than another JSON value @a
<span class="lineNum">   15104 </span>            :     rhs according to the following rules:
<span class="lineNum">   15105 </span>            :     - If @a lhs and @a rhs have the same type, the values are compared using
<span class="lineNum">   15106 </span>            :       the default `&lt;` operator.
<span class="lineNum">   15107 </span>            :     - Integer and floating-point numbers are automatically converted before
<span class="lineNum">   15108 </span>            :       comparison
<span class="lineNum">   15109 </span>            :     - In case @a lhs and @a rhs have different types, the values are ignored
<span class="lineNum">   15110 </span>            :       and the order of the types is considered, see
<span class="lineNum">   15111 </span>            :       @ref operator&lt;(const value_t, const value_t).
<span class="lineNum">   15112 </span>            : 
<span class="lineNum">   15113 </span>            :     @param[in] lhs  first JSON value to consider
<span class="lineNum">   15114 </span>            :     @param[in] rhs  second JSON value to consider
<span class="lineNum">   15115 </span>            :     @return whether @a lhs is less than @a rhs
<span class="lineNum">   15116 </span>            : 
<span class="lineNum">   15117 </span>            :     @complexity Linear.
<span class="lineNum">   15118 </span>            : 
<span class="lineNum">   15119 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   15120 </span>            : 
<span class="lineNum">   15121 </span>            :     @liveexample{The example demonstrates comparing several JSON
<span class="lineNum">   15122 </span>            :     types.,operator__less}
<span class="lineNum">   15123 </span>            : 
<a name="15124"><span class="lineNum">   15124 </span>            :     @since version 1.0.0</a>
<span class="lineNum">   15125 </span>            :     */
<span class="lineNum">   15126 </span><span class="lineCov">         30 :     friend bool operator&lt;(const_reference lhs, const_reference rhs) noexcept</span>
<span class="lineNum">   15127 </span>            :     {
<span class="lineNum">   15128 </span><span class="lineCov">         30 :         const auto lhs_type = lhs.type();</span>
<span class="lineNum">   15129 </span><span class="lineCov">         30 :         const auto rhs_type = rhs.type();</span>
<span class="lineNum">   15130 </span>            : 
<span class="lineNum">   15131 </span><span class="lineCov">         30 :         if (lhs_type == rhs_type)</span>
<span class="lineNum">   15132 </span>            :         {
<span class="lineNum">   15133 </span><span class="lineCov">         30 :             switch (lhs_type)</span>
<span class="lineNum">   15134 </span>            :             {
<span class="lineNum">   15135 </span>            :                 case value_t::array:
<span class="lineNum">   15136 </span><span class="lineNoCov">          0 :                     return (*lhs.m_value.array) &lt; (*rhs.m_value.array);</span>
<span class="lineNum">   15137 </span>            : 
<span class="lineNum">   15138 </span>            :                 case value_t::object:
<span class="lineNum">   15139 </span><span class="lineNoCov">          0 :                     return *lhs.m_value.object &lt; *rhs.m_value.object;</span>
<span class="lineNum">   15140 </span>            : 
<span class="lineNum">   15141 </span>            :                 case value_t::null:
<span class="lineNum">   15142 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">   15143 </span>            : 
<span class="lineNum">   15144 </span>            :                 case value_t::string:
<span class="lineNum">   15145 </span><span class="lineNoCov">          0 :                     return *lhs.m_value.string &lt; *rhs.m_value.string;</span>
<span class="lineNum">   15146 </span>            : 
<span class="lineNum">   15147 </span>            :                 case value_t::boolean:
<span class="lineNum">   15148 </span><span class="lineNoCov">          0 :                     return lhs.m_value.boolean &lt; rhs.m_value.boolean;</span>
<span class="lineNum">   15149 </span>            : 
<span class="lineNum">   15150 </span>            :                 case value_t::number_integer:
<span class="lineNum">   15151 </span><span class="lineNoCov">          0 :                     return lhs.m_value.number_integer &lt; rhs.m_value.number_integer;</span>
<span class="lineNum">   15152 </span>            : 
<span class="lineNum">   15153 </span>            :                 case value_t::number_unsigned:
<span class="lineNum">   15154 </span><span class="lineCov">         30 :                     return lhs.m_value.number_unsigned &lt; rhs.m_value.number_unsigned;</span>
<span class="lineNum">   15155 </span>            : 
<span class="lineNum">   15156 </span>            :                 case value_t::number_float:
<span class="lineNum">   15157 </span><span class="lineNoCov">          0 :                     return lhs.m_value.number_float &lt; rhs.m_value.number_float;</span>
<span class="lineNum">   15158 </span>            : 
<span class="lineNum">   15159 </span>            :                 default:
<span class="lineNum">   15160 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">   15161 </span>            :             }
<span class="lineNum">   15162 </span>            :         }
<span class="lineNum">   15163 </span><span class="lineNoCov">          0 :         else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)</span>
<span class="lineNum">   15164 </span>            :         {
<span class="lineNum">   15165 </span><span class="lineNoCov">          0 :             return static_cast&lt;number_float_t&gt;(lhs.m_value.number_integer) &lt; rhs.m_value.number_float;</span>
<span class="lineNum">   15166 </span>            :         }
<span class="lineNum">   15167 </span><span class="lineNoCov">          0 :         else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)</span>
<span class="lineNum">   15168 </span>            :         {
<span class="lineNum">   15169 </span><span class="lineNoCov">          0 :             return lhs.m_value.number_float &lt; static_cast&lt;number_float_t&gt;(rhs.m_value.number_integer);</span>
<span class="lineNum">   15170 </span>            :         }
<span class="lineNum">   15171 </span><span class="lineNoCov">          0 :         else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)</span>
<span class="lineNum">   15172 </span>            :         {
<span class="lineNum">   15173 </span><span class="lineNoCov">          0 :             return static_cast&lt;number_float_t&gt;(lhs.m_value.number_unsigned) &lt; rhs.m_value.number_float;</span>
<span class="lineNum">   15174 </span>            :         }
<span class="lineNum">   15175 </span><span class="lineNoCov">          0 :         else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)</span>
<span class="lineNum">   15176 </span>            :         {
<span class="lineNum">   15177 </span><span class="lineNoCov">          0 :             return lhs.m_value.number_float &lt; static_cast&lt;number_float_t&gt;(rhs.m_value.number_unsigned);</span>
<span class="lineNum">   15178 </span>            :         }
<span class="lineNum">   15179 </span><span class="lineNoCov">          0 :         else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)</span>
<span class="lineNum">   15180 </span>            :         {
<span class="lineNum">   15181 </span><span class="lineNoCov">          0 :             return lhs.m_value.number_integer &lt; static_cast&lt;number_integer_t&gt;(rhs.m_value.number_unsigned);</span>
<span class="lineNum">   15182 </span>            :         }
<span class="lineNum">   15183 </span><span class="lineNoCov">          0 :         else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)</span>
<span class="lineNum">   15184 </span>            :         {
<span class="lineNum">   15185 </span><span class="lineNoCov">          0 :             return static_cast&lt;number_integer_t&gt;(lhs.m_value.number_unsigned) &lt; rhs.m_value.number_integer;</span>
<span class="lineNum">   15186 </span>            :         }
<span class="lineNum">   15187 </span>            : 
<span class="lineNum">   15188 </span>            :         // We only reach this line if we cannot compare values. In that case,
<span class="lineNum">   15189 </span>            :         // we compare types. Note we have to call the operator explicitly,
<span class="lineNum">   15190 </span>            :         // because MSVC has problems otherwise.
<span class="lineNum">   15191 </span><span class="lineNoCov">          0 :         return operator&lt;(lhs_type, rhs_type);</span>
<span class="lineNum">   15192 </span>            :     }
<span class="lineNum">   15193 </span>            : 
<span class="lineNum">   15194 </span>            :     /*!
<span class="lineNum">   15195 </span>            :     @brief comparison: less than
<span class="lineNum">   15196 </span>            :     @copydoc operator&lt;(const_reference, const_reference)
<span class="lineNum">   15197 </span>            :     */
<span class="lineNum">   15198 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15199 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15200 </span>            :     friend bool operator&lt;(const_reference lhs, const ScalarType rhs) noexcept
<span class="lineNum">   15201 </span>            :     {
<span class="lineNum">   15202 </span>            :         return (lhs &lt; basic_json(rhs));
<span class="lineNum">   15203 </span>            :     }
<span class="lineNum">   15204 </span>            : 
<span class="lineNum">   15205 </span>            :     /*!
<span class="lineNum">   15206 </span>            :     @brief comparison: less than
<span class="lineNum">   15207 </span>            :     @copydoc operator&lt;(const_reference, const_reference)
<span class="lineNum">   15208 </span>            :     */
<span class="lineNum">   15209 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15210 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15211 </span>            :     friend bool operator&lt;(const ScalarType lhs, const_reference rhs) noexcept
<span class="lineNum">   15212 </span>            :     {
<span class="lineNum">   15213 </span>            :         return (basic_json(lhs) &lt; rhs);
<span class="lineNum">   15214 </span>            :     }
<span class="lineNum">   15215 </span>            : 
<span class="lineNum">   15216 </span>            :     /*!
<span class="lineNum">   15217 </span>            :     @brief comparison: less than or equal
<span class="lineNum">   15218 </span>            : 
<span class="lineNum">   15219 </span>            :     Compares whether one JSON value @a lhs is less than or equal to another
<span class="lineNum">   15220 </span>            :     JSON value by calculating `not (rhs &lt; lhs)`.
<span class="lineNum">   15221 </span>            : 
<span class="lineNum">   15222 </span>            :     @param[in] lhs  first JSON value to consider
<span class="lineNum">   15223 </span>            :     @param[in] rhs  second JSON value to consider
<span class="lineNum">   15224 </span>            :     @return whether @a lhs is less than or equal to @a rhs
<span class="lineNum">   15225 </span>            : 
<span class="lineNum">   15226 </span>            :     @complexity Linear.
<span class="lineNum">   15227 </span>            : 
<span class="lineNum">   15228 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   15229 </span>            : 
<span class="lineNum">   15230 </span>            :     @liveexample{The example demonstrates comparing several JSON
<span class="lineNum">   15231 </span>            :     types.,operator__greater}
<span class="lineNum">   15232 </span>            : 
<span class="lineNum">   15233 </span>            :     @since version 1.0.0
<span class="lineNum">   15234 </span>            :     */
<span class="lineNum">   15235 </span>            :     friend bool operator&lt;=(const_reference lhs, const_reference rhs) noexcept
<span class="lineNum">   15236 </span>            :     {
<span class="lineNum">   15237 </span>            :         return not (rhs &lt; lhs);
<span class="lineNum">   15238 </span>            :     }
<span class="lineNum">   15239 </span>            : 
<span class="lineNum">   15240 </span>            :     /*!
<span class="lineNum">   15241 </span>            :     @brief comparison: less than or equal
<span class="lineNum">   15242 </span>            :     @copydoc operator&lt;=(const_reference, const_reference)
<span class="lineNum">   15243 </span>            :     */
<span class="lineNum">   15244 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15245 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15246 </span>            :     friend bool operator&lt;=(const_reference lhs, const ScalarType rhs) noexcept
<span class="lineNum">   15247 </span>            :     {
<span class="lineNum">   15248 </span>            :         return (lhs &lt;= basic_json(rhs));
<span class="lineNum">   15249 </span>            :     }
<span class="lineNum">   15250 </span>            : 
<span class="lineNum">   15251 </span>            :     /*!
<span class="lineNum">   15252 </span>            :     @brief comparison: less than or equal
<span class="lineNum">   15253 </span>            :     @copydoc operator&lt;=(const_reference, const_reference)
<span class="lineNum">   15254 </span>            :     */
<span class="lineNum">   15255 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15256 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15257 </span>            :     friend bool operator&lt;=(const ScalarType lhs, const_reference rhs) noexcept
<span class="lineNum">   15258 </span>            :     {
<span class="lineNum">   15259 </span>            :         return (basic_json(lhs) &lt;= rhs);
<span class="lineNum">   15260 </span>            :     }
<span class="lineNum">   15261 </span>            : 
<span class="lineNum">   15262 </span>            :     /*!
<span class="lineNum">   15263 </span>            :     @brief comparison: greater than
<span class="lineNum">   15264 </span>            : 
<span class="lineNum">   15265 </span>            :     Compares whether one JSON value @a lhs is greater than another
<span class="lineNum">   15266 </span>            :     JSON value by calculating `not (lhs &lt;= rhs)`.
<span class="lineNum">   15267 </span>            : 
<span class="lineNum">   15268 </span>            :     @param[in] lhs  first JSON value to consider
<span class="lineNum">   15269 </span>            :     @param[in] rhs  second JSON value to consider
<span class="lineNum">   15270 </span>            :     @return whether @a lhs is greater than to @a rhs
<span class="lineNum">   15271 </span>            : 
<span class="lineNum">   15272 </span>            :     @complexity Linear.
<span class="lineNum">   15273 </span>            : 
<span class="lineNum">   15274 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   15275 </span>            : 
<span class="lineNum">   15276 </span>            :     @liveexample{The example demonstrates comparing several JSON
<span class="lineNum">   15277 </span>            :     types.,operator__lessequal}
<span class="lineNum">   15278 </span>            : 
<span class="lineNum">   15279 </span>            :     @since version 1.0.0
<span class="lineNum">   15280 </span>            :     */
<span class="lineNum">   15281 </span>            :     friend bool operator&gt;(const_reference lhs, const_reference rhs) noexcept
<span class="lineNum">   15282 </span>            :     {
<span class="lineNum">   15283 </span>            :         return not (lhs &lt;= rhs);
<span class="lineNum">   15284 </span>            :     }
<span class="lineNum">   15285 </span>            : 
<span class="lineNum">   15286 </span>            :     /*!
<span class="lineNum">   15287 </span>            :     @brief comparison: greater than
<span class="lineNum">   15288 </span>            :     @copydoc operator&gt;(const_reference, const_reference)
<span class="lineNum">   15289 </span>            :     */
<span class="lineNum">   15290 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15291 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15292 </span>            :     friend bool operator&gt;(const_reference lhs, const ScalarType rhs) noexcept
<span class="lineNum">   15293 </span>            :     {
<span class="lineNum">   15294 </span>            :         return (lhs &gt; basic_json(rhs));
<span class="lineNum">   15295 </span>            :     }
<span class="lineNum">   15296 </span>            : 
<span class="lineNum">   15297 </span>            :     /*!
<span class="lineNum">   15298 </span>            :     @brief comparison: greater than
<span class="lineNum">   15299 </span>            :     @copydoc operator&gt;(const_reference, const_reference)
<span class="lineNum">   15300 </span>            :     */
<span class="lineNum">   15301 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15302 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15303 </span>            :     friend bool operator&gt;(const ScalarType lhs, const_reference rhs) noexcept
<span class="lineNum">   15304 </span>            :     {
<span class="lineNum">   15305 </span>            :         return (basic_json(lhs) &gt; rhs);
<span class="lineNum">   15306 </span>            :     }
<span class="lineNum">   15307 </span>            : 
<span class="lineNum">   15308 </span>            :     /*!
<span class="lineNum">   15309 </span>            :     @brief comparison: greater than or equal
<span class="lineNum">   15310 </span>            : 
<span class="lineNum">   15311 </span>            :     Compares whether one JSON value @a lhs is greater than or equal to another
<span class="lineNum">   15312 </span>            :     JSON value by calculating `not (lhs &lt; rhs)`.
<span class="lineNum">   15313 </span>            : 
<span class="lineNum">   15314 </span>            :     @param[in] lhs  first JSON value to consider
<span class="lineNum">   15315 </span>            :     @param[in] rhs  second JSON value to consider
<span class="lineNum">   15316 </span>            :     @return whether @a lhs is greater than or equal to @a rhs
<span class="lineNum">   15317 </span>            : 
<span class="lineNum">   15318 </span>            :     @complexity Linear.
<span class="lineNum">   15319 </span>            : 
<span class="lineNum">   15320 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   15321 </span>            : 
<span class="lineNum">   15322 </span>            :     @liveexample{The example demonstrates comparing several JSON
<span class="lineNum">   15323 </span>            :     types.,operator__greaterequal}
<span class="lineNum">   15324 </span>            : 
<span class="lineNum">   15325 </span>            :     @since version 1.0.0
<span class="lineNum">   15326 </span>            :     */
<span class="lineNum">   15327 </span>            :     friend bool operator&gt;=(const_reference lhs, const_reference rhs) noexcept
<span class="lineNum">   15328 </span>            :     {
<span class="lineNum">   15329 </span>            :         return not (lhs &lt; rhs);
<span class="lineNum">   15330 </span>            :     }
<span class="lineNum">   15331 </span>            : 
<span class="lineNum">   15332 </span>            :     /*!
<span class="lineNum">   15333 </span>            :     @brief comparison: greater than or equal
<span class="lineNum">   15334 </span>            :     @copydoc operator&gt;=(const_reference, const_reference)
<span class="lineNum">   15335 </span>            :     */
<span class="lineNum">   15336 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15337 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15338 </span>            :     friend bool operator&gt;=(const_reference lhs, const ScalarType rhs) noexcept
<span class="lineNum">   15339 </span>            :     {
<span class="lineNum">   15340 </span>            :         return (lhs &gt;= basic_json(rhs));
<span class="lineNum">   15341 </span>            :     }
<span class="lineNum">   15342 </span>            : 
<span class="lineNum">   15343 </span>            :     /*!
<span class="lineNum">   15344 </span>            :     @brief comparison: greater than or equal
<span class="lineNum">   15345 </span>            :     @copydoc operator&gt;=(const_reference, const_reference)
<span class="lineNum">   15346 </span>            :     */
<span class="lineNum">   15347 </span>            :     template&lt;typename ScalarType, typename std::enable_if&lt;
<span class="lineNum">   15348 </span>            :                  std::is_scalar&lt;ScalarType&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15349 </span>            :     friend bool operator&gt;=(const ScalarType lhs, const_reference rhs) noexcept
<span class="lineNum">   15350 </span>            :     {
<span class="lineNum">   15351 </span>            :         return (basic_json(lhs) &gt;= rhs);
<span class="lineNum">   15352 </span>            :     }
<span class="lineNum">   15353 </span>            : 
<span class="lineNum">   15354 </span>            :     /// @}
<span class="lineNum">   15355 </span>            : 
<span class="lineNum">   15356 </span>            :     ///////////////////
<span class="lineNum">   15357 </span>            :     // serialization //
<span class="lineNum">   15358 </span>            :     ///////////////////
<span class="lineNum">   15359 </span>            : 
<span class="lineNum">   15360 </span>            :     /// @name serialization
<span class="lineNum">   15361 </span>            :     /// @{
<span class="lineNum">   15362 </span>            : 
<span class="lineNum">   15363 </span>            :     /*!
<span class="lineNum">   15364 </span>            :     @brief serialize to stream
<span class="lineNum">   15365 </span>            : 
<span class="lineNum">   15366 </span>            :     Serialize the given JSON value @a j to the output stream @a o. The JSON
<span class="lineNum">   15367 </span>            :     value will be serialized using the @ref dump member function.
<span class="lineNum">   15368 </span>            : 
<span class="lineNum">   15369 </span>            :     - The indentation of the output can be controlled with the member variable
<span class="lineNum">   15370 </span>            :       `width` of the output stream @a o. For instance, using the manipulator
<span class="lineNum">   15371 </span>            :       `std::setw(4)` on @a o sets the indentation level to `4` and the
<span class="lineNum">   15372 </span>            :       serialization result is the same as calling `dump(4)`.
<span class="lineNum">   15373 </span>            : 
<span class="lineNum">   15374 </span>            :     - The indentation character can be controlled with the member variable
<span class="lineNum">   15375 </span>            :       `fill` of the output stream @a o. For instance, the manipulator
<span class="lineNum">   15376 </span>            :       `std::setfill('\\t')` sets indentation to use a tab character rather than
<span class="lineNum">   15377 </span>            :       the default space character.
<span class="lineNum">   15378 </span>            : 
<span class="lineNum">   15379 </span>            :     @param[in,out] o  stream to serialize to
<span class="lineNum">   15380 </span>            :     @param[in] j  JSON value to serialize
<span class="lineNum">   15381 </span>            : 
<span class="lineNum">   15382 </span>            :     @return the stream @a o
<span class="lineNum">   15383 </span>            : 
<span class="lineNum">   15384 </span>            :     @throw type_error.316 if a string stored inside the JSON value is not
<span class="lineNum">   15385 </span>            :                           UTF-8 encoded
<span class="lineNum">   15386 </span>            : 
<span class="lineNum">   15387 </span>            :     @complexity Linear.
<span class="lineNum">   15388 </span>            : 
<span class="lineNum">   15389 </span>            :     @liveexample{The example below shows the serialization with different
<span class="lineNum">   15390 </span>            :     parameters to `width` to adjust the indentation level.,operator_serialize}
<span class="lineNum">   15391 </span>            : 
<span class="lineNum">   15392 </span>            :     @since version 1.0.0; indentation character added in version 3.0.0
<span class="lineNum">   15393 </span>            :     */
<span class="lineNum">   15394 </span>            :     friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const basic_json&amp; j)
<span class="lineNum">   15395 </span>            :     {
<span class="lineNum">   15396 </span>            :         // read width member and use it as indentation parameter if nonzero
<span class="lineNum">   15397 </span>            :         const bool pretty_print = (o.width() &gt; 0);
<span class="lineNum">   15398 </span>            :         const auto indentation = (pretty_print ? o.width() : 0);
<span class="lineNum">   15399 </span>            : 
<span class="lineNum">   15400 </span>            :         // reset width to 0 for subsequent calls to this stream
<span class="lineNum">   15401 </span>            :         o.width(0);
<span class="lineNum">   15402 </span>            : 
<span class="lineNum">   15403 </span>            :         // do the actual serialization
<span class="lineNum">   15404 </span>            :         serializer s(detail::output_adapter&lt;char&gt;(o), o.fill());
<span class="lineNum">   15405 </span>            :         s.dump(j, pretty_print, false, static_cast&lt;unsigned int&gt;(indentation));
<span class="lineNum">   15406 </span>            :         return o;
<span class="lineNum">   15407 </span>            :     }
<span class="lineNum">   15408 </span>            : 
<span class="lineNum">   15409 </span>            :     /*!
<span class="lineNum">   15410 </span>            :     @brief serialize to stream
<span class="lineNum">   15411 </span>            :     @deprecated This stream operator is deprecated and will be removed in
<span class="lineNum">   15412 </span>            :                 future 4.0.0 of the library. Please use
<span class="lineNum">   15413 </span>            :                 @ref operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)
<span class="lineNum">   15414 </span>            :                 instead; that is, replace calls like `j &gt;&gt; o;` with `o &lt;&lt; j;`.
<span class="lineNum">   15415 </span>            :     @since version 1.0.0; deprecated since version 3.0.0
<span class="lineNum">   15416 </span>            :     */
<span class="lineNum">   15417 </span>            :     JSON_DEPRECATED
<span class="lineNum">   15418 </span>            :     friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp; j, std::ostream&amp; o)
<span class="lineNum">   15419 </span>            :     {
<span class="lineNum">   15420 </span>            :         return o &lt;&lt; j;
<span class="lineNum">   15421 </span>            :     }
<span class="lineNum">   15422 </span>            : 
<span class="lineNum">   15423 </span>            :     /// @}
<span class="lineNum">   15424 </span>            : 
<span class="lineNum">   15425 </span>            : 
<span class="lineNum">   15426 </span>            :     /////////////////////
<span class="lineNum">   15427 </span>            :     // deserialization //
<span class="lineNum">   15428 </span>            :     /////////////////////
<span class="lineNum">   15429 </span>            : 
<span class="lineNum">   15430 </span>            :     /// @name deserialization
<span class="lineNum">   15431 </span>            :     /// @{
<span class="lineNum">   15432 </span>            : 
<span class="lineNum">   15433 </span>            :     /*!
<span class="lineNum">   15434 </span>            :     @brief deserialize from a compatible input
<span class="lineNum">   15435 </span>            : 
<span class="lineNum">   15436 </span>            :     This function reads from a compatible input. Examples are:
<span class="lineNum">   15437 </span>            :     - an array of 1-byte values
<span class="lineNum">   15438 </span>            :     - strings with character/literal type with size of 1 byte
<span class="lineNum">   15439 </span>            :     - input streams
<span class="lineNum">   15440 </span>            :     - container with contiguous storage of 1-byte values. Compatible container
<span class="lineNum">   15441 </span>            :       types include `std::vector`, `std::string`, `std::array`,
<span class="lineNum">   15442 </span>            :       `std::valarray`, and `std::initializer_list`. Furthermore, C-style
<span class="lineNum">   15443 </span>            :       arrays can be used with `std::begin()`/`std::end()`. User-defined
<span class="lineNum">   15444 </span>            :       containers can be used as long as they implement random-access iterators
<span class="lineNum">   15445 </span>            :       and a contiguous storage.
<span class="lineNum">   15446 </span>            : 
<span class="lineNum">   15447 </span>            :     @pre Each element of the container has a size of 1 byte. Violating this
<span class="lineNum">   15448 </span>            :     precondition yields undefined behavior. **This precondition is enforced
<span class="lineNum">   15449 </span>            :     with a static assertion.**
<span class="lineNum">   15450 </span>            : 
<span class="lineNum">   15451 </span>            :     @pre The container storage is contiguous. Violating this precondition
<span class="lineNum">   15452 </span>            :     yields undefined behavior. **This precondition is enforced with an
<span class="lineNum">   15453 </span>            :     assertion.**
<span class="lineNum">   15454 </span>            :     @pre Each element of the container has a size of 1 byte. Violating this
<span class="lineNum">   15455 </span>            :     precondition yields undefined behavior. **This precondition is enforced
<span class="lineNum">   15456 </span>            :     with a static assertion.**
<span class="lineNum">   15457 </span>            : 
<span class="lineNum">   15458 </span>            :     @warning There is no way to enforce all preconditions at compile-time. If
<span class="lineNum">   15459 </span>            :              the function is called with a noncompliant container and with
<span class="lineNum">   15460 </span>            :              assertions switched off, the behavior is undefined and will most
<span class="lineNum">   15461 </span>            :              likely yield segmentation violation.
<span class="lineNum">   15462 </span>            : 
<span class="lineNum">   15463 </span>            :     @param[in] i  input to read from
<span class="lineNum">   15464 </span>            :     @param[in] cb  a parser callback function of type @ref parser_callback_t
<span class="lineNum">   15465 </span>            :     which is used to control the deserialization by filtering unwanted values
<span class="lineNum">   15466 </span>            :     (optional)
<span class="lineNum">   15467 </span>            : 
<span class="lineNum">   15468 </span>            :     @return result of the deserialization
<span class="lineNum">   15469 </span>            : 
<span class="lineNum">   15470 </span>            :     @throw parse_error.101 if a parse error occurs; example: `&quot;&quot;unexpected end
<span class="lineNum">   15471 </span>            :     of input; expected string literal&quot;&quot;`
<span class="lineNum">   15472 </span>            :     @throw parse_error.102 if to_unicode fails or surrogate error
<span class="lineNum">   15473 </span>            :     @throw parse_error.103 if to_unicode fails
<span class="lineNum">   15474 </span>            : 
<span class="lineNum">   15475 </span>            :     @complexity Linear in the length of the input. The parser is a predictive
<span class="lineNum">   15476 </span>            :     LL(1) parser. The complexity can be higher if the parser callback function
<span class="lineNum">   15477 </span>            :     @a cb has a super-linear complexity.
<span class="lineNum">   15478 </span>            : 
<span class="lineNum">   15479 </span>            :     @note A UTF-8 byte order mark is silently ignored.
<span class="lineNum">   15480 </span>            : 
<span class="lineNum">   15481 </span>            :     @liveexample{The example below demonstrates the `parse()` function reading
<span class="lineNum">   15482 </span>            :     from an array.,parse__array__parser_callback_t}
<span class="lineNum">   15483 </span>            : 
<span class="lineNum">   15484 </span>            :     @liveexample{The example below demonstrates the `parse()` function with
<span class="lineNum">   15485 </span>            :     and without callback function.,parse__string__parser_callback_t}
<span class="lineNum">   15486 </span>            : 
<span class="lineNum">   15487 </span>            :     @liveexample{The example below demonstrates the `parse()` function with
<span class="lineNum">   15488 </span>            :     and without callback function.,parse__istream__parser_callback_t}
<span class="lineNum">   15489 </span>            : 
<span class="lineNum">   15490 </span>            :     @liveexample{The example below demonstrates the `parse()` function reading
<span class="lineNum">   15491 </span>            :     from a contiguous container.,parse__contiguouscontainer__parser_callback_t}
<span class="lineNum">   15492 </span>            : 
<a name="15493"><span class="lineNum">   15493 </span>            :     @since version 2.0.3 (contiguous containers)</a>
<span class="lineNum">   15494 </span>            :     */
<span class="lineNum">   15495 </span><span class="lineCov">        145 :     static basic_json parse(detail::input_adapter i,</span>
<span class="lineNum">   15496 </span>            :                             const parser_callback_t cb = nullptr,
<span class="lineNum">   15497 </span>            :                             const bool allow_exceptions = true)
<span class="lineNum">   15498 </span>            :     {
<span class="lineNum">   15499 </span><span class="lineCov">        145 :         basic_json result;</span>
<span class="lineNum">   15500 </span><span class="lineCov">        147 :         parser(i, cb, allow_exceptions).parse(true, result);</span>
<span class="lineNum">   15501 </span><span class="lineCov">        143 :         return result;</span>
<span class="lineNum">   15502 </span>            :     }
<span class="lineNum">   15503 </span>            : 
<span class="lineNum">   15504 </span>            :     /*!
<span class="lineNum">   15505 </span>            :     @copydoc basic_json parse(detail::input_adapter, const parser_callback_t)
<span class="lineNum">   15506 </span>            :     */
<span class="lineNum">   15507 </span>            :     static basic_json parse(detail::input_adapter&amp; i,
<span class="lineNum">   15508 </span>            :                             const parser_callback_t cb = nullptr,
<span class="lineNum">   15509 </span>            :                             const bool allow_exceptions = true)
<span class="lineNum">   15510 </span>            :     {
<span class="lineNum">   15511 </span>            :         basic_json result;
<span class="lineNum">   15512 </span>            :         parser(i, cb, allow_exceptions).parse(true, result);
<span class="lineNum">   15513 </span>            :         return result;
<span class="lineNum">   15514 </span>            :     }
<span class="lineNum">   15515 </span>            : 
<span class="lineNum">   15516 </span>            :     static bool accept(detail::input_adapter i)
<span class="lineNum">   15517 </span>            :     {
<span class="lineNum">   15518 </span>            :         return parser(i).accept(true);
<span class="lineNum">   15519 </span>            :     }
<span class="lineNum">   15520 </span>            : 
<span class="lineNum">   15521 </span>            :     static bool accept(detail::input_adapter&amp; i)
<span class="lineNum">   15522 </span>            :     {
<span class="lineNum">   15523 </span>            :         return parser(i).accept(true);
<span class="lineNum">   15524 </span>            :     }
<span class="lineNum">   15525 </span>            : 
<span class="lineNum">   15526 </span>            :     /*!
<span class="lineNum">   15527 </span>            :     @brief deserialize from an iterator range with contiguous storage
<span class="lineNum">   15528 </span>            : 
<span class="lineNum">   15529 </span>            :     This function reads from an iterator range of a container with contiguous
<span class="lineNum">   15530 </span>            :     storage of 1-byte values. Compatible container types include
<span class="lineNum">   15531 </span>            :     `std::vector`, `std::string`, `std::array`, `std::valarray`, and
<span class="lineNum">   15532 </span>            :     `std::initializer_list`. Furthermore, C-style arrays can be used with
<span class="lineNum">   15533 </span>            :     `std::begin()`/`std::end()`. User-defined containers can be used as long
<span class="lineNum">   15534 </span>            :     as they implement random-access iterators and a contiguous storage.
<span class="lineNum">   15535 </span>            : 
<span class="lineNum">   15536 </span>            :     @pre The iterator range is contiguous. Violating this precondition yields
<span class="lineNum">   15537 </span>            :     undefined behavior. **This precondition is enforced with an assertion.**
<span class="lineNum">   15538 </span>            :     @pre Each element in the range has a size of 1 byte. Violating this
<span class="lineNum">   15539 </span>            :     precondition yields undefined behavior. **This precondition is enforced
<span class="lineNum">   15540 </span>            :     with a static assertion.**
<span class="lineNum">   15541 </span>            : 
<span class="lineNum">   15542 </span>            :     @warning There is no way to enforce all preconditions at compile-time. If
<span class="lineNum">   15543 </span>            :              the function is called with noncompliant iterators and with
<span class="lineNum">   15544 </span>            :              assertions switched off, the behavior is undefined and will most
<span class="lineNum">   15545 </span>            :              likely yield segmentation violation.
<span class="lineNum">   15546 </span>            : 
<span class="lineNum">   15547 </span>            :     @tparam IteratorType iterator of container with contiguous storage
<span class="lineNum">   15548 </span>            :     @param[in] first  begin of the range to parse (included)
<span class="lineNum">   15549 </span>            :     @param[in] last  end of the range to parse (excluded)
<span class="lineNum">   15550 </span>            :     @param[in] cb  a parser callback function of type @ref parser_callback_t
<span class="lineNum">   15551 </span>            :     which is used to control the deserialization by filtering unwanted values
<span class="lineNum">   15552 </span>            :     (optional)
<span class="lineNum">   15553 </span>            :     @param[in] allow_exceptions  whether to throw exceptions in case of a
<span class="lineNum">   15554 </span>            :     parse error (optional, true by default)
<span class="lineNum">   15555 </span>            : 
<span class="lineNum">   15556 </span>            :     @return result of the deserialization
<span class="lineNum">   15557 </span>            : 
<span class="lineNum">   15558 </span>            :     @throw parse_error.101 in case of an unexpected token
<span class="lineNum">   15559 </span>            :     @throw parse_error.102 if to_unicode fails or surrogate error
<span class="lineNum">   15560 </span>            :     @throw parse_error.103 if to_unicode fails
<span class="lineNum">   15561 </span>            : 
<span class="lineNum">   15562 </span>            :     @complexity Linear in the length of the input. The parser is a predictive
<span class="lineNum">   15563 </span>            :     LL(1) parser. The complexity can be higher if the parser callback function
<span class="lineNum">   15564 </span>            :     @a cb has a super-linear complexity.
<span class="lineNum">   15565 </span>            : 
<span class="lineNum">   15566 </span>            :     @note A UTF-8 byte order mark is silently ignored.
<span class="lineNum">   15567 </span>            : 
<span class="lineNum">   15568 </span>            :     @liveexample{The example below demonstrates the `parse()` function reading
<span class="lineNum">   15569 </span>            :     from an iterator range.,parse__iteratortype__parser_callback_t}
<span class="lineNum">   15570 </span>            : 
<span class="lineNum">   15571 </span>            :     @since version 2.0.3
<span class="lineNum">   15572 </span>            :     */
<span class="lineNum">   15573 </span>            :     template&lt;class IteratorType, typename std::enable_if&lt;
<span class="lineNum">   15574 </span>            :                  std::is_base_of&lt;
<span class="lineNum">   15575 </span>            :                      std::random_access_iterator_tag,
<span class="lineNum">   15576 </span>            :                      typename std::iterator_traits&lt;IteratorType&gt;::iterator_category&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15577 </span>            :     static basic_json parse(IteratorType first, IteratorType last,
<span class="lineNum">   15578 </span>            :                             const parser_callback_t cb = nullptr,
<span class="lineNum">   15579 </span>            :                             const bool allow_exceptions = true)
<span class="lineNum">   15580 </span>            :     {
<span class="lineNum">   15581 </span>            :         basic_json result;
<span class="lineNum">   15582 </span>            :         parser(detail::input_adapter(first, last), cb, allow_exceptions).parse(true, result);
<span class="lineNum">   15583 </span>            :         return result;
<span class="lineNum">   15584 </span>            :     }
<span class="lineNum">   15585 </span>            : 
<span class="lineNum">   15586 </span>            :     template&lt;class IteratorType, typename std::enable_if&lt;
<span class="lineNum">   15587 </span>            :                  std::is_base_of&lt;
<span class="lineNum">   15588 </span>            :                      std::random_access_iterator_tag,
<span class="lineNum">   15589 </span>            :                      typename std::iterator_traits&lt;IteratorType&gt;::iterator_category&gt;::value, int&gt;::type = 0&gt;
<span class="lineNum">   15590 </span>            :     static bool accept(IteratorType first, IteratorType last)
<span class="lineNum">   15591 </span>            :     {
<span class="lineNum">   15592 </span>            :         return parser(detail::input_adapter(first, last)).accept(true);
<span class="lineNum">   15593 </span>            :     }
<span class="lineNum">   15594 </span>            : 
<span class="lineNum">   15595 </span>            :     /*!
<span class="lineNum">   15596 </span>            :     @brief deserialize from stream
<span class="lineNum">   15597 </span>            :     @deprecated This stream operator is deprecated and will be removed in
<span class="lineNum">   15598 </span>            :                 version 4.0.0 of the library. Please use
<span class="lineNum">   15599 </span>            :                 @ref operator&gt;&gt;(std::istream&amp;, basic_json&amp;)
<span class="lineNum">   15600 </span>            :                 instead; that is, replace calls like `j &lt;&lt; i;` with `i &gt;&gt; j;`.
<span class="lineNum">   15601 </span>            :     @since version 1.0.0; deprecated since version 3.0.0
<span class="lineNum">   15602 </span>            :     */
<span class="lineNum">   15603 </span>            :     JSON_DEPRECATED
<span class="lineNum">   15604 </span>            :     friend std::istream&amp; operator&lt;&lt;(basic_json&amp; j, std::istream&amp; i)
<span class="lineNum">   15605 </span>            :     {
<span class="lineNum">   15606 </span>            :         return operator&gt;&gt;(i, j);
<span class="lineNum">   15607 </span>            :     }
<span class="lineNum">   15608 </span>            : 
<span class="lineNum">   15609 </span>            :     /*!
<span class="lineNum">   15610 </span>            :     @brief deserialize from stream
<span class="lineNum">   15611 </span>            : 
<span class="lineNum">   15612 </span>            :     Deserializes an input stream to a JSON value.
<span class="lineNum">   15613 </span>            : 
<span class="lineNum">   15614 </span>            :     @param[in,out] i  input stream to read a serialized JSON value from
<span class="lineNum">   15615 </span>            :     @param[in,out] j  JSON value to write the deserialized input to
<span class="lineNum">   15616 </span>            : 
<span class="lineNum">   15617 </span>            :     @throw parse_error.101 in case of an unexpected token
<span class="lineNum">   15618 </span>            :     @throw parse_error.102 if to_unicode fails or surrogate error
<span class="lineNum">   15619 </span>            :     @throw parse_error.103 if to_unicode fails
<span class="lineNum">   15620 </span>            : 
<span class="lineNum">   15621 </span>            :     @complexity Linear in the length of the input. The parser is a predictive
<span class="lineNum">   15622 </span>            :     LL(1) parser.
<span class="lineNum">   15623 </span>            : 
<span class="lineNum">   15624 </span>            :     @note A UTF-8 byte order mark is silently ignored.
<span class="lineNum">   15625 </span>            : 
<span class="lineNum">   15626 </span>            :     @liveexample{The example below shows how a JSON value is constructed by
<span class="lineNum">   15627 </span>            :     reading a serialization from a stream.,operator_deserialize}
<span class="lineNum">   15628 </span>            : 
<span class="lineNum">   15629 </span>            :     @sa parse(std::istream&amp;, const parser_callback_t) for a variant with a
<span class="lineNum">   15630 </span>            :     parser callback function to filter values while parsing
<span class="lineNum">   15631 </span>            : 
<span class="lineNum">   15632 </span>            :     @since version 1.0.0
<span class="lineNum">   15633 </span>            :     */
<span class="lineNum">   15634 </span>            :     friend std::istream&amp; operator&gt;&gt;(std::istream&amp; i, basic_json&amp; j)
<span class="lineNum">   15635 </span>            :     {
<span class="lineNum">   15636 </span>            :         parser(detail::input_adapter(i)).parse(false, j);
<span class="lineNum">   15637 </span>            :         return i;
<span class="lineNum">   15638 </span>            :     }
<span class="lineNum">   15639 </span>            : 
<span class="lineNum">   15640 </span>            :     /// @}
<span class="lineNum">   15641 </span>            : 
<span class="lineNum">   15642 </span>            :     ///////////////////////////
<span class="lineNum">   15643 </span>            :     // convenience functions //
<span class="lineNum">   15644 </span>            :     ///////////////////////////
<span class="lineNum">   15645 </span>            : 
<span class="lineNum">   15646 </span>            :     /*!
<span class="lineNum">   15647 </span>            :     @brief return the type as string
<span class="lineNum">   15648 </span>            : 
<span class="lineNum">   15649 </span>            :     Returns the type name as string to be used in error messages - usually to
<span class="lineNum">   15650 </span>            :     indicate that a function was called on a wrong JSON type.
<span class="lineNum">   15651 </span>            : 
<span class="lineNum">   15652 </span>            :     @return a string representation of a the @a m_type member:
<span class="lineNum">   15653 </span>            :             Value type  | return value
<span class="lineNum">   15654 </span>            :             ----------- | -------------
<span class="lineNum">   15655 </span>            :             null        | `&quot;null&quot;`
<span class="lineNum">   15656 </span>            :             boolean     | `&quot;boolean&quot;`
<span class="lineNum">   15657 </span>            :             string      | `&quot;string&quot;`
<span class="lineNum">   15658 </span>            :             number      | `&quot;number&quot;` (for all number types)
<span class="lineNum">   15659 </span>            :             object      | `&quot;object&quot;`
<span class="lineNum">   15660 </span>            :             array       | `&quot;array&quot;`
<span class="lineNum">   15661 </span>            :             discarded   | `&quot;discarded&quot;`
<span class="lineNum">   15662 </span>            : 
<span class="lineNum">   15663 </span>            :     @exceptionsafety No-throw guarantee: this function never throws exceptions.
<span class="lineNum">   15664 </span>            : 
<span class="lineNum">   15665 </span>            :     @complexity Constant.
<span class="lineNum">   15666 </span>            : 
<span class="lineNum">   15667 </span>            :     @liveexample{The following code exemplifies `type_name()` for all JSON
<span class="lineNum">   15668 </span>            :     types.,type_name}
<span class="lineNum">   15669 </span>            : 
<span class="lineNum">   15670 </span>            :     @sa @ref type() -- return the type of the JSON value
<span class="lineNum">   15671 </span>            :     @sa @ref operator value_t() -- return the type of the JSON value (implicit)
<span class="lineNum">   15672 </span>            : 
<span class="lineNum">   15673 </span>            :     @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
<a name="15674"><span class="lineNum">   15674 </span>            :     since 3.0.0</a>
<span class="lineNum">   15675 </span>            :     */
<span class="lineNum">   15676 </span><span class="lineNoCov">          0 :     const char* type_name() const noexcept</span>
<span class="lineNum">   15677 </span>            :     {
<span class="lineNum">   15678 </span>            :         {
<span class="lineNum">   15679 </span><span class="lineNoCov">          0 :             switch (m_type)</span>
<span class="lineNum">   15680 </span>            :             {
<span class="lineNum">   15681 </span>            :                 case value_t::null:
<span class="lineNum">   15682 </span><span class="lineNoCov">          0 :                     return &quot;null&quot;;</span>
<span class="lineNum">   15683 </span>            :                 case value_t::object:
<span class="lineNum">   15684 </span><span class="lineNoCov">          0 :                     return &quot;object&quot;;</span>
<span class="lineNum">   15685 </span>            :                 case value_t::array:
<span class="lineNum">   15686 </span><span class="lineNoCov">          0 :                     return &quot;array&quot;;</span>
<span class="lineNum">   15687 </span>            :                 case value_t::string:
<span class="lineNum">   15688 </span><span class="lineNoCov">          0 :                     return &quot;string&quot;;</span>
<span class="lineNum">   15689 </span>            :                 case value_t::boolean:
<span class="lineNum">   15690 </span><span class="lineNoCov">          0 :                     return &quot;boolean&quot;;</span>
<span class="lineNum">   15691 </span>            :                 case value_t::discarded:
<span class="lineNum">   15692 </span><span class="lineNoCov">          0 :                     return &quot;discarded&quot;;</span>
<span class="lineNum">   15693 </span>            :                 default:
<span class="lineNum">   15694 </span><span class="lineNoCov">          0 :                     return &quot;number&quot;;</span>
<span class="lineNum">   15695 </span>            :             }
<span class="lineNum">   15696 </span>            :         }
<span class="lineNum">   15697 </span>            :     }
<span class="lineNum">   15698 </span>            : 
<span class="lineNum">   15699 </span>            : 
<span class="lineNum">   15700 </span>            :   private:
<span class="lineNum">   15701 </span>            :     //////////////////////
<span class="lineNum">   15702 </span>            :     // member variables //
<span class="lineNum">   15703 </span>            :     //////////////////////
<span class="lineNum">   15704 </span>            : 
<span class="lineNum">   15705 </span>            :     /// the type of the current element
<span class="lineNum">   15706 </span>            :     value_t m_type = value_t::null;
<span class="lineNum">   15707 </span>            : 
<span class="lineNum">   15708 </span>            :     /// the value of the current element
<span class="lineNum">   15709 </span>            :     json_value m_value = {};
<span class="lineNum">   15710 </span>            : 
<span class="lineNum">   15711 </span>            :     //////////////////////////////////////////
<span class="lineNum">   15712 </span>            :     // binary serialization/deserialization //
<span class="lineNum">   15713 </span>            :     //////////////////////////////////////////
<span class="lineNum">   15714 </span>            : 
<span class="lineNum">   15715 </span>            :     /// @name binary serialization/deserialization support
<span class="lineNum">   15716 </span>            :     /// @{
<span class="lineNum">   15717 </span>            : 
<span class="lineNum">   15718 </span>            :   public:
<span class="lineNum">   15719 </span>            :     /*!
<span class="lineNum">   15720 </span>            :     @brief create a CBOR serialization of a given JSON value
<span class="lineNum">   15721 </span>            : 
<span class="lineNum">   15722 </span>            :     Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
<span class="lineNum">   15723 </span>            :     Binary Object Representation) serialization format. CBOR is a binary
<span class="lineNum">   15724 </span>            :     serialization format which aims to be more compact than JSON itself, yet
<span class="lineNum">   15725 </span>            :     more efficient to parse.
<span class="lineNum">   15726 </span>            : 
<span class="lineNum">   15727 </span>            :     The library uses the following mapping from JSON values types to
<span class="lineNum">   15728 </span>            :     CBOR types according to the CBOR specification (RFC 7049):
<span class="lineNum">   15729 </span>            : 
<span class="lineNum">   15730 </span>            :     JSON value type | value/range                                | CBOR type                          | first byte
<span class="lineNum">   15731 </span>            :     --------------- | ------------------------------------------ | ---------------------------------- | ---------------
<span class="lineNum">   15732 </span>            :     null            | `null`                                     | Null                               | 0xF6
<span class="lineNum">   15733 </span>            :     boolean         | `true`                                     | True                               | 0xF5
<span class="lineNum">   15734 </span>            :     boolean         | `false`                                    | False                              | 0xF4
<span class="lineNum">   15735 </span>            :     number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
<span class="lineNum">   15736 </span>            :     number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
<span class="lineNum">   15737 </span>            :     number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
<span class="lineNum">   15738 </span>            :     number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
<span class="lineNum">   15739 </span>            :     number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
<span class="lineNum">   15740 </span>            :     number_integer  | 0..23                                      | Integer                            | 0x00..0x17
<span class="lineNum">   15741 </span>            :     number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
<span class="lineNum">   15742 </span>            :     number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
<span class="lineNum">   15743 </span>            :     number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
<span class="lineNum">   15744 </span>            :     number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
<span class="lineNum">   15745 </span>            :     number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
<span class="lineNum">   15746 </span>            :     number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
<span class="lineNum">   15747 </span>            :     number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
<span class="lineNum">   15748 </span>            :     number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
<span class="lineNum">   15749 </span>            :     number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
<span class="lineNum">   15750 </span>            :     number_float    | *any value*                                | Double-Precision Float             | 0xFB
<span class="lineNum">   15751 </span>            :     string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
<span class="lineNum">   15752 </span>            :     string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
<span class="lineNum">   15753 </span>            :     string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
<span class="lineNum">   15754 </span>            :     string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
<span class="lineNum">   15755 </span>            :     string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
<span class="lineNum">   15756 </span>            :     array           | *size*: 0..23                              | array                              | 0x80..0x97
<span class="lineNum">   15757 </span>            :     array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
<span class="lineNum">   15758 </span>            :     array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
<span class="lineNum">   15759 </span>            :     array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
<span class="lineNum">   15760 </span>            :     array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
<span class="lineNum">   15761 </span>            :     object          | *size*: 0..23                              | map                                | 0xA0..0xB7
<span class="lineNum">   15762 </span>            :     object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
<span class="lineNum">   15763 </span>            :     object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
<span class="lineNum">   15764 </span>            :     object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
<span class="lineNum">   15765 </span>            :     object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB
<span class="lineNum">   15766 </span>            : 
<span class="lineNum">   15767 </span>            :     @note The mapping is **complete** in the sense that any JSON value type
<span class="lineNum">   15768 </span>            :           can be converted to a CBOR value.
<span class="lineNum">   15769 </span>            : 
<span class="lineNum">   15770 </span>            :     @note If NaN or Infinity are stored inside a JSON number, they are
<span class="lineNum">   15771 </span>            :           serialized properly. This behavior differs from the @ref dump()
<span class="lineNum">   15772 </span>            :           function which serializes NaN or Infinity to `null`.
<span class="lineNum">   15773 </span>            : 
<span class="lineNum">   15774 </span>            :     @note The following CBOR types are not used in the conversion:
<span class="lineNum">   15775 </span>            :           - byte strings (0x40..0x5F)
<span class="lineNum">   15776 </span>            :           - UTF-8 strings terminated by &quot;break&quot; (0x7F)
<span class="lineNum">   15777 </span>            :           - arrays terminated by &quot;break&quot; (0x9F)
<span class="lineNum">   15778 </span>            :           - maps terminated by &quot;break&quot; (0xBF)
<span class="lineNum">   15779 </span>            :           - date/time (0xC0..0xC1)
<span class="lineNum">   15780 </span>            :           - bignum (0xC2..0xC3)
<span class="lineNum">   15781 </span>            :           - decimal fraction (0xC4)
<span class="lineNum">   15782 </span>            :           - bigfloat (0xC5)
<span class="lineNum">   15783 </span>            :           - tagged items (0xC6..0xD4, 0xD8..0xDB)
<span class="lineNum">   15784 </span>            :           - expected conversions (0xD5..0xD7)
<span class="lineNum">   15785 </span>            :           - simple values (0xE0..0xF3, 0xF8)
<span class="lineNum">   15786 </span>            :           - undefined (0xF7)
<span class="lineNum">   15787 </span>            :           - half and single-precision floats (0xF9-0xFA)
<span class="lineNum">   15788 </span>            :           - break (0xFF)
<span class="lineNum">   15789 </span>            : 
<span class="lineNum">   15790 </span>            :     @param[in] j  JSON value to serialize
<span class="lineNum">   15791 </span>            :     @return MessagePack serialization as byte vector
<span class="lineNum">   15792 </span>            : 
<span class="lineNum">   15793 </span>            :     @complexity Linear in the size of the JSON value @a j.
<span class="lineNum">   15794 </span>            : 
<span class="lineNum">   15795 </span>            :     @liveexample{The example shows the serialization of a JSON value to a byte
<span class="lineNum">   15796 </span>            :     vector in CBOR format.,to_cbor}
<span class="lineNum">   15797 </span>            : 
<span class="lineNum">   15798 </span>            :     @sa http://cbor.io
<span class="lineNum">   15799 </span>            :     @sa @ref from_cbor(detail::input_adapter, const bool strict) for the
<span class="lineNum">   15800 </span>            :         analogous deserialization
<span class="lineNum">   15801 </span>            :     @sa @ref to_msgpack(const basic_json&amp;) for the related MessagePack format
<span class="lineNum">   15802 </span>            :     @sa @ref to_ubjson(const basic_json&amp;, const bool, const bool) for the
<span class="lineNum">   15803 </span>            :              related UBJSON format
<span class="lineNum">   15804 </span>            : 
<span class="lineNum">   15805 </span>            :     @since version 2.0.9
<span class="lineNum">   15806 </span>            :     */
<span class="lineNum">   15807 </span>            :     static std::vector&lt;uint8_t&gt; to_cbor(const basic_json&amp; j)
<span class="lineNum">   15808 </span>            :     {
<span class="lineNum">   15809 </span>            :         std::vector&lt;uint8_t&gt; result;
<span class="lineNum">   15810 </span>            :         to_cbor(j, result);
<span class="lineNum">   15811 </span>            :         return result;
<span class="lineNum">   15812 </span>            :     }
<span class="lineNum">   15813 </span>            : 
<span class="lineNum">   15814 </span>            :     static void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;uint8_t&gt; o)
<span class="lineNum">   15815 </span>            :     {
<span class="lineNum">   15816 </span>            :         binary_writer&lt;uint8_t&gt;(o).write_cbor(j);
<span class="lineNum">   15817 </span>            :     }
<span class="lineNum">   15818 </span>            : 
<span class="lineNum">   15819 </span>            :     static void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
<span class="lineNum">   15820 </span>            :     {
<span class="lineNum">   15821 </span>            :         binary_writer&lt;char&gt;(o).write_cbor(j);
<span class="lineNum">   15822 </span>            :     }
<span class="lineNum">   15823 </span>            : 
<span class="lineNum">   15824 </span>            :     /*!
<span class="lineNum">   15825 </span>            :     @brief create a MessagePack serialization of a given JSON value
<span class="lineNum">   15826 </span>            : 
<span class="lineNum">   15827 </span>            :     Serializes a given JSON value @a j to a byte vector using the MessagePack
<span class="lineNum">   15828 </span>            :     serialization format. MessagePack is a binary serialization format which
<span class="lineNum">   15829 </span>            :     aims to be more compact than JSON itself, yet more efficient to parse.
<span class="lineNum">   15830 </span>            : 
<span class="lineNum">   15831 </span>            :     The library uses the following mapping from JSON values types to
<span class="lineNum">   15832 </span>            :     MessagePack types according to the MessagePack specification:
<span class="lineNum">   15833 </span>            : 
<span class="lineNum">   15834 </span>            :     JSON value type | value/range                       | MessagePack type | first byte
<span class="lineNum">   15835 </span>            :     --------------- | --------------------------------- | ---------------- | ----------
<span class="lineNum">   15836 </span>            :     null            | `null`                            | nil              | 0xC0
<span class="lineNum">   15837 </span>            :     boolean         | `true`                            | true             | 0xC3
<span class="lineNum">   15838 </span>            :     boolean         | `false`                           | false            | 0xC2
<span class="lineNum">   15839 </span>            :     number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
<span class="lineNum">   15840 </span>            :     number_integer  | -2147483648..-32769               | int32            | 0xD2
<span class="lineNum">   15841 </span>            :     number_integer  | -32768..-129                      | int16            | 0xD1
<span class="lineNum">   15842 </span>            :     number_integer  | -128..-33                         | int8             | 0xD0
<span class="lineNum">   15843 </span>            :     number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
<span class="lineNum">   15844 </span>            :     number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
<span class="lineNum">   15845 </span>            :     number_integer  | 128..255                          | uint 8           | 0xCC
<span class="lineNum">   15846 </span>            :     number_integer  | 256..65535                        | uint 16          | 0xCD
<span class="lineNum">   15847 </span>            :     number_integer  | 65536..4294967295                 | uint 32          | 0xCE
<span class="lineNum">   15848 </span>            :     number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
<span class="lineNum">   15849 </span>            :     number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
<span class="lineNum">   15850 </span>            :     number_unsigned | 128..255                          | uint 8           | 0xCC
<span class="lineNum">   15851 </span>            :     number_unsigned | 256..65535                        | uint 16          | 0xCD
<span class="lineNum">   15852 </span>            :     number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
<span class="lineNum">   15853 </span>            :     number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
<span class="lineNum">   15854 </span>            :     number_float    | *any value*                       | float 64         | 0xCB
<span class="lineNum">   15855 </span>            :     string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
<span class="lineNum">   15856 </span>            :     string          | *length*: 32..255                 | str 8            | 0xD9
<span class="lineNum">   15857 </span>            :     string          | *length*: 256..65535              | str 16           | 0xDA
<span class="lineNum">   15858 </span>            :     string          | *length*: 65536..4294967295       | str 32           | 0xDB
<span class="lineNum">   15859 </span>            :     array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
<span class="lineNum">   15860 </span>            :     array           | *size*: 16..65535                 | array 16         | 0xDC
<span class="lineNum">   15861 </span>            :     array           | *size*: 65536..4294967295         | array 32         | 0xDD
<span class="lineNum">   15862 </span>            :     object          | *size*: 0..15                     | fix map          | 0x80..0x8F
<span class="lineNum">   15863 </span>            :     object          | *size*: 16..65535                 | map 16           | 0xDE
<span class="lineNum">   15864 </span>            :     object          | *size*: 65536..4294967295         | map 32           | 0xDF
<span class="lineNum">   15865 </span>            : 
<span class="lineNum">   15866 </span>            :     @note The mapping is **complete** in the sense that any JSON value type
<span class="lineNum">   15867 </span>            :           can be converted to a MessagePack value.
<span class="lineNum">   15868 </span>            : 
<span class="lineNum">   15869 </span>            :     @note The following values can **not** be converted to a MessagePack value:
<span class="lineNum">   15870 </span>            :           - strings with more than 4294967295 bytes
<span class="lineNum">   15871 </span>            :           - arrays with more than 4294967295 elements
<span class="lineNum">   15872 </span>            :           - objects with more than 4294967295 elements
<span class="lineNum">   15873 </span>            : 
<span class="lineNum">   15874 </span>            :     @note The following MessagePack types are not used in the conversion:
<span class="lineNum">   15875 </span>            :           - bin 8 - bin 32 (0xC4..0xC6)
<span class="lineNum">   15876 </span>            :           - ext 8 - ext 32 (0xC7..0xC9)
<span class="lineNum">   15877 </span>            :           - float 32 (0xCA)
<span class="lineNum">   15878 </span>            :           - fixext 1 - fixext 16 (0xD4..0xD8)
<span class="lineNum">   15879 </span>            : 
<span class="lineNum">   15880 </span>            :     @note Any MessagePack output created @ref to_msgpack can be successfully
<span class="lineNum">   15881 </span>            :           parsed by @ref from_msgpack.
<span class="lineNum">   15882 </span>            : 
<span class="lineNum">   15883 </span>            :     @note If NaN or Infinity are stored inside a JSON number, they are
<span class="lineNum">   15884 </span>            :           serialized properly. This behavior differs from the @ref dump()
<span class="lineNum">   15885 </span>            :           function which serializes NaN or Infinity to `null`.
<span class="lineNum">   15886 </span>            : 
<span class="lineNum">   15887 </span>            :     @param[in] j  JSON value to serialize
<span class="lineNum">   15888 </span>            :     @return MessagePack serialization as byte vector
<span class="lineNum">   15889 </span>            : 
<span class="lineNum">   15890 </span>            :     @complexity Linear in the size of the JSON value @a j.
<span class="lineNum">   15891 </span>            : 
<span class="lineNum">   15892 </span>            :     @liveexample{The example shows the serialization of a JSON value to a byte
<span class="lineNum">   15893 </span>            :     vector in MessagePack format.,to_msgpack}
<span class="lineNum">   15894 </span>            : 
<span class="lineNum">   15895 </span>            :     @sa http://msgpack.org
<span class="lineNum">   15896 </span>            :     @sa @ref from_msgpack(const std::vector&lt;uint8_t&gt;&amp;, const size_t) for the
<span class="lineNum">   15897 </span>            :         analogous deserialization
<span class="lineNum">   15898 </span>            :     @sa @ref to_cbor(const basic_json&amp; for the related CBOR format
<span class="lineNum">   15899 </span>            :     @sa @ref to_ubjson(const basic_json&amp;, const bool, const bool) for the
<span class="lineNum">   15900 </span>            :              related UBJSON format
<span class="lineNum">   15901 </span>            : 
<span class="lineNum">   15902 </span>            :     @since version 2.0.9
<span class="lineNum">   15903 </span>            :     */
<span class="lineNum">   15904 </span>            :     static std::vector&lt;uint8_t&gt; to_msgpack(const basic_json&amp; j)
<span class="lineNum">   15905 </span>            :     {
<span class="lineNum">   15906 </span>            :         std::vector&lt;uint8_t&gt; result;
<span class="lineNum">   15907 </span>            :         to_msgpack(j, result);
<span class="lineNum">   15908 </span>            :         return result;
<span class="lineNum">   15909 </span>            :     }
<span class="lineNum">   15910 </span>            : 
<span class="lineNum">   15911 </span>            :     static void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;uint8_t&gt; o)
<span class="lineNum">   15912 </span>            :     {
<span class="lineNum">   15913 </span>            :         binary_writer&lt;uint8_t&gt;(o).write_msgpack(j);
<span class="lineNum">   15914 </span>            :     }
<span class="lineNum">   15915 </span>            : 
<span class="lineNum">   15916 </span>            :     static void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o)
<span class="lineNum">   15917 </span>            :     {
<span class="lineNum">   15918 </span>            :         binary_writer&lt;char&gt;(o).write_msgpack(j);
<span class="lineNum">   15919 </span>            :     }
<span class="lineNum">   15920 </span>            : 
<span class="lineNum">   15921 </span>            :     /*!
<span class="lineNum">   15922 </span>            :     @brief create a UBJSON serialization of a given JSON value
<span class="lineNum">   15923 </span>            : 
<span class="lineNum">   15924 </span>            :     Serializes a given JSON value @a j to a byte vector using the UBJSON
<span class="lineNum">   15925 </span>            :     (Universal Binary JSON) serialization format. UBJSON aims to be more compact
<span class="lineNum">   15926 </span>            :     than JSON itself, yet more efficient to parse.
<span class="lineNum">   15927 </span>            : 
<span class="lineNum">   15928 </span>            :     The library uses the following mapping from JSON values types to
<span class="lineNum">   15929 </span>            :     UBJSON types according to the UBJSON specification:
<span class="lineNum">   15930 </span>            : 
<span class="lineNum">   15931 </span>            :     JSON value type | value/range                       | UBJSON type | marker
<span class="lineNum">   15932 </span>            :     --------------- | --------------------------------- | ----------- | ------
<span class="lineNum">   15933 </span>            :     null            | `null`                            | null        | `Z`
<span class="lineNum">   15934 </span>            :     boolean         | `true`                            | true        | `T`
<span class="lineNum">   15935 </span>            :     boolean         | `false`                           | false       | `F`
<span class="lineNum">   15936 </span>            :     number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
<span class="lineNum">   15937 </span>            :     number_integer  | -2147483648..-32769               | int32       | `l`
<span class="lineNum">   15938 </span>            :     number_integer  | -32768..-129                      | int16       | `I`
<span class="lineNum">   15939 </span>            :     number_integer  | -128..127                         | int8        | `i`
<span class="lineNum">   15940 </span>            :     number_integer  | 128..255                          | uint8       | `U`
<span class="lineNum">   15941 </span>            :     number_integer  | 256..32767                        | int16       | `I`
<span class="lineNum">   15942 </span>            :     number_integer  | 32768..2147483647                 | int32       | `l`
<span class="lineNum">   15943 </span>            :     number_integer  | 2147483648..9223372036854775807   | int64       | `L`
<span class="lineNum">   15944 </span>            :     number_unsigned | 0..127                            | int8        | `i`
<span class="lineNum">   15945 </span>            :     number_unsigned | 128..255                          | uint8       | `U`
<span class="lineNum">   15946 </span>            :     number_unsigned | 256..32767                        | int16       | `I`
<span class="lineNum">   15947 </span>            :     number_unsigned | 32768..2147483647                 | int32       | `l`
<span class="lineNum">   15948 </span>            :     number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
<span class="lineNum">   15949 </span>            :     number_float    | *any value*                       | float64     | `D`
<span class="lineNum">   15950 </span>            :     string          | *with shortest length indicator*  | string      | `S`
<span class="lineNum">   15951 </span>            :     array           | *see notes on optimized format*   | array       | `[`
<span class="lineNum">   15952 </span>            :     object          | *see notes on optimized format*   | map         | `{`
<span class="lineNum">   15953 </span>            : 
<span class="lineNum">   15954 </span>            :     @note The mapping is **complete** in the sense that any JSON value type
<span class="lineNum">   15955 </span>            :           can be converted to a UBJSON value.
<span class="lineNum">   15956 </span>            : 
<span class="lineNum">   15957 </span>            :     @note The following values can **not** be converted to a UBJSON value:
<span class="lineNum">   15958 </span>            :           - strings with more than 9223372036854775807 bytes (theoretical)
<span class="lineNum">   15959 </span>            :           - unsigned integer numbers above 9223372036854775807
<span class="lineNum">   15960 </span>            : 
<span class="lineNum">   15961 </span>            :     @note The following markers are not used in the conversion:
<span class="lineNum">   15962 </span>            :           - `Z`: no-op values are not created.
<span class="lineNum">   15963 </span>            :           - `C`: single-byte strings are serialized with `S` markers.
<span class="lineNum">   15964 </span>            : 
<span class="lineNum">   15965 </span>            :     @note Any UBJSON output created @ref to_ubjson can be successfully parsed
<span class="lineNum">   15966 </span>            :           by @ref from_ubjson.
<span class="lineNum">   15967 </span>            : 
<span class="lineNum">   15968 </span>            :     @note If NaN or Infinity are stored inside a JSON number, they are
<span class="lineNum">   15969 </span>            :           serialized properly. This behavior differs from the @ref dump()
<span class="lineNum">   15970 </span>            :           function which serializes NaN or Infinity to `null`.
<span class="lineNum">   15971 </span>            : 
<span class="lineNum">   15972 </span>            :     @note The optimized formats for containers are supported: Parameter
<span class="lineNum">   15973 </span>            :           @a use_size adds size information to the beginning of a container and
<span class="lineNum">   15974 </span>            :           removes the closing marker. Parameter @a use_type further checks
<span class="lineNum">   15975 </span>            :           whether all elements of a container have the same type and adds the
<span class="lineNum">   15976 </span>            :           type marker to the beginning of the container. The @a use_type
<span class="lineNum">   15977 </span>            :           parameter must only be used together with @a use_size = true. Note
<span class="lineNum">   15978 </span>            :           that @a use_size = true alone may result in larger representations -
<span class="lineNum">   15979 </span>            :           the benefit of this parameter is that the receiving side is
<span class="lineNum">   15980 </span>            :           immediately informed on the number of elements of the container.
<span class="lineNum">   15981 </span>            : 
<span class="lineNum">   15982 </span>            :     @param[in] j  JSON value to serialize
<span class="lineNum">   15983 </span>            :     @param[in] use_size  whether to add size annotations to container types
<span class="lineNum">   15984 </span>            :     @param[in] use_type  whether to add type annotations to container types
<span class="lineNum">   15985 </span>            :                          (must be combined with @a use_size = true)
<span class="lineNum">   15986 </span>            :     @return UBJSON serialization as byte vector
<span class="lineNum">   15987 </span>            : 
<span class="lineNum">   15988 </span>            :     @complexity Linear in the size of the JSON value @a j.
<span class="lineNum">   15989 </span>            : 
<span class="lineNum">   15990 </span>            :     @liveexample{The example shows the serialization of a JSON value to a byte
<span class="lineNum">   15991 </span>            :     vector in UBJSON format.,to_ubjson}
<span class="lineNum">   15992 </span>            : 
<span class="lineNum">   15993 </span>            :     @sa http://ubjson.org
<span class="lineNum">   15994 </span>            :     @sa @ref from_ubjson(detail::input_adapter, const bool strict) for the
<span class="lineNum">   15995 </span>            :         analogous deserialization
<span class="lineNum">   15996 </span>            :     @sa @ref to_cbor(const basic_json&amp; for the related CBOR format
<span class="lineNum">   15997 </span>            :     @sa @ref to_msgpack(const basic_json&amp;) for the related MessagePack format
<span class="lineNum">   15998 </span>            : 
<span class="lineNum">   15999 </span>            :     @since version 3.1.0
<span class="lineNum">   16000 </span>            :     */
<span class="lineNum">   16001 </span>            :     static std::vector&lt;uint8_t&gt; to_ubjson(const basic_json&amp; j,
<span class="lineNum">   16002 </span>            :                                           const bool use_size = false,
<span class="lineNum">   16003 </span>            :                                           const bool use_type = false)
<span class="lineNum">   16004 </span>            :     {
<span class="lineNum">   16005 </span>            :         std::vector&lt;uint8_t&gt; result;
<span class="lineNum">   16006 </span>            :         to_ubjson(j, result, use_size, use_type);
<span class="lineNum">   16007 </span>            :         return result;
<span class="lineNum">   16008 </span>            :     }
<span class="lineNum">   16009 </span>            : 
<span class="lineNum">   16010 </span>            :     static void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;uint8_t&gt; o,
<span class="lineNum">   16011 </span>            :                           const bool use_size = false, const bool use_type = false)
<span class="lineNum">   16012 </span>            :     {
<span class="lineNum">   16013 </span>            :         binary_writer&lt;uint8_t&gt;(o).write_ubjson(j, use_size, use_type);
<span class="lineNum">   16014 </span>            :     }
<span class="lineNum">   16015 </span>            : 
<span class="lineNum">   16016 </span>            :     static void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o,
<span class="lineNum">   16017 </span>            :                           const bool use_size = false, const bool use_type = false)
<span class="lineNum">   16018 </span>            :     {
<span class="lineNum">   16019 </span>            :         binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type);
<span class="lineNum">   16020 </span>            :     }
<span class="lineNum">   16021 </span>            : 
<span class="lineNum">   16022 </span>            :     /*!
<span class="lineNum">   16023 </span>            :     @brief create a JSON value from an input in CBOR format
<span class="lineNum">   16024 </span>            : 
<span class="lineNum">   16025 </span>            :     Deserializes a given input @a i to a JSON value using the CBOR (Concise
<span class="lineNum">   16026 </span>            :     Binary Object Representation) serialization format.
<span class="lineNum">   16027 </span>            : 
<span class="lineNum">   16028 </span>            :     The library maps CBOR types to JSON value types as follows:
<span class="lineNum">   16029 </span>            : 
<span class="lineNum">   16030 </span>            :     CBOR type              | JSON value type | first byte
<span class="lineNum">   16031 </span>            :     ---------------------- | --------------- | ----------
<span class="lineNum">   16032 </span>            :     Integer                | number_unsigned | 0x00..0x17
<span class="lineNum">   16033 </span>            :     Unsigned integer       | number_unsigned | 0x18
<span class="lineNum">   16034 </span>            :     Unsigned integer       | number_unsigned | 0x19
<span class="lineNum">   16035 </span>            :     Unsigned integer       | number_unsigned | 0x1A
<span class="lineNum">   16036 </span>            :     Unsigned integer       | number_unsigned | 0x1B
<span class="lineNum">   16037 </span>            :     Negative integer       | number_integer  | 0x20..0x37
<span class="lineNum">   16038 </span>            :     Negative integer       | number_integer  | 0x38
<span class="lineNum">   16039 </span>            :     Negative integer       | number_integer  | 0x39
<span class="lineNum">   16040 </span>            :     Negative integer       | number_integer  | 0x3A
<span class="lineNum">   16041 </span>            :     Negative integer       | number_integer  | 0x3B
<span class="lineNum">   16042 </span>            :     Negative integer       | number_integer  | 0x40..0x57
<span class="lineNum">   16043 </span>            :     UTF-8 string           | string          | 0x60..0x77
<span class="lineNum">   16044 </span>            :     UTF-8 string           | string          | 0x78
<span class="lineNum">   16045 </span>            :     UTF-8 string           | string          | 0x79
<span class="lineNum">   16046 </span>            :     UTF-8 string           | string          | 0x7A
<span class="lineNum">   16047 </span>            :     UTF-8 string           | string          | 0x7B
<span class="lineNum">   16048 </span>            :     UTF-8 string           | string          | 0x7F
<span class="lineNum">   16049 </span>            :     array                  | array           | 0x80..0x97
<span class="lineNum">   16050 </span>            :     array                  | array           | 0x98
<span class="lineNum">   16051 </span>            :     array                  | array           | 0x99
<span class="lineNum">   16052 </span>            :     array                  | array           | 0x9A
<span class="lineNum">   16053 </span>            :     array                  | array           | 0x9B
<span class="lineNum">   16054 </span>            :     array                  | array           | 0x9F
<span class="lineNum">   16055 </span>            :     map                    | object          | 0xA0..0xB7
<span class="lineNum">   16056 </span>            :     map                    | object          | 0xB8
<span class="lineNum">   16057 </span>            :     map                    | object          | 0xB9
<span class="lineNum">   16058 </span>            :     map                    | object          | 0xBA
<span class="lineNum">   16059 </span>            :     map                    | object          | 0xBB
<span class="lineNum">   16060 </span>            :     map                    | object          | 0xBF
<span class="lineNum">   16061 </span>            :     False                  | `false`         | 0xF4
<span class="lineNum">   16062 </span>            :     True                   | `true`          | 0xF5
<span class="lineNum">   16063 </span>            :     Nill                   | `null`          | 0xF6
<span class="lineNum">   16064 </span>            :     Half-Precision Float   | number_float    | 0xF9
<span class="lineNum">   16065 </span>            :     Single-Precision Float | number_float    | 0xFA
<span class="lineNum">   16066 </span>            :     Double-Precision Float | number_float    | 0xFB
<span class="lineNum">   16067 </span>            : 
<span class="lineNum">   16068 </span>            :     @warning The mapping is **incomplete** in the sense that not all CBOR
<span class="lineNum">   16069 </span>            :              types can be converted to a JSON value. The following CBOR types
<span class="lineNum">   16070 </span>            :              are not supported and will yield parse errors (parse_error.112):
<span class="lineNum">   16071 </span>            :              - byte strings (0x40..0x5F)
<span class="lineNum">   16072 </span>            :              - date/time (0xC0..0xC1)
<span class="lineNum">   16073 </span>            :              - bignum (0xC2..0xC3)
<span class="lineNum">   16074 </span>            :              - decimal fraction (0xC4)
<span class="lineNum">   16075 </span>            :              - bigfloat (0xC5)
<span class="lineNum">   16076 </span>            :              - tagged items (0xC6..0xD4, 0xD8..0xDB)
<span class="lineNum">   16077 </span>            :              - expected conversions (0xD5..0xD7)
<span class="lineNum">   16078 </span>            :              - simple values (0xE0..0xF3, 0xF8)
<span class="lineNum">   16079 </span>            :              - undefined (0xF7)
<span class="lineNum">   16080 </span>            : 
<span class="lineNum">   16081 </span>            :     @warning CBOR allows map keys of any type, whereas JSON only allows
<span class="lineNum">   16082 </span>            :              strings as keys in object values. Therefore, CBOR maps with keys
<span class="lineNum">   16083 </span>            :              other than UTF-8 strings are rejected (parse_error.113).
<span class="lineNum">   16084 </span>            : 
<span class="lineNum">   16085 </span>            :     @note Any CBOR output created @ref to_cbor can be successfully parsed by
<span class="lineNum">   16086 </span>            :           @ref from_cbor.
<span class="lineNum">   16087 </span>            : 
<span class="lineNum">   16088 </span>            :     @param[in] i  an input in CBOR format convertible to an input adapter
<span class="lineNum">   16089 </span>            :     @param[in] strict  whether to expect the input to be consumed until EOF
<span class="lineNum">   16090 </span>            :                        (true by default)
<span class="lineNum">   16091 </span>            :     @return deserialized JSON value
<span class="lineNum">   16092 </span>            : 
<span class="lineNum">   16093 </span>            :     @throw parse_error.110 if the given input ends prematurely or the end of
<span class="lineNum">   16094 </span>            :     file was not reached when @a strict was set to true
<span class="lineNum">   16095 </span>            :     @throw parse_error.112 if unsupported features from CBOR were
<span class="lineNum">   16096 </span>            :     used in the given input @a v or if the input is not valid CBOR
<span class="lineNum">   16097 </span>            :     @throw parse_error.113 if a string was expected as map key, but not found
<span class="lineNum">   16098 </span>            : 
<span class="lineNum">   16099 </span>            :     @complexity Linear in the size of the input @a i.
<span class="lineNum">   16100 </span>            : 
<span class="lineNum">   16101 </span>            :     @liveexample{The example shows the deserialization of a byte vector in CBOR
<span class="lineNum">   16102 </span>            :     format to a JSON value.,from_cbor}
<span class="lineNum">   16103 </span>            : 
<span class="lineNum">   16104 </span>            :     @sa http://cbor.io
<span class="lineNum">   16105 </span>            :     @sa @ref to_cbor(const basic_json&amp;) for the analogous serialization
<span class="lineNum">   16106 </span>            :     @sa @ref from_msgpack(detail::input_adapter, const bool) for the
<span class="lineNum">   16107 </span>            :         related MessagePack format
<span class="lineNum">   16108 </span>            :     @sa @ref from_ubjson(detail::input_adapter, const bool) for the related
<span class="lineNum">   16109 </span>            :         UBJSON format
<span class="lineNum">   16110 </span>            : 
<span class="lineNum">   16111 </span>            :     @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
<span class="lineNum">   16112 </span>            :            consume input adapters, removed start_index parameter, and added
<span class="lineNum">   16113 </span>            :            @a strict parameter since 3.0.0
<span class="lineNum">   16114 </span>            :     */
<span class="lineNum">   16115 </span>            :     static basic_json from_cbor(detail::input_adapter i,
<span class="lineNum">   16116 </span>            :                                 const bool strict = true)
<span class="lineNum">   16117 </span>            :     {
<span class="lineNum">   16118 </span>            :         return binary_reader(i).parse_cbor(strict);
<span class="lineNum">   16119 </span>            :     }
<span class="lineNum">   16120 </span>            : 
<span class="lineNum">   16121 </span>            :     /*!
<span class="lineNum">   16122 </span>            :     @copydoc from_cbor(detail::input_adapter, const bool)
<span class="lineNum">   16123 </span>            :     */
<span class="lineNum">   16124 </span>            :     template&lt;typename A1, typename A2,
<span class="lineNum">   16125 </span>            :              detail::enable_if_t&lt;std::is_constructible&lt;detail::input_adapter, A1, A2&gt;::value, int&gt; = 0&gt;
<span class="lineNum">   16126 </span>            :     static basic_json from_cbor(A1 &amp;&amp; a1, A2 &amp;&amp; a2, const bool strict = true)
<span class="lineNum">   16127 </span>            :     {
<span class="lineNum">   16128 </span>            :         return binary_reader(detail::input_adapter(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2))).parse_cbor(strict);
<span class="lineNum">   16129 </span>            :     }
<span class="lineNum">   16130 </span>            : 
<span class="lineNum">   16131 </span>            :     /*!
<span class="lineNum">   16132 </span>            :     @brief create a JSON value from an input in MessagePack format
<span class="lineNum">   16133 </span>            : 
<span class="lineNum">   16134 </span>            :     Deserializes a given input @a i to a JSON value using the MessagePack
<span class="lineNum">   16135 </span>            :     serialization format.
<span class="lineNum">   16136 </span>            : 
<span class="lineNum">   16137 </span>            :     The library maps MessagePack types to JSON value types as follows:
<span class="lineNum">   16138 </span>            : 
<span class="lineNum">   16139 </span>            :     MessagePack type | JSON value type | first byte
<span class="lineNum">   16140 </span>            :     ---------------- | --------------- | ----------
<span class="lineNum">   16141 </span>            :     positive fixint  | number_unsigned | 0x00..0x7F
<span class="lineNum">   16142 </span>            :     fixmap           | object          | 0x80..0x8F
<span class="lineNum">   16143 </span>            :     fixarray         | array           | 0x90..0x9F
<span class="lineNum">   16144 </span>            :     fixstr           | string          | 0xA0..0xBF
<span class="lineNum">   16145 </span>            :     nil              | `null`          | 0xC0
<span class="lineNum">   16146 </span>            :     false            | `false`         | 0xC2
<span class="lineNum">   16147 </span>            :     true             | `true`          | 0xC3
<span class="lineNum">   16148 </span>            :     float 32         | number_float    | 0xCA
<span class="lineNum">   16149 </span>            :     float 64         | number_float    | 0xCB
<span class="lineNum">   16150 </span>            :     uint 8           | number_unsigned | 0xCC
<span class="lineNum">   16151 </span>            :     uint 16          | number_unsigned | 0xCD
<span class="lineNum">   16152 </span>            :     uint 32          | number_unsigned | 0xCE
<span class="lineNum">   16153 </span>            :     uint 64          | number_unsigned | 0xCF
<span class="lineNum">   16154 </span>            :     int 8            | number_integer  | 0xD0
<span class="lineNum">   16155 </span>            :     int 16           | number_integer  | 0xD1
<span class="lineNum">   16156 </span>            :     int 32           | number_integer  | 0xD2
<span class="lineNum">   16157 </span>            :     int 64           | number_integer  | 0xD3
<span class="lineNum">   16158 </span>            :     str 8            | string          | 0xD9
<span class="lineNum">   16159 </span>            :     str 16           | string          | 0xDA
<span class="lineNum">   16160 </span>            :     str 32           | string          | 0xDB
<span class="lineNum">   16161 </span>            :     array 16         | array           | 0xDC
<span class="lineNum">   16162 </span>            :     array 32         | array           | 0xDD
<span class="lineNum">   16163 </span>            :     map 16           | object          | 0xDE
<span class="lineNum">   16164 </span>            :     map 32           | object          | 0xDF
<span class="lineNum">   16165 </span>            :     negative fixint  | number_integer  | 0xE0-0xFF
<span class="lineNum">   16166 </span>            : 
<span class="lineNum">   16167 </span>            :     @warning The mapping is **incomplete** in the sense that not all
<span class="lineNum">   16168 </span>            :              MessagePack types can be converted to a JSON value. The following
<span class="lineNum">   16169 </span>            :              MessagePack types are not supported and will yield parse errors:
<span class="lineNum">   16170 </span>            :               - bin 8 - bin 32 (0xC4..0xC6)
<span class="lineNum">   16171 </span>            :               - ext 8 - ext 32 (0xC7..0xC9)
<span class="lineNum">   16172 </span>            :               - fixext 1 - fixext 16 (0xD4..0xD8)
<span class="lineNum">   16173 </span>            : 
<span class="lineNum">   16174 </span>            :     @note Any MessagePack output created @ref to_msgpack can be successfully
<span class="lineNum">   16175 </span>            :           parsed by @ref from_msgpack.
<span class="lineNum">   16176 </span>            : 
<span class="lineNum">   16177 </span>            :     @param[in] i  an input in MessagePack format convertible to an input
<span class="lineNum">   16178 </span>            :                   adapter
<span class="lineNum">   16179 </span>            :     @param[in] strict  whether to expect the input to be consumed until EOF
<span class="lineNum">   16180 </span>            :                        (true by default)
<span class="lineNum">   16181 </span>            : 
<span class="lineNum">   16182 </span>            :     @throw parse_error.110 if the given input ends prematurely or the end of
<span class="lineNum">   16183 </span>            :     file was not reached when @a strict was set to true
<span class="lineNum">   16184 </span>            :     @throw parse_error.112 if unsupported features from MessagePack were
<span class="lineNum">   16185 </span>            :     used in the given input @a i or if the input is not valid MessagePack
<span class="lineNum">   16186 </span>            :     @throw parse_error.113 if a string was expected as map key, but not found
<span class="lineNum">   16187 </span>            : 
<span class="lineNum">   16188 </span>            :     @complexity Linear in the size of the input @a i.
<span class="lineNum">   16189 </span>            : 
<span class="lineNum">   16190 </span>            :     @liveexample{The example shows the deserialization of a byte vector in
<span class="lineNum">   16191 </span>            :     MessagePack format to a JSON value.,from_msgpack}
<span class="lineNum">   16192 </span>            : 
<span class="lineNum">   16193 </span>            :     @sa http://msgpack.org
<span class="lineNum">   16194 </span>            :     @sa @ref to_msgpack(const basic_json&amp;) for the analogous serialization
<span class="lineNum">   16195 </span>            :     @sa @ref from_cbor(detail::input_adapter, const bool) for the related CBOR
<span class="lineNum">   16196 </span>            :         format
<span class="lineNum">   16197 </span>            :     @sa @ref from_ubjson(detail::input_adapter, const bool) for the related
<span class="lineNum">   16198 </span>            :         UBJSON format
<span class="lineNum">   16199 </span>            : 
<span class="lineNum">   16200 </span>            :     @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
<span class="lineNum">   16201 </span>            :            consume input adapters, removed start_index parameter, and added
<span class="lineNum">   16202 </span>            :            @a strict parameter since 3.0.0
<span class="lineNum">   16203 </span>            :     */
<span class="lineNum">   16204 </span>            :     static basic_json from_msgpack(detail::input_adapter i,
<span class="lineNum">   16205 </span>            :                                    const bool strict = true)
<span class="lineNum">   16206 </span>            :     {
<span class="lineNum">   16207 </span>            :         return binary_reader(i).parse_msgpack(strict);
<span class="lineNum">   16208 </span>            :     }
<span class="lineNum">   16209 </span>            : 
<span class="lineNum">   16210 </span>            :     /*!
<span class="lineNum">   16211 </span>            :     @copydoc from_msgpack(detail::input_adapter, const bool)
<span class="lineNum">   16212 </span>            :     */
<span class="lineNum">   16213 </span>            :     template&lt;typename A1, typename A2,
<span class="lineNum">   16214 </span>            :              detail::enable_if_t&lt;std::is_constructible&lt;detail::input_adapter, A1, A2&gt;::value, int&gt; = 0&gt;
<span class="lineNum">   16215 </span>            :     static basic_json from_msgpack(A1 &amp;&amp; a1, A2 &amp;&amp; a2, const bool strict = true)
<span class="lineNum">   16216 </span>            :     {
<span class="lineNum">   16217 </span>            :         return binary_reader(detail::input_adapter(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2))).parse_msgpack(strict);
<span class="lineNum">   16218 </span>            :     }
<span class="lineNum">   16219 </span>            : 
<span class="lineNum">   16220 </span>            :     /*!
<span class="lineNum">   16221 </span>            :     @brief create a JSON value from an input in UBJSON format
<span class="lineNum">   16222 </span>            : 
<span class="lineNum">   16223 </span>            :     Deserializes a given input @a i to a JSON value using the UBJSON (Universal
<span class="lineNum">   16224 </span>            :     Binary JSON) serialization format.
<span class="lineNum">   16225 </span>            : 
<span class="lineNum">   16226 </span>            :     The library maps UBJSON types to JSON value types as follows:
<span class="lineNum">   16227 </span>            : 
<span class="lineNum">   16228 </span>            :     UBJSON type | JSON value type                         | marker
<span class="lineNum">   16229 </span>            :     ----------- | --------------------------------------- | ------
<span class="lineNum">   16230 </span>            :     no-op       | *no value, next value is read*          | `N`
<span class="lineNum">   16231 </span>            :     null        | `null`                                  | `Z`
<span class="lineNum">   16232 </span>            :     false       | `false`                                 | `F`
<span class="lineNum">   16233 </span>            :     true        | `true`                                  | `T`
<span class="lineNum">   16234 </span>            :     float32     | number_float                            | `d`
<span class="lineNum">   16235 </span>            :     float64     | number_float                            | `D`
<span class="lineNum">   16236 </span>            :     uint8       | number_unsigned                         | `U`
<span class="lineNum">   16237 </span>            :     int8        | number_integer                          | `i`
<span class="lineNum">   16238 </span>            :     int16       | number_integer                          | `I`
<span class="lineNum">   16239 </span>            :     int32       | number_integer                          | `l`
<span class="lineNum">   16240 </span>            :     int64       | number_integer                          | `L`
<span class="lineNum">   16241 </span>            :     string      | string                                  | `S`
<span class="lineNum">   16242 </span>            :     char        | string                                  | `C`
<span class="lineNum">   16243 </span>            :     array       | array (optimized values are supported)  | `[`
<span class="lineNum">   16244 </span>            :     object      | object (optimized values are supported) | `{`
<span class="lineNum">   16245 </span>            : 
<span class="lineNum">   16246 </span>            :     @note The mapping is **complete** in the sense that any UBJSON value can
<span class="lineNum">   16247 </span>            :           be converted to a JSON value.
<span class="lineNum">   16248 </span>            : 
<span class="lineNum">   16249 </span>            :     @param[in] i  an input in UBJSON format convertible to an input adapter
<span class="lineNum">   16250 </span>            :     @param[in] strict  whether to expect the input to be consumed until EOF
<span class="lineNum">   16251 </span>            :                        (true by default)
<span class="lineNum">   16252 </span>            : 
<span class="lineNum">   16253 </span>            :     @throw parse_error.110 if the given input ends prematurely or the end of
<span class="lineNum">   16254 </span>            :     file was not reached when @a strict was set to true
<span class="lineNum">   16255 </span>            :     @throw parse_error.112 if a parse error occurs
<span class="lineNum">   16256 </span>            :     @throw parse_error.113 if a string could not be parsed successfully
<span class="lineNum">   16257 </span>            : 
<span class="lineNum">   16258 </span>            :     @complexity Linear in the size of the input @a i.
<span class="lineNum">   16259 </span>            : 
<span class="lineNum">   16260 </span>            :     @liveexample{The example shows the deserialization of a byte vector in
<span class="lineNum">   16261 </span>            :     UBJSON format to a JSON value.,from_ubjson}
<span class="lineNum">   16262 </span>            : 
<span class="lineNum">   16263 </span>            :     @sa http://ubjson.org
<span class="lineNum">   16264 </span>            :     @sa @ref to_ubjson(const basic_json&amp;, const bool, const bool) for the
<span class="lineNum">   16265 </span>            :              analogous serialization
<span class="lineNum">   16266 </span>            :     @sa @ref from_cbor(detail::input_adapter, const bool) for the related CBOR
<span class="lineNum">   16267 </span>            :         format
<span class="lineNum">   16268 </span>            :     @sa @ref from_msgpack(detail::input_adapter, const bool) for the related
<span class="lineNum">   16269 </span>            :         MessagePack format
<span class="lineNum">   16270 </span>            : 
<span class="lineNum">   16271 </span>            :     @since version 3.1.0
<span class="lineNum">   16272 </span>            :     */
<span class="lineNum">   16273 </span>            :     static basic_json from_ubjson(detail::input_adapter i,
<span class="lineNum">   16274 </span>            :                                   const bool strict = true)
<span class="lineNum">   16275 </span>            :     {
<span class="lineNum">   16276 </span>            :         return binary_reader(i).parse_ubjson(strict);
<span class="lineNum">   16277 </span>            :     }
<span class="lineNum">   16278 </span>            : 
<span class="lineNum">   16279 </span>            :     template&lt;typename A1, typename A2,
<span class="lineNum">   16280 </span>            :              detail::enable_if_t&lt;std::is_constructible&lt;detail::input_adapter, A1, A2&gt;::value, int&gt; = 0&gt;
<span class="lineNum">   16281 </span>            :     static basic_json from_ubjson(A1 &amp;&amp; a1, A2 &amp;&amp; a2, const bool strict = true)
<span class="lineNum">   16282 </span>            :     {
<span class="lineNum">   16283 </span>            :         return binary_reader(detail::input_adapter(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2))).parse_ubjson(strict);
<span class="lineNum">   16284 </span>            :     }
<span class="lineNum">   16285 </span>            : 
<span class="lineNum">   16286 </span>            :     /// @}
<span class="lineNum">   16287 </span>            : 
<span class="lineNum">   16288 </span>            :     //////////////////////////
<span class="lineNum">   16289 </span>            :     // JSON Pointer support //
<span class="lineNum">   16290 </span>            :     //////////////////////////
<span class="lineNum">   16291 </span>            : 
<span class="lineNum">   16292 </span>            :     /// @name JSON Pointer functions
<span class="lineNum">   16293 </span>            :     /// @{
<span class="lineNum">   16294 </span>            : 
<span class="lineNum">   16295 </span>            :     /*!
<span class="lineNum">   16296 </span>            :     @brief access specified element via JSON Pointer
<span class="lineNum">   16297 </span>            : 
<span class="lineNum">   16298 </span>            :     Uses a JSON pointer to retrieve a reference to the respective JSON value.
<span class="lineNum">   16299 </span>            :     No bound checking is performed. Similar to @ref operator[](const typename
<span class="lineNum">   16300 </span>            :     object_t::key_type&amp;), `null` values are created in arrays and objects if
<span class="lineNum">   16301 </span>            :     necessary.
<span class="lineNum">   16302 </span>            : 
<span class="lineNum">   16303 </span>            :     In particular:
<span class="lineNum">   16304 </span>            :     - If the JSON pointer points to an object key that does not exist, it
<span class="lineNum">   16305 </span>            :       is created an filled with a `null` value before a reference to it
<span class="lineNum">   16306 </span>            :       is returned.
<span class="lineNum">   16307 </span>            :     - If the JSON pointer points to an array index that does not exist, it
<span class="lineNum">   16308 </span>            :       is created an filled with a `null` value before a reference to it
<span class="lineNum">   16309 </span>            :       is returned. All indices between the current maximum and the given
<span class="lineNum">   16310 </span>            :       index are also filled with `null`.
<span class="lineNum">   16311 </span>            :     - The special value `-` is treated as a synonym for the index past the
<span class="lineNum">   16312 </span>            :       end.
<span class="lineNum">   16313 </span>            : 
<span class="lineNum">   16314 </span>            :     @param[in] ptr  a JSON pointer
<span class="lineNum">   16315 </span>            : 
<span class="lineNum">   16316 </span>            :     @return reference to the element pointed to by @a ptr
<span class="lineNum">   16317 </span>            : 
<span class="lineNum">   16318 </span>            :     @complexity Constant.
<span class="lineNum">   16319 </span>            : 
<span class="lineNum">   16320 </span>            :     @throw parse_error.106   if an array index begins with '0'
<span class="lineNum">   16321 </span>            :     @throw parse_error.109   if an array index was not a number
<span class="lineNum">   16322 </span>            :     @throw out_of_range.404  if the JSON pointer can not be resolved
<span class="lineNum">   16323 </span>            : 
<span class="lineNum">   16324 </span>            :     @liveexample{The behavior is shown in the example.,operatorjson_pointer}
<span class="lineNum">   16325 </span>            : 
<span class="lineNum">   16326 </span>            :     @since version 2.0.0
<span class="lineNum">   16327 </span>            :     */
<span class="lineNum">   16328 </span>            :     reference operator[](const json_pointer&amp; ptr)
<span class="lineNum">   16329 </span>            :     {
<span class="lineNum">   16330 </span>            :         return ptr.get_unchecked(this);
<span class="lineNum">   16331 </span>            :     }
<span class="lineNum">   16332 </span>            : 
<span class="lineNum">   16333 </span>            :     /*!
<span class="lineNum">   16334 </span>            :     @brief access specified element via JSON Pointer
<span class="lineNum">   16335 </span>            : 
<span class="lineNum">   16336 </span>            :     Uses a JSON pointer to retrieve a reference to the respective JSON value.
<span class="lineNum">   16337 </span>            :     No bound checking is performed. The function does not change the JSON
<span class="lineNum">   16338 </span>            :     value; no `null` values are created. In particular, the the special value
<span class="lineNum">   16339 </span>            :     `-` yields an exception.
<span class="lineNum">   16340 </span>            : 
<span class="lineNum">   16341 </span>            :     @param[in] ptr  JSON pointer to the desired element
<span class="lineNum">   16342 </span>            : 
<span class="lineNum">   16343 </span>            :     @return const reference to the element pointed to by @a ptr
<span class="lineNum">   16344 </span>            : 
<span class="lineNum">   16345 </span>            :     @complexity Constant.
<span class="lineNum">   16346 </span>            : 
<span class="lineNum">   16347 </span>            :     @throw parse_error.106   if an array index begins with '0'
<span class="lineNum">   16348 </span>            :     @throw parse_error.109   if an array index was not a number
<span class="lineNum">   16349 </span>            :     @throw out_of_range.402  if the array index '-' is used
<span class="lineNum">   16350 </span>            :     @throw out_of_range.404  if the JSON pointer can not be resolved
<span class="lineNum">   16351 </span>            : 
<span class="lineNum">   16352 </span>            :     @liveexample{The behavior is shown in the example.,operatorjson_pointer_const}
<span class="lineNum">   16353 </span>            : 
<span class="lineNum">   16354 </span>            :     @since version 2.0.0
<span class="lineNum">   16355 </span>            :     */
<span class="lineNum">   16356 </span>            :     const_reference operator[](const json_pointer&amp; ptr) const
<span class="lineNum">   16357 </span>            :     {
<span class="lineNum">   16358 </span>            :         return ptr.get_unchecked(this);
<span class="lineNum">   16359 </span>            :     }
<span class="lineNum">   16360 </span>            : 
<span class="lineNum">   16361 </span>            :     /*!
<span class="lineNum">   16362 </span>            :     @brief access specified element via JSON Pointer
<span class="lineNum">   16363 </span>            : 
<span class="lineNum">   16364 </span>            :     Returns a reference to the element at with specified JSON pointer @a ptr,
<span class="lineNum">   16365 </span>            :     with bounds checking.
<span class="lineNum">   16366 </span>            : 
<span class="lineNum">   16367 </span>            :     @param[in] ptr  JSON pointer to the desired element
<span class="lineNum">   16368 </span>            : 
<span class="lineNum">   16369 </span>            :     @return reference to the element pointed to by @a ptr
<span class="lineNum">   16370 </span>            : 
<span class="lineNum">   16371 </span>            :     @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
<span class="lineNum">   16372 </span>            :     begins with '0'. See example below.
<span class="lineNum">   16373 </span>            : 
<span class="lineNum">   16374 </span>            :     @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
<span class="lineNum">   16375 </span>            :     is not a number. See example below.
<span class="lineNum">   16376 </span>            : 
<span class="lineNum">   16377 </span>            :     @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
<span class="lineNum">   16378 </span>            :     is out of range. See example below.
<span class="lineNum">   16379 </span>            : 
<span class="lineNum">   16380 </span>            :     @throw out_of_range.402 if the array index '-' is used in the passed JSON
<span class="lineNum">   16381 </span>            :     pointer @a ptr. As `at` provides checked access (and no elements are
<span class="lineNum">   16382 </span>            :     implicitly inserted), the index '-' is always invalid. See example below.
<span class="lineNum">   16383 </span>            : 
<span class="lineNum">   16384 </span>            :     @throw out_of_range.403 if the JSON pointer describes a key of an object
<span class="lineNum">   16385 </span>            :     which cannot be found. See example below.
<span class="lineNum">   16386 </span>            : 
<span class="lineNum">   16387 </span>            :     @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
<span class="lineNum">   16388 </span>            :     See example below.
<span class="lineNum">   16389 </span>            : 
<span class="lineNum">   16390 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   16391 </span>            :     changes in the JSON value.
<span class="lineNum">   16392 </span>            : 
<span class="lineNum">   16393 </span>            :     @complexity Constant.
<span class="lineNum">   16394 </span>            : 
<span class="lineNum">   16395 </span>            :     @since version 2.0.0
<span class="lineNum">   16396 </span>            : 
<span class="lineNum">   16397 </span>            :     @liveexample{The behavior is shown in the example.,at_json_pointer}
<span class="lineNum">   16398 </span>            :     */
<span class="lineNum">   16399 </span>            :     reference at(const json_pointer&amp; ptr)
<span class="lineNum">   16400 </span>            :     {
<span class="lineNum">   16401 </span>            :         return ptr.get_checked(this);
<span class="lineNum">   16402 </span>            :     }
<span class="lineNum">   16403 </span>            : 
<span class="lineNum">   16404 </span>            :     /*!
<span class="lineNum">   16405 </span>            :     @brief access specified element via JSON Pointer
<span class="lineNum">   16406 </span>            : 
<span class="lineNum">   16407 </span>            :     Returns a const reference to the element at with specified JSON pointer @a
<span class="lineNum">   16408 </span>            :     ptr, with bounds checking.
<span class="lineNum">   16409 </span>            : 
<span class="lineNum">   16410 </span>            :     @param[in] ptr  JSON pointer to the desired element
<span class="lineNum">   16411 </span>            : 
<span class="lineNum">   16412 </span>            :     @return reference to the element pointed to by @a ptr
<span class="lineNum">   16413 </span>            : 
<span class="lineNum">   16414 </span>            :     @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
<span class="lineNum">   16415 </span>            :     begins with '0'. See example below.
<span class="lineNum">   16416 </span>            : 
<span class="lineNum">   16417 </span>            :     @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
<span class="lineNum">   16418 </span>            :     is not a number. See example below.
<span class="lineNum">   16419 </span>            : 
<span class="lineNum">   16420 </span>            :     @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
<span class="lineNum">   16421 </span>            :     is out of range. See example below.
<span class="lineNum">   16422 </span>            : 
<span class="lineNum">   16423 </span>            :     @throw out_of_range.402 if the array index '-' is used in the passed JSON
<span class="lineNum">   16424 </span>            :     pointer @a ptr. As `at` provides checked access (and no elements are
<span class="lineNum">   16425 </span>            :     implicitly inserted), the index '-' is always invalid. See example below.
<span class="lineNum">   16426 </span>            : 
<span class="lineNum">   16427 </span>            :     @throw out_of_range.403 if the JSON pointer describes a key of an object
<span class="lineNum">   16428 </span>            :     which cannot be found. See example below.
<span class="lineNum">   16429 </span>            : 
<span class="lineNum">   16430 </span>            :     @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
<span class="lineNum">   16431 </span>            :     See example below.
<span class="lineNum">   16432 </span>            : 
<span class="lineNum">   16433 </span>            :     @exceptionsafety Strong guarantee: if an exception is thrown, there are no
<span class="lineNum">   16434 </span>            :     changes in the JSON value.
<span class="lineNum">   16435 </span>            : 
<span class="lineNum">   16436 </span>            :     @complexity Constant.
<span class="lineNum">   16437 </span>            : 
<span class="lineNum">   16438 </span>            :     @since version 2.0.0
<span class="lineNum">   16439 </span>            : 
<span class="lineNum">   16440 </span>            :     @liveexample{The behavior is shown in the example.,at_json_pointer_const}
<span class="lineNum">   16441 </span>            :     */
<span class="lineNum">   16442 </span>            :     const_reference at(const json_pointer&amp; ptr) const
<span class="lineNum">   16443 </span>            :     {
<span class="lineNum">   16444 </span>            :         return ptr.get_checked(this);
<span class="lineNum">   16445 </span>            :     }
<span class="lineNum">   16446 </span>            : 
<span class="lineNum">   16447 </span>            :     /*!
<span class="lineNum">   16448 </span>            :     @brief return flattened JSON value
<span class="lineNum">   16449 </span>            : 
<span class="lineNum">   16450 </span>            :     The function creates a JSON object whose keys are JSON pointers (see [RFC
<span class="lineNum">   16451 </span>            :     6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
<span class="lineNum">   16452 </span>            :     primitive. The original JSON value can be restored using the @ref
<span class="lineNum">   16453 </span>            :     unflatten() function.
<span class="lineNum">   16454 </span>            : 
<span class="lineNum">   16455 </span>            :     @return an object that maps JSON pointers to primitive values
<span class="lineNum">   16456 </span>            : 
<span class="lineNum">   16457 </span>            :     @note Empty objects and arrays are flattened to `null` and will not be
<span class="lineNum">   16458 </span>            :           reconstructed correctly by the @ref unflatten() function.
<span class="lineNum">   16459 </span>            : 
<span class="lineNum">   16460 </span>            :     @complexity Linear in the size the JSON value.
<span class="lineNum">   16461 </span>            : 
<span class="lineNum">   16462 </span>            :     @liveexample{The following code shows how a JSON object is flattened to an
<span class="lineNum">   16463 </span>            :     object whose keys consist of JSON pointers.,flatten}
<span class="lineNum">   16464 </span>            : 
<span class="lineNum">   16465 </span>            :     @sa @ref unflatten() for the reverse function
<span class="lineNum">   16466 </span>            : 
<span class="lineNum">   16467 </span>            :     @since version 2.0.0
<span class="lineNum">   16468 </span>            :     */
<span class="lineNum">   16469 </span>            :     basic_json flatten() const
<span class="lineNum">   16470 </span>            :     {
<span class="lineNum">   16471 </span>            :         basic_json result(value_t::object);
<span class="lineNum">   16472 </span>            :         json_pointer::flatten(&quot;&quot;, *this, result);
<span class="lineNum">   16473 </span>            :         return result;
<span class="lineNum">   16474 </span>            :     }
<span class="lineNum">   16475 </span>            : 
<span class="lineNum">   16476 </span>            :     /*!
<span class="lineNum">   16477 </span>            :     @brief unflatten a previously flattened JSON value
<span class="lineNum">   16478 </span>            : 
<span class="lineNum">   16479 </span>            :     The function restores the arbitrary nesting of a JSON value that has been
<span class="lineNum">   16480 </span>            :     flattened before using the @ref flatten() function. The JSON value must
<span class="lineNum">   16481 </span>            :     meet certain constraints:
<span class="lineNum">   16482 </span>            :     1. The value must be an object.
<span class="lineNum">   16483 </span>            :     2. The keys must be JSON pointers (see
<span class="lineNum">   16484 </span>            :        [RFC 6901](https://tools.ietf.org/html/rfc6901))
<span class="lineNum">   16485 </span>            :     3. The mapped values must be primitive JSON types.
<span class="lineNum">   16486 </span>            : 
<span class="lineNum">   16487 </span>            :     @return the original JSON from a flattened version
<span class="lineNum">   16488 </span>            : 
<span class="lineNum">   16489 </span>            :     @note Empty objects and arrays are flattened by @ref flatten() to `null`
<span class="lineNum">   16490 </span>            :           values and can not unflattened to their original type. Apart from
<span class="lineNum">   16491 </span>            :           this example, for a JSON value `j`, the following is always true:
<span class="lineNum">   16492 </span>            :           `j == j.flatten().unflatten()`.
<span class="lineNum">   16493 </span>            : 
<span class="lineNum">   16494 </span>            :     @complexity Linear in the size the JSON value.
<span class="lineNum">   16495 </span>            : 
<span class="lineNum">   16496 </span>            :     @throw type_error.314  if value is not an object
<span class="lineNum">   16497 </span>            :     @throw type_error.315  if object values are not primitive
<span class="lineNum">   16498 </span>            : 
<span class="lineNum">   16499 </span>            :     @liveexample{The following code shows how a flattened JSON object is
<span class="lineNum">   16500 </span>            :     unflattened into the original nested JSON object.,unflatten}
<span class="lineNum">   16501 </span>            : 
<span class="lineNum">   16502 </span>            :     @sa @ref flatten() for the reverse function
<span class="lineNum">   16503 </span>            : 
<span class="lineNum">   16504 </span>            :     @since version 2.0.0
<span class="lineNum">   16505 </span>            :     */
<span class="lineNum">   16506 </span>            :     basic_json unflatten() const
<span class="lineNum">   16507 </span>            :     {
<span class="lineNum">   16508 </span>            :         return json_pointer::unflatten(*this);
<span class="lineNum">   16509 </span>            :     }
<span class="lineNum">   16510 </span>            : 
<span class="lineNum">   16511 </span>            :     /// @}
<span class="lineNum">   16512 </span>            : 
<span class="lineNum">   16513 </span>            :     //////////////////////////
<span class="lineNum">   16514 </span>            :     // JSON Patch functions //
<span class="lineNum">   16515 </span>            :     //////////////////////////
<span class="lineNum">   16516 </span>            : 
<span class="lineNum">   16517 </span>            :     /// @name JSON Patch functions
<span class="lineNum">   16518 </span>            :     /// @{
<span class="lineNum">   16519 </span>            : 
<span class="lineNum">   16520 </span>            :     /*!
<span class="lineNum">   16521 </span>            :     @brief applies a JSON patch
<span class="lineNum">   16522 </span>            : 
<span class="lineNum">   16523 </span>            :     [JSON Patch](http://jsonpatch.com) defines a JSON document structure for
<span class="lineNum">   16524 </span>            :     expressing a sequence of operations to apply to a JSON) document. With
<span class="lineNum">   16525 </span>            :     this function, a JSON Patch is applied to the current JSON value by
<span class="lineNum">   16526 </span>            :     executing all operations from the patch.
<span class="lineNum">   16527 </span>            : 
<span class="lineNum">   16528 </span>            :     @param[in] json_patch  JSON patch document
<span class="lineNum">   16529 </span>            :     @return patched document
<span class="lineNum">   16530 </span>            : 
<span class="lineNum">   16531 </span>            :     @note The application of a patch is atomic: Either all operations succeed
<span class="lineNum">   16532 </span>            :           and the patched document is returned or an exception is thrown. In
<span class="lineNum">   16533 </span>            :           any case, the original value is not changed: the patch is applied
<span class="lineNum">   16534 </span>            :           to a copy of the value.
<span class="lineNum">   16535 </span>            : 
<span class="lineNum">   16536 </span>            :     @throw parse_error.104 if the JSON patch does not consist of an array of
<span class="lineNum">   16537 </span>            :     objects
<span class="lineNum">   16538 </span>            : 
<span class="lineNum">   16539 </span>            :     @throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
<span class="lineNum">   16540 </span>            :     attributes are missing); example: `&quot;operation add must have member path&quot;`
<span class="lineNum">   16541 </span>            : 
<span class="lineNum">   16542 </span>            :     @throw out_of_range.401 if an array index is out of range.
<span class="lineNum">   16543 </span>            : 
<span class="lineNum">   16544 </span>            :     @throw out_of_range.403 if a JSON pointer inside the patch could not be
<span class="lineNum">   16545 </span>            :     resolved successfully in the current JSON value; example: `&quot;key baz not
<span class="lineNum">   16546 </span>            :     found&quot;`
<span class="lineNum">   16547 </span>            : 
<span class="lineNum">   16548 </span>            :     @throw out_of_range.405 if JSON pointer has no parent (&quot;add&quot;, &quot;remove&quot;,
<span class="lineNum">   16549 </span>            :     &quot;move&quot;)
<span class="lineNum">   16550 </span>            : 
<span class="lineNum">   16551 </span>            :     @throw other_error.501 if &quot;test&quot; operation was unsuccessful
<span class="lineNum">   16552 </span>            : 
<span class="lineNum">   16553 </span>            :     @complexity Linear in the size of the JSON value and the length of the
<span class="lineNum">   16554 </span>            :     JSON patch. As usually only a fraction of the JSON value is affected by
<span class="lineNum">   16555 </span>            :     the patch, the complexity can usually be neglected.
<span class="lineNum">   16556 </span>            : 
<span class="lineNum">   16557 </span>            :     @liveexample{The following code shows how a JSON patch is applied to a
<span class="lineNum">   16558 </span>            :     value.,patch}
<span class="lineNum">   16559 </span>            : 
<span class="lineNum">   16560 </span>            :     @sa @ref diff -- create a JSON patch by comparing two JSON values
<span class="lineNum">   16561 </span>            : 
<span class="lineNum">   16562 </span>            :     @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
<span class="lineNum">   16563 </span>            :     @sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)
<span class="lineNum">   16564 </span>            : 
<span class="lineNum">   16565 </span>            :     @since version 2.0.0
<span class="lineNum">   16566 </span>            :     */
<span class="lineNum">   16567 </span>            :     basic_json patch(const basic_json&amp; json_patch) const
<span class="lineNum">   16568 </span>            :     {
<span class="lineNum">   16569 </span>            :         // make a working copy to apply the patch to
<span class="lineNum">   16570 </span>            :         basic_json result = *this;
<span class="lineNum">   16571 </span>            : 
<span class="lineNum">   16572 </span>            :         // the valid JSON Patch operations
<span class="lineNum">   16573 </span>            :         enum class patch_operations {add, remove, replace, move, copy, test, invalid};
<span class="lineNum">   16574 </span>            : 
<span class="lineNum">   16575 </span>            :         const auto get_op = [](const std::string &amp; op)
<span class="lineNum">   16576 </span>            :         {
<span class="lineNum">   16577 </span>            :             if (op == &quot;add&quot;)
<span class="lineNum">   16578 </span>            :             {
<span class="lineNum">   16579 </span>            :                 return patch_operations::add;
<span class="lineNum">   16580 </span>            :             }
<span class="lineNum">   16581 </span>            :             if (op == &quot;remove&quot;)
<span class="lineNum">   16582 </span>            :             {
<span class="lineNum">   16583 </span>            :                 return patch_operations::remove;
<span class="lineNum">   16584 </span>            :             }
<span class="lineNum">   16585 </span>            :             if (op == &quot;replace&quot;)
<span class="lineNum">   16586 </span>            :             {
<span class="lineNum">   16587 </span>            :                 return patch_operations::replace;
<span class="lineNum">   16588 </span>            :             }
<span class="lineNum">   16589 </span>            :             if (op == &quot;move&quot;)
<span class="lineNum">   16590 </span>            :             {
<span class="lineNum">   16591 </span>            :                 return patch_operations::move;
<span class="lineNum">   16592 </span>            :             }
<span class="lineNum">   16593 </span>            :             if (op == &quot;copy&quot;)
<span class="lineNum">   16594 </span>            :             {
<span class="lineNum">   16595 </span>            :                 return patch_operations::copy;
<span class="lineNum">   16596 </span>            :             }
<span class="lineNum">   16597 </span>            :             if (op == &quot;test&quot;)
<span class="lineNum">   16598 </span>            :             {
<span class="lineNum">   16599 </span>            :                 return patch_operations::test;
<span class="lineNum">   16600 </span>            :             }
<span class="lineNum">   16601 </span>            : 
<span class="lineNum">   16602 </span>            :             return patch_operations::invalid;
<span class="lineNum">   16603 </span>            :         };
<span class="lineNum">   16604 </span>            : 
<span class="lineNum">   16605 </span>            :         // wrapper for &quot;add&quot; operation; add value at ptr
<span class="lineNum">   16606 </span>            :         const auto operation_add = [&amp;result](json_pointer &amp; ptr, basic_json val)
<span class="lineNum">   16607 </span>            :         {
<span class="lineNum">   16608 </span>            :             // adding to the root of the target document means replacing it
<span class="lineNum">   16609 </span>            :             if (ptr.is_root())
<span class="lineNum">   16610 </span>            :             {
<span class="lineNum">   16611 </span>            :                 result = val;
<span class="lineNum">   16612 </span>            :             }
<span class="lineNum">   16613 </span>            :             else
<span class="lineNum">   16614 </span>            :             {
<span class="lineNum">   16615 </span>            :                 // make sure the top element of the pointer exists
<span class="lineNum">   16616 </span>            :                 json_pointer top_pointer = ptr.top();
<span class="lineNum">   16617 </span>            :                 if (top_pointer != ptr)
<span class="lineNum">   16618 </span>            :                 {
<span class="lineNum">   16619 </span>            :                     result.at(top_pointer);
<span class="lineNum">   16620 </span>            :                 }
<span class="lineNum">   16621 </span>            : 
<span class="lineNum">   16622 </span>            :                 // get reference to parent of JSON pointer ptr
<span class="lineNum">   16623 </span>            :                 const auto last_path = ptr.pop_back();
<span class="lineNum">   16624 </span>            :                 basic_json&amp; parent = result[ptr];
<span class="lineNum">   16625 </span>            : 
<span class="lineNum">   16626 </span>            :                 switch (parent.m_type)
<span class="lineNum">   16627 </span>            :                 {
<span class="lineNum">   16628 </span>            :                     case value_t::null:
<span class="lineNum">   16629 </span>            :                     case value_t::object:
<span class="lineNum">   16630 </span>            :                     {
<span class="lineNum">   16631 </span>            :                         // use operator[] to add value
<span class="lineNum">   16632 </span>            :                         parent[last_path] = val;
<span class="lineNum">   16633 </span>            :                         break;
<span class="lineNum">   16634 </span>            :                     }
<span class="lineNum">   16635 </span>            : 
<span class="lineNum">   16636 </span>            :                     case value_t::array:
<span class="lineNum">   16637 </span>            :                     {
<span class="lineNum">   16638 </span>            :                         if (last_path == &quot;-&quot;)
<span class="lineNum">   16639 </span>            :                         {
<span class="lineNum">   16640 </span>            :                             // special case: append to back
<span class="lineNum">   16641 </span>            :                             parent.push_back(val);
<span class="lineNum">   16642 </span>            :                         }
<span class="lineNum">   16643 </span>            :                         else
<span class="lineNum">   16644 </span>            :                         {
<span class="lineNum">   16645 </span>            :                             const auto idx = json_pointer::array_index(last_path);
<span class="lineNum">   16646 </span>            :                             if (JSON_UNLIKELY(static_cast&lt;size_type&gt;(idx) &gt; parent.size()))
<span class="lineNum">   16647 </span>            :                             {
<span class="lineNum">   16648 </span>            :                                 // avoid undefined behavior
<span class="lineNum">   16649 </span>            :                                 JSON_THROW(out_of_range::create(401, &quot;array index &quot; + std::to_string(idx) + &quot; is out of range&quot;));
<span class="lineNum">   16650 </span>            :                             }
<span class="lineNum">   16651 </span>            :                             else
<span class="lineNum">   16652 </span>            :                             {
<span class="lineNum">   16653 </span>            :                                 // default case: insert add offset
<span class="lineNum">   16654 </span>            :                                 parent.insert(parent.begin() + static_cast&lt;difference_type&gt;(idx), val);
<span class="lineNum">   16655 </span>            :                             }
<span class="lineNum">   16656 </span>            :                         }
<span class="lineNum">   16657 </span>            :                         break;
<span class="lineNum">   16658 </span>            :                     }
<span class="lineNum">   16659 </span>            : 
<span class="lineNum">   16660 </span>            :                     default:
<span class="lineNum">   16661 </span>            :                     {
<span class="lineNum">   16662 </span>            :                         // if there exists a parent it cannot be primitive
<span class="lineNum">   16663 </span>            :                         assert(false);  // LCOV_EXCL_LINE
<span class="lineNum">   16664 </span>            :                     }
<span class="lineNum">   16665 </span>            :                 }
<span class="lineNum">   16666 </span>            :             }
<span class="lineNum">   16667 </span>            :         };
<span class="lineNum">   16668 </span>            : 
<span class="lineNum">   16669 </span>            :         // wrapper for &quot;remove&quot; operation; remove value at ptr
<span class="lineNum">   16670 </span>            :         const auto operation_remove = [&amp;result](json_pointer &amp; ptr)
<span class="lineNum">   16671 </span>            :         {
<span class="lineNum">   16672 </span>            :             // get reference to parent of JSON pointer ptr
<span class="lineNum">   16673 </span>            :             const auto last_path = ptr.pop_back();
<span class="lineNum">   16674 </span>            :             basic_json&amp; parent = result.at(ptr);
<span class="lineNum">   16675 </span>            : 
<span class="lineNum">   16676 </span>            :             // remove child
<span class="lineNum">   16677 </span>            :             if (parent.is_object())
<span class="lineNum">   16678 </span>            :             {
<span class="lineNum">   16679 </span>            :                 // perform range check
<span class="lineNum">   16680 </span>            :                 auto it = parent.find(last_path);
<span class="lineNum">   16681 </span>            :                 if (JSON_LIKELY(it != parent.end()))
<span class="lineNum">   16682 </span>            :                 {
<span class="lineNum">   16683 </span>            :                     parent.erase(it);
<span class="lineNum">   16684 </span>            :                 }
<span class="lineNum">   16685 </span>            :                 else
<span class="lineNum">   16686 </span>            :                 {
<span class="lineNum">   16687 </span>            :                     JSON_THROW(out_of_range::create(403, &quot;key '&quot; + last_path + &quot;' not found&quot;));
<span class="lineNum">   16688 </span>            :                 }
<span class="lineNum">   16689 </span>            :             }
<span class="lineNum">   16690 </span>            :             else if (parent.is_array())
<span class="lineNum">   16691 </span>            :             {
<span class="lineNum">   16692 </span>            :                 // note erase performs range check
<span class="lineNum">   16693 </span>            :                 parent.erase(static_cast&lt;size_type&gt;(json_pointer::array_index(last_path)));
<span class="lineNum">   16694 </span>            :             }
<span class="lineNum">   16695 </span>            :         };
<span class="lineNum">   16696 </span>            : 
<span class="lineNum">   16697 </span>            :         // type check: top level value must be an array
<span class="lineNum">   16698 </span>            :         if (JSON_UNLIKELY(not json_patch.is_array()))
<span class="lineNum">   16699 </span>            :         {
<span class="lineNum">   16700 </span>            :             JSON_THROW(parse_error::create(104, 0, &quot;JSON patch must be an array of objects&quot;));
<span class="lineNum">   16701 </span>            :         }
<span class="lineNum">   16702 </span>            : 
<span class="lineNum">   16703 </span>            :         // iterate and apply the operations
<span class="lineNum">   16704 </span>            :         for (const auto&amp; val : json_patch)
<span class="lineNum">   16705 </span>            :         {
<span class="lineNum">   16706 </span>            :             // wrapper to get a value for an operation
<span class="lineNum">   16707 </span>            :             const auto get_value = [&amp;val](const std::string &amp; op,
<span class="lineNum">   16708 </span>            :                                           const std::string &amp; member,
<span class="lineNum">   16709 </span>            :                                           bool string_type) -&gt; basic_json &amp;
<span class="lineNum">   16710 </span>            :             {
<span class="lineNum">   16711 </span>            :                 // find value
<span class="lineNum">   16712 </span>            :                 auto it = val.m_value.object-&gt;find(member);
<span class="lineNum">   16713 </span>            : 
<span class="lineNum">   16714 </span>            :                 // context-sensitive error message
<span class="lineNum">   16715 </span>            :                 const auto error_msg = (op == &quot;op&quot;) ? &quot;operation&quot; : &quot;operation '&quot; + op + &quot;'&quot;;
<span class="lineNum">   16716 </span>            : 
<span class="lineNum">   16717 </span>            :                 // check if desired value is present
<span class="lineNum">   16718 </span>            :                 if (JSON_UNLIKELY(it == val.m_value.object-&gt;end()))
<span class="lineNum">   16719 </span>            :                 {
<span class="lineNum">   16720 </span>            :                     JSON_THROW(parse_error::create(105, 0, error_msg + &quot; must have member '&quot; + member + &quot;'&quot;));
<span class="lineNum">   16721 </span>            :                 }
<span class="lineNum">   16722 </span>            : 
<span class="lineNum">   16723 </span>            :                 // check if result is of type string
<span class="lineNum">   16724 </span>            :                 if (JSON_UNLIKELY(string_type and not it-&gt;second.is_string()))
<span class="lineNum">   16725 </span>            :                 {
<span class="lineNum">   16726 </span>            :                     JSON_THROW(parse_error::create(105, 0, error_msg + &quot; must have string member '&quot; + member + &quot;'&quot;));
<span class="lineNum">   16727 </span>            :                 }
<span class="lineNum">   16728 </span>            : 
<span class="lineNum">   16729 </span>            :                 // no error: return value
<span class="lineNum">   16730 </span>            :                 return it-&gt;second;
<span class="lineNum">   16731 </span>            :             };
<span class="lineNum">   16732 </span>            : 
<span class="lineNum">   16733 </span>            :             // type check: every element of the array must be an object
<span class="lineNum">   16734 </span>            :             if (JSON_UNLIKELY(not val.is_object()))
<span class="lineNum">   16735 </span>            :             {
<span class="lineNum">   16736 </span>            :                 JSON_THROW(parse_error::create(104, 0, &quot;JSON patch must be an array of objects&quot;));
<span class="lineNum">   16737 </span>            :             }
<span class="lineNum">   16738 </span>            : 
<span class="lineNum">   16739 </span>            :             // collect mandatory members
<span class="lineNum">   16740 </span>            :             const std::string op = get_value(&quot;op&quot;, &quot;op&quot;, true);
<span class="lineNum">   16741 </span>            :             const std::string path = get_value(op, &quot;path&quot;, true);
<span class="lineNum">   16742 </span>            :             json_pointer ptr(path);
<span class="lineNum">   16743 </span>            : 
<span class="lineNum">   16744 </span>            :             switch (get_op(op))
<span class="lineNum">   16745 </span>            :             {
<span class="lineNum">   16746 </span>            :                 case patch_operations::add:
<span class="lineNum">   16747 </span>            :                 {
<span class="lineNum">   16748 </span>            :                     operation_add(ptr, get_value(&quot;add&quot;, &quot;value&quot;, false));
<span class="lineNum">   16749 </span>            :                     break;
<span class="lineNum">   16750 </span>            :                 }
<span class="lineNum">   16751 </span>            : 
<span class="lineNum">   16752 </span>            :                 case patch_operations::remove:
<span class="lineNum">   16753 </span>            :                 {
<span class="lineNum">   16754 </span>            :                     operation_remove(ptr);
<span class="lineNum">   16755 </span>            :                     break;
<span class="lineNum">   16756 </span>            :                 }
<span class="lineNum">   16757 </span>            : 
<span class="lineNum">   16758 </span>            :                 case patch_operations::replace:
<span class="lineNum">   16759 </span>            :                 {
<span class="lineNum">   16760 </span>            :                     // the &quot;path&quot; location must exist - use at()
<span class="lineNum">   16761 </span>            :                     result.at(ptr) = get_value(&quot;replace&quot;, &quot;value&quot;, false);
<span class="lineNum">   16762 </span>            :                     break;
<span class="lineNum">   16763 </span>            :                 }
<span class="lineNum">   16764 </span>            : 
<span class="lineNum">   16765 </span>            :                 case patch_operations::move:
<span class="lineNum">   16766 </span>            :                 {
<span class="lineNum">   16767 </span>            :                     const std::string from_path = get_value(&quot;move&quot;, &quot;from&quot;, true);
<span class="lineNum">   16768 </span>            :                     json_pointer from_ptr(from_path);
<span class="lineNum">   16769 </span>            : 
<span class="lineNum">   16770 </span>            :                     // the &quot;from&quot; location must exist - use at()
<span class="lineNum">   16771 </span>            :                     basic_json v = result.at(from_ptr);
<span class="lineNum">   16772 </span>            : 
<span class="lineNum">   16773 </span>            :                     // The move operation is functionally identical to a
<span class="lineNum">   16774 </span>            :                     // &quot;remove&quot; operation on the &quot;from&quot; location, followed
<span class="lineNum">   16775 </span>            :                     // immediately by an &quot;add&quot; operation at the target
<span class="lineNum">   16776 </span>            :                     // location with the value that was just removed.
<span class="lineNum">   16777 </span>            :                     operation_remove(from_ptr);
<span class="lineNum">   16778 </span>            :                     operation_add(ptr, v);
<span class="lineNum">   16779 </span>            :                     break;
<span class="lineNum">   16780 </span>            :                 }
<span class="lineNum">   16781 </span>            : 
<span class="lineNum">   16782 </span>            :                 case patch_operations::copy:
<span class="lineNum">   16783 </span>            :                 {
<span class="lineNum">   16784 </span>            :                     const std::string from_path = get_value(&quot;copy&quot;, &quot;from&quot;, true);
<span class="lineNum">   16785 </span>            :                     const json_pointer from_ptr(from_path);
<span class="lineNum">   16786 </span>            : 
<span class="lineNum">   16787 </span>            :                     // the &quot;from&quot; location must exist - use at()
<span class="lineNum">   16788 </span>            :                     basic_json v = result.at(from_ptr);
<span class="lineNum">   16789 </span>            : 
<span class="lineNum">   16790 </span>            :                     // The copy is functionally identical to an &quot;add&quot;
<span class="lineNum">   16791 </span>            :                     // operation at the target location using the value
<span class="lineNum">   16792 </span>            :                     // specified in the &quot;from&quot; member.
<span class="lineNum">   16793 </span>            :                     operation_add(ptr, v);
<span class="lineNum">   16794 </span>            :                     break;
<span class="lineNum">   16795 </span>            :                 }
<span class="lineNum">   16796 </span>            : 
<span class="lineNum">   16797 </span>            :                 case patch_operations::test:
<span class="lineNum">   16798 </span>            :                 {
<span class="lineNum">   16799 </span>            :                     bool success = false;
<span class="lineNum">   16800 </span>            :                     JSON_TRY
<span class="lineNum">   16801 </span>            :                     {
<span class="lineNum">   16802 </span>            :                         // check if &quot;value&quot; matches the one at &quot;path&quot;
<span class="lineNum">   16803 </span>            :                         // the &quot;path&quot; location must exist - use at()
<span class="lineNum">   16804 </span>            :                         success = (result.at(ptr) == get_value(&quot;test&quot;, &quot;value&quot;, false));
<span class="lineNum">   16805 </span>            :                     }
<span class="lineNum">   16806 </span>            :                     JSON_CATCH (out_of_range&amp;)
<span class="lineNum">   16807 </span>            :                     {
<span class="lineNum">   16808 </span>            :                         // ignore out of range errors: success remains false
<span class="lineNum">   16809 </span>            :                     }
<span class="lineNum">   16810 </span>            : 
<span class="lineNum">   16811 </span>            :                     // throw an exception if test fails
<span class="lineNum">   16812 </span>            :                     if (JSON_UNLIKELY(not success))
<span class="lineNum">   16813 </span>            :                     {
<span class="lineNum">   16814 </span>            :                         JSON_THROW(other_error::create(501, &quot;unsuccessful: &quot; + val.dump()));
<span class="lineNum">   16815 </span>            :                     }
<span class="lineNum">   16816 </span>            : 
<span class="lineNum">   16817 </span>            :                     break;
<span class="lineNum">   16818 </span>            :                 }
<span class="lineNum">   16819 </span>            : 
<span class="lineNum">   16820 </span>            :                 case patch_operations::invalid:
<span class="lineNum">   16821 </span>            :                 {
<span class="lineNum">   16822 </span>            :                     // op must be &quot;add&quot;, &quot;remove&quot;, &quot;replace&quot;, &quot;move&quot;, &quot;copy&quot;, or
<span class="lineNum">   16823 </span>            :                     // &quot;test&quot;
<span class="lineNum">   16824 </span>            :                     JSON_THROW(parse_error::create(105, 0, &quot;operation value '&quot; + op + &quot;' is invalid&quot;));
<span class="lineNum">   16825 </span>            :                 }
<span class="lineNum">   16826 </span>            :             }
<span class="lineNum">   16827 </span>            :         }
<span class="lineNum">   16828 </span>            : 
<span class="lineNum">   16829 </span>            :         return result;
<span class="lineNum">   16830 </span>            :     }
<span class="lineNum">   16831 </span>            : 
<span class="lineNum">   16832 </span>            :     /*!
<span class="lineNum">   16833 </span>            :     @brief creates a diff as a JSON patch
<span class="lineNum">   16834 </span>            : 
<span class="lineNum">   16835 </span>            :     Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
<span class="lineNum">   16836 </span>            :     be changed into the value @a target by calling @ref patch function.
<span class="lineNum">   16837 </span>            : 
<span class="lineNum">   16838 </span>            :     @invariant For two JSON values @a source and @a target, the following code
<span class="lineNum">   16839 </span>            :     yields always `true`:
<span class="lineNum">   16840 </span>            :     @code {.cpp}
<span class="lineNum">   16841 </span>            :     source.patch(diff(source, target)) == target;
<span class="lineNum">   16842 </span>            :     @endcode
<span class="lineNum">   16843 </span>            : 
<span class="lineNum">   16844 </span>            :     @note Currently, only `remove`, `add`, and `replace` operations are
<span class="lineNum">   16845 </span>            :           generated.
<span class="lineNum">   16846 </span>            : 
<span class="lineNum">   16847 </span>            :     @param[in] source  JSON value to compare from
<span class="lineNum">   16848 </span>            :     @param[in] target  JSON value to compare against
<span class="lineNum">   16849 </span>            :     @param[in] path    helper value to create JSON pointers
<span class="lineNum">   16850 </span>            : 
<span class="lineNum">   16851 </span>            :     @return a JSON patch to convert the @a source to @a target
<span class="lineNum">   16852 </span>            : 
<span class="lineNum">   16853 </span>            :     @complexity Linear in the lengths of @a source and @a target.
<span class="lineNum">   16854 </span>            : 
<span class="lineNum">   16855 </span>            :     @liveexample{The following code shows how a JSON patch is created as a
<span class="lineNum">   16856 </span>            :     diff for two JSON values.,diff}
<span class="lineNum">   16857 </span>            : 
<span class="lineNum">   16858 </span>            :     @sa @ref patch -- apply a JSON patch
<span class="lineNum">   16859 </span>            :     @sa @ref merge_patch -- apply a JSON Merge Patch
<span class="lineNum">   16860 </span>            : 
<span class="lineNum">   16861 </span>            :     @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
<span class="lineNum">   16862 </span>            : 
<span class="lineNum">   16863 </span>            :     @since version 2.0.0
<span class="lineNum">   16864 </span>            :     */
<span class="lineNum">   16865 </span>            :     static basic_json diff(const basic_json&amp; source, const basic_json&amp; target,
<span class="lineNum">   16866 </span>            :                            const std::string&amp; path = &quot;&quot;)
<span class="lineNum">   16867 </span>            :     {
<span class="lineNum">   16868 </span>            :         // the patch
<span class="lineNum">   16869 </span>            :         basic_json result(value_t::array);
<span class="lineNum">   16870 </span>            : 
<span class="lineNum">   16871 </span>            :         // if the values are the same, return empty patch
<span class="lineNum">   16872 </span>            :         if (source == target)
<span class="lineNum">   16873 </span>            :         {
<span class="lineNum">   16874 </span>            :             return result;
<span class="lineNum">   16875 </span>            :         }
<span class="lineNum">   16876 </span>            : 
<span class="lineNum">   16877 </span>            :         if (source.type() != target.type())
<span class="lineNum">   16878 </span>            :         {
<span class="lineNum">   16879 </span>            :             // different types: replace value
<span class="lineNum">   16880 </span>            :             result.push_back(
<span class="lineNum">   16881 </span>            :             {
<span class="lineNum">   16882 </span>            :                 {&quot;op&quot;, &quot;replace&quot;}, {&quot;path&quot;, path}, {&quot;value&quot;, target}
<span class="lineNum">   16883 </span>            :             });
<span class="lineNum">   16884 </span>            :         }
<span class="lineNum">   16885 </span>            :         else
<span class="lineNum">   16886 </span>            :         {
<span class="lineNum">   16887 </span>            :             switch (source.type())
<span class="lineNum">   16888 </span>            :             {
<span class="lineNum">   16889 </span>            :                 case value_t::array:
<span class="lineNum">   16890 </span>            :                 {
<span class="lineNum">   16891 </span>            :                     // first pass: traverse common elements
<span class="lineNum">   16892 </span>            :                     std::size_t i = 0;
<span class="lineNum">   16893 </span>            :                     while (i &lt; source.size() and i &lt; target.size())
<span class="lineNum">   16894 </span>            :                     {
<span class="lineNum">   16895 </span>            :                         // recursive call to compare array values at index i
<span class="lineNum">   16896 </span>            :                         auto temp_diff = diff(source[i], target[i], path + &quot;/&quot; + std::to_string(i));
<span class="lineNum">   16897 </span>            :                         result.insert(result.end(), temp_diff.begin(), temp_diff.end());
<span class="lineNum">   16898 </span>            :                         ++i;
<span class="lineNum">   16899 </span>            :                     }
<span class="lineNum">   16900 </span>            : 
<span class="lineNum">   16901 </span>            :                     // i now reached the end of at least one array
<span class="lineNum">   16902 </span>            :                     // in a second pass, traverse the remaining elements
<span class="lineNum">   16903 </span>            : 
<span class="lineNum">   16904 </span>            :                     // remove my remaining elements
<span class="lineNum">   16905 </span>            :                     const auto end_index = static_cast&lt;difference_type&gt;(result.size());
<span class="lineNum">   16906 </span>            :                     while (i &lt; source.size())
<span class="lineNum">   16907 </span>            :                     {
<span class="lineNum">   16908 </span>            :                         // add operations in reverse order to avoid invalid
<span class="lineNum">   16909 </span>            :                         // indices
<span class="lineNum">   16910 </span>            :                         result.insert(result.begin() + end_index, object(
<span class="lineNum">   16911 </span>            :                         {
<span class="lineNum">   16912 </span>            :                             {&quot;op&quot;, &quot;remove&quot;},
<span class="lineNum">   16913 </span>            :                             {&quot;path&quot;, path + &quot;/&quot; + std::to_string(i)}
<span class="lineNum">   16914 </span>            :                         }));
<span class="lineNum">   16915 </span>            :                         ++i;
<span class="lineNum">   16916 </span>            :                     }
<span class="lineNum">   16917 </span>            : 
<span class="lineNum">   16918 </span>            :                     // add other remaining elements
<span class="lineNum">   16919 </span>            :                     while (i &lt; target.size())
<span class="lineNum">   16920 </span>            :                     {
<span class="lineNum">   16921 </span>            :                         result.push_back(
<span class="lineNum">   16922 </span>            :                         {
<span class="lineNum">   16923 </span>            :                             {&quot;op&quot;, &quot;add&quot;},
<span class="lineNum">   16924 </span>            :                             {&quot;path&quot;, path + &quot;/&quot; + std::to_string(i)},
<span class="lineNum">   16925 </span>            :                             {&quot;value&quot;, target[i]}
<span class="lineNum">   16926 </span>            :                         });
<span class="lineNum">   16927 </span>            :                         ++i;
<span class="lineNum">   16928 </span>            :                     }
<span class="lineNum">   16929 </span>            : 
<span class="lineNum">   16930 </span>            :                     break;
<span class="lineNum">   16931 </span>            :                 }
<span class="lineNum">   16932 </span>            : 
<span class="lineNum">   16933 </span>            :                 case value_t::object:
<span class="lineNum">   16934 </span>            :                 {
<span class="lineNum">   16935 </span>            :                     // first pass: traverse this object's elements
<span class="lineNum">   16936 </span>            :                     for (auto it = source.cbegin(); it != source.cend(); ++it)
<span class="lineNum">   16937 </span>            :                     {
<span class="lineNum">   16938 </span>            :                         // escape the key name to be used in a JSON patch
<span class="lineNum">   16939 </span>            :                         const auto key = json_pointer::escape(it.key());
<span class="lineNum">   16940 </span>            : 
<span class="lineNum">   16941 </span>            :                         if (target.find(it.key()) != target.end())
<span class="lineNum">   16942 </span>            :                         {
<span class="lineNum">   16943 </span>            :                             // recursive call to compare object values at key it
<span class="lineNum">   16944 </span>            :                             auto temp_diff = diff(it.value(), target[it.key()], path + &quot;/&quot; + key);
<span class="lineNum">   16945 </span>            :                             result.insert(result.end(), temp_diff.begin(), temp_diff.end());
<span class="lineNum">   16946 </span>            :                         }
<span class="lineNum">   16947 </span>            :                         else
<span class="lineNum">   16948 </span>            :                         {
<span class="lineNum">   16949 </span>            :                             // found a key that is not in o -&gt; remove it
<span class="lineNum">   16950 </span>            :                             result.push_back(object(
<span class="lineNum">   16951 </span>            :                             {
<span class="lineNum">   16952 </span>            :                                 {&quot;op&quot;, &quot;remove&quot;}, {&quot;path&quot;, path + &quot;/&quot; + key}
<span class="lineNum">   16953 </span>            :                             }));
<span class="lineNum">   16954 </span>            :                         }
<span class="lineNum">   16955 </span>            :                     }
<span class="lineNum">   16956 </span>            : 
<span class="lineNum">   16957 </span>            :                     // second pass: traverse other object's elements
<span class="lineNum">   16958 </span>            :                     for (auto it = target.cbegin(); it != target.cend(); ++it)
<span class="lineNum">   16959 </span>            :                     {
<span class="lineNum">   16960 </span>            :                         if (source.find(it.key()) == source.end())
<span class="lineNum">   16961 </span>            :                         {
<span class="lineNum">   16962 </span>            :                             // found a key that is not in this -&gt; add it
<span class="lineNum">   16963 </span>            :                             const auto key = json_pointer::escape(it.key());
<span class="lineNum">   16964 </span>            :                             result.push_back(
<span class="lineNum">   16965 </span>            :                             {
<span class="lineNum">   16966 </span>            :                                 {&quot;op&quot;, &quot;add&quot;}, {&quot;path&quot;, path + &quot;/&quot; + key},
<span class="lineNum">   16967 </span>            :                                 {&quot;value&quot;, it.value()}
<span class="lineNum">   16968 </span>            :                             });
<span class="lineNum">   16969 </span>            :                         }
<span class="lineNum">   16970 </span>            :                     }
<span class="lineNum">   16971 </span>            : 
<span class="lineNum">   16972 </span>            :                     break;
<span class="lineNum">   16973 </span>            :                 }
<span class="lineNum">   16974 </span>            : 
<span class="lineNum">   16975 </span>            :                 default:
<span class="lineNum">   16976 </span>            :                 {
<span class="lineNum">   16977 </span>            :                     // both primitive type: replace value
<span class="lineNum">   16978 </span>            :                     result.push_back(
<span class="lineNum">   16979 </span>            :                     {
<span class="lineNum">   16980 </span>            :                         {&quot;op&quot;, &quot;replace&quot;}, {&quot;path&quot;, path}, {&quot;value&quot;, target}
<span class="lineNum">   16981 </span>            :                     });
<span class="lineNum">   16982 </span>            :                     break;
<span class="lineNum">   16983 </span>            :                 }
<span class="lineNum">   16984 </span>            :             }
<span class="lineNum">   16985 </span>            :         }
<span class="lineNum">   16986 </span>            : 
<span class="lineNum">   16987 </span>            :         return result;
<span class="lineNum">   16988 </span>            :     }
<span class="lineNum">   16989 </span>            : 
<span class="lineNum">   16990 </span>            :     /// @}
<span class="lineNum">   16991 </span>            : 
<span class="lineNum">   16992 </span>            :     ////////////////////////////////
<span class="lineNum">   16993 </span>            :     // JSON Merge Patch functions //
<span class="lineNum">   16994 </span>            :     ////////////////////////////////
<span class="lineNum">   16995 </span>            : 
<span class="lineNum">   16996 </span>            :     /// @name JSON Merge Patch functions
<span class="lineNum">   16997 </span>            :     /// @{
<span class="lineNum">   16998 </span>            : 
<span class="lineNum">   16999 </span>            :     /*!
<span class="lineNum">   17000 </span>            :     @brief applies a JSON Merge Patch
<span class="lineNum">   17001 </span>            : 
<span class="lineNum">   17002 </span>            :     The merge patch format is primarily intended for use with the HTTP PATCH
<span class="lineNum">   17003 </span>            :     method as a means of describing a set of modifications to a target
<span class="lineNum">   17004 </span>            :     resource's content. This function applies a merge patch to the current
<span class="lineNum">   17005 </span>            :     JSON value.
<span class="lineNum">   17006 </span>            : 
<span class="lineNum">   17007 </span>            :     The function implements the following algorithm from Section 2 of
<span class="lineNum">   17008 </span>            :     [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):
<span class="lineNum">   17009 </span>            : 
<span class="lineNum">   17010 </span>            :     ```
<span class="lineNum">   17011 </span>            :     define MergePatch(Target, Patch):
<span class="lineNum">   17012 </span>            :       if Patch is an Object:
<span class="lineNum">   17013 </span>            :         if Target is not an Object:
<span class="lineNum">   17014 </span>            :           Target = {} // Ignore the contents and set it to an empty Object
<span class="lineNum">   17015 </span>            :         for each Name/Value pair in Patch:
<span class="lineNum">   17016 </span>            :           if Value is null:
<span class="lineNum">   17017 </span>            :             if Name exists in Target:
<span class="lineNum">   17018 </span>            :               remove the Name/Value pair from Target
<span class="lineNum">   17019 </span>            :           else:
<span class="lineNum">   17020 </span>            :             Target[Name] = MergePatch(Target[Name], Value)
<span class="lineNum">   17021 </span>            :         return Target
<span class="lineNum">   17022 </span>            :       else:
<span class="lineNum">   17023 </span>            :         return Patch
<span class="lineNum">   17024 </span>            :     ```
<span class="lineNum">   17025 </span>            : 
<span class="lineNum">   17026 </span>            :     Thereby, `Target` is the current object; that is, the patch is applied to
<span class="lineNum">   17027 </span>            :     the current value.
<span class="lineNum">   17028 </span>            : 
<span class="lineNum">   17029 </span>            :     @param[in] patch  the patch to apply
<span class="lineNum">   17030 </span>            : 
<span class="lineNum">   17031 </span>            :     @complexity Linear in the lengths of @a patch.
<span class="lineNum">   17032 </span>            : 
<span class="lineNum">   17033 </span>            :     @liveexample{The following code shows how a JSON Merge Patch is applied to
<span class="lineNum">   17034 </span>            :     a JSON document.,merge_patch}
<span class="lineNum">   17035 </span>            : 
<span class="lineNum">   17036 </span>            :     @sa @ref patch -- apply a JSON patch
<span class="lineNum">   17037 </span>            :     @sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)
<span class="lineNum">   17038 </span>            : 
<span class="lineNum">   17039 </span>            :     @since version 3.0.0
<span class="lineNum">   17040 </span>            :     */
<span class="lineNum">   17041 </span>            :     void merge_patch(const basic_json&amp; patch)
<span class="lineNum">   17042 </span>            :     {
<span class="lineNum">   17043 </span>            :         if (patch.is_object())
<span class="lineNum">   17044 </span>            :         {
<span class="lineNum">   17045 </span>            :             if (not is_object())
<span class="lineNum">   17046 </span>            :             {
<span class="lineNum">   17047 </span>            :                 *this = object();
<span class="lineNum">   17048 </span>            :             }
<span class="lineNum">   17049 </span>            :             for (auto it = patch.begin(); it != patch.end(); ++it)
<span class="lineNum">   17050 </span>            :             {
<span class="lineNum">   17051 </span>            :                 if (it.value().is_null())
<span class="lineNum">   17052 </span>            :                 {
<span class="lineNum">   17053 </span>            :                     erase(it.key());
<span class="lineNum">   17054 </span>            :                 }
<span class="lineNum">   17055 </span>            :                 else
<span class="lineNum">   17056 </span>            :                 {
<span class="lineNum">   17057 </span>            :                     operator[](it.key()).merge_patch(it.value());
<span class="lineNum">   17058 </span>            :                 }
<span class="lineNum">   17059 </span>            :             }
<span class="lineNum">   17060 </span>            :         }
<span class="lineNum">   17061 </span>            :         else
<span class="lineNum">   17062 </span>            :         {
<span class="lineNum">   17063 </span>            :             *this = patch;
<span class="lineNum">   17064 </span>            :         }
<span class="lineNum">   17065 </span>            :     }
<span class="lineNum">   17066 </span>            : 
<span class="lineNum">   17067 </span>            :     /// @}
<span class="lineNum">   17068 </span>            : };
<span class="lineNum">   17069 </span>            : } // namespace nlohmann
<span class="lineNum">   17070 </span>            : 
<span class="lineNum">   17071 </span>            : ///////////////////////
<span class="lineNum">   17072 </span>            : // nonmember support //
<span class="lineNum">   17073 </span>            : ///////////////////////
<span class="lineNum">   17074 </span>            : 
<span class="lineNum">   17075 </span>            : // specialization of std::swap, and std::hash
<span class="lineNum">   17076 </span>            : namespace std
<span class="lineNum">   17077 </span>            : {
<span class="lineNum">   17078 </span>            : /*!
<span class="lineNum">   17079 </span>            : @brief exchanges the values of two JSON objects
<span class="lineNum">   17080 </span>            : 
<span class="lineNum">   17081 </span>            : @since version 1.0.0
<span class="lineNum">   17082 </span>            : */
<span class="lineNum">   17083 </span>            : template&lt;&gt;
<span class="lineNum">   17084 </span>            : inline void swap(rockets_nlohmann::json&amp; j1,
<span class="lineNum">   17085 </span>            :                  rockets_nlohmann::json&amp; j2) noexcept(
<span class="lineNum">   17086 </span>            :                      is_nothrow_move_constructible&lt;rockets_nlohmann::json&gt;::value and
<span class="lineNum">   17087 </span>            :                      is_nothrow_move_assignable&lt;rockets_nlohmann::json&gt;::value
<span class="lineNum">   17088 </span>            :                  )
<span class="lineNum">   17089 </span>            : {
<span class="lineNum">   17090 </span>            :     j1.swap(j2);
<span class="lineNum">   17091 </span>            : }
<span class="lineNum">   17092 </span>            : 
<span class="lineNum">   17093 </span>            : /// hash value for JSON objects
<span class="lineNum">   17094 </span>            : template&lt;&gt;
<span class="lineNum">   17095 </span>            : struct hash&lt;rockets_nlohmann::json&gt;
<span class="lineNum">   17096 </span>            : {
<span class="lineNum">   17097 </span>            :     /*!
<span class="lineNum">   17098 </span>            :     @brief return a hash value for a JSON object
<span class="lineNum">   17099 </span>            : 
<span class="lineNum">   17100 </span>            :     @since version 1.0.0
<span class="lineNum">   17101 </span>            :     */
<span class="lineNum">   17102 </span>            :     std::size_t operator()(const rockets_nlohmann::json&amp; j) const
<span class="lineNum">   17103 </span>            :     {
<span class="lineNum">   17104 </span>            :         // a naive hashing via the string representation
<span class="lineNum">   17105 </span>            :         const auto&amp; h = hash&lt;rockets_nlohmann::json::string_t&gt;();
<span class="lineNum">   17106 </span>            :         return h(j.dump());
<span class="lineNum">   17107 </span>            :     }
<span class="lineNum">   17108 </span>            : };
<span class="lineNum">   17109 </span>            : 
<span class="lineNum">   17110 </span>            : /// specialization for std::less&lt;value_t&gt;
<span class="lineNum">   17111 </span>            : /// @note: do not remove the space after '&lt;',
<span class="lineNum">   17112 </span>            : ///        see https://github.com/nlohmann/json/pull/679
<span class="lineNum">   17113 </span>            : template&lt;&gt;
<span class="lineNum">   17114 </span>            : struct less&lt; ::rockets_nlohmann::detail::value_t&gt;
<span class="lineNum">   17115 </span>            : {
<span class="lineNum">   17116 </span>            :     /*!
<span class="lineNum">   17117 </span>            :     @brief compare two value_t enum values
<span class="lineNum">   17118 </span>            :     @since version 3.0.0
<span class="lineNum">   17119 </span>            :     */
<span class="lineNum">   17120 </span>            :     bool operator()(rockets_nlohmann::detail::value_t lhs,
<span class="lineNum">   17121 </span>            :                     rockets_nlohmann::detail::value_t rhs) const noexcept
<span class="lineNum">   17122 </span>            :     {
<span class="lineNum">   17123 </span>            :         return rockets_nlohmann::detail::operator&lt;(lhs, rhs);
<span class="lineNum">   17124 </span>            :     }
<span class="lineNum">   17125 </span>            : };
<span class="lineNum">   17126 </span>            : 
<span class="lineNum">   17127 </span>            : } // namespace std
<span class="lineNum">   17128 </span>            : 
<span class="lineNum">   17129 </span>            : /*!
<span class="lineNum">   17130 </span>            : @brief user-defined string literal for JSON values
<span class="lineNum">   17131 </span>            : 
<span class="lineNum">   17132 </span>            : This operator implements a user-defined string literal for JSON objects. It
<span class="lineNum">   17133 </span>            : can be used by adding `&quot;_json&quot;` to a string literal and returns a JSON object
<span class="lineNum">   17134 </span>            : if no parse error occurred.
<span class="lineNum">   17135 </span>            : 
<span class="lineNum">   17136 </span>            : @param[in] s  a string representation of a JSON object
<span class="lineNum">   17137 </span>            : @param[in] n  the length of string @a s
<span class="lineNum">   17138 </span>            : @return a JSON object
<span class="lineNum">   17139 </span>            : 
<span class="lineNum">   17140 </span>            : @since version 1.0.0
<span class="lineNum">   17141 </span>            : */
<span class="lineNum">   17142 </span>            : inline rockets_nlohmann::json operator &quot;&quot; _json(const char* s, std::size_t n)
<span class="lineNum">   17143 </span>            : {
<span class="lineNum">   17144 </span>            :     return rockets_nlohmann::json::parse(s, s + n);
<span class="lineNum">   17145 </span>            : }
<span class="lineNum">   17146 </span>            : 
<span class="lineNum">   17147 </span>            : /*!
<span class="lineNum">   17148 </span>            : @brief user-defined string literal for JSON pointer
<span class="lineNum">   17149 </span>            : 
<span class="lineNum">   17150 </span>            : This operator implements a user-defined string literal for JSON Pointers. It
<span class="lineNum">   17151 </span>            : can be used by adding `&quot;_json_pointer&quot;` to a string literal and returns a JSON pointer
<span class="lineNum">   17152 </span>            : object if no parse error occurred.
<span class="lineNum">   17153 </span>            : 
<span class="lineNum">   17154 </span>            : @param[in] s  a string representation of a JSON Pointer
<span class="lineNum">   17155 </span>            : @param[in] n  the length of string @a s
<span class="lineNum">   17156 </span>            : @return a JSON pointer object
<span class="lineNum">   17157 </span>            : 
<span class="lineNum">   17158 </span>            : @since version 2.0.0
<span class="lineNum">   17159 </span>            : */
<span class="lineNum">   17160 </span>            : inline rockets_nlohmann::json::json_pointer operator &quot;&quot; _json_pointer(const char* s, std::size_t n)
<span class="lineNum">   17161 </span>            : {
<span class="lineNum">   17162 </span>            :     return rockets_nlohmann::json::json_pointer(std::string(s, n));
<span class="lineNum">   17163 </span>            : }
<span class="lineNum">   17164 </span>            : 
<span class="lineNum">   17165 </span>            : // #include &lt;nlohmann/detail/macro_unscope.hpp&gt;
<span class="lineNum">   17166 </span>            : 
<span class="lineNum">   17167 </span>            : 
<span class="lineNum">   17168 </span>            : // restore GCC/clang diagnostic settings
<span class="lineNum">   17169 </span>            : #if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
<span class="lineNum">   17170 </span>            :     #pragma GCC diagnostic pop
<span class="lineNum">   17171 </span>            : #endif
<span class="lineNum">   17172 </span>            : #if defined(__clang__)
<span class="lineNum">   17173 </span>            :     #pragma GCC diagnostic pop
<span class="lineNum">   17174 </span>            : #endif
<span class="lineNum">   17175 </span>            : 
<span class="lineNum">   17176 </span>            : // clean up
<span class="lineNum">   17177 </span>            : #undef JSON_CATCH
<span class="lineNum">   17178 </span>            : #undef JSON_THROW
<span class="lineNum">   17179 </span>            : #undef JSON_TRY
<span class="lineNum">   17180 </span>            : #undef JSON_LIKELY
<span class="lineNum">   17181 </span>            : #undef JSON_UNLIKELY
<span class="lineNum">   17182 </span>            : #undef JSON_DEPRECATED
<span class="lineNum">   17183 </span>            : #undef JSON_HAS_CPP_14
<span class="lineNum">   17184 </span>            : #undef JSON_HAS_CPP_17
<span class="lineNum">   17185 </span>            : #undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
<span class="lineNum">   17186 </span>            : #undef NLOHMANN_BASIC_JSON_TPL
<span class="lineNum">   17187 </span>            : #undef NLOHMANN_JSON_HAS_HELPER
<span class="lineNum">   17188 </span>            : 
<span class="lineNum">   17189 </span>            : 
<span class="lineNum">   17190 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
