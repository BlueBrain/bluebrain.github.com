<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RTNeuron: bbp::rtneuron::Scene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTNeuron
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classbbp_1_1rtneuron_1_1Scene.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbbp_1_1rtneuron_1_1Scene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bbp::rtneuron::Scene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The scene to be rendered by one or more views.  
 <a href="classbbp_1_1rtneuron_1_1Scene.html#details">More...</a></p>

<p><code>#include &lt;Scene.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for a handler to a target or model added to the scene.  <a href="classbbp_1_1rtneuron_1_1Scene_1_1Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene_1_1ObjectOperation.html">ObjectOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to encapsulate operations that can be performed on scene objects.  <a href="classbbp_1_1rtneuron_1_1Scene_1_1ObjectOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5a8478b55382cd0d86b28c883b6eb39b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a8478b55382cd0d86b28c883b6eb39b"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classbbp_1_1rtneuron_1_1Scene_1_1ObjectOperation.html">ObjectOperation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ObjectOperationPtr</b></td></tr>
<tr class="separator:a5a8478b55382cd0d86b28c883b6eb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aa3b842b3b766ceb98a1080146de05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25aa3b842b3b766ceb98a1080146de05"></a>
typedef std::shared_ptr&lt; <a class="el" href="classbbp_1_1rtneuron_1_1Scene_1_1Object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ObjectPtr</b></td></tr>
<tr class="separator:a25aa3b842b3b766ceb98a1080146de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e0ce383621e24b645e2424d423a8a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e0ce383621e24b645e2424d423a8a3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_SIGNAL</b> (CellSelected, uint32_t, uint16_t, uint16_t)</td></tr>
<tr class="separator:a6e0ce383621e24b645e2424d423a8a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac0aad4a8c1eb8ab764ec722cbc7992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ac0aad4a8c1eb8ab764ec722cbc7992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_SIGNAL</b> (CellSetSelected, const GIDSet &amp;)</td></tr>
<tr class="separator:a1ac0aad4a8c1eb8ab764ec722cbc7992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af351101cf8e577f7850d6d44f3a426e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af351101cf8e577f7850d6d44f3a426e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_SIGNAL</b> (Progress, const std::string &amp;, size_t, size_t)</td></tr>
<tr class="separator:af351101cf8e577f7850d6d44f3a426e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b3fcad0892bead7a71a5d52943eee3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b3fcad0892bead7a71a5d52943eee3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_SIGNAL</b> (Dirty, bool)</td></tr>
<tr class="separator:af2b3fcad0892bead7a71a5d52943eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a52a29099236fb230e614ddc78774e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a52a29099236fb230e614ddc78774e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_SIGNAL</b> (SimulationUpdated, float)</td></tr>
<tr class="separator:a3a52a29099236fb230e614ddc78774e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a7758dd19d11bb1588acc11eba2800"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07a7758dd19d11bb1588acc11eba2800"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (const <a class="el" href="classbbp_1_1rtneuron_1_1Scene.html">Scene</a> &amp;)=delete</td></tr>
<tr class="separator:a07a7758dd19d11bb1588acc11eba2800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daa2b6d3fbffe640497aeaa7bb59de3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8daa2b6d3fbffe640497aeaa7bb59de3"></a>
<a class="el" href="classbbp_1_1rtneuron_1_1Scene.html">Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classbbp_1_1rtneuron_1_1Scene.html">Scene</a> &amp;)=delete</td></tr>
<tr class="separator:a8daa2b6d3fbffe640497aeaa7bb59de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a194a1b27fee3b94a9c135c0435ec2fa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194a1b27fee3b94a9c135c0435ec2fa5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a194a1b27fee3b94a9c135c0435ec2fa5">Scene</a> (const RTNeuronPtr &amp;application, const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:a194a1b27fee3b94a9c135c0435ec2fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to be invoked by <a class="el" href="classbbp_1_1rtneuron_1_1RTNeuron.html" title="The main application class. ">RTNeuron</a> class. <br /></td></tr>
<tr class="separator:a194a1b27fee3b94a9c135c0435ec2fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2785b46315634306e06b613599ec0fbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2785b46315634306e06b613599ec0fbc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RTNeuron</b></td></tr>
<tr class="separator:a2785b46315634306e06b613599ec0fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018ff8a950133459fda57a235706a80b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018ff8a950133459fda57a235706a80b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>View</b></td></tr>
<tr class="separator:a018ff8a950133459fda57a235706a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
C++ public interface wrapped in Python</h2></td></tr>
<tr class="memitem:a9159c7a54362edbdcba1813752436ccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9159c7a54362edbdcba1813752436ccc"></a>
CellSelectedSignal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a9159c7a54362edbdcba1813752436ccc">cellSelected</a></td></tr>
<tr class="memdesc:a9159c7a54362edbdcba1813752436ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal emitted when a cell is selected by pick. <br /></td></tr>
<tr class="separator:a9159c7a54362edbdcba1813752436ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049762e408792d251a6a19d532b692af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a049762e408792d251a6a19d532b692af"></a>
CellSetSelectedSignal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a049762e408792d251a6a19d532b692af">cellSetSelected</a></td></tr>
<tr class="memdesc:a049762e408792d251a6a19d532b692af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal emitted when a group of cells is selected by pick. <br /></td></tr>
<tr class="separator:a049762e408792d251a6a19d532b692af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c135e53b743b8aad9454a274fddcdeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c135e53b743b8aad9454a274fddcdeb"></a>
SynapseSelectedSignal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a5c135e53b743b8aad9454a274fddcdeb">synapseSelected</a></td></tr>
<tr class="memdesc:a5c135e53b743b8aad9454a274fddcdeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal emitted when a synapse is selected by pick. <br /></td></tr>
<tr class="separator:a5c135e53b743b8aad9454a274fddcdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2693955c0935f4548aea8a0b9c4e5cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a2693955c0935f4548aea8a0b9c4e5cc7">getAttributes</a> ()</td></tr>
<tr class="memdesc:a2693955c0935f4548aea8a0b9c4e5cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The runtime configurable attribute map.  <a href="#a2693955c0935f4548aea8a0b9c4e5cc7">More...</a><br /></td></tr>
<tr class="separator:a2693955c0935f4548aea8a0b9c4e5cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ffddb8fb995eb06cb81660c77e5c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a19ffddb8fb995eb06cb81660c77e5c8b">setCircuit</a> (const CircuitPtr &amp;circuit)</td></tr>
<tr class="memdesc:a19ffddb8fb995eb06cb81660c77e5c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the brain::Circuit to be used for this scene.  <a href="#a19ffddb8fb995eb06cb81660c77e5c8b">More...</a><br /></td></tr>
<tr class="separator:a19ffddb8fb995eb06cb81660c77e5c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9e340edb91479315f057ebf9550386"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b9e340edb91479315f057ebf9550386"></a>
CircuitPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a0b9e340edb91479315f057ebf9550386">getCircuit</a> () const </td></tr>
<tr class="memdesc:a0b9e340edb91479315f057ebf9550386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current brain::Circuit to be used for this scene. <br /></td></tr>
<tr class="separator:a0b9e340edb91479315f057ebf9550386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fdc528c9713dc34c3dfc985921230c"><td class="memItemLeft" align="right" valign="top">ObjectPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a68fdc528c9713dc34c3dfc985921230c">addNeurons</a> (const GIDSet &amp;gids, const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:a68fdc528c9713dc34c3dfc985921230c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of neurons to the scene.  <a href="#a68fdc528c9713dc34c3dfc985921230c">More...</a><br /></td></tr>
<tr class="separator:a68fdc528c9713dc34c3dfc985921230c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4707d2ca31640d938e236a903dc340"><td class="memItemLeft" align="right" valign="top">ObjectPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a1c4707d2ca31640d938e236a903dc340">addAfferentSynapses</a> (const brain::Synapses &amp;synapses, const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:a1c4707d2ca31640d938e236a903dc340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a set of synapse glyphs at their post-synaptic locations to the scene.  <a href="#a1c4707d2ca31640d938e236a903dc340">More...</a><br /></td></tr>
<tr class="separator:a1c4707d2ca31640d938e236a903dc340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5fe906285e4f8a6a6230a7de51017"><td class="memItemLeft" align="right" valign="top">ObjectPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#aa0e5fe906285e4f8a6a6230a7de51017">addEfferentSynapses</a> (const brain::Synapses &amp;synapses, const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:aa0e5fe906285e4f8a6a6230a7de51017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a set of synapse glyphs at their pre-synaptic locations to the scene.  <a href="#aa0e5fe906285e4f8a6a6230a7de51017">More...</a><br /></td></tr>
<tr class="separator:aa0e5fe906285e4f8a6a6230a7de51017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8543ab4df800225c69cb690bcf9816ff"><td class="memItemLeft" align="right" valign="top">ObjectPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a8543ab4df800225c69cb690bcf9816ff">addModel</a> (const char *filename, const Matrix4f &amp;transform, const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:a8543ab4df800225c69cb690bcf9816ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a 3D model from a file and adds it to the scene.  <a href="#a8543ab4df800225c69cb690bcf9816ff">More...</a><br /></td></tr>
<tr class="separator:a8543ab4df800225c69cb690bcf9816ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc864b838db3d07a563323542669f80"><td class="memItemLeft" align="right" valign="top">ObjectPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a1bc864b838db3d07a563323542669f80">addModel</a> (const char *filename, const char *transform=&quot;&quot;, const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:a1bc864b838db3d07a563323542669f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of the function above.  <a href="#a1bc864b838db3d07a563323542669f80">More...</a><br /></td></tr>
<tr class="separator:a1bc864b838db3d07a563323542669f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af749e837d677eaf8fdd2d54374fc1b03"><td class="memItemLeft" align="right" valign="top">ObjectPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#af749e837d677eaf8fdd2d54374fc1b03">addGeometry</a> (const osg::ref_ptr&lt; osg::Array &gt; &amp;vertices, const osg::ref_ptr&lt; osg::DrawElementsUInt &gt; &amp;primitive=osg::ref_ptr&lt; osg::DrawElementsUInt &gt;(), const osg::ref_ptr&lt; osg::Vec4Array &gt; &amp;colors=osg::ref_ptr&lt; osg::Vec3Array &gt;(), const osg::ref_ptr&lt; osg::Vec3Array &gt; &amp;normals=osg::ref_ptr&lt; osg::Vec3Array &gt;(), const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;attributes=<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>())</td></tr>
<tr class="memdesc:af749e837d677eaf8fdd2d54374fc1b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds geometry described as vertices and faces to the scene.  <a href="#af749e837d677eaf8fdd2d54374fc1b03">More...</a><br /></td></tr>
<tr class="separator:af749e837d677eaf8fdd2d54374fc1b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5289d56ad5685b95e8d140c36c42e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#ae5289d56ad5685b95e8d140c36c42e0a">update</a> ()</td></tr>
<tr class="memdesc:ae5289d56ad5685b95e8d140c36c42e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use when auto_update is false to trigger the scene update.  <a href="#ae5289d56ad5685b95e8d140c36c42e0a">More...</a><br /></td></tr>
<tr class="separator:ae5289d56ad5685b95e8d140c36c42e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf251b073c8b7f802906422275c121d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ObjectPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#abf251b073c8b7f802906422275c121d4">getObjects</a> ()</td></tr>
<tr class="memdesc:abf251b073c8b7f802906422275c121d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handlers to all objects added to the scene.  <a href="#abf251b073c8b7f802906422275c121d4">More...</a><br /></td></tr>
<tr class="separator:abf251b073c8b7f802906422275c121d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329d0a163983de5f738a314ce5f25367"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a329d0a163983de5f738a314ce5f25367"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a329d0a163983de5f738a314ce5f25367">remove</a> (const ObjectPtr &amp;object)</td></tr>
<tr class="memdesc:a329d0a163983de5f738a314ce5f25367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a target/model from the scene given its handler. <br /></td></tr>
<tr class="separator:a329d0a163983de5f738a314ce5f25367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1821a772691886aa61923daae68308d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a1821a772691886aa61923daae68308d0">clear</a> ()</td></tr>
<tr class="memdesc:a1821a772691886aa61923daae68308d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the objects from the scene.  <a href="#a1821a772691886aa61923daae68308d0">More...</a><br /></td></tr>
<tr class="separator:a1821a772691886aa61923daae68308d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4829b380008f09f2aee34d5d149814c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a4829b380008f09f2aee34d5d149814c5">highlight</a> (const GIDSet &amp;gids, bool on)</td></tr>
<tr class="memdesc:a4829b380008f09f2aee34d5d149814c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle highlighing of a cell set.  <a href="#a4829b380008f09f2aee34d5d149814c5">More...</a><br /></td></tr>
<tr class="separator:a4829b380008f09f2aee34d5d149814c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae352820e4f902a99dcbce4faf62eeda8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae352820e4f902a99dcbce4faf62eeda8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#ae352820e4f902a99dcbce4faf62eeda8">setNeuronSelectionMask</a> (const GIDSet &amp;gids)</td></tr>
<tr class="memdesc:ae352820e4f902a99dcbce4faf62eeda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the set of unselectable cells. <br /></td></tr>
<tr class="separator:ae352820e4f902a99dcbce4faf62eeda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372ed2496b9b26834498ebbec6b61a40"><td class="memItemLeft" align="right" valign="top">const GIDSet &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a372ed2496b9b26834498ebbec6b61a40">getNeuronSelectionMask</a> () const </td></tr>
<tr class="memdesc:a372ed2496b9b26834498ebbec6b61a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of unselectable cells.  <a href="#a372ed2496b9b26834498ebbec6b61a40">More...</a><br /></td></tr>
<tr class="separator:a372ed2496b9b26834498ebbec6b61a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827d526e6484597606547e67275e3099"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a827d526e6484597606547e67275e3099"></a>
const GIDSet &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a827d526e6484597606547e67275e3099">getHighlightedNeurons</a> () const </td></tr>
<tr class="memdesc:a827d526e6484597606547e67275e3099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the gids of the highlighted neurons. <br /></td></tr>
<tr class="separator:a827d526e6484597606547e67275e3099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01a47cfb6e06a2a0700137ce2c0044e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab01a47cfb6e06a2a0700137ce2c0044e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#ab01a47cfb6e06a2a0700137ce2c0044e">setSimulation</a> (const CompartmentReportPtr &amp;report)</td></tr>
<tr class="memdesc:ab01a47cfb6e06a2a0700137ce2c0044e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread safe with regard to the rendering loop. <br /></td></tr>
<tr class="separator:ab01a47cfb6e06a2a0700137ce2c0044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c67d259f3b2bb4968807555e0c7d1dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c67d259f3b2bb4968807555e0c7d1dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a1c67d259f3b2bb4968807555e0c7d1dd">setSimulation</a> (const SpikeReportReaderPtr &amp;report)</td></tr>
<tr class="memdesc:a1c67d259f3b2bb4968807555e0c7d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread safe with regard to the rendering loop. <br /></td></tr>
<tr class="separator:a1c67d259f3b2bb4968807555e0c7d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f99c193f4ffac2d36d245d208b3f37f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a6f99c193f4ffac2d36d245d208b3f37f">pick</a> (const Vector3f &amp;origin, const Vector3f &amp;direction) const </td></tr>
<tr class="memdesc:a6f99c193f4ffac2d36d245d208b3f37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection test between the pointer ray and the scene elements.  <a href="#a6f99c193f4ffac2d36d245d208b3f37f">More...</a><br /></td></tr>
<tr class="separator:a6f99c193f4ffac2d36d245d208b3f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62104763faf0c71b4071caf3dc0d2944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a62104763faf0c71b4071caf3dc0d2944">pick</a> (const <a class="el" href="classbbp_1_1rtneuron_1_1View.html">View</a> &amp;view, float left, float right, float bottom, float top) const </td></tr>
<tr class="memdesc:a62104763faf0c71b4071caf3dc0d2944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection test of the space region selected by a rectangular area projected using the camera from the given view.  <a href="#a62104763faf0c71b4071caf3dc0d2944">More...</a><br /></td></tr>
<tr class="separator:a62104763faf0c71b4071caf3dc0d2944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128d0943e757bff167ac36fe68d1b3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a128d0943e757bff167ac36fe68d1b3e9">setClipPlane</a> (unsigned int index, const Vector4f &amp;plane)</td></tr>
<tr class="memdesc:a128d0943e757bff167ac36fe68d1b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or modifies a clipping plane.  <a href="#a128d0943e757bff167ac36fe68d1b3e9">More...</a><br /></td></tr>
<tr class="separator:a128d0943e757bff167ac36fe68d1b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfd1bdfacb9668fb6694c7a97ff24a2"><td class="memItemLeft" align="right" valign="top">Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#acdfd1bdfacb9668fb6694c7a97ff24a2">getClipPlane</a> (unsigned int index) const </td></tr>
<tr class="memdesc:acdfd1bdfacb9668fb6694c7a97ff24a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the clip plane with a given index.  <a href="#acdfd1bdfacb9668fb6694c7a97ff24a2">More...</a><br /></td></tr>
<tr class="separator:acdfd1bdfacb9668fb6694c7a97ff24a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4f7df4ddbb92f5cae966a36e18bf05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c4f7df4ddbb92f5cae966a36e18bf05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearClipPlanes</b> ()</td></tr>
<tr class="separator:a8c4f7df4ddbb92f5cae966a36e18bf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafdb648491bb2519d7236b722636459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#aeafdb648491bb2519d7236b722636459">getCircuitSceneBoundingSphere</a> () const </td></tr>
<tr class="separator:aeafdb648491bb2519d7236b722636459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8db1325dd07b614ba9cb0065579be05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#aa8db1325dd07b614ba9cb0065579be05">getSomasBoundingSphere</a> () const </td></tr>
<tr class="separator:aa8db1325dd07b614ba9cb0065579be05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30c482a16b2767da51f6f72df805837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#ae30c482a16b2767da51f6f72df805837">getSynapsesBoundingSphere</a> () const </td></tr>
<tr class="separator:ae30c482a16b2767da51f6f72df805837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1236f85be13b9cbeedef48d5073ec929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1236f85be13b9cbeedef48d5073ec929"></a>
<a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getExtraModelsBoundingSphere</b> () const </td></tr>
<tr class="separator:a1236f85be13b9cbeedef48d5073ec929"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
C++ only public interface</h2></td></tr>
<tr class="memitem:a64a005aa0ee68bed724454a867357e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64a005aa0ee68bed724454a867357e08"></a>
ProgressSignal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a64a005aa0ee68bed724454a867357e08">progress</a></td></tr>
<tr class="memdesc:a64a005aa0ee68bed724454a867357e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted as scene loading/creation advances. <br /></td></tr>
<tr class="separator:a64a005aa0ee68bed724454a867357e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c37bb1a013cd4849f302a9b8710a7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4c37bb1a013cd4849f302a9b8710a7a"></a>
DirtySignal&#160;</td><td class="memItemRight" valign="bottom"><b>dirty</b></td></tr>
<tr class="separator:ae4c37bb1a013cd4849f302a9b8710a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f72a6a4ab349864d612bda8d8632e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f72a6a4ab349864d612bda8d8632e9"></a>
SimulationUpdatedSignal&#160;</td><td class="memItemRight" valign="bottom"><b>simulationUpdated</b></td></tr>
<tr class="separator:a73f72a6a4ab349864d612bda8d8632e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056516d88f5a07a966c08237984f1f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a056516d88f5a07a966c08237984f1f4b">mapSimulation</a> (uint32_t frameNumber, float millisecond)</td></tr>
<tr class="memdesc:a056516d88f5a07a966c08237984f1f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the simulation timestamp to be available for the given frame number.  <a href="#a056516d88f5a07a966c08237984f1f4b">More...</a><br /></td></tr>
<tr class="separator:a056516d88f5a07a966c08237984f1f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a3bb592ed79645e312c53df4a4582c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a83a3bb592ed79645e312c53df4a4582c">prepareSimulation</a> (uint32_t frameNumber, float millisecond)</td></tr>
<tr class="memdesc:a83a3bb592ed79645e312c53df4a4582c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger the simulation data mapper to map simulation data to be used for a given frame.  <a href="#a83a3bb592ed79645e312c53df4a4582c">More...</a><br /></td></tr>
<tr class="separator:a83a3bb592ed79645e312c53df4a4582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c4f5ee36fab983f810ec65ec7bff91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28c4f5ee36fab983f810ec65ec7bff91"></a>
const CompartmentReportPtr &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCompartmentReport</b> () const </td></tr>
<tr class="separator:a28c4f5ee36fab983f810ec65ec7bff91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1df82e92f9eaf7797e9dacd1873098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace1df82e92f9eaf7797e9dacd1873098"></a>
const core::SpikeReportPtr &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpikeReport</b> () const </td></tr>
<tr class="separator:ace1df82e92f9eaf7797e9dacd1873098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89dbfec0a7d1e19781443bafc124dd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa89dbfec0a7d1e19781443bafc124dd5"></a>
std::shared_ptr&lt; osgEq::Scene &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#aa89dbfec0a7d1e19781443bafc124dd5">getSceneProxy</a> ()</td></tr>
<tr class="memdesc:aa89dbfec0a7d1e19781443bafc124dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scene interface to be used by Equalizer. <br /></td></tr>
<tr class="separator:aa89dbfec0a7d1e19781443bafc124dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The scene to be rendered by one or more views. </p>
<p><a class="anchor" id="Scene_details"></a>A scene contains the circuit elements to be displayed, additional mesh models and is associated with simulation data (this may be moved to the <a class="el" href="classbbp_1_1rtneuron_1_1View.html" title="This class represents a view on a scene. ">View</a> class in the future).</p>
<p>The attributes that can be passed to <a class="el" href="classbbp_1_1rtneuron_1_1RTNeuron.html#a6cf0ac856d6bb6cfea607f2ab587f30c" title="Creates a Scene to be used in this application. ">RTNeuron::createScene</a> are the following:</p><ul>
<li><em>accurate_headlight</em> (bool): Apply shading assuming directional light rays from the camera position or parallel to the projection plane.</li>
<li><em>alpha_blending</em> (<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html" title="An attribute map that stores arbitrary values using strings as keys. ">AttributeMap</a>): If provided, transparent rendering will be enabled in this scene. The attributes to configure the alpha-blending algorithm are:<ul>
<li><em>mode</em> (string): depth_peeling, multilayer_depth_peeling or fragment_linked_list if compiled with OpenGL 3 support.</li>
<li><em>max_passes</em> (string): Maximum number of rendering passes for multipass algorithms.</li>
<li><em>cutoff_samples</em> (string): In multipass algorithms, the number of samples returned by the occlusion query at which the frame can be considered finished.</li>
<li><em>slices</em> (int) [only for multi-layer depth peeling]: Number of slices to use in the per-pixel depth partition of the scene. If the input attribute map is empty, transparent rendering will be disabled.</li>
</ul>
</li>
<li><em>circuit</em> (string): URI of the circuit to use for this scene.</li>
<li><em>mesh_path</em> (string): Path where neuron meshes are located for the given circuit. This path will be try to be inferred for circuits described by Circuit/BlueConfig.</li>
<li><em>connect_first_order_branches</em> (bool): Translate the start point of first order branches to connect them to the soma (detailed or spherical depending on the case).</li>
<li><em>em_shading</em> (bool): Choose between regular phong or fake electron microscopy shading.</li>
<li><em>inflatable_neurons</em> (bool): If true the neuron models can be inflated by displacing the membrame surface in the normal direction. The inflation factor is specified as a view attribute called <em>inflation_factor</em>.</li>
<li><em>load_morphologyes</em> (bool): Whether load morphologies for calculating soma radii or not.</li>
<li><em>lod</em> (<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html" title="An attribute map that stores arbitrary values using strings as keys. ">AttributeMap</a>): Level of detail options for different types of objects<ul>
<li><em>neurons</em> (<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html" title="An attribute map that stores arbitrary values using strings as keys. ">AttributeMap</a>): Each attribute is a pair of floats between [0, 1] indicating the relative range in which a particular level of detail is used. Attribute names refer to levels of detail and they can be: <em>mesh</em>, high_detail_cylinders*, <em>low_detail_cylinders</em>, <em>tubelets</em>, <em>detailed_soma</em>, spherical_soma*</li>
</ul>
</li>
<li><em>mesh_based_partition</em> (bool): Use the meshes for load balancing spatial partitions. Otherwise only the morpholgies are used. This options requires use_meshes to be also true.</li>
<li><em>partitioning</em> (DataBasePartitioning): The type of decomposition to use for DB (sort-last) partitions.</li>
<li><em>preload_skeletons</em> (bool): Preload all the capsule skeletons used for view frustum culling into the GPU instead of doing the first type they are visible.</li>
<li><em>unique_morphologies</em> (bool) If true, enables optimizations in spatial partitions that are only possible assuming that morphologies are unique.</li>
<li><em>use_cuda</em> (bool): Enable CUDA based view frustums culling.</li>
<li><em>use_meshes</em> (bool): Whether triangular meshes should be used for neurons or not.</li>
</ul>
<p>Scenes must be created using <a class="el" href="classbbp_1_1rtneuron_1_1RTNeuron.html#a6cf0ac856d6bb6cfea607f2ab587f30c" title="Creates a Scene to be used in this application. ">RTNeuron::createScene</a> before the Equalizer configuration is started. At creation time scenes are assigned an internal ID. In multi-procress configurations (be it in the same machine or not), the scenes to used must be created in the same order to ensure the consistency of the frames.</p>
<p>At this moment, scene changes are not propagated from the application process to the rendering clients. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1c4707d2ca31640d938e236a903dc340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr bbp::rtneuron::Scene::addAfferentSynapses </td>
          <td>(</td>
          <td class="paramtype">const brain::Synapses &amp;&#160;</td>
          <td class="paramname"><em>synapses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a set of synapse glyphs at their post-synaptic locations to the scene. </p>
<p>Thread safe with regard to the rendering loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synapses</td><td>The synapse container. </td></tr>
    <tr><td class="paramname">attributes</td><td>Synapse display attributes:<ul>
<li>radius (float)</li>
<li>color (floatx4)</li>
<li>surface (bool): If true, the synapses are placed on the surfaces of the geometry, or in the center otherwise </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object handler to the synapse set added. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e5fe906285e4f8a6a6230a7de51017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr bbp::rtneuron::Scene::addEfferentSynapses </td>
          <td>(</td>
          <td class="paramtype">const brain::Synapses &amp;&#160;</td>
          <td class="paramname"><em>synapses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a set of synapse glyphs at their pre-synaptic locations to the scene. </p>
<p>Exactly the same as the function addAfferentSynapses but for efferent synapses.</p>
<dl class="section return"><dt>Returns</dt><dd>An object handler to the synapse set added. </dd></dl>

</div>
</div>
<a class="anchor" id="af749e837d677eaf8fdd2d54374fc1b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr bbp::rtneuron::Scene::addGeometry </td>
          <td>(</td>
          <td class="paramtype">const osg::ref_ptr&lt; osg::Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const osg::ref_ptr&lt; osg::DrawElementsUInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>primitive</em> = <code>osg::ref_ptr&lt;&#160;osg::DrawElementsUInt&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const osg::ref_ptr&lt; osg::Vec4Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>colors</em> = <code>osg::ref_ptr&lt;&#160;osg::Vec3Array&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const osg::ref_ptr&lt; osg::Vec3Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em> = <code>osg::ref_ptr&lt;&#160;osg::Vec3Array&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds geometry described as vertices and faces to the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>A Vec4Array for points with radius, a Vec3Array for all the other cases. </td></tr>
    <tr><td class="paramname">primitive</td><td>The primitive indices for triangles or lines, not used for displaying points. </td></tr>
    <tr><td class="paramname">colors</td><td>An optional per vertex color array for per vertex color binding or a single element array for single overall color. If not provided a default color will be used. </td></tr>
    <tr><td class="paramname">normals</td><td>An optional array with per vertex normals. </td></tr>
    <tr><td class="paramname">attributes</td><td>Optional attributes concerning shading details<ul>
<li>flat (bool): If true, the normal array is ignored and flat shading is used instead. If false and no normal array is provided, vertex normals are computed on the fly. Flat shading is only meaningful for triangle meshes.</li>
<li>line_width (float): Line width. Only for line primitives.</li>
<li>point_size (float): For points without individual size/radius this is the overall size. Its interpretation depends on the point style. For spheres, it's the radius. For points or circles, this is the screen size in pixels. If not specified, it will default to 1.</li>
<li>point_style (string): Use "spheres" to add real 3D spheres to the scene, "points" to add round points sprites and "circles" to add circles with 1 pixel of line width (the last two use regular GL_POINTS style). The default style if not specified is points.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object handler to the model added. </dd></dl>

</div>
</div>
<a class="anchor" id="a8543ab4df800225c69cb690bcf9816ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr bbp::rtneuron::Scene::addModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a 3D model from a file and adds it to the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Model file to load. </td></tr>
    <tr><td class="paramname">transform</td><td>An affine transformation to apply to the model. </td></tr>
    <tr><td class="paramname">attributes</td><td>Model attributes:<ul>
<li>color (floatx4) The diffuse color to be applied to the model to all parts that don't specify any material already.</li>
<li>flat (bool): If true and the model doesn't include it's own shaders, a shader to render facets with flat shading will be applied. If false, it has no effect.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object handler to the model added.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Additional models are not divided up in DB decompositions. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bc864b838db3d07a563323542669f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr bbp::rtneuron::Scene::addModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>transform</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload of the function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Model file to load. </td></tr>
    <tr><td class="paramname">transform</td><td>A sequence of affine transformations. The sequence is specified as a colon separated string of 3 possible transformations:<ul>
<li>rotations "r@x,y,z,angle"</li>
<li>scalings "s@x,y,z"</li>
<li>translations "t@x,y,z" </li>
</ul>
</td></tr>
    <tr><td class="paramname">attributes</td><td>See function above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object handler to the model added.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Additional models are not divided up in DB decompositions </dd></dl>

</div>
</div>
<a class="anchor" id="a68fdc528c9713dc34c3dfc985921230c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ObjectPtr bbp::rtneuron::Scene::addNeurons </td>
          <td>(</td>
          <td class="paramtype">const GIDSet &amp;&#160;</td>
          <td class="paramname"><em>gids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of neurons to the scene. </p>
<p>This is an asynchronous operation. The neuron container as well as the attribute map are copied internally so it is safe to modify them afterwards. Thread safe with regard to the rendering loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gids</td><td>An iterable or numpy array convertible to a GID set.</td></tr>
    <tr><td class="paramname">attributes</td><td>Neuron display attributes:<ul>
<li>mode (RepresentationMode): How to display neurons. Neurons added with SOMA or NO_AXON modes cannot be switched to WHOLE_NEURON later on.</li>
<li>color_scheme (ColorScheme): Coloring method to use. SOLID_COLOR by default is not provided</li>
<li>color (floatx4): RGBA tuple to be used as base color for SOLID_COLOR and BY_WIDTH_COLORS color schemes.</li>
<li>colormaps (<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html" title="An attribute map that stores arbitrary values using strings as keys. ">AttributeMap</a>): Optional submap with target specific color maps. These color maps override the color maps from the view. The supported color maps are:<ul>
<li><em>by_distance_to_soma</em>: The color map to use for the BY_DISTANCE_TO_SOMA_COLORS coloring scheme.<ul>
<li><em>by_width</em>: The color map to use for the BY_WIDTH_COLORS coloring scheme.</li>
<li><em>compartments</em>: The color map to use for compartmental simulation data.</li>
</ul>
</li>
<li><em>spikes</em>: The color map to use for spike rendering. The range of this color map must be always [0, 1], otherwise the rendering results are undefined.</li>
</ul>
</li>
<li>primary_color (floatx4): An alias of the above.</li>
<li>secondary_color (floatx4): RGBA tuple to be used as secondary color for BY_WIDTH_COLORS.</li>
<li>max_visible_branch_order (int): Changes the maximum branching order of visible sections. Use -1 to make all braches visible and 0 to make only the soma visible.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object handler to the neuron set added. </dd></dl>

</div>
</div>
<a class="anchor" id="a1821a772691886aa61923daae68308d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the objects from the scene. </p>
<p>Clipping planes are removed.</p>
<p>To be called only from the application node. </p>

</div>
</div>
<a class="anchor" id="a2693955c0935f4548aea8a0b9c4e5cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html">AttributeMap</a>&amp; bbp::rtneuron::Scene::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The runtime configurable attribute map. </p>
<p>The modifiable attributes are:</p><ul>
<li><em>alpha_blending</em> (<a class="el" href="classbbp_1_1rtneuron_1_1AttributeMap.html" title="An attribute map that stores arbitrary values using strings as keys. ">AttributeMap</a>): The attribute map with options for transparency algorithms. See <a class="el" href="classbbp_1_1rtneuron_1_1Scene.html" title="The scene to be rendered by one or more views. ">Scene</a> class documentation</li>
<li><em>em_shading</em> (bool): See <a class="el" href="classbbp_1_1rtneuron_1_1Scene.html" title="The scene to be rendered by one or more views. ">Scene</a> class documentation</li>
<li><em>auto_update</em> (bool): Whether scene modifications automatically trigger a dirty signal or not.</li>
<li><em>inflatable_neurons</em> (bool): Enable/disable neuron membrame inflation along the surface normal. The inflation factor is specified as a view attribute called <em>inflation_factor</em>. </li>
</ul>

</div>
</div>
<a class="anchor" id="aeafdb648491bb2519d7236b722636459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a> bbp::rtneuron::Scene::getCircuitSceneBoundingSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#aa8db1325dd07b614ba9cb0065579be05">getSomasBoundingSphere()</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="acdfd1bdfacb9668fb6694c7a97ff24a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector4f bbp::rtneuron::Scene::getClipPlane </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the clip plane with a given index. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if no plane has been assigned in that index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a372ed2496b9b26834498ebbec6b61a40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GIDSet&amp; bbp::rtneuron::Scene::getNeuronSelectionMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of unselectable cells. </p>
<p>This mask affects the results of <a class="el" href="classbbp_1_1rtneuron_1_1Scene.html#a6f99c193f4ffac2d36d245d208b3f37f" title="Intersection test between the pointer ray and the scene elements. ">pick()</a> functions. </p>

</div>
</div>
<a class="anchor" id="abf251b073c8b7f802906422275c121d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ObjectPtr&gt; bbp::rtneuron::Scene::getObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the handlers to all objects added to the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>An STL vector of object handlers. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8db1325dd07b614ba9cb0065579be05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a> bbp::rtneuron::Scene::getSomasBoundingSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The center and radius around the somas of the scene. </dd></dl>

</div>
</div>
<a class="anchor" id="ae30c482a16b2767da51f6f72df805837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classosg_1_1BoundingSphereImpl.html">osg::BoundingSphere</a> bbp::rtneuron::Scene::getSynapsesBoundingSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The center and radius around the synapses of the scene. </dd></dl>

</div>
</div>
<a class="anchor" id="a4829b380008f09f2aee34d5d149814c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::highlight </td>
          <td>(</td>
          <td class="paramtype">const GIDSet &amp;&#160;</td>
          <td class="paramname"><em>gids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle highlighing of a cell set. </p>
<p>To be called only from the application node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gids</td><td>An iterable or numpy array convertible to a GID set. </td></tr>
    <tr><td class="paramname">on</td><td>True to highlight the cell, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a056516d88f5a07a966c08237984f1f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::mapSimulation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>millisecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the simulation timestamp to be available for the given frame number. </p>
<p>The simulation is applied to all subscenes assuming that they will be needed to complete the frame (e.g. 2D/DB decompositions).</p>
<p>If the mapper is working on the given timestamp, this function waits for it to finish. In other case it cancel the current operation, triggers the mapping of the timestamp and waits for it to finish.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd><p class="startdd">The frame number will be used in time multiplexing. </p>
<p class="enddd">Efficient implementation if DB load balancing is dynamic. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6f99c193f4ffac2d36d245d208b3f37f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::pick </td>
          <td>(</td>
          <td class="paramtype">const Vector3f &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3f &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersection test between the pointer ray and the scene elements. </p>
<p>May emit cellSelected or synapseSelected signals if a scene object was hit.</p>
<p>A signal is used to communicate the result to allow decoupling the GUI event handling code from selection action callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>world space origin of the pick ray </td></tr>
    <tr><td class="paramname">direction</td><td>pick ray direction, does not need to be normalized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62104763faf0c71b4071caf3dc0d2944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::pick </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbbp_1_1rtneuron_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersection test of the space region selected by a rectangular area projected using the camera from the given view. </p>
<p>The implementation distinguishes between perspective and orthographic projections. Will emit a cellSetSelected signal with the group of somas intersected by the projection of the rectangle (both towards infinite and the camera position).</p>
<p>A signal is used to communicate the result to allow decoupling the GUI event hanlding code from selection action callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td></td></tr>
    <tr><td class="paramname">left</td><td>Normalized position (in [0,1]) of the left side of the rectangle relative to the camera projection frustum/prism. </td></tr>
    <tr><td class="paramname">right</td><td>Normalized position (in [0,1]) of the right side of the rectangle relative to the camera projection frustum/prism. </td></tr>
    <tr><td class="paramname">bottom</td><td>Normalized position (in [0,1]) of the bottom side of the rectangle relative to the camera projection frustum/prism. </td></tr>
    <tr><td class="paramname">top</td><td>Normalized position (in [0,1]) of the top side of the rectangle relative to the camera projection frustum/prism. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83a3bb592ed79645e312c53df4a4582c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int bbp::rtneuron::Scene::prepareSimulation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>millisecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger the simulation data mapper to map simulation data to be used for a given frame. </p>
<p>This function does essentially the same as above but it doesn't wait for the mapper to finish, neither cancels its current operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td></td></tr>
    <tr><td class="paramname">millisecond</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of mapping threads that will participate and need to be waited. This is equivalent to how many times simulationUpdated will be signalled. </dd></dl>

</div>
</div>
<a class="anchor" id="a19ffddb8fb995eb06cb81660c77e5c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::setCircuit </td>
          <td>(</td>
          <td class="paramtype">const CircuitPtr &amp;&#160;</td>
          <td class="paramname"><em>circuit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the brain::Circuit to be used for this scene. </p>
<p>Throws if the scene already contains neurons or synapses. </p>

</div>
</div>
<a class="anchor" id="a128d0943e757bff167ac36fe68d1b3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::setClipPlane </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector4f &amp;&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or modifies a clipping plane. </p>
<p>Clipping planes are only applied to subscenes that have no spatial decomposition, otherwise they are silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Number of plane to be set. The maximum number of clipping planes is 8. </td></tr>
    <tr><td class="paramname">plane</td><td>Plane equation of the clipping plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if index is &gt;= 8. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5289d56ad5685b95e8d140c36c42e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bbp::rtneuron::Scene::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To use when auto_update is false to trigger the scene update. </p>
<p>If the auto_update attribute is false, adding/removing objects from the scene or changing attributes that modify the rendering style will not trigger a new frame and consequent scene update. This function can be used to trigger it manually. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/jenkins/01/workspace/oss.RTNeuron.documentation/build_type/Debug/platform/cscsviz-vm/build/install/include/rtneuron/Scene.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>bbp</b></li><li class="navelem"><b>rtneuron</b></li><li class="navelem"><a class="el" href="classbbp_1_1rtneuron_1_1Scene.html">Scene</a></li>
    <li class="footer">Generated on Sat Jun 16 2018 07:26:05 for RTNeuron by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
