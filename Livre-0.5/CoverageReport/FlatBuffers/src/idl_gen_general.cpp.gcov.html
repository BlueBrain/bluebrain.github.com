<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Livre - FlatBuffers/src/idl_gen_general.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">FlatBuffers/src</a> - idl_gen_general.cpp<span style="font-size: 80%;"> (source / <a href="idl_gen_general.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Livre</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">363</td>
            <td class="headerCovTableEntryLo">1.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-03-10 14:06:39</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntryLo">7.1 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2014 Google Inc. All rights reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       5 </span>            :  * you may not use this file except in compliance with the License.
<span class="lineNum">       6 </span>            :  * You may obtain a copy of the License at
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      11 </span>            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      12 </span>            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      13 </span>            :  * See the License for the specific language governing permissions and
<span class="lineNum">      14 </span>            :  * limitations under the License.
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : // independent from idl_parser, since this code is not needed for most clients
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;flatbuffers/flatbuffers.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;flatbuffers/idl.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;flatbuffers/util.h&quot;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : namespace flatbuffers {
<span class="lineNum">      24 </span>            : 
<a name="25"><span class="lineNum">      25 </span>            : // Convert an underscore_based_indentifier in to camelCase.</a>
<span class="lineNum">      26 </span>            : // Also uppercases the first character if first is true.
<span class="lineNum">      27 </span><span class="lineNoCov">          0 : std::string MakeCamel(const std::string &amp;in, bool first) {</span>
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :   std::string s;</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; in.length(); i++) {</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :     if (!i &amp;&amp; first)</span>
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :       s += static_cast&lt;char&gt;(toupper(in[0]));</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :     else if (in[i] == '_' &amp;&amp; i + 1 &lt; in.length())</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :       s += static_cast&lt;char&gt;(toupper(in[++i]));</span>
<span class="lineNum">      34 </span>            :     else
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :       s += in[i];</span>
<span class="lineNum">      36 </span>            :   }
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   return s;</span>
<span class="lineNum">      38 </span>            : }
<a name="39"><span class="lineNum">      39 </span>            : </a>
<span class="lineNum">      40 </span>            : // Generate a documentation comment, if available.
<span class="lineNum">      41 </span><span class="lineCov">        122 : void GenComment(const std::vector&lt;std::string&gt; &amp;dc, std::string *code_ptr,</span>
<span class="lineNum">      42 </span>            :                 const char *prefix) {
<span class="lineNum">      43 </span><span class="lineCov">        122 :   std::string &amp;code = *code_ptr;</span>
<span class="lineNum">      44 </span><span class="lineCov">        390 :   for (auto it = dc.begin();</span>
<span class="lineNum">      45 </span><span class="lineCov">        260 :        it != dc.end();</span>
<span class="lineNum">      46 </span>            :        ++it) {
<span class="lineNum">      47 </span><span class="lineCov">          8 :     code += std::string(prefix) + &quot;///&quot; + *it + &quot;\n&quot;;</span>
<span class="lineNum">      48 </span>            :   }
<span class="lineNum">      49 </span><span class="lineCov">        122 : }</span>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // These arrays need to correspond to the GeneratorOptions::k enum.
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : struct LanguageParameters {
<span class="lineNum">      54 </span>            :   GeneratorOptions::Language language;
<span class="lineNum">      55 </span>            :   // Whether function names in the language typically start with uppercase.
<span class="lineNum">      56 </span>            :   bool first_camel_upper;
<span class="lineNum">      57 </span>            :   const char *file_extension;
<span class="lineNum">      58 </span>            :   const char *string_type;
<span class="lineNum">      59 </span>            :   const char *bool_type;
<span class="lineNum">      60 </span>            :   const char *open_curly;
<span class="lineNum">      61 </span>            :   const char *const_decl;
<span class="lineNum">      62 </span>            :   const char *inheritance_marker;
<span class="lineNum">      63 </span>            :   const char *namespace_ident;
<span class="lineNum">      64 </span>            :   const char *namespace_begin;
<span class="lineNum">      65 </span>            :   const char *namespace_end;
<span class="lineNum">      66 </span>            :   const char *set_bb_byteorder;
<span class="lineNum">      67 </span>            :   const char *includes;
<span class="lineNum">      68 </span>            : };
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : LanguageParameters language_parameters[] = {
<span class="lineNum">      71 </span>            :   {
<span class="lineNum">      72 </span>            :     GeneratorOptions::kJava,
<span class="lineNum">      73 </span>            :     false,
<span class="lineNum">      74 </span>            :     &quot;.java&quot;,
<span class="lineNum">      75 </span>            :     &quot;String&quot;,
<span class="lineNum">      76 </span>            :     &quot;boolean &quot;,
<span class="lineNum">      77 </span>            :     &quot; {\n&quot;,
<span class="lineNum">      78 </span>            :     &quot; final &quot;,
<span class="lineNum">      79 </span>            :     &quot; extends &quot;,
<span class="lineNum">      80 </span>            :     &quot;package &quot;,
<span class="lineNum">      81 </span>            :     &quot;;&quot;,
<span class="lineNum">      82 </span>            :     &quot;&quot;,
<span class="lineNum">      83 </span>            :     &quot;_bb.order(ByteOrder.LITTLE_ENDIAN); &quot;,
<span class="lineNum">      84 </span>            :     &quot;import java.nio.*;\nimport java.lang.*;\nimport java.util.*;\n&quot;
<span class="lineNum">      85 </span>            :       &quot;import com.google.flatbuffers.*;\n\n&quot;,
<span class="lineNum">      86 </span>            :   },
<span class="lineNum">      87 </span>            :   {
<span class="lineNum">      88 </span>            :     GeneratorOptions::kCSharp,
<span class="lineNum">      89 </span>            :     true,
<span class="lineNum">      90 </span>            :     &quot;.cs&quot;,
<span class="lineNum">      91 </span>            :     &quot;string&quot;,
<span class="lineNum">      92 </span>            :     &quot;bool &quot;,
<span class="lineNum">      93 </span>            :     &quot;\n{\n&quot;,
<span class="lineNum">      94 </span>            :     &quot; readonly &quot;,
<span class="lineNum">      95 </span>            :     &quot; : &quot;,
<span class="lineNum">      96 </span>            :     &quot;namespace &quot;,
<span class="lineNum">      97 </span>            :     &quot;\n{&quot;,
<span class="lineNum">      98 </span>            :     &quot;\n}\n&quot;,
<span class="lineNum">      99 </span>            :     &quot;&quot;,
<span class="lineNum">     100 </span>            :     &quot;using FlatBuffers;\n\n&quot;,
<span class="lineNum">     101 </span>            :   }
<span class="lineNum">     102 </span>            : };
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : static_assert(sizeof(language_parameters) / sizeof(LanguageParameters) ==
<span class="lineNum">     105 </span>            :               GeneratorOptions::kMAX,
<a name="106"><span class="lineNum">     106 </span>            :               &quot;Please add extra elements to the arrays above.&quot;);</a>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 : static std::string FunctionStart(const LanguageParameters &amp;lang, char upper) {</span>
<span class="lineNum">     109 </span>            :   return std::string() +
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :       (lang.language == GeneratorOptions::kJava</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :          ? static_cast&lt;char&gt;(tolower(upper))</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :          : upper);</span>
<a name="113"><span class="lineNum">     113 </span>            : }</a>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : static std::string GenTypeBasic(const LanguageParameters &amp;lang,</span>
<span class="lineNum">     116 </span>            :                                 const Type &amp;type) {
<span class="lineNum">     117 </span>            :   static const char *gtypename[] = {
<span class="lineNum">     118 </span>            :     #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, JTYPE, GTYPE, NTYPE) \
<span class="lineNum">     119 </span>            :         #JTYPE, #NTYPE,
<span class="lineNum">     120 </span>            :       FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)
<span class="lineNum">     121 </span>            :     #undef FLATBUFFERS_TD
<span class="lineNum">     122 </span>            :   };
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   return gtypename[type.base_type * GeneratorOptions::kMAX + lang.language];</span>
<span class="lineNum">     124 </span>            : }
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : static std::string GenTypeGet(const LanguageParameters &amp;lang,
<a name="127"><span class="lineNum">     127 </span>            :                               const Type &amp;type);</a>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : static std::string GenTypePointer(const LanguageParameters &amp;lang,</span>
<span class="lineNum">     130 </span>            :                                   const Type &amp;type) {
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   switch (type.base_type) {</span>
<span class="lineNum">     132 </span>            :     case BASE_TYPE_STRING:
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       return lang.string_type;</span>
<span class="lineNum">     134 </span>            :     case BASE_TYPE_VECTOR:
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :       return GenTypeGet(lang, type.VectorType());</span>
<span class="lineNum">     136 </span>            :     case BASE_TYPE_STRUCT:
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :       return type.struct_def-&gt;name;</span>
<span class="lineNum">     138 </span>            :     case BASE_TYPE_UNION:
<span class="lineNum">     139 </span>            :       // fall through
<span class="lineNum">     140 </span>            :     default:
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :       return &quot;Table&quot;;</span>
<span class="lineNum">     142 </span>            :   }
<a name="143"><span class="lineNum">     143 </span>            : }</a>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 : static std::string GenTypeGet(const LanguageParameters &amp;lang,</span>
<span class="lineNum">     146 </span>            :                               const Type &amp;type) {
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   return IsScalar(type.base_type)</span>
<span class="lineNum">     148 </span>            :     ? GenTypeBasic(lang, type)
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     : GenTypePointer(lang, type);</span>
<a name="150"><span class="lineNum">     150 </span>            : }</a>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : static void GenEnum(const LanguageParameters &amp;lang, EnumDef &amp;enum_def,</span>
<span class="lineNum">     153 </span>            :                     std::string *code_ptr) {
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   std::string &amp;code = *code_ptr;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   if (enum_def.generated) return;</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :   // Generate enum definitions of the form:
<span class="lineNum">     158 </span>            :   // public static (final) int name = value;
<span class="lineNum">     159 </span>            :   // In Java, we use ints rather than the Enum feature, because we want them
<span class="lineNum">     160 </span>            :   // to map directly to how they're used in C/C++ and file formats.
<span class="lineNum">     161 </span>            :   // That, and Java Enums are expensive, and not universally liked.
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   GenComment(enum_def.doc_comment, code_ptr);</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   code += &quot;public class &quot; + enum_def.name + lang.open_curly;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   for (auto it = enum_def.vals.vec.begin();</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :        it != enum_def.vals.vec.end();</span>
<span class="lineNum">     166 </span>            :        ++it) {
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     auto &amp;ev = **it;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     GenComment(ev.doc_comment, code_ptr, &quot;  &quot;);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     code += &quot;  public static&quot;;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     code += lang.const_decl;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     code += GenTypeBasic(lang, enum_def.underlying_type);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     code += &quot; &quot; + ev.name + &quot; = &quot;;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     code += NumToString(ev.value) + &quot;;\n&quot;;</span>
<span class="lineNum">     174 </span>            :   }
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :   // Generate a generate string table for enum values.
<span class="lineNum">     177 </span>            :   // Problem is, if values are very sparse that could generate really big
<span class="lineNum">     178 </span>            :   // tables. Ideally in that case we generate a map lookup instead, but for
<span class="lineNum">     179 </span>            :   // the moment we simply don't output a table at all.
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   auto range = enum_def.vals.vec.back()-&gt;value -</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :                enum_def.vals.vec.front()-&gt;value + 1;</span>
<span class="lineNum">     182 </span>            :   // Average distance between values above which we consider a table
<span class="lineNum">     183 </span>            :   // &quot;too sparse&quot;. Change at will.
<span class="lineNum">     184 </span>            :   static const int kMaxSparseness = 5;
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   if (range / static_cast&lt;int64_t&gt;(enum_def.vals.vec.size()) &lt; kMaxSparseness) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     code += &quot;\n  private static&quot;;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     code += lang.const_decl;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     code += lang.string_type;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     code += &quot;[] names = { &quot;;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     auto val = enum_def.vals.vec.front()-&gt;value;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     for (auto it = enum_def.vals.vec.begin();</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :          it != enum_def.vals.vec.end();</span>
<span class="lineNum">     193 </span>            :          ++it) {
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       while (val++ != (*it)-&gt;value) code += &quot;\&quot;\&quot;, &quot;;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :       code += &quot;\&quot;&quot; + (*it)-&gt;name + &quot;\&quot;, &quot;;</span>
<span class="lineNum">     196 </span>            :     }
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     code += &quot;};\n\n&quot;;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     code += &quot;  public static &quot;;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     code += lang.string_type;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     code += &quot; &quot; + MakeCamel(&quot;name&quot;, lang.first_camel_upper);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     code += &quot;(int e) { return names[e&quot;;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     if (enum_def.vals.vec.front()-&gt;value)</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       code += &quot; - &quot; + enum_def.vals.vec.front()-&gt;name;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     code += &quot;]; }\n&quot;;</span>
<span class="lineNum">     205 </span>            :   }
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   // Close the class
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   code += &quot;};\n\n&quot;;</span>
<span class="lineNum">     209 </span>            : }
<a name="210"><span class="lineNum">     210 </span>            : </a>
<span class="lineNum">     211 </span>            : // Returns the function name that is able to read a value of the given type.
<span class="lineNum">     212 </span><span class="lineNoCov">          0 : static std::string GenGetter(const LanguageParameters &amp;lang,</span>
<span class="lineNum">     213 </span>            :                              const Type &amp;type) {
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   switch (type.base_type) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     case BASE_TYPE_STRING: return &quot;__string&quot;;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     case BASE_TYPE_STRUCT: return &quot;__struct&quot;;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     case BASE_TYPE_UNION: return &quot;__union&quot;;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     case BASE_TYPE_VECTOR: return GenGetter(lang, type.VectorType());</span>
<span class="lineNum">     219 </span>            :     default:
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       return &quot;bb.&quot; + FunctionStart(lang, 'G') + &quot;et&quot; +</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         (GenTypeBasic(lang, type) != &quot;byte&quot;</span>
<span class="lineNum">     222 </span>            :           ? MakeCamel(GenTypeGet(lang, type))
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :           : &quot;&quot;);</span>
<span class="lineNum">     224 </span>            :   }
<span class="lineNum">     225 </span>            : }
<a name="226"><span class="lineNum">     226 </span>            : </a>
<span class="lineNum">     227 </span>            : // Returns the method name for use with add/put calls.
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : static std::string GenMethod(const LanguageParameters &amp;lang, const Type &amp;type) {</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   return IsScalar(type.base_type)</span>
<span class="lineNum">     230 </span>            :     ? MakeCamel(GenTypeBasic(lang, type))
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     : (IsStruct(type) ? &quot;Struct&quot; : &quot;Offset&quot;);</span>
<span class="lineNum">     232 </span>            : }
<span class="lineNum">     233 </span>            : 
<a name="234"><span class="lineNum">     234 </span>            : // Recursively generate arguments for a constructor, to deal with nested</a>
<span class="lineNum">     235 </span>            : // structs.
<span class="lineNum">     236 </span><span class="lineNoCov">          0 : static void GenStructArgs(const LanguageParameters &amp;lang,</span>
<span class="lineNum">     237 </span>            :                           const StructDef &amp;struct_def,
<span class="lineNum">     238 </span>            :                           std::string *code_ptr, const char *nameprefix) {
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   std::string &amp;code = *code_ptr;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   for (auto it = struct_def.fields.vec.begin();</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :        it != struct_def.fields.vec.end();</span>
<span class="lineNum">     242 </span>            :        ++it) {
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     auto &amp;field = **it;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     if (IsStruct(field.value.type)) {</span>
<span class="lineNum">     245 </span>            :       // Generate arguments for a struct inside a struct. To ensure names
<span class="lineNum">     246 </span>            :       // don't clash, and to make it obvious these arguments are constructing
<span class="lineNum">     247 </span>            :       // a nested struct, prefix the name with the struct name.
<span class="lineNum">     248 </span>            :       GenStructArgs(lang, *field.value.type.struct_def, code_ptr,
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                     (field.value.type.struct_def-&gt;name + &quot;_&quot;).c_str());</span>
<span class="lineNum">     250 </span>            :     } else {
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :       code += &quot;, &quot; + GenTypeBasic(lang, field.value.type) + &quot; &quot; + nameprefix;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       code += MakeCamel(field.name, lang.first_camel_upper);</span>
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span>            :   }
<span class="lineNum">     255 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : // Recusively generate struct construction statements of the form:
<a name="258"><span class="lineNum">     258 </span>            : // builder.putType(name);</a>
<span class="lineNum">     259 </span>            : // and insert manual padding.
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : static void GenStructBody(const LanguageParameters &amp;lang,</span>
<span class="lineNum">     261 </span>            :                           const StructDef &amp;struct_def,
<span class="lineNum">     262 </span>            :                           std::string *code_ptr, const char *nameprefix) {
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   std::string &amp;code = *code_ptr;</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   code += &quot;    builder.&quot; + FunctionStart(lang, 'P') + &quot;rep(&quot;;</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   code += NumToString(struct_def.minalign) + &quot;, &quot;;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   code += NumToString(struct_def.bytesize) + &quot;);\n&quot;;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   for (auto it = struct_def.fields.vec.rbegin();</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :        it != struct_def.fields.vec.rend(); ++it) {</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     auto &amp;field = **it;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     if (field.padding) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       code += &quot;    builder.&quot; + FunctionStart(lang, 'P') + &quot;ad(&quot;;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       code += NumToString(field.padding) + &quot;);\n&quot;;</span>
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     if (IsStruct(field.value.type)) {</span>
<span class="lineNum">     275 </span>            :       GenStructBody(lang, *field.value.type.struct_def, code_ptr,
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                     (field.value.type.struct_def-&gt;name + &quot;_&quot;).c_str());</span>
<span class="lineNum">     277 </span>            :     } else {
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       code += &quot;    builder.&quot; + FunctionStart(lang, 'P') + &quot;ut&quot;;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       code += GenMethod(lang, field.value.type) + &quot;(&quot; += nameprefix;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       code += MakeCamel(field.name, lang.first_camel_upper) + &quot;);\n&quot;;</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span>            :   }
<a name="283"><span class="lineNum">     283 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : static void GenStruct(const LanguageParameters &amp;lang, const Parser &amp;parser,</span>
<span class="lineNum">     286 </span>            :                       StructDef &amp;struct_def, std::string *code_ptr) {
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   if (struct_def.generated) return;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   std::string &amp;code = *code_ptr;</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :   // Generate a struct accessor class, with methods of the form:
<span class="lineNum">     291 </span>            :   // public type name() { return bb.getType(i + offset); }
<span class="lineNum">     292 </span>            :   // or for tables of the form:
<span class="lineNum">     293 </span>            :   // public type name() {
<span class="lineNum">     294 </span>            :   //   int o = __offset(offset); return o != 0 ? bb.getType(o + i) : default;
<span class="lineNum">     295 </span>            :   // }
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   GenComment(struct_def.doc_comment, code_ptr);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   code += &quot;public class &quot; + struct_def.name + lang.inheritance_marker;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   code += struct_def.fixed ? &quot;Struct&quot; : &quot;Table&quot;;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   code += &quot; {\n&quot;;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   if (!struct_def.fixed) {</span>
<span class="lineNum">     301 </span>            :     // Generate a special accessor for the table that when used as the root
<span class="lineNum">     302 </span>            :     // of a FlatBuffer
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     code += &quot;  public static &quot; + struct_def.name + &quot; &quot;;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     code += FunctionStart(lang, 'G') + &quot;etRootAs&quot; + struct_def.name;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     code += &quot;(ByteBuffer _bb) { &quot;;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     code += lang.set_bb_byteorder;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     code += &quot;return (new &quot; + struct_def.name;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     code += &quot;()).__init(_bb.&quot; + FunctionStart(lang, 'G');</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     code += &quot;etInt(_bb.position()) + _bb.position(), _bb); }\n&quot;;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     if (parser.root_struct_def == &amp;struct_def) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :       if (parser.file_identifier_.length()) {</span>
<span class="lineNum">     312 </span>            :         // Check if a buffer has the identifier.
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         code += &quot;  public static &quot;;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         code += lang.bool_type + struct_def.name;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         code += &quot;BufferHasIdentifier(ByteBuffer _bb) { return &quot;;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         code += &quot;__has_identifier(_bb, \&quot;&quot; + parser.file_identifier_;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         code += &quot;\&quot;); }\n&quot;;</span>
<span class="lineNum">     318 </span>            :       }
<span class="lineNum">     319 </span>            :     }
<span class="lineNum">     320 </span>            :   }
<span class="lineNum">     321 </span>            :   // Generate the __init method that sets the field in a pre-existing
<span class="lineNum">     322 </span>            :   // accessor object. This is to allow object reuse.
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   code += &quot;  public &quot; + struct_def.name;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   code += &quot; __init(int _i, ByteBuffer _bb) &quot;;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   code += &quot;{ bb_pos = _i; bb = _bb; return this; }\n\n&quot;;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   for (auto it = struct_def.fields.vec.begin();</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :        it != struct_def.fields.vec.end();</span>
<span class="lineNum">     328 </span>            :        ++it) {
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     auto &amp;field = **it;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     if (field.deprecated) continue;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     GenComment(field.doc_comment, code_ptr, &quot;  &quot;);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     std::string type_name = GenTypeGet(lang, field.value.type);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     std::string method_start = &quot;  public &quot; + type_name + &quot; &quot; +</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                                MakeCamel(field.name, lang.first_camel_upper);</span>
<span class="lineNum">     335 </span>            :     // Generate the accessors that don't do object reuse.
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     if (field.value.type.base_type == BASE_TYPE_STRUCT) {</span>
<span class="lineNum">     337 </span>            :       // Calls the accessor that takes an accessor object with a new object.
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       code += method_start + &quot;() { return &quot;;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       code += MakeCamel(field.name, lang.first_camel_upper);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       code += &quot;(new &quot;;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       code += type_name + &quot;()); }\n&quot;;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     } else if (field.value.type.base_type == BASE_TYPE_VECTOR &amp;&amp;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                field.value.type.element == BASE_TYPE_STRUCT) {</span>
<span class="lineNum">     344 </span>            :       // Accessors for vectors of structs also take accessor objects, this
<span class="lineNum">     345 </span>            :       // generates a variant without that argument.
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       code += method_start + &quot;(int j) { return &quot;;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :       code += MakeCamel(field.name, lang.first_camel_upper);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       code += &quot;(new &quot;;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       code += type_name + &quot;(), j); }\n&quot;;</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     std::string getter = GenGetter(lang, field.value.type);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     code += method_start + &quot;(&quot;;</span>
<span class="lineNum">     353 </span>            :     // Most field accessors need to retrieve and test the field offset first,
<span class="lineNum">     354 </span>            :     // this is the prefix code for that:
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     auto offset_prefix = &quot;) { int o = __offset(&quot; +</span>
<span class="lineNum">     356 </span>            :                          NumToString(field.value.offset) +
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                          &quot;); return o != 0 ? &quot;;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     std::string default_cast = &quot;&quot;;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if (lang.language == GeneratorOptions::kCSharp)</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       default_cast = &quot;(&quot; + type_name + &quot;)&quot;;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     if (IsScalar(field.value.type.base_type)) {</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       if (struct_def.fixed) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         code += &quot;) { return &quot; + getter;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         code += &quot;(bb_pos + &quot; + NumToString(field.value.offset) + &quot;)&quot;;</span>
<span class="lineNum">     365 </span>            :       } else {
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         code += offset_prefix + getter;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         code += &quot;(o + bb_pos) : &quot; + default_cast + field.value.constant;</span>
<span class="lineNum">     368 </span>            :       }
<span class="lineNum">     369 </span>            :     } else {
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :       switch (field.value.type.base_type) {</span>
<span class="lineNum">     371 </span>            :         case BASE_TYPE_STRUCT:
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :           code += type_name + &quot; obj&quot;;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :           if (struct_def.fixed) {</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :             code += &quot;) { return obj.__init(bb_pos + &quot;;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :             code += NumToString(field.value.offset) + &quot;, bb)&quot;;</span>
<span class="lineNum">     376 </span>            :           } else {
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :             code += offset_prefix;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :             code += &quot;obj.__init(&quot;;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :             code += field.value.type.struct_def-&gt;fixed</span>
<span class="lineNum">     380 </span>            :                       ? &quot;o + bb_pos&quot;
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :                       : &quot;__indirect(o + bb_pos)&quot;;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :             code += &quot;, bb) : null&quot;;</span>
<span class="lineNum">     383 </span>            :           }
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     385 </span>            :         case BASE_TYPE_STRING:
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :           code += offset_prefix + getter +&quot;(o + bb_pos) : null&quot;;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     388 </span>            :         case BASE_TYPE_VECTOR: {
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :           auto vectortype = field.value.type.VectorType();</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :           if (vectortype.base_type == BASE_TYPE_STRUCT) {</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :             code += type_name + &quot; obj, &quot;;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :             getter = &quot;obj.__init&quot;;</span>
<span class="lineNum">     393 </span>            :           }
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :           code += &quot;int j&quot; + offset_prefix + getter +&quot;(&quot;;</span>
<span class="lineNum">     395 </span>            :           auto index = &quot;__vector(o) + j * &quot; +
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                        NumToString(InlineSize(vectortype));</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :           if (vectortype.base_type == BASE_TYPE_STRUCT) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :             code += vectortype.struct_def-&gt;fixed</span>
<span class="lineNum">     399 </span>            :                       ? index
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                       : &quot;__indirect(&quot; + index + &quot;)&quot;;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :             code += &quot;, bb&quot;;</span>
<span class="lineNum">     402 </span>            :           } else {
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             code += index;</span>
<span class="lineNum">     404 </span>            :           }
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :           code += &quot;) : &quot;;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :           code += IsScalar(field.value.type.element)</span>
<span class="lineNum">     407 </span>            :                   ? default_cast + &quot;0&quot;
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                   : &quot;null&quot;;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     410 </span>            :         }
<span class="lineNum">     411 </span>            :         case BASE_TYPE_UNION:
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :           code += type_name + &quot; obj&quot; + offset_prefix + getter;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :           code += &quot;(obj, o) : null&quot;;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     415 </span>            :         default:
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :           assert(0);</span>
<span class="lineNum">     417 </span>            :       }
<span class="lineNum">     418 </span>            :     }
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     code += &quot;; }\n&quot;;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     if (field.value.type.base_type == BASE_TYPE_VECTOR) {</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :       code += &quot;  public int &quot; + MakeCamel(field.name, lang.first_camel_upper);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       code += &quot;Length(&quot; + offset_prefix;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :       code += &quot;__vector_len(o) : 0; }\n&quot;;</span>
<span class="lineNum">     424 </span>            :     }
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     if ((field.value.type.base_type == BASE_TYPE_VECTOR ||</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :          field.value.type.base_type == BASE_TYPE_STRING) &amp;&amp;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         lang.language == GeneratorOptions::kJava) {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :       code += &quot;  public ByteBuffer &quot;;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       code += MakeCamel(field.name, lang.first_camel_upper);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       code += &quot;AsByteBuffer() { return __vector_as_bytebuffer(&quot;;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       code += NumToString(field.value.offset) + &quot;, &quot;;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       code += NumToString(field.value.type.base_type == BASE_TYPE_STRING ? 1 :</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :                           InlineSize(field.value.type.VectorType()));</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       code += &quot;); }\n&quot;;</span>
<span class="lineNum">     435 </span>            :     }
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   code += &quot;\n&quot;;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (struct_def.fixed) {</span>
<span class="lineNum">     439 </span>            :     // create a struct constructor function
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     code += &quot;  public static int &quot; + FunctionStart(lang, 'C') + &quot;reate&quot;;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     code += struct_def.name + &quot;(FlatBufferBuilder builder&quot;;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     GenStructArgs(lang, struct_def, code_ptr, &quot;&quot;);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     code += &quot;) {\n&quot;;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     GenStructBody(lang, struct_def, code_ptr, &quot;&quot;);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     code += &quot;    return builder.&quot;;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     code += FunctionStart(lang, 'O') + &quot;ffset();\n  }\n&quot;;</span>
<span class="lineNum">     447 </span>            :   } else {
<span class="lineNum">     448 </span>            :     // Generate a method that creates a table in one go. This is only possible
<span class="lineNum">     449 </span>            :     // when the table has no struct fields, since those have to be created
<span class="lineNum">     450 </span>            :     // inline, and there's no way to do so in Java.
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     bool has_no_struct_fields = true;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     int num_fields = 0;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     for (auto it = struct_def.fields.vec.begin();</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :          it != struct_def.fields.vec.end(); ++it) {</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       auto &amp;field = **it;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       if (field.deprecated) continue;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       if (IsStruct(field.value.type)) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         has_no_struct_fields = false;</span>
<span class="lineNum">     459 </span>            :       } else {
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         num_fields++;</span>
<span class="lineNum">     461 </span>            :       }
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     if (has_no_struct_fields &amp;&amp; num_fields) {</span>
<span class="lineNum">     464 </span>            :       // Generate a table constructor of the form:
<span class="lineNum">     465 </span>            :       // public static void createName(FlatBufferBuilder builder, args...)
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       code += &quot;  public static int &quot; + FunctionStart(lang, 'C') + &quot;reate&quot;;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       code += struct_def.name;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       code += &quot;(FlatBufferBuilder builder&quot;;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :       for (auto it = struct_def.fields.vec.begin();</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :            it != struct_def.fields.vec.end(); ++it) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         auto &amp;field = **it;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :         if (field.deprecated) continue;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         code += &quot;,\n      &quot; + GenTypeBasic(lang, field.value.type) + &quot; &quot;;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         code += field.name;</span>
<span class="lineNum">     475 </span>            :         // Java doesn't have defaults, which means this method must always
<span class="lineNum">     476 </span>            :         // supply all arguments, and thus won't compile when fields are added.
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         if (lang.language != GeneratorOptions::kJava)</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :           code += &quot; = &quot; + field.value.constant;</span>
<span class="lineNum">     479 </span>            :       }
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       code += &quot;) {\n    builder.&quot;;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       code += FunctionStart(lang, 'S') + &quot;tartObject(&quot;;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       code += NumToString(struct_def.fields.vec.size()) + &quot;);\n&quot;;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       for (size_t size = struct_def.sortbysize ? sizeof(largest_scalar_t) : 1;</span>
<span class="lineNum">     484 </span>            :            size;
<span class="lineNum">     485 </span>            :            size /= 2) {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         for (auto it = struct_def.fields.vec.rbegin();</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :              it != struct_def.fields.vec.rend(); ++it) {</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :           auto &amp;field = **it;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :           if (!field.deprecated &amp;&amp;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :               (!struct_def.sortbysize ||</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                size == SizeOf(field.value.type.base_type))) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :             code += &quot;    &quot; + struct_def.name + &quot;.&quot;;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :             code += FunctionStart(lang, 'A') + &quot;dd&quot;;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :             code += MakeCamel(field.name) + &quot;(builder, &quot; + field.name + &quot;);\n&quot;;</span>
<span class="lineNum">     495 </span>            :           }
<span class="lineNum">     496 </span>            :         }
<span class="lineNum">     497 </span>            :       }
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       code += &quot;    return &quot; + struct_def.name + &quot;.&quot;;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       code += FunctionStart(lang, 'E') + &quot;nd&quot; + struct_def.name;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       code += &quot;(builder);\n  }\n\n&quot;;</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span>            :     // Generate a set of static methods that allow table construction,
<span class="lineNum">     503 </span>            :     // of the form:
<span class="lineNum">     504 </span>            :     // public static void addName(FlatBufferBuilder builder, short name)
<span class="lineNum">     505 </span>            :     // { builder.addShort(id, name, default); }
<span class="lineNum">     506 </span>            :     // Unlike the Create function, these always work.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     code += &quot;  public static void &quot; + FunctionStart(lang, 'S') + &quot;tart&quot;;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     code += struct_def.name;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     code += &quot;(FlatBufferBuilder builder) { builder.&quot;;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     code += FunctionStart(lang, 'S') + &quot;tartObject(&quot;;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     code += NumToString(struct_def.fields.vec.size()) + &quot;); }\n&quot;;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     for (auto it = struct_def.fields.vec.begin();</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :          it != struct_def.fields.vec.end(); ++it) {</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       auto &amp;field = **it;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       if (field.deprecated) continue;</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       code += &quot;  public static void &quot; + FunctionStart(lang, 'A') + &quot;dd&quot;;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :       code += MakeCamel(field.name);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       code += &quot;(FlatBufferBuilder builder, &quot;;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       code += GenTypeBasic(lang, field.value.type);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       auto argname = MakeCamel(field.name, false);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       if (!IsScalar(field.value.type.base_type)) argname += &quot;Offset&quot;;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       code += &quot; &quot; + argname + &quot;) { builder.&quot; + FunctionStart(lang, 'A') + &quot;dd&quot;;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       code += GenMethod(lang, field.value.type) + &quot;(&quot;;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       code += NumToString(it - struct_def.fields.vec.begin()) + &quot;, &quot;;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       code += argname + &quot;, &quot; + field.value.constant;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       code += &quot;); }\n&quot;;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       if (field.value.type.base_type == BASE_TYPE_VECTOR) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         auto vector_type = field.value.type.VectorType();</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         auto alignment = InlineAlignment(vector_type);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         auto elem_size = InlineSize(vector_type);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         if (!IsStruct(vector_type)) {</span>
<span class="lineNum">     532 </span>            :           // Generate a method to create a vector from a Java array.
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :           code += &quot;  public static int &quot; + FunctionStart(lang, 'C') + &quot;reate&quot;;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :           code += MakeCamel(field.name);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :           code += &quot;Vector(FlatBufferBuilder builder, &quot;;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :           code += GenTypeBasic(lang, vector_type) + &quot;[] data) &quot;;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :           code += &quot;{ builder.&quot; + FunctionStart(lang, 'S') + &quot;tartVector(&quot;;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :           code += NumToString(elem_size);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :           code += &quot;, data.&quot; + FunctionStart(lang, 'L') + &quot;ength, &quot;;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :           code += NumToString(alignment);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :           code += &quot;); for (int i = data.&quot;;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :           code += FunctionStart(lang, 'L') + &quot;ength - 1; i &gt;= 0; i--) builder.&quot;;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :           code += FunctionStart(lang, 'A') + &quot;dd&quot;;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :           code += GenMethod(lang, vector_type);</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :           code += &quot;(data[i]); return builder.&quot;;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :           code += FunctionStart(lang, 'E') + &quot;ndVector(); }\n&quot;;</span>
<span class="lineNum">     547 </span>            :         }
<span class="lineNum">     548 </span>            :         // Generate a method to start a vector, data to be added manually after.
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         code += &quot;  public static void &quot; + FunctionStart(lang, 'S') + &quot;tart&quot;;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         code += MakeCamel(field.name);</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         code += &quot;Vector(FlatBufferBuilder builder, int numElems) &quot;;</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         code += &quot;{ builder.&quot; + FunctionStart(lang, 'S') + &quot;tartVector(&quot;;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         code += NumToString(elem_size);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         code += &quot;, numElems, &quot; + NumToString(alignment);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         code += &quot;); }\n&quot;;</span>
<span class="lineNum">     556 </span>            :       }
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     code += &quot;  public static int &quot;;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     code += FunctionStart(lang, 'E') + &quot;nd&quot; + struct_def.name;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     code += &quot;(FlatBufferBuilder builder) {\n    int o = builder.&quot;;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     code += FunctionStart(lang, 'E') + &quot;ndObject();\n&quot;;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     for (auto it = struct_def.fields.vec.begin();</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :          it != struct_def.fields.vec.end();</span>
<span class="lineNum">     564 </span>            :          ++it) {
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :       auto &amp;field = **it;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :       if (!field.deprecated &amp;&amp; field.required) {</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         code += &quot;    builder.&quot; + FunctionStart(lang, 'R') + &quot;equired(o, &quot;;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         code += NumToString(field.value.offset);</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         code += &quot;);  // &quot; + field.name + &quot;\n&quot;;</span>
<span class="lineNum">     570 </span>            :       }
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     code += &quot;    return o;\n  }\n&quot;;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :     if (parser.root_struct_def == &amp;struct_def) {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :       code += &quot;  public static void &quot;;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       code += FunctionStart(lang, 'F') + &quot;inish&quot; + struct_def.name;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :       code += &quot;Buffer(FlatBufferBuilder builder, int offset) { &quot;;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       code += &quot;builder.&quot; + FunctionStart(lang, 'F') + &quot;inish(offset&quot;;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :       if (parser.file_identifier_.length())</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :         code += &quot;, \&quot;&quot; + parser.file_identifier_ + &quot;\&quot;&quot;;</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :       code += &quot;); }\n&quot;;</span>
<span class="lineNum">     581 </span>            :     }
<span class="lineNum">     582 </span>            :   }
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   code += &quot;};\n\n&quot;;</span>
<span class="lineNum">     584 </span>            : }
<span class="lineNum">     585 </span>            : 
<a name="586"><span class="lineNum">     586 </span>            : // Save out the generated code for a single class while adding</a>
<span class="lineNum">     587 </span>            : // declaration boilerplate.
<span class="lineNum">     588 </span><span class="lineNoCov">          0 : static bool SaveClass(const LanguageParameters &amp;lang, const Parser &amp;parser,</span>
<span class="lineNum">     589 </span>            :                       const Definition &amp;def, const std::string &amp;classcode,
<span class="lineNum">     590 </span>            :                       const std::string &amp;path, bool needs_includes) {
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   if (!classcode.length()) return true;</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   std::string namespace_general;</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   std::string namespace_dir = path;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   auto &amp;namespaces = parser.namespaces_.back()-&gt;components;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   for (auto it = namespaces.begin(); it != namespaces.end(); ++it) {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     if (namespace_general.length()) {</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :       namespace_general += &quot;.&quot;;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       namespace_dir += kPathSeparator;</span>
<span class="lineNum">     600 </span>            :     }
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     namespace_general += *it;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     namespace_dir += *it;</span>
<span class="lineNum">     603 </span>            :   }
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   EnsureDirExists(namespace_dir);</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   std::string code = &quot;// automatically generated, do not modify\n\n&quot;;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   if (!namespaces.empty()) {</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       code += lang.namespace_ident + namespace_general + lang.namespace_begin;</span>
<span class="lineNum">     609 </span>            :   }
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   code += &quot;\n\n&quot;;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   if (needs_includes) code += lang.includes;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   code += classcode;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   code += lang.namespace_end;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   auto filename = namespace_dir + kPathSeparator + def.name +</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :                   lang.file_extension;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   return SaveFile(filename.c_str(), code, false);</span>
<a name="617"><span class="lineNum">     617 </span>            : }</a>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 : bool GenerateGeneral(const Parser &amp;parser,</span>
<span class="lineNum">     620 </span>            :                      const std::string &amp;path,
<span class="lineNum">     621 </span>            :                      const std::string &amp; /*file_name*/,
<span class="lineNum">     622 </span>            :                      const GeneratorOptions &amp;opts) {
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   assert(opts.lang &lt;= GeneratorOptions::kMAX);</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   auto lang = language_parameters[opts.lang];</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   for (auto it = parser.enums_.vec.begin();</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :        it != parser.enums_.vec.end(); ++it) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     std::string enumcode;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     GenEnum(lang, **it, &amp;enumcode);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     if (!SaveClass(lang, parser, **it, enumcode, path, false))</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   for (auto it = parser.structs_.vec.begin();</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :        it != parser.structs_.vec.end(); ++it) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     std::string declcode;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     GenStruct(lang, parser, **it, &amp;declcode);</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     if (!SaveClass(lang, parser, **it, declcode, path, true))</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     644 </span>            : }
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : }  // namespace flatbuffers
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
