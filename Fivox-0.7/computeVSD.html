<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Fivox: VSD computation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fivox
   &#160;<span id="projectnumber">0.7.0</span>
   </div>
   <div id="projectbrief">ITK library to sample events into regular volumes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('computeVSD.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">VSD computation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The compute-vsd application was developed with the goal of helping scientists to do their experiments and research in the context of in-silico VSD imaging. The design and validation process was done in collaboration with them.</p>
<p>It uses the existing Fivox library, with a few modifications and additions, such as a new loader (VSDLoader).</p>
<h2>Usage</h2>
<pre class="fragment">compute-vsd --volume 'fivoxvsd://BlueConfig?report=voltages&amp;target=Column&amp;areas=/path/to/report/area.bbp&amp;dt=0.1'
            --curve /path/to/dyecurve.txt --depth 2000 [--interpolate-attenuation]
            --v0 -65 --g0 10000 [--ap-threshold -55] [--export-volume] [--export-point-sprites]
            --sigma 0.001 --sensor-res 512 --sensor-dim 1000
            --frame[s] '0 10' (or alternatively, --time[s] '0 100') --output /path/to/output/prefix_
</pre><h3>Parameters:</h3>
<h5>Volume (fivoxvsd://)</h5>
<ul>
<li>BlueConfig: Path to the BlueConfig file</li>
<li>report: Name of the voltage report in the BlueConfig</li>
<li>target: Name of the Cell Target</li>
<li>areas: Path to the area report file</li>
<li>dt: Timestep between requested frames in milliseconds</li>
<li>gidFraction: Take random cells from a fraction [0,1] of the given target</li>
</ul>
<h5>VSD computation</h5>
<ul>
<li>&ndash;curve: Path to the dye curve file. If not specified, the VSD values are not attenuated</li>
<li>&ndash;depth: Depth of the attenuation curve area of influence, in micrometers. It also defines the Y-coordinate at which it starts being applied, down until y=0</li>
<li>&ndash;interpolate-attenuation: If specified, linearly interpolate the attenuation values from the dye curve file. Use nearest-neighbor otherwise (default).</li>
<li>&ndash;v0: Resting potential in millivolts</li>
<li>&ndash;g0: Multiplier for surface area in background fluorescence term</li>
<li>&ndash;ap-threshold: Action potential threshold in millivolts</li>
<li>&ndash;export-volume: If specified, generate a 3D volume containing the VSD signal (.mhd and .raw files)</li>
<li>&ndash;export-point-sprites: If specified, generate a set of files describing the VSD events as point sprites (.psh, .psp and .psi files)</li>
</ul>
<h5>Beer-Lambert projection</h5>
<ul>
<li>&ndash;sigma: Absorption + scattering coefficient (units per micrometer) in the Beer-Lambert law. It must be a positive value</li>
<li>&ndash;soma-pixels: Produce a text file with the GID, 3D position and corresponding pixel coordinates in the final 2D image for all the cells loaded</li>
</ul>
<h5>Common</h5>
<ul>
<li>&ndash;sensor-res: Number of pixels per side of the square sensor</li>
<li>&ndash;sensor-dim: Length of side of the square sensor in micrometers</li>
<li>&ndash;frame[s]: Frame[s] to load in the report</li>
<li>&ndash;time[s]: Timestamp[s] (milliseconds) to load in the report</li>
<li>&ndash;output: Path to the directory which will store both the 2D projection data and optionally the 3D volume containing the VSD values</li>
</ul>
<h2>Algorithm</h2>
<p>The basic idea is to generate a set of events in 3D space, each of them corresponding to a compartment in the neuron morphology, and then update these events with the computed VSD value, based on the reported voltage from the simulation.</p>
<p>The 3D space will then be sampled into a homogeneous volume, resulting in a set of cubic voxels, each of them containing the aggregated VSD value of all the events falling within the voxel extent.</p>
<p>Finally, the contents of the 3D volume will be projected vertically onto a 2D surface that represents the pial surface of the brain.</p>
<p>All the steps in the process are detailed next.</p>
<h3>Creation of the events</h3>
<p>The first step is to read the circuit information from the BlueConfig file, using Brion, and load the morphologies corresponding to the target specified. At the same time, we read the voltage report, and obtain the number of compartments per section, for all the sections in each of the morphologies. With this information we can compute the position of the center of the compartments, by linearly interpolating the sections coordinates.</p>
<p>Each of these compartments becomes an event that will eventually be updated and evaluated, with an initial value of 0.</p>
<h3>Calculation of the raw VSD signal from simulation data</h3>
<p>Then, and depending on the number of frames/times specified as a command line argument, the corresponding timestamp is loaded in the voltage report. If the number of compartments that is loaded from the simulation differs from the number of areas in the area report, then the application will throw an exception, as this is a requirement for the correct behaviour of the algorithm.</p>
<p>At this point, all the events will be updated with the VSD value as follows:</p>
<blockquote class="doxtable">
<p>VSD = (V - V0 + G0) * SA * AttenuationFactor </p>
</blockquote>
<p>being <b>V</b> the corresponding voltage from the simulation report; <b>V0</b> the specified resting potential; <b>G0</b> the specified area multiplier; and <b>SA</b> the compartment's surface area.</p>
<p>The value of V can be modified, if spike filtering is enabled. For experimental purposes, it is possible to set an artificial threshold for the spiking activity: if the input voltage goes above the specified threshold value, the signal is cropped.</p>
<blockquote class="doxtable">
<p>V = min(V, actionPotentialThreshold) </p>
</blockquote>
<p>The attenuation factor is a variable that depends on several factors. If a dye curve file is not specified as input, it will always be 1, so no attenuation is applied. It also depends on the Y-coordinate of each of the compartment and the depth of the loaded circuit (modifiable by an input parameter). Its value is computed as follows:</p>
<ol type="1">
<li>The values in the input dye curve file are normalized so they go between 0 and 1.</li>
<li>If the compartment is above the specified depth value, the first attenuation factor in the input dye curve file is applied.</li>
<li>If the compartment is below 0, the last attenuation factor in the input dye curve file is applied.</li>
<li>If the compartment is within the specified depth, the circuit space is vertically subdivided in as many regions as values are in the file. Each of the attenuation factors in the file will be applied to the compartments that fall in the corresponding region.</li>
<li>When the interpolate-attenuation option is specified, the attenuation factor applied to the VSD value s the result of lineraly interpolating the two closest values in the input dye curve file, so the curve is smoother.</li>
</ol>
<p>If the <em>export-point-sprites</em> command line option is specified, the resulting information (VSD events) will be written to disk in the form of point sprite files.</p>
<h3>Voxelization</h3>
<p>Based on two input parameters, <em>sensor-res</em> and <em>sensor-dim</em>, we compute the desired resolution for the resulting 3D volume, setting the size of the voxels. In the X and Z axes, the extent of the volume corresponds to the value specified in sensor-dim, in micrometers; and the number of voxels per side is determined by sensor-res. The origin of the resulting volume corresponds to the center of the bounding box of the soma positions.</p>
<p>All the events are evaluated, computing the corresponding voxel indices based on the event positions, and summing their values together when more than one share a voxel index. The original floating point value is kept, being 0 the default for empty voxels.</p>
<p>At this point, if the <em>export-volume</em> command line option is specified, the resulting 3D volume is written to disk.</p>
<h3>Projection of VSD data to the surface of brain</h3>
<p>To generate the projection of the data from the 3D volume onto a 2D image (representing the plane that rests on the pial surface of the brain), the Beer-Lambert law is used. To do that, we accumulate all the voxel values along the Y direction, resulting in a 2-dimensional squared array of floating point values, with <em>sensor-res</em> pixels per side.</p>
<p>For that, an ITK image filter was implemented. This filter does, for each of the pixels in the final VSD projection:</p>
<blockquote class="doxtable">
<p>2DValue = sum(3Dvalue_j * exp(-sigma * depth_j)) </p>
</blockquote>
<p>being <b>j</b> the index of each of the voxels in the Y axis; <b>3Dvalue</b> the content of a specific voxel; <b>sigma</b> a coefficient specified by the user; and <b>depth</b> the depth of the voxel in micrometers, starting from 0 at the top of the volume.</p>
<p>If the <em>soma-pixels</em> command line option is specified, a text file will be written to disk, containing the GID, 3D position and corresponding pixel coordinates in the final 2D image for the somas of all the cells loaded.</p>
<h2>File formats</h2>
<h4>Dye curve file:</h4>
<p>ASCII file containing all the attenuation factors, one value per line, from the top to the bottom, being the first attenuation value the one that will be applied to the top coordinates of the data.</p>
<p>Example, attenuating more in the middle part:</p>
<div class="fragment"><div class="line">1.00</div><div class="line">0.96</div><div class="line">0.82</div><div class="line">0.70</div><div class="line">0.58</div><div class="line">0.45</div><div class="line">0.31</div><div class="line">0.20</div><div class="line">0.54</div><div class="line">0.83</div><div class="line">0.95</div></div><!-- fragment --><h4>VSD point sprite files:</h4>
<p>A metadata header ASCII file (.psh), a binary file containing the positions for all the VSD events (.psp), and one binary file containing all the event values for each generated frame (.psi).</p>
<h4>Output 3D volume:</h4>
<p>A metadata header file (.mhd) and the binary file containing the actual volume values (.raw), that can be opened from any volume rendering application, i.e. Livre or Paraview.</p>
<h4>Output 2D image projection:</h4>
<p>A VTK file containing a metadata header section and a binary section with the floating point values of the 2D projection. Readable as a NumPy array from Python, as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;import vtk</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">from</span> vtk.util <span class="keyword">import</span> numpy_support</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">import</span> numpy</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;reader = vtk.vtkStructuredPointsReader()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;reader.SetFileName(<span class="stringliteral">&quot;image.vtk&quot;</span>)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;reader.ReadAllScalarsOn()</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;reader.Update()</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;points = reader.GetOutput().GetPointData().GetScalars()</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;array = numpy_support.vtk_to_numpy(points)</div></div><!-- fragment --><h4>Soma positions and pixel coordinates:</h4>
<p>ASCII file containing all GIDs, 3D positions and corresponding pixel coordinates in the final 2D projection, for all the somas in the scene, with one cell per line.</p>
<p>It also includes a header section with a brief explanation of the format, file version, and the library used to generate it. Example with 10 cells:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Soma position and corresponding pixel index for each cell, in the following format:</span></div><div class="line"><span class="preprocessor">#     gid [ posX posY posZ ]: i j</span></div><div class="line"><span class="preprocessor"># File version: 1</span></div><div class="line"><span class="preprocessor"># Fivox version: 0.6.0</span></div><div class="line">10 [     50.115       1971     61.384 ]: 258 256</div><div class="line">20 [     54.818     1997.1     71.462 ]: 261 262</div><div class="line">30 [     50.896     1760.8     56.659 ]: 258 254</div><div class="line">40 [     38.099     1807.9     30.819 ]: 252 241</div><div class="line">50 [     19.888     1755.2     69.948 ]: 243 261</div><div class="line">60 [     42.529     1730.5     50.998 ]: 254 251</div><div class="line">70 [     59.509     1742.3     50.691 ]: 263 251</div><div class="line">80 [     43.298     1826.1     57.443 ]: 255 254</div><div class="line">160 [     52.034     1595.8     55.536 ]: 259 253</div><div class="line">170 [     29.455     1451.9     28.081 ]: 248 239</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="UserGuide.html">User guide</a></li>
    <li class="footer">Generated on Fri Jun 9 2017 05:17:55 for Fivox by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
