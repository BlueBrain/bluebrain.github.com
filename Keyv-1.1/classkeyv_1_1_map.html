<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Keyv: keyv::Map Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Keyv
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">Key-Value based storage and caching using a variety of backends</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classkeyv_1_1_map.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classkeyv_1_1_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">keyv::Map Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Unified interface to save key-value pairs in a store.  
 <a href="classkeyv_1_1_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_map_8h_source.html">Map.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for keyv::Map:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classkeyv_1_1_map__coll__graph.png" border="0" usemap="#keyv_1_1_map_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e9a1c8d64490a469e4209dcd9b99f29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a> (const servus::URI &amp;uri)</td></tr>
<tr class="memdesc:a2e9a1c8d64490a469e4209dcd9b99f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new map.  <a href="#a2e9a1c8d64490a469e4209dcd9b99f29">More...</a><br /></td></tr>
<tr class="separator:a2e9a1c8d64490a469e4209dcd9b99f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1f00603e7db85d8d7663ea18fc243a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1f00603e7db85d8d7663ea18fc243a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (<a class="el" href="classkeyv_1_1_map.html">Map</a> &amp;&amp;from)</td></tr>
<tr class="separator:aeb1f00603e7db85d8d7663ea18fc243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f44bc787a936c54abd5fbd9875164ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f44bc787a936c54abd5fbd9875164ea"></a>
<a class="el" href="classkeyv_1_1_map.html">Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classkeyv_1_1_map.html">Map</a> &amp;&amp;from)</td></tr>
<tr class="separator:a9f44bc787a936c54abd5fbd9875164ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f144c6836a17d0382f29606416efe6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a31f144c6836a17d0382f29606416efe6">~Map</a> ()</td></tr>
<tr class="memdesc:a31f144c6836a17d0382f29606416efe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the map.  <a href="#a31f144c6836a17d0382f29606416efe6">More...</a><br /></td></tr>
<tr class="separator:a31f144c6836a17d0382f29606416efe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23860564004acd599b68341aa372e70b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a23860564004acd599b68341aa372e70b">setQueueDepth</a> (const size_t depth)</td></tr>
<tr class="memdesc:a23860564004acd599b68341aa372e70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of asynchronous outstanding write operations.  <a href="#a23860564004acd599b68341aa372e70b">More...</a><br /></td></tr>
<tr class="separator:a23860564004acd599b68341aa372e70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b8cf86ef21176a023a7c6882162aa"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:afd0b8cf86ef21176a023a7c6882162aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#afd0b8cf86ef21176a023a7c6882162aa">insert</a> (const std::string &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:afd0b8cf86ef21176a023a7c6882162aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update a value in the database.  <a href="#afd0b8cf86ef21176a023a7c6882162aa">More...</a><br /></td></tr>
<tr class="separator:afd0b8cf86ef21176a023a7c6882162aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf4677eb56ae4ce4480f6202db28b9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbf4677eb56ae4ce4480f6202db28b9b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const std::string &amp;key, const void *data, size_t size)</td></tr>
<tr class="separator:acbf4677eb56ae4ce4480f6202db28b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae2cd84dcb9f869d3f746db8f8ec7b4"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:aeae2cd84dcb9f869d3f746db8f8ec7b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#aeae2cd84dcb9f869d3f746db8f8ec7b4">insert</a> (const std::string &amp;key, const std::vector&lt; V &gt; &amp;values)</td></tr>
<tr class="memdesc:aeae2cd84dcb9f869d3f746db8f8ec7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update a vector of values in the database.  <a href="#aeae2cd84dcb9f869d3f746db8f8ec7b4">More...</a><br /></td></tr>
<tr class="separator:aeae2cd84dcb9f869d3f746db8f8ec7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43928e5c6c298a2e02de2e3740395421"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a43928e5c6c298a2e02de2e3740395421"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a43928e5c6c298a2e02de2e3740395421">insert</a> (const std::string &amp;key, const std::set&lt; V &gt; &amp;values)</td></tr>
<tr class="memdesc:a43928e5c6c298a2e02de2e3740395421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update a set of values in the database.  <a href="#a43928e5c6c298a2e02de2e3740395421">More...</a><br /></td></tr>
<tr class="separator:a43928e5c6c298a2e02de2e3740395421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c0cceb4a4d0ea849b90304848cc390"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a11c0cceb4a4d0ea849b90304848cc390">operator[]</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:a11c0cceb4a4d0ea849b90304848cc390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value for a key.  <a href="#a11c0cceb4a4d0ea849b90304848cc390">More...</a><br /></td></tr>
<tr class="separator:a11c0cceb4a4d0ea849b90304848cc390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382030f70d9e8df2e1c2459dc22241c6"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a382030f70d9e8df2e1c2459dc22241c6"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a382030f70d9e8df2e1c2459dc22241c6">get</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:a382030f70d9e8df2e1c2459dc22241c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value for a key.  <a href="#a382030f70d9e8df2e1c2459dc22241c6">More...</a><br /></td></tr>
<tr class="separator:a382030f70d9e8df2e1c2459dc22241c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32311f8c04b489e3cba29e362a51b480"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a32311f8c04b489e3cba29e362a51b480"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a32311f8c04b489e3cba29e362a51b480">getVector</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:a32311f8c04b489e3cba29e362a51b480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value as a vector for a key.  <a href="#a32311f8c04b489e3cba29e362a51b480">More...</a><br /></td></tr>
<tr class="separator:a32311f8c04b489e3cba29e362a51b480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba228e44a816dd0cc67409355fbe6409"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:aba228e44a816dd0cc67409355fbe6409"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#aba228e44a816dd0cc67409355fbe6409">getSet</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:aba228e44a816dd0cc67409355fbe6409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a value as a set for a key.  <a href="#aba228e44a816dd0cc67409355fbe6409">More...</a><br /></td></tr>
<tr class="separator:aba228e44a816dd0cc67409355fbe6409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ef4e6e1db8c678fb88ff22ca1f35c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#ab8ef4e6e1db8c678fb88ff22ca1f35c9">getValues</a> (const Strings &amp;keys, const <a class="el" href="namespacekeyv.html#a2515288c63590159f571e52c077113aa">ConstValueFunc</a> &amp;func) const </td></tr>
<tr class="memdesc:ab8ef4e6e1db8c678fb88ff22ca1f35c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve values from a list of keys and calls back for each found value.  <a href="#ab8ef4e6e1db8c678fb88ff22ca1f35c9">More...</a><br /></td></tr>
<tr class="separator:ab8ef4e6e1db8c678fb88ff22ca1f35c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef08c2f88a9ae5f5e444b87a6e1af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a3aef08c2f88a9ae5f5e444b87a6e1af0">takeValues</a> (const Strings &amp;keys, const <a class="el" href="namespacekeyv.html#ad01306efc808a71f2da325142f9fba78">ValueFunc</a> &amp;func) const </td></tr>
<tr class="memdesc:a3aef08c2f88a9ae5f5e444b87a6e1af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve values from a list of keys and calls back for each found value.  <a href="#a3aef08c2f88a9ae5f5e444b87a6e1af0">More...</a><br /></td></tr>
<tr class="separator:a3aef08c2f88a9ae5f5e444b87a6e1af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d5f10d47e6c64c83361a31ffd07641"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#af7d5f10d47e6c64c83361a31ffd07641">flush</a> ()</td></tr>
<tr class="memdesc:af7d5f10d47e6c64c83361a31ffd07641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush outstanding operations to the backend storage.  <a href="#af7d5f10d47e6c64c83361a31ffd07641">More...</a><br /></td></tr>
<tr class="separator:af7d5f10d47e6c64c83361a31ffd07641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e5f17373059dd8ec8f60f60d007d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#ae0e5f17373059dd8ec8f60f60d007d11">setByteswap</a> (const bool swap)</td></tr>
<tr class="memdesc:ae0e5f17373059dd8ec8f60f60d007d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable endianness conversion on reads.  <a href="#ae0e5f17373059dd8ec8f60f60d007d11">More...</a><br /></td></tr>
<tr class="separator:ae0e5f17373059dd8ec8f60f60d007d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039665d385e1d1c67cbc882a470368ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a039665d385e1d1c67cbc882a470368ba"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a039665d385e1d1c67cbc882a470368ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_insert</b> (const std::string &amp;k, const std::string &amp;v, const std::false_type &amp;)</td></tr>
<tr class="separator:a039665d385e1d1c67cbc882a470368ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aee1157dd269ba5f37f938713575acf47"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#aee1157dd269ba5f37f938713575acf47">handles</a> (const servus::URI &amp;uri)</td></tr>
<tr class="separator:aee1157dd269ba5f37f938713575acf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52492a97cf9efff86e51768b7b771b1e"><td class="memItemLeft" align="right" valign="top">static MapPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkeyv_1_1_map.html#a52492a97cf9efff86e51768b7b771b1e">createCache</a> ()</td></tr>
<tr class="memdesc:a52492a97cf9efff86e51768b7b771b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a map which can be used for caching IO on the local system.  <a href="#a52492a97cf9efff86e51768b7b771b1e">More...</a><br /></td></tr>
<tr class="separator:a52492a97cf9efff86e51768b7b771b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Unified interface to save key-value pairs in a store. </p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Copyright (c) 2014-2016, Stefan.Eilemann@epfl.ch</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of Keyv &lt;https://github.com/BlueBrain/Keyv&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * - Redistributions of source code must retain the above copyright notice, this</span></div><div class="line"><span class="comment"> *   list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"> * - Redistributions in binary form must reproduce the above copyright notice,</span></div><div class="line"><span class="comment"> *   this list of conditions and the following disclaimer in the documentation</span></div><div class="line"><span class="comment"> *   and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"> * - Neither the name of Eyescale Software GmbH nor the names of its</span></div><div class="line"><span class="comment"> *   contributors may be used to endorse or promote products derived from this</span></div><div class="line"><span class="comment"> *   software without specific prior written permission.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span></div><div class="line"><span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></div><div class="line"><span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span></div><div class="line"><span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span></div><div class="line"><span class="comment"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span></div><div class="line"><span class="comment"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span></div><div class="line"><span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span></div><div class="line"><span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span></div><div class="line"><span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span></div><div class="line"><span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></div><div class="line"><span class="comment"> * POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define TEST_RUNTIME 240 //seconds</span></div><div class="line"><span class="preprocessor">#include &lt;keyv/Map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;lunchbox/test.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lunchbox/clock.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lunchbox/os.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lunchbox/rng.h&gt;</span></div><div class="line"><span class="preprocessor">#ifdef KEYV_USE_LEVELDB</span></div><div class="line"><span class="preprocessor">#  include &lt;leveldb/db.h&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#include &lt;boost/format.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="classkeyv_1_1_map.html">keyv::Map</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> ints[] = { 17, 53, 42, 65535, 32768 };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> numInts = <span class="keyword">sizeof</span>( ints ) / <span class="keyword">sizeof</span>( <span class="keywordtype">int</span> );</div><div class="line"><span class="keyword">const</span> int64_t loopTime = 1000;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keywordtype">void</span> insertVector( <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a>&amp; map )</div><div class="line">{</div><div class="line">    std::vector&lt; T &gt; vector;</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; numInts; ++i )</div><div class="line">        vector.push_back( T( ints[ i ] ));</div><div class="line">    TEST( map.insert( <span class="keyword">typeid</span>( vector ).name(), vector ));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keywordtype">void</span> readVector( <span class="keyword">const</span> <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a>&amp; map )</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> std::vector&lt; T &gt;&amp; vector =</div><div class="line">        map.getVector&lt; T &gt;( <span class="keyword">typeid</span>( vector ).name( ));</div><div class="line">    TESTINFO( vector.size() ==  numInts, vector.size() &lt;&lt; <span class="stringliteral">&quot; != &quot;</span> &lt;&lt; numInts );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; numInts; ++i )</div><div class="line">        TEST( vector[ i ] == T( ints[i] ));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keywordtype">void</span> insertVector( <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a>&amp; map, <span class="keyword">const</span> <span class="keywordtype">size_t</span> elems )</div><div class="line">{</div><div class="line">    std::vector&lt; T &gt; vector;</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; elems; ++i )</div><div class="line">        vector.push_back( T(i) );</div><div class="line">    TEST( map.insert( std::string( <span class="stringliteral">&quot;bulk&quot;</span> ) + <span class="keyword">typeid</span>( vector ).name(), vector ));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keywordtype">void</span> readVector( <span class="keyword">const</span> <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a>&amp; map, <span class="keyword">const</span> <span class="keywordtype">size_t</span> elems )</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> std::vector&lt; T &gt;&amp; vector =</div><div class="line">        map.getVector&lt; T &gt;( std::string( <span class="stringliteral">&quot;bulk&quot;</span> ) + <span class="keyword">typeid</span>( vector ).name());</div><div class="line">    TESTINFO( vector.size() ==  elems, vector.size() &lt;&lt; <span class="stringliteral">&quot; != &quot;</span> &lt;&lt; elems );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; numInts; ++i )</div><div class="line">        TESTINFO( vector[ i ] == T( i ), vector[ i ] &lt;&lt; <span class="stringliteral">&quot; != &quot;</span> &lt;&lt; i );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> read( <span class="keyword">const</span> <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a>&amp; map )</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> std::set&lt; uint32_t &gt;&amp; bigSet =</div><div class="line">        map.getSet&lt; uint32_t &gt;( <span class="stringliteral">&quot;std::set&lt; uint32_t &gt;&quot;</span> );</div><div class="line">    TEST( bigSet.size() == 1000 );</div><div class="line">    <span class="keywordflow">for</span>( uint32_t i = 1; i &lt;= 1000; ++i )</div><div class="line">        TEST( bigSet.find( i ) != bigSet.end( ));</div><div class="line"></div><div class="line">    TEST( map[ <span class="stringliteral">&quot;foo&quot;</span> ] == <span class="stringliteral">&quot;bar&quot;</span> );</div><div class="line">    TEST( map[ <span class="stringliteral">&quot;bar&quot;</span> ].empty( ));</div><div class="line">    TEST( map.get&lt; <span class="keywordtype">bool</span> &gt;( <span class="stringliteral">&quot;bValue&quot;</span> ) == <span class="keyword">true</span> );</div><div class="line">    TEST( map.get&lt; <span class="keywordtype">int</span> &gt;( <span class="stringliteral">&quot;iValue&quot;</span> ) == 42 );</div><div class="line"></div><div class="line">    readVector&lt; int &gt;( map );</div><div class="line">    readVector&lt; uint16_t &gt;( map );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::set&lt; int &gt;&amp; <span class="keyword">set</span> = map.getSet&lt; <span class="keywordtype">int</span> &gt;( <span class="stringliteral">&quot;std::set&lt; int &gt;&quot;</span> );</div><div class="line">    TESTINFO( <span class="keyword">set</span>.size() ==  numInts, <span class="keyword">set</span>.size() &lt;&lt; <span class="stringliteral">&quot; != &quot;</span> &lt;&lt; numInts );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; numInts; ++i )</div><div class="line">        TESTINFO( <span class="keyword">set</span>.find( ints[i] ) != <span class="keyword">set</span>.end(),</div><div class="line">                  ints[i] &lt;&lt; <span class="stringliteral">&quot; not found in set&quot;</span> );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> read( <span class="keyword">const</span> std::string&amp; uriStr )</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> servus::URI uri( uriStr );</div><div class="line">    <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a> map( uri );</div><div class="line">    read( map );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> testAvailable( <span class="keyword">const</span> std::string&amp; uriStr )</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> servus::URI uri( uriStr );</div><div class="line">        <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a> map( uri );</div><div class="line">        <span class="keywordflow">if</span>( !map.insert( <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span> ))</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">return</span> map[ <span class="stringliteral">&quot;foo&quot;</span> ] == <span class="stringliteral">&quot;bar&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>( ... )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup( <span class="keyword">const</span> std::string&amp; uriStr )</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> servus::URI uri( uriStr );</div><div class="line">    <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a> map( uri );</div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span> ));</div><div class="line">    TESTINFO( map[ <span class="stringliteral">&quot;foo&quot;</span> ] == <span class="stringliteral">&quot;bar&quot;</span>,</div><div class="line">              map[ <span class="stringliteral">&quot;foo&quot;</span> ] &lt;&lt; <span class="stringliteral">&quot; length &quot;</span> &lt;&lt; map[ <span class="stringliteral">&quot;foo&quot;</span> ].length( ));</div><div class="line">    TEST( map[ <span class="stringliteral">&quot;bar&quot;</span> ].empty( ));</div><div class="line"></div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;the quick brown fox&quot;</span>, <span class="stringliteral">&quot;jumped over something&quot;</span> ));</div><div class="line">    TESTINFO( map[ <span class="stringliteral">&quot;the quick brown fox&quot;</span> ] == <span class="stringliteral">&quot;jumped over something&quot;</span>,</div><div class="line">              map[ <span class="stringliteral">&quot;the quick brown fox&quot;</span> ] );</div><div class="line"></div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;hans&quot;</span>, std::string( <span class="stringliteral">&quot;dampf&quot;</span> )));</div><div class="line">    TESTINFO( map[ <span class="stringliteral">&quot;hans&quot;</span> ] == <span class="stringliteral">&quot;dampf&quot;</span>, map[ <span class="stringliteral">&quot;hans&quot;</span> ] );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> bValue = <span class="keyword">true</span>;</div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;bValue&quot;</span>, bValue ));</div><div class="line">    TEST( map.get&lt; <span class="keywordtype">bool</span> &gt;( <span class="stringliteral">&quot;bValue&quot;</span> ) == bValue );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> iValue = 42;</div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;iValue&quot;</span>, iValue ));</div><div class="line">    TEST( map.get&lt; <span class="keywordtype">int</span> &gt;( <span class="stringliteral">&quot;iValue&quot;</span> ) == iValue );</div><div class="line"></div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;coffee&quot;</span>, 0xC0FFEE ));</div><div class="line">    map.setByteswap( <span class="keyword">true</span> );</div><div class="line">    TEST( map.get&lt; <span class="keywordtype">unsigned</span> &gt;( <span class="stringliteral">&quot;coffee&quot;</span> ) == 0xEEFFC000u );</div><div class="line">    map.setByteswap( <span class="keyword">false</span> );</div><div class="line">    TEST( map.get&lt; <span class="keywordtype">int</span> &gt;( <span class="stringliteral">&quot;coffee&quot;</span> ) == 0xC0FFEE );</div><div class="line"></div><div class="line">    insertVector&lt; int &gt;( map );</div><div class="line">    insertVector&lt; uint16_t &gt;( map );</div><div class="line">    readVector&lt; int &gt;( map );</div><div class="line">    readVector&lt; uint16_t &gt;( map );</div><div class="line"></div><div class="line">    insertVector&lt; int &gt;( map, LB_128KB );</div><div class="line">    insertVector&lt; uint16_t &gt;( map, LB_128KB );</div><div class="line">    readVector&lt; int &gt;( map, LB_128KB );</div><div class="line">    readVector&lt; uint16_t &gt;( map, LB_128KB );</div><div class="line"></div><div class="line">    std::set&lt; int &gt; <span class="keyword">set</span>( ints, ints + numInts );</div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;std::set&lt; int &gt;&quot;</span>, <span class="keyword">set</span> ));</div><div class="line"></div><div class="line">    std::set&lt; uint32_t &gt; bigSet;</div><div class="line">    <span class="keywordflow">for</span>( uint32_t i = 1; i &lt;= 1000; ++i )</div><div class="line">        bigSet.insert( i );</div><div class="line">    TEST( map.insert( <span class="stringliteral">&quot;std::set&lt; uint32_t &gt;&quot;</span>, bigSet ));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> lunchbox::Strings keys = { <span class="stringliteral">&quot;hans&quot;</span>, <span class="stringliteral">&quot;coffee&quot;</span> };</div><div class="line">    <span class="keywordtype">size_t</span> numResults = 0;</div><div class="line">    map.takeValues( keys, [&amp;]( <span class="keyword">const</span> std::string&amp; key, <span class="keywordtype">char</span>* data,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">size_t</span> size )</div><div class="line">    {</div><div class="line">        TESTINFO( std::find( keys.begin(), keys.end(), key ) != keys.end(),</div><div class="line">                  key );</div><div class="line">        TEST( data );</div><div class="line">        TESTINFO( size &gt; 0, key &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; uriStr );</div><div class="line">        ++numResults;</div><div class="line">        free( data );</div><div class="line">    });</div><div class="line">    TEST( numResults == keys.size( ));</div><div class="line"></div><div class="line">    numResults = 0;</div><div class="line">    map.getValues( keys, [&amp;]( <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> <span class="keywordtype">char</span>* data,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">size_t</span> size )</div><div class="line">    {</div><div class="line">        TEST( std::find( keys.begin(), keys.end(), key) != keys.end( ));</div><div class="line">        TEST( data );</div><div class="line">        TEST( size &gt; 0 );</div><div class="line">        ++numResults;</div><div class="line">    });</div><div class="line">    TEST( numResults == keys.size( ));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> benchmark( <span class="keyword">const</span> std::string&amp; uriStr, <span class="keyword">const</span> uint64_t queueDepth,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">size_t</span> valueSize )</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> std::string lastURI;</div><div class="line">    <span class="keywordflow">if</span>( uriStr != lastURI )</div><div class="line">    {</div><div class="line">        std::cout</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; uriStr &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; depth,     size,  writes/s,     MB/s,  reads/s,      MB/s&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">        lastURI = uriStr;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// cppcheck-suppress zerodivcond</span></div><div class="line">    std::cout &lt;&lt; boost::format( <span class="stringliteral">&quot;%6i, %8i,&quot;</span>) % queueDepth % valueSize</div><div class="line">              &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> servus::URI uri( uriStr );</div><div class="line">    <a class="code" href="classkeyv_1_1_map.html#a2e9a1c8d64490a469e4209dcd9b99f29">Map</a> map( uri );</div><div class="line">    map.setQueueDepth( queueDepth );</div><div class="line"></div><div class="line">    <span class="comment">// Prepare keys and value</span></div><div class="line">    lunchbox::Strings keys;</div><div class="line">    keys.resize( queueDepth + 1 );</div><div class="line">    <span class="keywordflow">for</span>( uint64_t i = 0; i &lt;= queueDepth; ++i )</div><div class="line">        keys[i].assign( reinterpret_cast&lt; char* &gt;( &amp;i ), 8 );</div><div class="line"></div><div class="line">    std::string value( valueSize, <span class="charliteral">&#39;*&#39;</span> );</div><div class="line">    lunchbox::RNG rng;</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; valueSize; ++i )</div><div class="line">        value[i] = rng.get&lt;<span class="keywordtype">char</span>&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// write performance</span></div><div class="line">    lunchbox::Clock clock;</div><div class="line">    uint64_t i = 0;</div><div class="line">    <span class="keywordflow">while</span>( clock.getTime64() &lt; loopTime || i &lt;= queueDepth )</div><div class="line">    {</div><div class="line">        map.insert( keys[ i % (queueDepth+1) ], value );</div><div class="line">        ++i;</div><div class="line">    }</div><div class="line">    map.flush();</div><div class="line">    <span class="keywordtype">float</span> time = clock.getTimef() / 1000.f;</div><div class="line">    <span class="keyword">const</span> uint64_t wOps = i;</div><div class="line"></div><div class="line">    <span class="comment">// cppcheck-suppress zerodivcond</span></div><div class="line">    std::cout &lt;&lt; boost::format( <span class="stringliteral">&quot;%9.2f, %9.2f,&quot;</span>) % (wOps/time)</div><div class="line">        % (wOps/1024.f/1024.f * valueSize / time) &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="comment">// read performance</span></div><div class="line">    clock.reset();</div><div class="line">    <span class="keywordflow">if</span>( queueDepth == 0 ) <span class="comment">// sync read</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>( i = 0; i &lt; wOps &amp;&amp; clock.getTime64() &lt; loopTime; ++i ) <span class="comment">// read keys</span></div><div class="line">            map[ keys[ i % (queueDepth+1) ]];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// async read</span></div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> getValue = []( <span class="keyword">const</span> std::string&amp;, <span class="keyword">const</span> <span class="keywordtype">char</span>*, size_t ) {};</div><div class="line">        <span class="keywordflow">for</span>( i = 0; i &lt; wOps &amp;&amp; clock.getTime64() &lt; loopTime; i += queueDepth )</div><div class="line">        {</div><div class="line">            lunchbox::Strings subKeys;</div><div class="line">            subKeys.reserve( queueDepth );</div><div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j = i; j &lt; i + queueDepth; ++j )</div><div class="line">                subKeys.push_back( keys[ j % (queueDepth+1) ]);</div><div class="line">            map.getValues( subKeys, getValue );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    time = clock.getTimef() / 1000.f;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; boost::format( <span class="stringliteral">&quot;%9.2f, %9.2f&quot;</span>) % (i/time)</div><div class="line">        % (i/1024.f/1024.f * valueSize / time) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// try to make sure there&#39;s nothing outstanding if we messed up in our test</span></div><div class="line">    map.flush();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> testGenericFailures()</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        setup( <span class="stringliteral">&quot;foobar://&quot;</span> );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>( <span class="keyword">const</span> std::runtime_error&amp; )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    TESTINFO( <span class="keyword">false</span>, <span class="stringliteral">&quot;Missing exception&quot;</span> );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> testLevelDBFailures()</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef KEYV_USE_LEVELDB</span></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        setup( <span class="stringliteral">&quot;leveldb://?store=/doesnotexist/deadbeef/coffee&quot;</span> );</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>( <span class="keyword">const</span> std::runtime_error&amp; )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    TESTINFO( <span class="keyword">false</span>, <span class="stringliteral">&quot;Missing exception&quot;</span> );</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">size_t</span> dup( <span class="keyword">const</span> <span class="keywordtype">size_t</span> value )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> value == 0 ? 1 : value &lt;&lt; 1;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>TestSpec</div><div class="line">{</div><div class="line">    TestSpec( <span class="keyword">const</span> std::string&amp; uri_, <span class="keyword">const</span> <span class="keywordtype">size_t</span> depth_, <span class="keyword">const</span> <span class="keywordtype">size_t</span> size_ )</div><div class="line">        : uri( uri_ ), depth( depth_ ), size( size_ ) {}</div><div class="line"></div><div class="line">    std::string uri;</div><div class="line">    <span class="keywordtype">size_t</span> depth;</div><div class="line">    <span class="keywordtype">size_t</span> size;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>( argc == 4 )</div><div class="line">    {</div><div class="line">        benchmark( argv[1], atoi( argv[2] ), atoi( argv[3] ));</div><div class="line">        <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">    }</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> perfTest =</div><div class="line">        std::string( argv[0] ).find( <span class="stringliteral">&quot;perf-&quot;</span> ) != std::string::npos;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::vector&lt; TestSpec &gt; TestSpecs;</div><div class="line">    TestSpecs tests;</div><div class="line"><span class="preprocessor">#ifdef KEYV_USE_LEVELDB</span></div><div class="line">    tests.push_back( TestSpec( <span class="stringliteral">&quot;&quot;</span>, 0, 65536 ));</div><div class="line">    tests.push_back( TestSpec( <span class="stringliteral">&quot;leveldb://&quot;</span>, 0, 65536 ));</div><div class="line">    tests.push_back( TestSpec( <span class="stringliteral">&quot;leveldb://?store=keyvMap2.leveldb&quot;</span>, 0, 65536 ));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#ifdef KEYV_USE_LIBMEMCACHED</span></div><div class="line">    <span class="keywordflow">if</span>( testAvailable( <span class="stringliteral">&quot;memcached://&quot;</span> ))</div><div class="line">        tests.push_back( TestSpec( <span class="stringliteral">&quot;memcached://&quot;</span>, 65536, 65536 ));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#ifdef KEYV_USE_RADOS</span></div><div class="line">    tests.push_back( TestSpec(</div><div class="line">                    <span class="stringliteral">&quot;ceph://client.vizpoc@vizpoc/home/eilemann/.ceph/ceph.conf&quot;</span>,</div><div class="line">                     8192, LB_4MB ));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span>( !tests.empty( ))</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> TestSpec test = tests.back();</div><div class="line">            tests.pop_back();</div><div class="line"></div><div class="line">            setup( test.uri );</div><div class="line">            read( test.uri );</div><div class="line">            <span class="keywordflow">if</span>( perfTest )</div><div class="line">            {</div><div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 1; i &lt;= test.size; i = i &lt;&lt; 2 )</div><div class="line">                    benchmark( test.uri, test.depth, i );</div><div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt;= test.depth; i = dup( i ))</div><div class="line">                    benchmark( test.uri, i, 1024 );</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"><span class="preprocessor">#ifdef KEYV_USE_LEVELDB</span></div><div class="line">    <span class="keywordflow">catch</span>( <span class="keyword">const</span> leveldb::Status&amp; status )</div><div class="line">    {</div><div class="line">        TESTINFO( !<span class="stringliteral">&quot;exception&quot;</span>, status.ToString( ));</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <span class="keywordflow">catch</span>( <span class="keyword">const</span> std::runtime_error&amp; error )</div><div class="line">    {</div><div class="line">        TESTINFO( !<span class="stringliteral">&quot;exception&quot;</span>, error.what( ));</div><div class="line">    }</div><div class="line"></div><div class="line">    testGenericFailures();</div><div class="line">    testLevelDBFailures();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_map_8h_source.html#l00060">60</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2e9a1c8d64490a469e4209dcd9b99f29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">keyv::Map::Map </td>
          <td>(</td>
          <td class="paramtype">const servus::URI &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new map. </p>
<p>Depending on the URI scheme an implementation backend is chosen. If no URI is given, a default one is selected. Available implementations are:</p><ul>
<li>ceph://path_to_ceph.conf (if KEYV_USE_RADOS is defined)</li>
<li>leveldb://path (if KEYV_USE_LEVELDB is defined)</li>
<li>memcached://[server] (if KEYV_USE_LIBMEMCACHED is defined)</li>
</ul>
<p>If no path is given for leveldb, the implementation uses keyvMap.leveldb in the current working directory.</p>
<p>If no servers are given for memcached, the implementation uses all servers in the MEMCACHED_SERVERS environment variable, or 127.0.0.1. MEMCACHED_SERVERS contains a comma-separated list of servers. Each server contains the address, and optionally a colon-separated port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>the storage backend and destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no suitable implementation is found. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if opening the leveldb failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a31f144c6836a17d0382f29606416efe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">keyv::Map::~Map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct the map. </p>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a52492a97cf9efff86e51768b7b771b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MapPtr keyv::Map::createCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a map which can be used for caching IO on the local system. </p>
<p>The concrete implementation used depends on the system setup and available backend implementations. If no suitable implementation is found, a null pointer is returned.</p>
<p>The current implementation returns:</p><ul>
<li>A memcached-backed cache if libmemcached is available and the environment variable MEMCACHED_SERVERS is set (see constructor documentation for details).</li>
<li>A leveldb-backed cache if leveldb is available and LEVELDB_CACHE is set to the path for the leveldb storage.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classkeyv_1_1_map.html" title="Unified interface to save key-value pairs in a store. ">Map</a> for caching IO, or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d5f10d47e6c64c83361a31ffd07641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool keyv::Map::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush outstanding operations to the backend storage. </p>
<dl class="section version"><dt>Version</dt><dd>1.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a382030f70d9e8df2e1c2459dc22241c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V keyv::Map::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a value for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value, or an empty string if the key is not available. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.11 </dd></dl>

<p>Definition at line <a class="el" href="_map_8h_source.html#l00196">196</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba228e44a816dd0cc67409355fbe6409"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; V &gt; keyv::Map::getSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a value as a set for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the values, or an empty set if the key is not available. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

<p>Definition at line <a class="el" href="_map_8h_source.html#l00338">338</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ef4e6e1db8c678fb88ff22ca1f35c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void keyv::Map::getValues </td>
          <td>(</td>
          <td class="paramtype">const Strings &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacekeyv.html#a2515288c63590159f571e52c077113aa">ConstValueFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve values from a list of keys and calls back for each found value. </p>
<p>Depending on the backend implementation, this is more optimal than calling <a class="el" href="classkeyv_1_1_map.html#a382030f70d9e8df2e1c2459dc22241c6" title="Retrieve a value for a key. ">get()</a> for each key.</p>
<p>The ownership of the returned data in the callback is not transfered, so the value needs to be copied if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>list of keys to obtain </td></tr>
    <tr><td class="paramname">func</td><td>callback function which is called for each found key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.14 </dd></dl>

</div>
</div>
<a class="anchor" id="a32311f8c04b489e3cba29e362a51b480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; V &gt; keyv::Map::getVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a value as a vector for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the values, or an empty vector if the key is not available. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

<p>Definition at line <a class="el" href="_map_8h_source.html#l00324">324</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee1157dd269ba5f37f938713575acf47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool keyv::Map::handles </td>
          <td>(</td>
          <td class="paramtype">const servus::URI &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if an implementation for the given URI is available. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

</div>
</div>
<a class="anchor" id="afd0b8cf86ef21176a023a7c6882162aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool keyv::Map::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or update a value in the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to store the value. </td></tr>
    <tr><td class="paramname">value</td><td>the value stored at the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the value is not copyable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

<p>Definition at line <a class="el" href="_map_8h_source.html#l00141">141</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeae2cd84dcb9f869d3f746db8f8ec7b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool keyv::Map::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or update a vector of values in the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to store the value. </td></tr>
    <tr><td class="paramname">values</td><td>the values stored at the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the vector values are not copyable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

<p>Definition at line <a class="el" href="_map_8h_source.html#l00160">160</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43928e5c6c298a2e02de2e3740395421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool keyv::Map::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or update a set of values in the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to store the value. </td></tr>
    <tr><td class="paramname">values</td><td>the values stored at the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the set values are not copyable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

<p>Definition at line <a class="el" href="_map_8h_source.html#l00177">177</a> of file <a class="el" href="_map_8h_source.html">Map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11c0cceb4a4d0ea849b90304848cc390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string keyv::Map::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a value for a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value, or an empty string if the key is not available. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.9.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e5f17373059dd8ec8f60f60d007d11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void keyv::Map::setByteswap </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>swap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable endianness conversion on reads. </p>
<dl class="section version"><dt>Version</dt><dd>1.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a23860564004acd599b68341aa372e70b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t keyv::Map::setQueueDepth </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of asynchronous outstanding write operations. </p>
<p>Some backend implementations support asynchronous writes, which can be enabled by setting a non-zero queue depth. Applications then need to quarantee that the inserted values stay valid until 'depth' other elements have been inserted or <a class="el" href="classkeyv_1_1_map.html#af7d5f10d47e6c64c83361a31ffd07641" title="Flush outstanding operations to the backend storage. ">flush()</a> has been called. Implementations which do not support asynchronous writes return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the queue depth chosen by the implementation, smaller or equal to the given depth. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.11 </dd></dl>

</div>
</div>
<a class="anchor" id="a3aef08c2f88a9ae5f5e444b87a6e1af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void keyv::Map::takeValues </td>
          <td>(</td>
          <td class="paramtype">const Strings &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacekeyv.html#ad01306efc808a71f2da325142f9fba78">ValueFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve values from a list of keys and calls back for each found value. </p>
<p>Depending on the backend implementation, this is more optimal than calling <a class="el" href="classkeyv_1_1_map.html#a382030f70d9e8df2e1c2459dc22241c6" title="Retrieve a value for a key. ">get()</a> for each key.</p>
<p>The ownership of the returned data in the callback is transfered, so the data must be free'd by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>list of keys to obtain </td></tr>
    <tr><td class="paramname">func</td><td>callback function which is called for each found key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.14 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_map_8h_source.html">Map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacekeyv.html">keyv</a></li><li class="navelem"><a class="el" href="classkeyv_1_1_map.html">Map</a></li>
    <li class="footer">Generated on Tue Jan 10 2017 03:57:22 for Keyv by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
