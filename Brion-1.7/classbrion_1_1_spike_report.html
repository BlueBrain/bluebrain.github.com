<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Brion: brion::SpikeReport Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Brion
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
   <div id="projectbrief">The Blue Brain C++ I/O library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classbrion_1_1_spike_report.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbrion_1_1_spike_report-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">brion::SpikeReport Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Read access to a <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">SpikeReport</a>.  
 <a href="classbrion_1_1_spike_report.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spike_report_8h_source.html">spikeReport.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for brion::SpikeReport:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classbrion_1_1_spike_report__inherit__graph.png" border="0" usemap="#brion_1_1_spike_report_inherit__map" alt="Inheritance graph"/></div>
</div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for brion::SpikeReport:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classbrion_1_1_spike_report__coll__graph.png" border="0" usemap="#brion_1_1_spike_report_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad9af81cd27062d7bc7e88f262829ce3e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#ad9af81cd27062d7bc7e88f262829ce3e">ReadMode</a> { <b>STATIC</b> = 0, 
<b>STREAM</b>
 }</td></tr>
<tr class="memdesc:ad9af81cd27062d7bc7e88f262829ce3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type to specify how spikes are read by this <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">SpikeReport</a>.  <a href="classbrion_1_1_spike_report.html#ad9af81cd27062d7bc7e88f262829ce3e">More...</a><br /></td></tr>
<tr class="separator:ad9af81cd27062d7bc7e88f262829ce3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51ae7286154ca0d7caf1a1bd8cfc094d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a51ae7286154ca0d7caf1a1bd8cfc094d">SpikeReport</a> (const URI &amp;uri, const int mode)</td></tr>
<tr class="memdesc:a51ae7286154ca0d7caf1a1bd8cfc094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">SpikeReport</a> object given a URI.  <a href="#a51ae7286154ca0d7caf1a1bd8cfc094d">More...</a><br /></td></tr>
<tr class="separator:a51ae7286154ca0d7caf1a1bd8cfc094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50beeeb2c939998028f2e5e32d121364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a50beeeb2c939998028f2e5e32d121364">~SpikeReport</a> ()</td></tr>
<tr class="memdesc:a50beeeb2c939998028f2e5e32d121364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a50beeeb2c939998028f2e5e32d121364">More...</a><br /></td></tr>
<tr class="separator:a50beeeb2c939998028f2e5e32d121364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc05e732f005032f8080f88e88bd168"><td class="memItemLeft" align="right" valign="top">const URI &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a4dc05e732f005032f8080f88e88bd168">getURI</a> () const </td></tr>
<tr class="memdesc:a4dc05e732f005032f8080f88e88bd168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the URI used to instantiate the report.  <a href="#a4dc05e732f005032f8080f88e88bd168">More...</a><br /></td></tr>
<tr class="separator:a4dc05e732f005032f8080f88e88bd168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa614522cbaa72578637baf4f60bfee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbrion_1_1_spike_report.html#ad9af81cd27062d7bc7e88f262829ce3e">ReadMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a6fa614522cbaa72578637baf4f60bfee">getReadMode</a> () const </td></tr>
<tr class="separator:a6fa614522cbaa72578637baf4f60bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dc196f6a69b39e0bc69c0ec3be75fc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a35dc196f6a69b39e0bc69c0ec3be75fc">getStartTime</a> () const </td></tr>
<tr class="memdesc:a35dc196f6a69b39e0bc69c0ec3be75fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time of the first spike.  <a href="#a35dc196f6a69b39e0bc69c0ec3be75fc">More...</a><br /></td></tr>
<tr class="separator:a35dc196f6a69b39e0bc69c0ec3be75fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f90cebedf6f79bd3c8e15de3c2861aa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a5f90cebedf6f79bd3c8e15de3c2861aa">getEndTime</a> () const </td></tr>
<tr class="memdesc:a5f90cebedf6f79bd3c8e15de3c2861aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time of the last spike.  <a href="#a5f90cebedf6f79bd3c8e15de3c2861aa">More...</a><br /></td></tr>
<tr class="separator:a5f90cebedf6f79bd3c8e15de3c2861aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f75302f6cd63780f10d6cedda3b01f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacebrion.html#a3024f035dc7ae61a265392d2a0b580c5">Spikes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#af1f75302f6cd63780f10d6cedda3b01f">getSpikes</a> () const </td></tr>
<tr class="memdesc:af1f75302f6cd63780f10d6cedda3b01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spike times and cell GIDs.  <a href="#af1f75302f6cd63780f10d6cedda3b01f">More...</a><br /></td></tr>
<tr class="separator:af1f75302f6cd63780f10d6cedda3b01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399159966dde8dd7e8568d452ee0eaae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a399159966dde8dd7e8568d452ee0eaae">writeSpikes</a> (const <a class="el" href="namespacebrion.html#a3024f035dc7ae61a265392d2a0b580c5">Spikes</a> &amp;spikes)</td></tr>
<tr class="memdesc:a399159966dde8dd7e8568d452ee0eaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the spike times and cell GIDs.  <a href="#a399159966dde8dd7e8568d452ee0eaae">More...</a><br /></td></tr>
<tr class="separator:a399159966dde8dd7e8568d452ee0eaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9000f0d5acebebfcd07a99172eb7dc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a9000f0d5acebebfcd07a99172eb7dc67">waitUntil</a> (const float timeStamp, const uint32_t timeout=LB_TIMEOUT_INDEFINITE)</td></tr>
<tr class="memdesc:a9000f0d5acebebfcd07a99172eb7dc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the caller until the first spike past the given time stamp arrives or the network stream is closed by the source.  <a href="#a9000f0d5acebebfcd07a99172eb7dc67">More...</a><br /></td></tr>
<tr class="separator:a9000f0d5acebebfcd07a99172eb7dc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e366cdface09f9de23b0ef369f7d7fc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a5e366cdface09f9de23b0ef369f7d7fc">getNextSpikeTime</a> ()</td></tr>
<tr class="memdesc:a5e366cdface09f9de23b0ef369f7d7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time of the next spike available in the internal cache.  <a href="#a5e366cdface09f9de23b0ef369f7d7fc">More...</a><br /></td></tr>
<tr class="separator:a5e366cdface09f9de23b0ef369f7d7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bbe0c626970b0bde9939a2a495747a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#ab5bbe0c626970b0bde9939a2a495747a">getLatestSpikeTime</a> ()</td></tr>
<tr class="memdesc:ab5bbe0c626970b0bde9939a2a495747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time of the latest spike that has been received.  <a href="#ab5bbe0c626970b0bde9939a2a495747a">More...</a><br /></td></tr>
<tr class="separator:ab5bbe0c626970b0bde9939a2a495747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025c64d02116e0b86e0e07cb4cc975f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a025c64d02116e0b86e0e07cb4cc975f9">clear</a> (const float startTime, const float endTime)</td></tr>
<tr class="memdesc:a025c64d02116e0b86e0e07cb4cc975f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all spikes contained in the given time interval.  <a href="#a025c64d02116e0b86e0e07cb4cc975f9">More...</a><br /></td></tr>
<tr class="separator:a025c64d02116e0b86e0e07cb4cc975f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5610cfd2b4f663e5c9e6393af63a472c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbrion_1_1_spike_report.html#a5610cfd2b4f663e5c9e6393af63a472c">close</a> ()</td></tr>
<tr class="memdesc:a5610cfd2b4f663e5c9e6393af63a472c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the report.  <a href="#a5610cfd2b4f663e5c9e6393af63a472c">More...</a><br /></td></tr>
<tr class="separator:a5610cfd2b4f663e5c9e6393af63a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Read access to a <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">SpikeReport</a>. </p>
<p>Following RAII, this class is ready to use after the creation and will ensure release of resources upon destruction.</p>
<p>There are two type of SpikeReports, depending on the semantics of the data source:</p><ul>
<li>Static reports: The full spike data base is made available at construction time. This is the mode used by Bluron and NEST report file readers.</li>
<li><p class="startli">Stream based reports: Spikes are read from a network stream. The stream always moves forward in time. The reader cannot steer or control how the source produces the spikes. Spikes are cached internally and made available by calling waitUntil. The user can clear spikes stored inside a given time window. In this report type, getStartTime and getEndTime return the time window of the spikes that are available to the client.</p>
<p class="startli">Client code can implement a moving window using <a class="el" href="classbrion_1_1_spike_report.html#a9000f0d5acebebfcd07a99172eb7dc67" title="Lock the caller until the first spike past the given time stamp arrives or the network stream is clos...">waitUntil()</a> and <a class="el" href="classbrion_1_1_spike_report.html#a5e366cdface09f9de23b0ef369f7d7fc" title="Return the time of the next spike available in the internal cache. ">getNextSpikeTime()</a>. The conceived usage is to decide a window width, and call <a class="el" href="classbrion_1_1_spike_report.html#a9000f0d5acebebfcd07a99172eb7dc67" title="Lock the caller until the first spike past the given time stamp arrives or the network stream is clos...">waitUntil()</a> using <a class="el" href="classbrion_1_1_spike_report.html#a5e366cdface09f9de23b0ef369f7d7fc" title="Return the time of the next spike available in the internal cache. ">getNextSpikeTime()</a> + width.</p>
<p class="startli">The loop </p><div class="fragment"><div class="line"><span class="keywordflow">while</span>( report.waitUntil( report.getNextSpikeTime( )))</div>
<div class="line">    ;</div>
</div><!-- fragment --><p> is guaranteed to always make progress until the end of the stream is reached.</p>
</li>
</ul>
<p>This class is not thread-safe except where stated otherwise. </p>

<p>Definition at line <a class="el" href="spike_report_8h_source.html#l00066">66</a> of file <a class="el" href="spike_report_8h_source.html">spikeReport.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ad9af81cd27062d7bc7e88f262829ce3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbrion_1_1_spike_report.html#ad9af81cd27062d7bc7e88f262829ce3e">brion::SpikeReport::ReadMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type to specify how spikes are read by this <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">SpikeReport</a>. </p>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

<p>Definition at line <a class="el" href="spike_report_8h_source.html#l00073">73</a> of file <a class="el" href="spike_report_8h_source.html">spikeReport.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51ae7286154ca0d7caf1a1bd8cfc094d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">brion::SpikeReport::SpikeReport </td>
          <td>(</td>
          <td class="paramtype">const URI &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classbrion_1_1_spike_report.html" title="Read access to a SpikeReport. ">SpikeReport</a> object given a URI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>URI to spike report. The report type is deduced from here. The report types with built-in support are:<ul>
<li>Bluron ('dat' extension), Bluron file based reports.</li>
<li>NEST ('gdf' extension). NEST file based reports. In read mode, shell wildcards are accepted at the file path leaf to load multiple report files. Support for additional types can be added through plugins; see <a class="el" href="classbrion_1_1_spike_report_plugin.html" title="Base interface for spike report readers plugins. ">SpikeReportPlugin</a> for the details.</li>
</ul>
</td></tr>
    <tr><td class="paramname">mode</td><td>the brion::AccessMode bitmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the input URI is not handled by any registered spike report plugin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a50beeeb2c939998028f2e5e32d121364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">brion::SpikeReport::~SpikeReport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="section version"><dt>Version</dt><dd>1.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a025c64d02116e0b86e0e07cb4cc975f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void brion::SpikeReport::clear </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>endTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all spikes contained in the given time interval. </p>
<p>The purpose of this method is to implement a moving window on top of this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startTime</td><td>The start point of the interval </td></tr>
    <tr><td class="paramname">endTime</td><td>The end point, if smaller than startTime no operation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>is the operation is not supported by the reader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a5610cfd2b4f663e5c9e6393af63a472c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void brion::SpikeReport::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the report. </p>
<p>Only meaningful for STREAM based reports. For reports opened in write mode it finishes the reporting. For reports opened in read mode it disconnects from the source, any call waiting in waitUntil will be unblocked.</p>
<p>Implicitly called by the destructor. Calling any other function after the report has been closed has undefined behavior.</p>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a5f90cebedf6f79bd3c8e15de3c2861aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float brion::SpikeReport::getEndTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time of the last spike. </p>
<dl class="section return"><dt>Returns</dt><dd>The time in milliseconds, or UNDEFINED_TIMESTAMP if there are no spikes. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ab5bbe0c626970b0bde9939a2a495747a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float brion::SpikeReport::getLatestSpikeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the time of the latest spike that has been received. </p>
<dl class="section return"><dt>Returns</dt><dd>undefined in STATIC reports. Let t be the timestamp of the latest spike received, in STREAM reports it returns:<ul>
<li>UNDEFINED_TIMESTAMP is no spike has been received</li>
<li>t if at least one spike has been received and the end of the stream has not been reahed.</li>
<li>An unspecified value x, such as x &gt; t, if at least one spike has been received and the end of the stream has been reached.</li>
</ul>
</dd></dl>
<p>In any case, the function <a class="el" href="classbrion_1_1_spike_report.html#a9000f0d5acebebfcd07a99172eb7dc67" title="Lock the caller until the first spike past the given time stamp arrives or the network stream is clos...">waitUntil()</a> is guaranteed to not block if it takes as input a valid timestamp smaller than the value returned by <a class="el" href="classbrion_1_1_spike_report.html#ab5bbe0c626970b0bde9939a2a495747a" title="Return the time of the latest spike that has been received. ">getLatestSpikeTime()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if invoked on non STREAM writers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a5e366cdface09f9de23b0ef369f7d7fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float brion::SpikeReport::getNextSpikeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the time of the next spike available in the internal cache. </p>
<dl class="section return"><dt>Returns</dt><dd>undefined in STATIC reports. In STREAM reports there are several cases:<ul>
<li>0 if no spikes have been received.</li>
<li>The earliest spike time in milliseconds than has been received, but has not been digested by <a class="el" href="classbrion_1_1_spike_report.html#a9000f0d5acebebfcd07a99172eb7dc67" title="Lock the caller until the first spike past the given time stamp arrives or the network stream is clos...">waitUntil()</a> if the internal cache is not empty.</li>
<li>The latest timestamp that was extracted from the cache if the cache is empty.</li>
<li>UNDEFINED_TIMESTAMP if the end of the stream has been reached and the cache is empty. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if invoked on non STREAM writers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a6fa614522cbaa72578637baf4f60bfee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbrion_1_1_spike_report.html#ad9af81cd27062d7bc7e88f262829ce3e">ReadMode</a> brion::SpikeReport::getReadMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="af1f75302f6cd63780f10d6cedda3b01f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacebrion.html#a3024f035dc7ae61a265392d2a0b580c5">Spikes</a>&amp; brion::SpikeReport::getSpikes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spike times and cell GIDs. </p>
<p>In STREAM reports this method returns all the spikes than have been moved from the receive cache.</p>
<dl class="section version"><dt>Version</dt><dd>1.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a35dc196f6a69b39e0bc69c0ec3be75fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float brion::SpikeReport::getStartTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time of the first spike. </p>
<dl class="section return"><dt>Returns</dt><dd>The time in milliseconds, or UNDEFINED_TIMESTAMP if there are no spikes. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc05e732f005032f8080f88e88bd168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const URI&amp; brion::SpikeReport::getURI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the URI used to instantiate the report. </p>
<p>It could be different from the input URI, depending on the plugin implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>The URI used in the instance. It could be the same as the input URI or a different one, depending on the implementation </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a9000f0d5acebebfcd07a99172eb7dc67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool brion::SpikeReport::waitUntil </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>timeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>LB_TIMEOUT_INDEFINITE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the caller until the first spike past the given time stamp arrives or the network stream is closed by the source. </p>
<p>This is the only function that updates the Spikes data set returned by <a class="el" href="classbrion_1_1_spike_report.html#af1f75302f6cd63780f10d6cedda3b01f" title="Get the spike times and cell GIDs. ">getSpikes()</a> with the spikes received from the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeStamp</td><td>The spike time to wait for in milliseconds. Using UNDEFINED_TIMESTAMP will make this function wait until the end of the stream. </td></tr>
    <tr><td class="paramname">timeout</td><td>An optional timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true at the moment a spike with time stamp larger than the input parameter arrives. False if any of the events below occur before the desired timestamp arrives:<ul>
<li>The timeout goes off.</li>
<li>The network stream is closed or reaches the end.</li>
<li>The report is closed.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if invoked on STATIC readers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<a class="anchor" id="a399159966dde8dd7e8568d452ee0eaae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void brion::SpikeReport::writeSpikes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacebrion.html#a3024f035dc7ae61a265392d2a0b580c5">Spikes</a> &amp;&#160;</td>
          <td class="paramname"><em>spikes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the spike times and cell GIDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spikes</td><td>Spikes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if invoked on spike readers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>1.4 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="spike_report_8h_source.html">spikeReport.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebrion.html">brion</a></li><li class="navelem"><a class="el" href="classbrion_1_1_spike_report.html">SpikeReport</a></li>
    <li class="footer">Generated on Mon Apr 4 2016 17:30:19 for Brion by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
